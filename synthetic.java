public static < K , V > Map < K , List < V >> transpose ( List < Map < K , V > > list ) { Map < K , List < V > > result = new HashMap < > ( ) ; for ( Map < K , V > map : list ) { for ( Map . Entry < K , V > entry : map . entrySet ( ) ) { List < V > values = result . get ( entry . getKey ( ) ) ; if ( values == null ) { values = new ArrayList < > ( ) ; result . put ( entry . getKey ( ) , values ) ; } values . add ( entry . getValue ( ) ) ; } } return result ; }
List < String > list = new ArrayList < String > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . add ( " d " ) ; list . add ( " e " ) ; list . add ( " f " ) ; list . add ( " g " ) ; list . add ( " h " ) ; list . add ( " i " ) ; list . add ( " j " ) ; list . add ( " k " ) ; list . add ( " l " ) ; list . add ( " m " ) ; list . add ( " n " ) ; list . add ( " o " ) ; list . add ( " p " ) ; list . add ( " q " ) ; list . add ( " r " ) ; list . add ( " s " ) ; list . add ( " t " ) ; list . add ( " u " ) ; list . add ( " v " ) ; list . add ( " w " ) ; list . add ( " x " ) ; list . add ( " y " ) ; list . add ( " z " ) ; List < String > list2 = new ArrayList < String > ( ) ; list2 . add ( " a " ) ; list2 . add ( " b " ) ; list2 . add ( " c " ) ; list2 . add ( " d " ) ; list2 . add ( " e " ) ; list2 . add ( " f " ) ; list2 . add ( " g " ) ; list2 . add ( " h " ) ; list2 . add ( " i " ) ; list2 . add ( " j " ) ; list2 . add ( " k " ) ; list2 . add ( " l " ) ; list2 . add ( " m " ) ; list2 . add ( " n " ) ; list2 . add ( " o " ) ; list2 . add ( " p " ) ; list2 . add ( " q " ) ; list2 . add ( " r " ) ; list2 . add ( " s " ) ; list2 . add ( " t " ) ; list2 . add ( " u " ) ; list2 . add ( " v " ) ; list2 . add ( " w " ) ; list2 . add ( " x " ) ; list2 . add ( " y " ) ; list2 . add ( " z " ) ; List < Integer > indexes = new ArrayList < Integer > ( ) ; for ( String s : list2 ) { indexes . add ( list . indexOf ( s ) ) ; } System . out . println ( indexes ) ;
List < String > list = Arrays . asList ( " a " , " b " , " c " ) ; String [ ] array = list . toArray ( new String [ list . size ( ) ] ) ;
Query query = new Query ( " Person " ) ; query . addFilter ( " address " , Query . FilterOperator . EQUAL , KeyFactory . createKey ( " Address " , "123" ) ) ; DatastoreService datastore = DatastoreServiceFactory . getDatastoreService ( ) ; PreparedQuery pq = datastore . prepare ( query ) ; for ( Entity result : pq . asIterable ( ) ) { String firstName = ( String ) result . getProperty ( " firstName " ) ; String lastName = ( String ) result . getProperty ( " lastName " ) ; System . out . println ( firstName + " ▁ " + lastName + " ▁ lives ▁ at ▁ " + result . getProperty ( " address " ) ) ; }
public static List < Integer > sum ( List < List < Integer > > lists ) { List < Integer > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < lists . get ( 0 ) . size ( ) ; i ++ ) { int sum = 0 ; for ( List < Integer > list : lists ) { sum += list . get ( i ) ; } result . add ( sum ) ; } return result ; }
public static < T > List < List < T > > unzip ( List < List < T > > list ) { List < List < T > > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < list . get ( 0 ) . size ( ) ; i ++ ) { List < T > subList = new ArrayList < > ( ) ; for ( List < T > sub : list ) { subList . add ( sub . get ( i ) ) ; } result . add ( subList ) ; } return result ; }
public static List < Pair < String , Integer > > map ( String s ) { List < Pair < String , Integer > > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { result . add ( new Pair < > ( s . substring ( i , i + 1 ) , i ) ) ; } return result ; }
String [ ] list = { " a " , " b " , " c " } ; System . out . println ( String . join ( " \t " , list ) ) ;
List < List < Integer > > listOfLists = new ArrayList < > ( ) ; listOfLists . add ( Arrays . asList ( 1 , 2 , 3 ) ) ; listOfLists . add ( Arrays . asList ( 4 , 5 , 6 ) ) ; listOfLists . add ( Arrays . asList ( 7 , 8 , 9 ) ) ; List < Integer > mergedList = listOfLists . stream ( ) . flatMap ( Collection :: stream ) . collect ( Collectors . toList ( ) ) ;
import pandas as pd import matplotlib . pyplot as plt df = pd . read_csv ( ' data . csv ' ) df . plot ( kind = ' bar ' , stacked = True ) plt . show ( )
String str = " This ▁ is ▁ a ▁ [ test ] ▁ string . " ; Pattern p = Pattern . compile ( " \\ [ ( . * ? ) \\ ] " ) ; Matcher m = p . matcher ( str ) ; while ( m . find ( ) ) { System . out . println ( m . group ( 1 ) ) ; }
Map < String , String > map = new HashMap < > ( ) ; map . put ( " key " , " value " ) ;
public static float hexToFloat ( String hex ) { return Float . intBitsToFloat ( Integer . parseInt ( hex , 16 ) ) ; }
List < Tuple2 < String , Integer > > list = new ArrayList < > ( ) ; list . add ( new Tuple2 < > ( " a " , 1 ) ) ; list . add ( new Tuple2 < > ( " b " , 2 ) ) ; list . add ( new Tuple2 < > ( " c " , 3 ) ) ;
String regex = " \\ b ( \\ w + ) ( \\ s + \\ 1 ) + \\ b " ; Pattern p = Pattern . compile ( regex , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( input ) ; while ( m . find ( ) ) { input = input . replaceAll ( m . group ( ) , m . group ( 1 ) ) ; }
File dir = new File ( " / path / to / dir " ) ; File [ ] files = dir . listFiles ( ) ; Random rand = new Random ( ) ; File file = files [ rand . nextInt ( files . length ) ] ;
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . add ( " d " ) ; list . add ( " e " ) ; list . add ( " f " ) ; list . add ( " g " ) ; list . add ( " h " ) ; list . add ( " i " ) ; list . add ( " j " ) ; list . add ( " k " ) ; list . add ( " l " ) ; list . add ( " m " ) ; list . add ( " n " ) ; list . add ( " o " ) ; list . add ( " p " ) ; list . add ( " q " ) ; list . add ( " r " ) ; list . add ( " s " ) ; list . add ( " t " ) ; list . add ( " u " ) ; list . add ( " v " ) ; list . add ( " w " ) ; list . add ( " x " ) ; list . add ( " y " ) ; list . add ( " z " ) ; list . removeIf ( s -> s . equals ( " a " ) ) ;
import java . net . InetAddress ; import java . net . UnknownHostException ; public class Main { public static void main ( String [ ] args ) throws UnknownHostException { InetAddress start = InetAddress . getByName ( "192.168.0.1" ) ; InetAddress end = InetAddress . getByName ( "192.168.0.255" ) ; InetAddress current = start ; while ( ! current . equals ( end ) ) { System . out . println ( current ) ; byte [ ] address = current . getAddress ( ) ; address [ 3 ] ++ ; current = InetAddress . getByAddress ( address ) ; } } }
public static boolean allEqual ( List < Integer > list ) { return list . stream ( ) . distinct ( ) . limit ( 2 ) . count ( ) <= 1 ; }
String value = "00001" ; int intValue = Integer . parseInt ( value ) ; intValue ++ ; String newValue = String . format ( " % 05d " , intValue ) ;
for ( int i = list . size ( ) - 1 ; i >= 0 ; i -- ) { System . out . println ( list . get ( i ) ) ; }
Map < String , List < String > > map = new HashMap < > ( ) ; map . put ( " key1" , Arrays . asList ( " value1" , " value2" ) ) ; map . put ( " key2" , Arrays . asList ( " value3" , " value4" ) ) ;
String fileName = " file . txt " ; String line = null ; try { FileReader fileReader = new FileReader ( fileName ) ; BufferedReader bufferedReader = new BufferedReader ( fileReader ) ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { System . out . println ( line ) ; } bufferedReader . close ( ) ; } catch ( FileNotFoundException ex ) { System . out . println ( " Unable ▁ to ▁ open ▁ file ▁ ' " + fileName + " ' " ) ; } catch ( IOException ex ) { System . out . println ( " Error ▁ reading ▁ file ▁ ' " + fileName + " ' " ) ; }
List < String > list = new ArrayList < > ( ) ; list . add ( "2019-01-01" ) ; list . add ( "2019-01-02" ) ; list . add ( "2019-01-03" ) ; list . add ( "2019-01-04" ) ; list . add ( "2019-01-05" ) ; list . add ( "2019-01-06" ) ; list . add ( "2019-01-07" ) ; list . add ( "2019-01-08" ) ; list . add ( "2019-01-09" ) ; list . add ( "2019-01-10" ) ; list . add ( "2019-01-11" ) ; list . add ( "2019-01-12" ) ; list . add ( "2019-01-13" ) ; list . add ( "2019-01-14" ) ; list . add ( "2019-01-15" ) ; list . add ( "2019-01-16" ) ; list . add ( "2019-01-17" ) ; list . add ( "2019-01-18" ) ; list . add ( "2019-01-19" ) ; list . add ( "2019-01-20" ) ; list . add ( "2019-01-21" ) ; list . add ( "2019-01-22" ) ; list . add ( "2019-01-23" ) ; list . add ( "2019-01-24" ) ; list . add ( "2019-01-25" ) ; list . add ( "2019-01-26" ) ; list . add ( "2019-01-27" ) ; list . add ( "2019-01-28" ) ; list . add ( "2019-01-29" ) ; list . add ( "2019-01-30" ) ; list . add ( "2019-01-31" ) ; Collections . sort ( list , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { try { return new SimpleDateFormat ( " yyyy - MM - dd " ) . parse ( o1 ) . compareTo ( new SimpleDateFormat ( " yyyy - MM - dd " ) . parse ( o2 ) ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return 0 ; } } ) ; for ( String s : list ) { System . out . println ( s ) ; }
public static boolean all ( String s , Predicate < Character > p ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! p . test ( s . charAt ( i ) ) ) { return false ; } } return true ; }
Collections . sort ( list , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { return o1 . split ( " ▁ " ) [ 1 ] . compareTo ( o2 . split ( " ▁ " ) [ 1 ] ) ; } } ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . removeIf ( s -> s . equals ( " b " ) ) ;
public static int sum ( List < Object > list ) { int sum = 0 ; for ( Object obj : list ) { if ( obj instanceof Integer ) { sum += ( Integer ) obj ; } else if ( obj instanceof List ) { sum += sum ( ( List < Object > ) obj ) ; } } return sum ; }
String s = " Hello ▁ World " ; s = s . replaceAll ( " [ aeiou ] " , " _ " ) ; System . out . println ( s ) ;
Spectrogram spectrogram = new Spectrogram ( data , sampleRate ) ; Colorbar colorbar = new Colorbar ( spectrogram ) ; spectrogram . addColorbar ( colorbar ) ;
public class MaxValue { public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int max = arr [ 0 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; } } System . out . println ( max ) ; } }
String str = " Hello ▁ < < name > > , ▁ We ▁ have ▁ your ▁ full ▁ name ▁ as ▁ < < full ▁ name > > ▁ in ▁ our ▁ system . " ; String name = " Alex ▁ Kolenchiskey " ; String fullName = " Alex ▁ Kolenchiskey " ; String str1 = str . replace ( " < < name > > " , name ) ; String str2 = str1 . replace ( " < < full ▁ name > > " , fullName ) ; System . out . println ( str2 ) ;
import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Iterator ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Row ; import org . apache . poi . xssf . usermodel . XSSFSheet ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; public class ReadExcelFile { public static void main ( String [ ] args ) throws IOException { FileInputStream file = new FileInputStream ( new File ( " C : \\ Users \\ Saurabh ▁ Dhingra \\ workspace \\ Read ▁ Excel ▁ File \\ src\ \r eadExcelFile \\ ReadExcelFile . xlsx " ) ) ; XSSFWorkbook workbook = new XSSFWorkbook ( file ) ; XSSFSheet sheet = workbook . getSheetAt ( 0 ) ; Iterator < Row > rowIterator = sheet . iterator ( ) ; while ( rowIterator . hasNext ( ) ) { Row row = rowIterator . next ( ) ; Iterator < Cell > cellIterator = row . cellIterator ( ) ; while ( cellIterator . hasNext ( ) ) { Cell cell = cellIterator . next ( ) ; switch ( cell . getCellType ( ) ) { case Cell . CELL_TYPE_NUMERIC : System . out . print ( cell . getNumericCellValue ( ) + " t " ) ; break ; case Cell . CELL_TYPE_STRING :
for file in ` ls * . java ` do echo " Processing ▁ $ file " sed - i ' s / \t / ▁ ▁ ▁ ▁ / g ' $file done
public static int longestWord ( String [ ] words ) { int maxLength = 0 ; for ( String word : words ) { maxLength = Math . max ( maxLength , word . length ( ) ) ; } return maxLength ; }
import pprint import logging logging . basicConfig ( filename = ' example . log ' , level = logging . DEBUG ) logging . debug ( pprint . pformat ( some_dict ) )
public static void createDirIfNotExists ( String dir ) { File theDir = new File ( dir ) ; if ( ! theDir . exists ( ) ) { System . out . println ( " creating ▁ directory : ▁ " + dir ) ; boolean result = false ; try { theDir . mkdir ( ) ; result = true ; } catch ( SecurityException se ) { } if ( result ) { System . out . println ( " DIR ▁ created " ) ; } } }
List < List < Integer > > list = new ArrayList < > ( ) ; list . add ( Arrays . asList ( 1 , 2 , 3 ) ) ; list . add ( Arrays . asList ( 4 , 5 , 6 ) ) ; list . add ( Arrays . asList ( 7 , 8 , 9 ) ) ; List < Integer > flatList = list . stream ( ) . flatMap ( Collection :: stream ) . collect ( Collectors . toList ( ) ) ;
Map < String , String > map = new HashMap < > ( ) ; map . put ( " key1" , " value1" ) ; map . put ( " key2" , null ) ; map . put ( " key3" , " value3" ) ; map . entrySet ( ) . removeIf ( entry -> entry . getValue ( ) == null ) ;
public static < K , V extends Comparable < ? super V > > K maxKey ( Map < K , V > map ) { Entry < K , V > max = null ; for ( Entry < K , V > entry : map . entrySet ( ) ) { if ( max == null || entry . getValue ( ) . compareTo ( max . getValue ( ) ) > 0 ) { max = entry ; } } return max . getKey ( ) ; }
MongoCursor < Document > cursor = collection . find ( ) . iterator ( ) ; while ( cursor . hasNext ( ) ) { Document doc = cursor . next ( ) ; for ( Map . Entry < String , Object > entry : doc . entrySet ( ) ) { System . out . println ( entry . getKey ( ) + " : ▁ " + entry . getValue ( ) ) ; } }
int index = IntStream . range ( 0 , list . size ( ) ) . filter ( i -> list . get ( i ) ) . findFirst ( ) . orElse ( - 1 ) ;
FileWriter fw = new FileWriter ( " output . txt " ) ; fw . write ( " Hello ▁ World " ) ; fw . close ( ) ;
List < String > list1 = new ArrayList < String > ( ) ; list1 . add ( " a " ) ; list1 . add ( " b " ) ; list1 . add ( " c " ) ; List < String > list2 = new ArrayList < String > ( ) ; list2 . add ( " d " ) ; list2 . add ( " e " ) ; list2 . add ( " f " ) ; list1 . addAll ( list2 ) ;
public static Date epochToDate ( long epoch ) { return new Date ( epoch ) ; }
String str = " Hello ▁ World " ; str = str . replace ( " World " , " Java " ) ;
public static void main ( String [ ] args ) { LocalDate start = LocalDate . of ( 2020 , 1 , 1 ) ; LocalDate end = LocalDate . of ( 2020 , 12 , 31 ) ; List < LocalDate > dates = new ArrayList < > ( ) ; while ( start . isBefore ( end ) ) { LocalDate date = start . with ( TemporalAdjusters . dayOfWeekInMonth ( 2 , DayOfWeek . FRIDAY ) ) ; dates . add ( date ) ; start = start . plusMonths ( 1 ) ; } System . out . println ( dates ) ; }
String cp1251 = " Привет " ; String utf8 = new String ( cp1251 . getBytes ( " CP1251" ) , " UTF - 8" ) ;
String str = " www . google . com " ; String [ ] parts = str . split ( " \\ . " ) ; String lastWord = parts [ parts . length - 1 ] ;
File dir = new File ( " / home / user / Documents " ) ; File [ ] files = dir . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir , String name ) { return name . endsWith ( " . txt " ) ; } } ) ;
import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; public class DownloadFile { public static void main ( String [ ] args ) throws IOException { String url = " http : // www . example . com / example . zip " ; String file = " example . zip " ; downloadUsingStream ( url , file ) ; } private static void downloadUsingStream ( String urlStr , String file ) throws IOException { URL url = new URL ( urlStr ) ; InputStream is = url . openStream ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ 4096 ] ; int bytesRead = 0 ; System . out . print ( " Downloading ▁ " + urlStr + " ▁ . . . ▁ " ) ; while ( ( bytesRead = is . read ( buffer ) ) != - 1 ) { fos . write ( buffer , 0 , bytesRead ) ; } System . out . println ( " done ! " ) ; is . close ( ) ; fos . close ( ) ; } }
String s = " Hello ▁ World " ; s = s . replaceAll ( " \\ s " , " _ " ) ; System . out . println ( s ) ;
Collections . sort ( list , new Comparator < Person > ( ) { @ Override public int compare ( Person o1 , Person o2 ) { return o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; } } ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( "1" ) ; list . add ( "2" ) ; list . add ( "3" ) ; List < Integer > intList = list . stream ( ) . map ( Integer :: parseInt ) . collect ( Collectors . toList ( ) ) ;
Collections . sort ( list , new Comparator < Map . Entry < String , Integer > > ( ) { @ Override public int compare ( Map . Entry < String , Integer > o1 , Map . Entry < String , Integer > o2 ) { return o1 . getValue ( ) . compareTo ( o2 . getValue ( ) ) ; } } ) ;
String str = " Hello ! ▁ This ▁ is ▁ a ▁ test ▁ string . " ; str = str . replaceAll ( " [ ^ a - zA - Z0-9 ] " , " " ) ;
public class User { private String name ; private String email ; private String phone ; private String address ; private String city ; private String state ; private String country ; private String zip ; private String password ; private String role ; private String status ; private String createdAt ; private String updatedAt ; }
public static void main ( String [ ] args ) { Cluster cluster = Cluster . builder ( ) . addContactPoint ( "127.0.0.1" ) . build ( ) ; Session session = cluster . connect ( " mykeyspace " ) ; ResultSet results = session . execute ( " SELECT ▁ * ▁ FROM ▁ mytable " ) ; for ( Row row : results ) { System . out . format ( " % s ▁ % d \n " , row . getString ( " mycolumn " ) , row . getInt ( " mycolumn2" ) ) ; } }
int [ ] [ ] matrix = new int [ list1 . size ( ) ] [ list2 . size ( ) ] ; for ( int i = 0 ; i < list1 . size ( ) ; i ++ ) { for ( int j = 0 ; j < list2 . size ( ) ; j ++ ) { matrix [ i ] [ j ] = list1 . get ( i ) * list2 . get ( j ) ; } }
String str = " Hello ▁ World " ; int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' l ' ) { count ++ ; } } System . out . println ( count ) ;
String s = " \" Hello \" " ; s = s . replaceAll ( " \" " , " \\ \\ \" " ) ;
public static void main ( String [ ] args ) { LocalDateTime now = LocalDateTime . now ( ) ; LocalDateTime plus = now . plusYears ( 100 ) ; LocalDateTime minus = now . minusYears ( 100 ) ; System . out . println ( now ) ; System . out . println ( plus ) ; System . out . println ( minus ) ; }
String str = " \\ \" " ; str = str . replace ( " \ \" , " " ) ;
public static double [ ] mean ( double [ ] [ ] x ) { double [ ] mean = new double [ x [ 0 ] . length ] ; for ( int i = 0 ; i < x . length ; i ++ ) { for ( int j = 0 ; j < x [ 0 ] . length ; j ++ ) { mean [ j ] += x [ i ] [ j ] ; } } for ( int i = 0 ; i < mean . length ; i ++ ) { mean [ i ] /= x . length ; } return mean ; }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; String input = scanner . nextLine ( ) ; System . out . println ( input ) ; } }
import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class RegexTest { public static void main ( String [ ] args ) { String text = " This ▁ is ▁ a ▁ [ test ] ▁ of ▁ the ▁ [ emergency ] ▁ broadcast ▁ system . " ; Pattern pattern = Pattern . compile ( " \\ [ ( . * ? ) \\ ] " ) ; Matcher matcher = pattern . matcher ( text ) ; while ( matcher . find ( ) ) { System . out . println ( matcher . group ( 1 ) ) ; } } }
public static int lastIndexOf ( String str , char ch ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ch ) { return i ; } } return - 1 ; }
String [ ] list = { " a " , " b " , " c " } ; String result = String . join ( " , " , list ) ;
List < String > list = new ArrayList < > ( ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { list . add ( entry . getValue ( ) ) ; }
try { } catch ( Exception e ) { }
String s = " Hello " ; s . toUpperCase ( ) ;
if ( myVar != null ) { }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . HttpURLConnection ; import java . net . URL ; public class HttpURLConnectionExample { private static final String USER_AGENT = " Mozilla / 5.0" ; private static final String GET_URL = " http : // localhost : 9090 / SpringMVCExample " ; private static final String POST_URL = " http : // localhost : 9090 / SpringMVCExample / home " ; private static final String POST_PARAMS = " userName = Pankaj " ; public static void main ( String [ ] args ) throws IOException { sendGET ( ) ; System . out . println ( " GET ▁ DONE " ) ; sendPOST ( ) ; System . out . println ( " POST ▁ DONE " ) ; } private static void sendGET ( ) throws IOException { URL obj = new URL ( GET_URL ) ; HttpURLConnection con = ( HttpURLConnection ) obj . openConnection ( ) ; con . setRequestMethod ( " GET " ) ; con . setRequestProperty ( " User - Agent " , USER_AGENT ) ; int responseCode = con . getResponseCode ( ) ; System . out . println ( " GET ▁ Response ▁ Code ▁ : : ▁ " + responseCode ) ; if ( responseCode == HttpURLConnection . HTTP_OK ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String inputLine ; StringBuffer response = new StringBuffer ( ) ; while ( ( inputLine = in . readLine ( ) ) != null ) { response . append ( inputLine ) ; } in . close ( ) ; System . out . println ( response . toString ( ) ) ; } else { System . out . println ( " GET ▁ request ▁ not ▁ worked " ) ; } } private static void sendPOST ( ) throws IOException { URL obj = new URL ( POST_URL ) ; HttpURLConnection con = ( HttpURLConnection ) obj . openConnection ( ) ; con . setRequestMethod ( " POST " ) ; con . setRequestProperty ( "User-Agent
List < String > list = Arrays . asList ( "1" , "2" , "3" ) ; List < Integer > intList = list . stream ( ) . map ( Integer :: parseInt ) . collect ( Collectors . toList ( ) ) ;
String str = " hello ▁ world " ; str . toUpperCase ( ) ;
Map < String , Integer > map = new HashMap < > ( ) ; for ( String s : list ) { map . put ( s , map . getOrDefault ( s , 0 ) + 1 ) ; }
public static int countWord ( String word , String sentence ) { int count = 0 ; for ( String s : sentence . split ( " ▁ " ) ) { if ( s . equals ( word ) ) { count ++ ; } } return count ; }
int [ ] [ ] arr = new int [ ] [ ] { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int [ ] [ ] sliced = Arrays . copyOfRange ( arr , 1 , 3 ) ;
int sum = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { sum += list . get ( i ) . getValue ( ) ; }
public class AlphanumericSort { public static void main ( String [ ] args ) { List < String > list = Arrays . asList ( " a1" , " a10" , " a2" , " a3" , " a4" , " a5" , " a6" , " a7" , " a8" , " a9" ) ; Collections . sort ( list , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { return extractInt ( o1 ) - extractInt ( o2 ) ; } int extractInt ( String s ) { String num = s . replaceAll ( " \\ D " , " " ) ; return num . isEmpty ( ) ? 0 : Integer . parseInt ( num ) ; } } ) ; System . out . println ( list ) ; } }
String s = " This ▁ is ▁ a ▁ ( test ) ▁ string " ; s = s . replaceAll ( " \\ ( \\ w + \\ ) " , " " ) ;
List < Integer > list1 = new ArrayList < > ( ) ; list1 . add ( 1 ) ; list1 . add ( 2 ) ; list1 . add ( 3 ) ; List < Integer > list2 = new ArrayList < > ( ) ; list2 . add ( 4 ) ; list2 . add ( 5 ) ; list2 . add ( 6 ) ; list2 . addAll ( 0 , list1 ) ; System . out . println ( list2 ) ;
int count = 0 ; for ( String s : list ) { if ( s == null ) { count ++ ; } }
String rreplace ( String s , String toReplace , String replacement ) { int pos = s . lastIndexOf ( toReplace ) ; if ( pos > - 1 ) { return s . substring ( 0 , pos ) + replacement + s . substring ( pos + toReplace . length ( ) , s . length ( ) ) ; } else { return s ; } }
import java . util . Date ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; DateFormat dateFormat = new SimpleDateFormat ( " yyyy / MM / dd ▁ HH : mm : ss " ) ; Date date = new Date ( ) ; System . out . println ( dateFormat . format ( date ) ) ;
import hep . aida . * ; import java . util . Random ; public class Hist2DColorBar { public static void main ( String [ ] args ) { IAnalysisFactory af = IAnalysisFactory . create ( ) ; ITree tree = af . createTreeFactory ( ) . create ( ) ; IHistogramFactory hf = af . createHistogramFactory ( tree ) ; IPlotter plotter = af . createPlotterFactory ( ) . create ( " Plot " ) ; IHistogram2D h2d = hf . createHistogram2D ( " h2d " , 50 , - 3 , 3 , 50 , - 3 , 3 ) ; Random r = new Random ( ) ; for ( int i = 0 ; i < 10000 ; i ++ ) { double x = r . nextGaussian ( ) ; double y = r . nextGaussian ( ) ; h2d . fill ( x , y ) ; } plotter . region ( 0 ) . plot ( h2d ) ; plotter . show ( ) ; plotter . interact ( ) ; } }
public static void main ( String [ ] args ) { int n = 3 ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = 0 ; } print ( arr ) ; while ( increment ( arr ) ) { print ( arr ) ; } } private static boolean increment ( int [ ] arr ) { int i = arr . length - 1 ; while ( i >= 0 ) { if ( arr [ i ] == 0 ) { arr [ i ] = 1 ; return true ; } else { arr [ i ] = 0 ; i -- ; } } return false ; } private static void print ( int [ ] arr ) { for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] ) ; } System . out . println ( ) ; }
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; int sum = 0 ; for ( Integer value : map . values ( ) ) { sum += value ; } System . out . println ( sum ) ;
public static void main ( String [ ] args ) { String html = " < html > < body > < div > < p > Hello < / p > < p > World < / p > < / div > < / body > < / html > " ; Document doc = Jsoup . parse ( html ) ; Element p = doc . select ( " p : contains ( World ) " ) . first ( ) ; System . out . println ( p . text ( ) ) ; }
String acronym = " U . S . A . " ; acronym = acronym . replaceAll ( " \\ . + " , " " ) ;
String s = " Hello , ▁ World ! " ; s = s . replaceAll ( " [ ^ a - zA - Z0-9 ] " , " " ) ;
public static Map < String , String > toMap ( List < List < String > > list ) { Map < String , String > map = new HashMap < > ( ) ; for ( List < String > entry : list ) { map . put ( entry . get ( 0 ) , entry . get ( 1 ) ) ; } return map ; }
public static void reverse ( List < Integer > list , int start , int end ) { if ( start < 0 || end >= list . size ( ) || start >= end ) { return ; } while ( start < end ) { int temp = list . get ( start ) ; list . set ( start , list . get ( end ) ) ; list . set ( end , temp ) ; start ++ ; end -- ; } }
public static boolean isInDictionary ( String word , Map < String , List < String > > dictionary ) { for ( String key : dictionary . keySet ( ) ) { if ( dictionary . get ( key ) . contains ( word ) ) { return true ; } } return false ; }
String json = " { \" name \" : \" John \" , \" age \" : 30 , \" car \" : null } " ; JSONObject obj = new JSONObject ( json ) ; String name = obj . getString ( " name " ) ; int age = obj . getInt ( " age " ) ; System . out . println ( name ) ; System . out . println ( age ) ;
List < Tuple < String , Integer > > list1 = new ArrayList < > ( ) ; list1 . add ( new Tuple < > ( " a " , 1 ) ) ; list1 . add ( new Tuple < > ( " b " , 2 ) ) ; list1 . add ( new Tuple < > ( " c " , 3 ) ) ; List < Tuple < String , Integer > > list2 = new ArrayList < > ( ) ; list2 . add ( new Tuple < > ( " a " , 1 ) ) ; list2 . add ( new Tuple < > ( " b " , 2 ) ) ; list2 . add ( new Tuple < > ( " c " , 3 ) ) ; boolean isEqual = list1 . equals ( list2 ) ;
List < String > list = new ArrayList < String > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . add ( " d " ) ; list . add ( " e " ) ; list . add ( " f " ) ; list . add ( " g " ) ; list . add ( " h " ) ; list . add ( " i " ) ; list . add ( " j " ) ; list . add ( " k " ) ; list . add ( " l " ) ; list . add ( " m " ) ; list . add ( " n " ) ; list . add ( " o " ) ; list . add ( " p " ) ; list . add ( " q " ) ; list . add ( " r " ) ; list . add ( " s " ) ; list . add ( " t " ) ; list . add ( " u " ) ; list . add ( " v " ) ; list . add ( " w " ) ; list . add ( " x " ) ; list . add ( " y " ) ; list . add ( " z " ) ; Collections . sort ( list , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { if ( o1 . matches ( " [ a - m ] . * " ) && o2 . matches ( " [ n - z ] . * " ) ) { return - 1 ; } else if ( o1 . matches ( " [ n - z ] . * " ) && o2 . matches ( " [ a - m ] . * " ) ) { return 1 ; } else { return o1 . compareTo ( o2 ) ; } } } ) ; System . out . println ( list ) ;
String unicodeString = " Hello ▁ World " ; byte [ ] byteString = unicodeString . getBytes ( " UTF - 8" ) ;
List < String > lines = Arrays . asList ( " spring " , " node " , " mkyong " ) ; List < String > result = lines . stream ( ) . filter ( line -> ! " mkyong " . equals ( line ) ) . collect ( Collectors . toList ( ) ) ; result . forEach ( System . out :: println ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . remove ( " b " ) ;
List < String > list1 = new ArrayList < String > ( ) ; list1 . add ( " a " ) ; list1 . add ( " b " ) ; list1 . add ( " c " ) ; List < String > list2 = new ArrayList < String > ( ) ; list2 . add ( " d " ) ; list2 . add ( " e " ) ; list2 . add ( " f " ) ; list1 . addAll ( list2 ) ;
public static Date getLastDayOfMonth ( Date date ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; calendar . set ( Calendar . DAY_OF_MONTH , calendar . getActualMaximum ( Calendar . DAY_OF_MONTH ) ) ; return calendar . getTime ( ) ; }
List < Map < String , Object > > list = new ArrayList < > ( ) ; list . add ( new HashMap < String , Object > ( ) { { put ( " key1" , " value1" ) ; put ( " key2" , " value2" ) ; } } ) ; list . add ( new HashMap < String , Object > ( ) { { put ( " key1" , " value1" ) ; put ( " key2" , " value2" ) ; } } ) ; list . add ( new HashMap < String , Object > ( ) { { put ( " key1" , " value1" ) ; put ( " key2" , " value2" ) ; } } ) ; list . forEach ( map -> map . remove ( " key1" ) ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( " abc " ) ; list . add ( " def " ) ; list . add ( " ghi " ) ; list . add ( " jkl " ) ; List < String > subList = new ArrayList < > ( ) ; subList . add ( " abc " ) ; subList . add ( " jkl " ) ; list . removeAll ( subList ) ;
List < List < Integer > > list = new ArrayList < > ( ) ; list . add ( Arrays . asList ( 1 , 2 , 3 ) ) ; list . add ( Arrays . asList ( 4 , 5 , 6 ) ) ; list . add ( Arrays . asList ( 7 , 8 , 9 ) ) ; List < List < Integer > > zipped = IntStream . range ( 0 , list . get ( 0 ) . size ( ) ) . mapToObj ( i -> list . stream ( ) . map ( l -> l . get ( i ) ) . collect ( Collectors . toList ( ) ) ) . collect ( Collectors . toList ( ) ) ;
String s = " Hello , ▁ World ! " ; System . out . println ( s . toUpperCase ( ) ) ;
public static void main ( String [ ] args ) { List < Tuple2 < String , Float > > list = new ArrayList < > ( ) ; list . add ( new Tuple2 < > ( " a " , 1.0f ) ) ; list . add ( new Tuple2 < > ( " b " , 2.0f ) ) ; list . add ( new Tuple2 < > ( " c " , 3.0f ) ) ; list . add ( new Tuple2 < > ( " d " , 4.0f ) ) ; list . add ( new Tuple2 < > ( " e " , 5.0f ) ) ; list . add ( new Tuple2 < > ( " f " , 6.0f ) ) ; list . add ( new Tuple2 < > ( " g " , 7.0f ) ) ; list . add ( new Tuple2 < > ( " h " , 8.0f ) ) ; list . add ( new Tuple2 < > ( " i " , 9.0f ) ) ; list . add ( new Tuple2 < > ( " j " , 10.0f ) ) ; list . add ( new Tuple2 < > ( " k " , 11.0f ) ) ; list . add ( new Tuple2 < > ( " l " , 12.0f ) ) ; list . add ( new Tuple2 < > ( " m " , 13.0f ) ) ; list . add ( new Tuple2 < > ( " n " , 14.0f ) ) ; list . add ( new Tuple2 < > ( " o " , 15.0f ) ) ; list . add ( new Tuple2 < > ( " p " , 16.0f ) ) ; list . add ( new Tuple2 < > ( " q " , 17.0f ) ) ; list . add ( new Tuple2 < > ( " r " , 18.0f ) ) ; list . add ( new Tuple2 < > ( " s " , 19.0f ) ) ; list . add ( new Tuple2 < > ( " t " , 20.0f ) ) ; list . add ( new Tuple2 < > ( " u " , 21.0f ) ) ; list . add ( new Tuple2 < > ( " v " , 22.0f ) ) ; list . add ( new Tuple2 < > ( " w " , 23.0f ) ) ; list .
public static char mostFrequentChar ( String s ) { Map < Character , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( map . containsKey ( c ) ) { map . put ( c , map . get ( c ) + 1 ) ; } else { map . put ( c , 1 ) ; } } int max = 0 ; char maxChar = ' ▁ ' ; for ( Map . Entry < Character , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) > max ) { max = entry . getValue ( ) ; maxChar = entry . getKey ( ) ; } } return maxChar ; }
String str = " Hello ▁ World " ; if ( str . matches ( " . * [ a - zA - Z ] . * " ) ) { System . out . println ( " String ▁ contains ▁ letters " ) ; } else { System . out . println ( " String ▁ doesn ' t ▁ contain ▁ letters " ) ; }
Map < String , Double > map = new HashMap < > ( ) ; map . put ( " a " , 1.0 ) ; map . put ( " b " , 2.0 ) ; map . put ( " c " , 3.0 ) ; double sum = 0.0 ; for ( Double value : map . values ( ) ) { sum += value ; } double average = sum / map . size ( ) ;
Collections . sort ( list , new Comparator < int [ ] > ( ) { @ Override public int compare ( int [ ] o1 , int [ ] o2 ) { if ( o1 [ 0 ] != o2 [ 0 ] ) { return o2 [ 0 ] - o1 [ 0 ] ; } else { return o1 [ 1 ] - o2 [ 1 ] ; } } } ) ;
Map < String , String > map = new HashMap < > ( ) ; map . put ( " key " , " value " ) ;
String [ ] words = { " Hello " , " World " } ; String firstLetters = " " ; for ( String word : words ) { firstLetters += word . charAt ( 0 ) ; }
public static List < List < Integer > > getAllCombinations ( List < Integer > list ) { List < List < Integer > > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < list . size ( ) ; j ++ ) { List < Integer > temp = new ArrayList < > ( ) ; temp . add ( list . get ( i ) ) ; temp . add ( list . get ( j ) ) ; result . add ( temp ) ; } } return result ; }
Collections . sort ( list , new Comparator < Person > ( ) { @ Override public int compare ( Person p1 , Person p2 ) { int cmp = p1 . getLastName ( ) . compareTo ( p2 . getLastName ( ) ) ; if ( cmp != 0 ) { return cmp ; } return p1 . getFirstName ( ) . compareTo ( p2 . getFirstName ( ) ) ; } } ) ;
import java . util . Random ; public class RandomNumberGenerator { public static void main ( String [ ] args ) { Random random = new Random ( ) ; int [ ] distribution = new int [ 10 ] ; for ( int i = 0 ; i < 1000000 ; i ++ ) { distribution [ random . nextInt ( 10 ) ] ++ ; } for ( int i = 0 ; i < 10 ; i ++ ) { System . out . println ( i + " : ▁ " + distribution [ i ] ) ; } } }
int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int [ ] arr2 = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr2 . length ; j ++ ) { if ( arr [ i ] == arr2 [ j ] ) { System . out . println ( i + " ▁ " + j ) ; } } }
String url = " http : // www . example . com / foo / bar / baz " ; String lastPart = url . substring ( url . lastIndexOf ( ' / ' ) + 1 ) ;
String str = " Hello ▁ World " ; str = str . replaceAll ( " [ ^ \\ d . ] " , " " ) ;
String str = " Hello ▁ World " ; str . matches ( " [ a - zA - Z ▁ ] + " ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; List < List < String > > listOfLists = new ArrayList < > ( ) ; listOfLists . add ( list ) ; listOfLists . add ( list ) ; listOfLists . add ( list ) ; List < String > mergedList = listOfLists . stream ( ) . flatMap ( Collection :: stream ) . collect ( Collectors . toList ( ) ) ;
Map < String , String > map = new HashMap < > ( ) ; map . put ( " A " , " a " ) ; map . put ( " B " , " b " ) ; map . put ( " C " , " c " ) ; Map < String , String > lowercaseMap = map . entrySet ( ) . stream ( ) . collect ( Collectors . toMap ( e -> e . getKey ( ) . toLowerCase ( ) , e -> e . getValue ( ) . toLowerCase ( ) ) ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; if ( list . contains ( " a " ) || list . contains ( " b " ) || list . contains ( " c " ) ) { }
Collections . sort ( list , new Comparator < Map . Entry < String , Integer > > ( ) { @ Override public int compare ( Map . Entry < String , Integer > o1 , Map . Entry < String , Integer > o2 ) { return o1 . getValue ( ) . compareTo ( o2 . getValue ( ) ) ; } } ) ;
public static boolean containsNonAscii ( String str ) { return ! str . matches ( " \\ p { ASCII } + " ) ; }
Date date = new Date ( ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; cal . add ( Calendar . MONTH , 6 ) ; date = cal . getTime ( ) ;
Tuple2 < String , Integer > tuple1 = new Tuple2 < > ( " a " , 1 ) ; Tuple2 < String , Integer > tuple2 = new Tuple2 < > ( " b " , 2 ) ; Tuple2 < String , Integer > tuple3 = new Tuple2 < > ( " c " , 3 ) ; Tuple3 < String , Integer , Integer > tuple = new Tuple3 < > ( tuple1 , tuple2 , tuple3 ) ;
Colorbar cb = plot . getColorbar ( ) ; cb . setRange ( 0 , 1 ) ;
String s = " ÄÖÜäöüß " ; byte [ ] bytes = s . getBytes ( " ISO - 8859-1" ) ; String s2 = new String ( bytes , " UTF - 8" ) ;
List < String > list1 = Arrays . asList ( " a " , " b " , " c " ) ; List < String > list2 = Arrays . asList ( " d " , " e " , " f " ) ; List < String > list3 = new ArrayList < > ( ) ; list3 . addAll ( list1 ) ; list3 . addAll ( list2 ) ;
import java . io . * ; public class WriteMultipleLines { public static void main ( String [ ] args ) { String fileName = " temp . txt " ; try { FileWriter fileWriter = new FileWriter ( fileName ) ; BufferedWriter bufferedWriter = new BufferedWriter ( fileWriter ) ; bufferedWriter . write ( " Hello ▁ there , " ) ; bufferedWriter . write ( " ▁ here ▁ is ▁ some ▁ text . " ) ; bufferedWriter . newLine ( ) ; bufferedWriter . write ( " We ▁ are ▁ writing " ) ; bufferedWriter . write ( " ▁ the ▁ text ▁ to ▁ the ▁ file . " ) ; bufferedWriter . close ( ) ; } catch ( IOException ex ) { System . out . println ( " Error ▁ writing ▁ to ▁ file ▁ ' " + fileName + " ' " ) ; } } }
import com . github . mike10004 . common . system . SystemInfo ; import com . github . mike10004 . common . system . SystemInfo . CpuUsage ; import com . github . mike10004 . common . system . SystemInfo . MemoryUsage ; SystemInfo systemInfo = SystemInfo . getInstance ( ) ; CpuUsage cpuUsage = systemInfo . getCpuUsage ( ) ; MemoryUsage memoryUsage = systemInfo . getMemoryUsage ( ) ;
String s = " \\ N { GREEK ▁ SMALL ▁ LETTER ▁ ALPHA } \\ N { GREEK ▁ CAPITAL ▁ LETTER ▁ OMEGA } " ; System . out . println ( s ) ;
String str = " ▁ ▁ ▁ Hello ▁ World ▁ ▁ ▁ " ; str = str . trim ( ) ;
List < Integer > list = new ArrayList < > ( ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( null ) ; list . add ( 0 ) ; list . removeAll ( Collections . singleton ( null ) ) ; System . out . println ( list ) ;
String str = " This ▁ is ▁ a ▁ test . ▁ This ▁ is , ▁ too . " ; String word = " is " ; int pos = str . indexOf ( word ) ; int start = str . lastIndexOf ( " ▁ " , pos ) ; int end = str . indexOf ( " ▁ " , pos ) ; if ( start == - 1 ) { start = 0 ; } if ( end == - 1 ) { end = str . length ( ) ; } String sentence = str . substring ( start , end ) ; System . out . println ( sentence ) ;
import java . util . ArrayList ; import java . util . List ; import org . apache . commons . math3 . ml . clustering . CentroidCluster ; import org . apache . commons . math3 . ml . clustering . KMeansPlusPlusClusterer ; import org . apache . commons . math3 . ml . clustering . MultiKMeansPlusPlusClusterer ; import org . apache . commons . math3 . ml . distance . EuclideanDistance ; public class KMeans { public static void main ( String [ ] args ) { List < Point > points = new ArrayList < Point > ( ) ; points . add ( new Point ( 1 ) ) ; points . add ( new Point ( 2 ) ) ; points . add ( new Point ( 3 ) ) ; points . add ( new Point ( 4 ) ) ; points . add ( new Point ( 5 ) ) ; points . add ( new Point ( 6 ) ) ; points . add ( new Point ( 7 ) ) ; points . add ( new Point ( 8 ) ) ; points . add ( new Point ( 9 ) ) ; points . add ( new Point ( 10 ) ) ; KMeansPlusPlusClusterer < Point > clusterer = new KMeansPlusPlusClusterer < Point > ( 2 , 1000 , new EuclideanDistance ( ) ) ; List < CentroidCluster < Point > > clusterResults = clusterer . cluster ( points ) ; for ( CentroidCluster < Point > cluster : clusterResults ) { System . out . println ( " Cluster ▁ center : ▁ " + cluster . getCenter ( ) . getPoint ( ) [ 0 ] ) ; System . out . println ( " Points : ▁ " ) ; for ( Point point : cluster . getPoints ( ) ) { System . out . println ( point . getPoint ( ) [ 0 ] ) ; } } } } class Point { private double [ ] point ; public Point ( double x ) { point = new double [ ] { x } ; } public double [ ] getPoint ( ) { return point ; } }
import java . util . Calendar ; import java . util . Date ; import java . util . TimeZone ; public class Main { public static void main ( String [ ] args ) { Date date = new Date ( ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; calendar . setTimeZone ( TimeZone . getTimeZone ( " UTC " ) ) ; System . out . println ( calendar . getTime ( ) ) ; } }
if ( map . containsKey ( key ) ) { }
Collections . sort ( list , new Comparator < List < String > > ( ) { @ Override public int compare ( List < String > o1 , List < String > o2 ) { return o1 . get ( index ) . compareTo ( o2 . get ( index ) ) ; } } ) ;
public static String get ( String url ) throws IOException { URL obj = new URL ( url ) ; HttpURLConnection con = ( HttpURLConnection ) obj . openConnection ( ) ; con . setRequestMethod ( " GET " ) ; con . setRequestProperty ( " User - Agent " , " Mozilla / 5.0" ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String inputLine ; StringBuffer response = new StringBuffer ( ) ; while ( ( inputLine = in . readLine ( ) ) != null ) { response . append ( inputLine ) ; } in . close ( ) ; return response . toString ( ) ; } public static String post ( String url , String data ) throws IOException { URL obj = new URL ( url ) ; HttpURLConnection con = ( HttpURLConnection ) obj . openConnection ( ) ; con . setRequestMethod ( " POST " ) ; con . setRequestProperty ( " User - Agent " , " Mozilla / 5.0" ) ; con . setRequestProperty ( " Accept - Language " , " en - US , en ; q = 0.5" ) ; con . setDoOutput ( true ) ; DataOutputStream wr = new DataOutputStream ( con . getOutputStream ( ) ) ; wr . writeBytes ( data ) ; wr . flush ( ) ; wr . close ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String inputLine ; StringBuffer response = new StringBuffer ( ) ; while ( ( inputLine = in . readLine ( ) ) != null ) { response . append ( inputLine ) ; } in . close ( ) ; return response . toString ( ) ; }
public class SortJson { public static void main ( String [ ] args ) throws IOException { String json = " { \" a \" : 1 , \" b \" : 2 , \" c \" : 3 , \" d \" : 4 , \" e \" : 5 } " ; ObjectMapper mapper = new ObjectMapper ( ) ; Map < String , Integer > map = mapper . readValue ( json , new TypeReference < Map < String , Integer > > ( ) { } ) ; Map < String , Integer > sortedMap = map . entrySet ( ) . stream ( ) . sorted ( Map . Entry . comparingByKey ( ) ) . collect ( Collectors . toMap ( Map . Entry :: getKey , Map . Entry :: getValue , ( oldValue , newValue ) -> oldValue , LinkedHashMap :: new ) ) ; System . out . println ( sortedMap ) ; } }
Random random = new Random ( ) ; int index = random . nextInt ( list . size ( ) ) ; String item = list . get ( index ) ;
List < Integer > list = new ArrayList < > ( ) ; list . add ( Integer . valueOf ( "1" ) ) ; list . add ( Integer . valueOf ( "2" ) ) ; list . add ( Integer . valueOf ( "3" ) ) ;
public static < T > List < Set < T > > removeDuplicates ( List < Set < T > > list ) { List < Set < T > > result = new ArrayList < > ( ) ; for ( Set < T > set : list ) { if ( ! result . contains ( set ) ) { result . add ( set ) ; } } return result ; }
List < String > names = new ArrayList < > ( ) ; for ( Person person : persons ) { names . add ( person . getName ( ) ) ; }
JButton button = new JButton ( " Button " ) ; button . setBackground ( Color . RED ) ;
String regex = " \\ d + " ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( string ) ; if ( matcher . find ( ) ) { System . out . println ( matcher . group ( 0 ) ) ; }
import java . util . Map ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Iterator ; import java . util . Enumeration ; import java . util . regex . Pattern ; import java . util . regex . Matcher ; import java . util . logging . Logger ; import java . util . logging . Level ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . HttpURLConnection ; import java . net . URLConnection ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . net . SocketException ; import java . net . SocketTimeoutException ; import java . net . ConnectException ; import java . net . ProtocolException ; import java . net . HttpRetryException ; import java . net . Proxy ; import java . net . ProxySelector ; import java . net . InetSocketAddress ; import java . net . Proxy . Type ; import java . net . CookieHandler ; import java . net . CookieManager ; import java . net . CookiePolicy ; import java . net . CookieStore ; import java . net . HttpCookie ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . HttpCookie ; import java . net . CookieStore ; import java . net . CookiePolicy ; import java . net . CookieManager ; import java . net . CookieHandler ; import java . net . HttpURLConnection ; import java . net . URLConnection ; import java . net . URL ; import java . net . MalformedURLException ; import java . net . URLEncoder ; import java . net . URL
String arabicText = " العربية " ; String englishText = " English " ; String mixedText = " العربية ▁ English " ; String arabicTextRegex = " [ \u0600 - \u06FF ] + " ; String englishTextRegex = " [ a - zA - Z ] + " ; System . out . println ( arabicText . matches ( arabicTextRegex ) ) ; System . out . println ( englishText . matches ( arabicTextRegex ) ) ; System . out . println ( mixedText . matches ( arabicTextRegex ) ) ; System . out . println ( arabicText . matches ( englishTextRegex ) ) ; System . out . println ( englishText . matches ( englishTextRegex ) ) ; System . out . println ( mixedText . matches ( englishTextRegex ) ) ;
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ;
public static void main ( String [ ] args ) { List < String > list = Arrays . asList ( " a " , " b " , " c " ) ; List < List < String > > result = new ArrayList < > ( ) ; permute ( list , 0 , result ) ; System . out . println ( result ) ; } private static void permute ( List < String > list , int start , List < List < String > > result ) { if ( start == list . size ( ) ) { result . add ( new ArrayList < > ( list ) ) ; } else { for ( int i = start ; i < list . size ( ) ; i ++ ) { Collections . swap ( list , start , i ) ; permute ( list , start + 1 , result ) ; Collections . swap ( list , start , i ) ; } } }
public class ReverseString { public static void main ( String [ ] args ) { String str = " Hello ▁ World " ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { sb . append ( str . charAt ( i ) ) ; } System . out . println ( sb . toString ( ) ) ; } }
JSONObject json = new JSONObject ( jsonString ) ; JSONArray jsonArray = json . getJSONArray ( " key " ) ; for ( int i = 0 ; i < jsonArray . length ( ) ; i ++ ) { JSONObject jsonObject = jsonArray . getJSONObject ( i ) ; String value = jsonObject . getString ( " key " ) ; }
public static List < String > splitString ( String str , int chunkSize ) { List < String > chunks = new ArrayList < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i += chunkSize ) { chunks . add ( str . substring ( i , Math . min ( str . length ( ) , i + chunkSize ) ) ) ; } return chunks ; }
Collections . sort ( list , new Comparator < List < Integer > > ( ) { @ Override public int compare ( List < Integer > o1 , List < Integer > o2 ) { return o1 . get ( 0 ) - o2 . get ( 0 ) ; } } ) ;
String s = "123abc " ; s . matches ( " ^ \\ d + . * " ) ;
public static boolean isNumeric ( String str ) { try { double d = Double . parseDouble ( str ) ; } catch ( NumberFormatException nfe ) { return false ; } return true ; }
String text = " aab " ; String regexp = " a + " ; Pattern pattern = Pattern . compile ( regexp ) ; Matcher matcher = pattern . matcher ( text ) ; while ( matcher . find ( ) ) { System . out . println ( matcher . group ( ) ) ; }
public class Main { public static void main ( String [ ] args ) { Map < String , String > map1 = new HashMap < > ( ) ; map1 . put ( " key1" , " value1" ) ; map1 . put ( " key2" , " value2" ) ; map1 . put ( " key3" , " value3" ) ; Map < String , String > map2 = new HashMap < > ( ) ; map2 . put ( " key3" , " value3" ) ; map2 . put ( " key2" , " value2" ) ; map2 . put ( " key1" , " value1" ) ; System . out . println ( map1 . hashCode ( ) ) ; System . out . println ( map2 . hashCode ( ) ) ; } }
Canvas canvas = new Canvas ( ) ; TextItem textItem = new TextItem ( " Hello ▁ World " ) ; textItem . setFontSize ( 20 ) ; canvas . addItem ( textItem ) ;
public static boolean containsList ( List < Object > list ) { for ( Object o : list ) { if ( o instanceof List ) { return true ; } } return false ; }
String hex = "0123456789ABCDEF " ; List < Integer > values = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < hex . length ( ) ; i ++ ) { char c = hex . charAt ( i ) ; int d = Character . digit ( c , 16 ) ; values . add ( d ) ; }
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; String last = list . get ( list . size ( ) - 1 ) ;
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; System . out . print ( " Enter ▁ your ▁ name : ▁ " ) ; String name = scanner . nextLine ( ) ; System . out . println ( " Hello ▁ " + name ) ; } }
public class Solution { public int strStr ( String haystack , String needle ) { if ( needle . length ( ) == 0 ) return 0 ; if ( haystack . length ( ) == 0 ) return - 1 ; for ( int i = 0 ; i < haystack . length ( ) - needle . length ( ) + 1 ; i ++ ) { if ( haystack . substring ( i , i + needle . length ( ) ) . equals ( needle ) ) { return i ; } } return - 1 ; } }
public static float stringToFloat ( String s ) { return Float . intBitsToFloat ( s . hashCode ( ) ) ; }
String s = " Hello ▁ World " ; s = s . replaceAll ( " ( ? i ) hello " , " Hi " ) ;
List < String > list = Arrays . asList ( " a " , " b " , " c " , " d " , " a " , " b " , " c " , " d " ) ; int count = 0 ; for ( String element : list ) { if ( element . equals ( " a " ) ) { count ++ ; } } System . out . println ( count ) ;
# Import BeautifulSoup from bs4 import BeautifulSoup # Create a BeautifulSoup object from the HTML : soup soup = BeautifulSoup ( html_doc , ' html . parser ' ) # Print the title of Guido 's webpage print ( soup . title ) # Find all ' a ' tags ( which define hyperlinks ) : a_tags a_tags = soup . find_all ( ' a ' ) # Print the URLs to the shell for link in a_tags : print ( link . get ( ' href ' ) )
int x = 5 ; if ( x instanceof Integer ) { System . out . println ( " x ▁ is ▁ an ▁ integer " ) ; }
Arrays . sort ( array , new Comparator < int [ ] > ( ) { @ Override public int compare ( int [ ] o1 , int [ ] o2 ) { return Integer . compare ( o1 [ 0 ] , o2 [ 0 ] ) ; } } ) ;
public class Main { public static void main ( String [ ] args ) { System . out . println ( new Main ( ) . getClass ( ) . getName ( ) ) ; } }
Collections . sort ( list , new Comparator < Tuple > ( ) { @ Override public int compare ( Tuple o1 , Tuple o2 ) { return o1 . getSecond ( ) . compareTo ( o2 . getSecond ( ) ) ; } } ) ;
public class Solution { public boolean repeatedSubstringPattern ( String s ) { int len = s . length ( ) ; for ( int i = len / 2 ; i >= 1 ; i -- ) { if ( len % i == 0 ) { int m = len / i ; String subS = s . substring ( 0 , i ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int j = 0 ; j < m ; j ++ ) { sb . append ( subS ) ; } if ( sb . toString ( ) . equals ( s ) ) return true ; } } return false ; } }
import java . sql . Connection ; import java . sql . DriverManager ; import java . sql . SQLException ; public class Main { public static void main ( String [ ] args ) throws SQLException { Connection connection = DriverManager . getConnection ( " jdbc : mysql : // localhost : 3306 / test ? useServerPrepStmts = true & cachePrepStmts = false " , " root " , " root " ) ; } }
URL url = new URL ( " http : // www . example . com / example . txt " ) ; ReadableByteChannel rbc = Channels . newChannel ( url . openStream ( ) ) ; FileOutputStream fos = new FileOutputStream ( " example . txt " ) ; fos . getChannel ( ) . transferFrom ( rbc , 0 , Long . MAX_VALUE ) ;
from bs4 import BeautifulSoup import requests url = ' https : // www . google . com / search ? q = java ' response = requests . get ( url ) soup = BeautifulSoup ( response . text , ' html . parser ' ) for meta in soup . find_all ( ' meta ' ) : if ' name ' in meta . attrs and meta [ ' name ' ] == ' description ' : print ( meta [ ' content ' ] )
String [ ] arr = { " abc " , " ab " , " a " , " abcd " } ; Arrays . sort ( arr , new Comparator < String > ( ) { @ Override public int compare ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) { return s1 . length ( ) - s2 . length ( ) ; } return s1 . compareTo ( s2 ) ; } } ) ;
public static int convertToBase10 ( String s ) { int result = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { result = result * 2 + ( s . charAt ( i ) - '0' ) ; } return result ; }
public static int countOccurrences ( String haystack , char needle ) { int count = 0 ; for ( int i = 0 ; i < haystack . length ( ) ; i ++ ) { if ( haystack . charAt ( i ) == needle ) { count ++ ; } } return count ; }
String html = " < html > < head > < title > Test < / title > < / head > < body > \u00A0 < / body > < / html > " ; Document doc = Jsoup . parse ( html ) ; String text = doc . text ( ) ; System . out . println ( text ) ;
List < Integer > list = new ArrayList < > ( ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; list . add ( 4 ) ; list . add ( 5 ) ; list . add ( 6 ) ; list . add ( 7 ) ; list . add ( 8 ) ; list . add ( 9 ) ; list . add ( 10 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; System . out . println ( list ) ;
import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Row ; import org . apache . poi . ss . usermodel . Sheet ; import org . apache . poi . ss . usermodel . Workbook ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; public class XlsxWriter { public static void main ( String [ ] args ) throws IOException { String [ ] columns = { " Name " , " Email " , " Date ▁ Of ▁ Birth " , " Salary " } ; String path = " C : \\ Users \\ user \\ Desktop\ \" ; String fileName = " Employee . xlsx " ; String sheetName = " Employee " ; List < Employee > list = new ArrayList < > ( ) ; list . add ( new Employee ( " Rajeev ▁ Singh " , " rajeev @ example . com " , "1991-04-21" , 9000000.0 ) ) ; list . add ( new Employee ( " Thomas ▁ cook " , " thomas @ example . com " , "1980-07-02" , 6500000.0 ) ) ; list . add ( new Employee ( " Steve ▁ Maiden " , " steve @ example . com " , "1978-09-23" , 7500000.0 ) ) ; list . add ( new Employee ( " Brad ▁ pit " , " brad @ example . com " , "1956-12-02" , 8500000.0 ) ) ; list . add ( new Employee ( " Herry ▁ Porter " , " herry @ example . com " , "1961-01-25" , 7500000.0 ) ) ; list . add ( new Employee ( " Clark ▁ Man " , " clark @ example . com " , "1951-11-12" , 6500000.0 ) ) ; list . add ( new Employee ( " Paul ▁ Robinson " , " paul @ example . com " , "1964-01-31" , 5500000.0 ) ) ; list . add ( new Employee ( " Buffet " , " buffet @ example . com " ,
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , "1" ) ; map . put ( " b " , "2" ) ; map . put ( " c " , "3" ) ; Map < String , Integer > result = map . entrySet ( ) . stream ( ) . collect ( Collectors . toMap ( Map . Entry :: getKey , e -> Integer . valueOf ( e . getValue ( ) ) ) ) ;
Map < String , String > map = new HashMap < > ( ) ; map . put ( " key1" , " value1" ) ; map . put ( " key2" , " value2" ) ; List < String > list = new ArrayList < > ( map . values ( ) ) ;
String str = " Hello ▁ World " ; String subStr = str . substring ( 0 , 5 ) ;
public static void main ( String [ ] args ) { String word = " hello " ; int count = 0 ; for ( int i = 0 ; i < word . length ( ) - 1 ; i ++ ) { if ( isConsonant ( word . charAt ( i ) ) && isConsonant ( word . charAt ( i + 1 ) ) ) { count ++ ; } } System . out . println ( count ) ; } public static boolean isConsonant ( char c ) { return ! ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ; }
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . clear ( ) ;
Yaml yaml = new Yaml ( ) ; Map < String , Object > map = yaml . load ( new FileInputStream ( new File ( " test . yaml " ) ) ) ;
import java . io . File ; import java . io . FileNotFoundException ; import java . util . Scanner ; public class ReadCSV { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner scanner = new Scanner ( new File ( " data . csv " ) ) ; scanner . useDelimiter ( " , " ) ; while ( scanner . hasNext ( ) ) { System . out . print ( scanner . next ( ) + " | " ) ; } scanner . close ( ) ; } }
String sql = " SELECT ▁ * ▁ FROM ▁ users ▁ WHERE ▁ id ▁ IN ▁ ( ? ) " ; PreparedStatement stmt = conn . prepareStatement ( sql ) ; stmt . setArray ( 1 , conn . createArrayOf ( " integer " , new Integer [ ] { 1 , 2 , 3 } ) ) ; ResultSet rs = stmt . executeQuery ( ) ;
List < String > list1 = Arrays . asList ( " a " , " b " , " c " ) ; List < String > list2 = Arrays . asList ( "1" , "2" , "3" ) ; List < Tuple2 < String , String > > list = list1 . stream ( ) . flatMap ( s1 -> list2 . stream ( ) . map ( s2 -> new Tuple2 < > ( s1 , s2 ) ) ) . collect ( Collectors . toList ( ) ) ;
String [ ] array = { " a " , " b " , " c " } ; String string = " a " ; Arrays . asList ( array ) . contains ( string ) ;
int count = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == null ) { count ++ ; } }
List < String > list = Arrays . asList ( " a " , " " , " b " , " c " , " " , " d " ) ; list . removeAll ( Collections . singleton ( " " ) ) ;
String str = " Hello ▁ World " ; String newStr = str . substring ( 2 ) ;
String s = " a \n b " ; Pattern p = Pattern . compile ( " ( . * ? ) b " , Pattern . DOTALL ) ; Matcher m = p . matcher ( s ) ; m . find ( ) ; System . out . println ( m . group ( 1 ) ) ;
public static boolean allEqual ( List < Integer > list ) { return list . stream ( ) . distinct ( ) . limit ( 2 ) . count ( ) <= 1 ; }
if ( list . isEmpty ( ) ) { }
public class Main { public static void main ( String [ ] args ) { Thread thread1 = new Thread ( new Runnable ( ) { @ Override public void run ( ) { System . out . println ( " Hello ▁ from ▁ thread ▁ 1" ) ; } } ) ; Thread thread2 = new Thread ( new Runnable ( ) { @ Override public void run ( ) { System . out . println ( " Hello ▁ from ▁ thread ▁ 2" ) ; } } ) ; thread1 . start ( ) ; thread2 . start ( ) ; } }
List < String > first = Arrays . asList ( " a " , " b " , " c " ) ; List < String > second = Arrays . asList ( " x " , " y " , " z " ) ; List < String > result = new ArrayList < > ( ) ; result . add ( first . get ( 0 ) ) ; result . add ( second . get ( second . size ( ) - 1 ) ) ;
List < String > names = new ArrayList < String > ( ) ; for ( User user : users ) { names . add ( user . getName ( ) ) ; }
List < Integer > list = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Tuple2 < Integer , Integer > > pairs = new ArrayList < > ( ) ; for ( int i = 0 ; i < list . size ( ) - 1 ; i ++ ) { if ( list . get ( i ) % 2 == 0 && list . get ( i + 1 ) % 2 == 0 ) { pairs . add ( new Tuple2 < > ( list . get ( i ) , list . get ( i + 1 ) ) ) ; } }
File dir = new File ( " / path / to / dir " ) ; File [ ] files = dir . listFiles ( ) ; for ( File file : files ) { if ( file . isFile ( ) ) { System . out . println ( file . getName ( ) ) ; } }
import java . util . ArrayList ; import java . util . List ; import com . google . gson . Gson ; import com . google . gson . GsonBuilder ; public class Main { public static void main ( String [ ] args ) { Gson gson = new GsonBuilder ( ) . create ( ) ; List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; String json = gson . toJson ( list ) ; System . out . println ( json ) ; } }
Random random = new Random ( ) ; int randomInt = random . nextInt ( 10 ) ;
public static < T > List < List < T > > splitList ( List < T > list , int chunkSize ) { List < List < T > > chunks = new ArrayList < > ( ) ; for ( int i = 0 ; i < list . size ( ) ; i += chunkSize ) { chunks . add ( list . subList ( i , Math . min ( i + chunkSize , list . size ( ) ) ) ) ; } return chunks ; }
boolean x = true ; boolean y = false ; boolean z = x ^ y ;
List < String > list = Arrays . asList ( " a " , " b " , " c " ) ; List < String > newList = list . stream ( ) . map ( s -> " x " + s ) . collect ( Collectors . toList ( ) ) ;
import java . util . Random ; import java . util . Set ; import java . util . TreeSet ; public class RandomNumberGenerator { public static void main ( String [ ] args ) { Random random = new Random ( ) ; Set < Integer > set = new TreeSet < > ( ) ; while ( set . size ( ) < 10 ) { set . add ( random . nextInt ( 100 ) ) ; } System . out . println ( set ) ; } }
from bs4 import BeautifulSoup soup = BeautifulSoup ( html , ' html . parser ' ) soup . find_all ( string = re . compile ( ' Java ' ) )
String str = " Hello ▁ World " ; str = str . replace ( ' l ' , ' x ' ) ;
Map < String , List < String > > map = new HashMap < > ( ) ; map . put ( " key " , new ArrayList < > ( ) ) ; map . get ( " key " ) . add ( " value " ) ;
String [ ] strs = { " abc " , " def " , " ghi " } ; for ( int i = 0 ; i < strs . length ; i ++ ) { strs [ i ] = strs [ i ] . replace ( " a " , " " ) ; }
String time = "12:00:00" ; SimpleDateFormat sdf = new SimpleDateFormat ( " HH : mm : ss " ) ; Date date = sdf . parse ( time ) ;
List < List < String > > list = new ArrayList < > ( ) ; list . add ( Arrays . asList ( " a " , " b " , " c " ) ) ; list . add ( Arrays . asList ( " d " , " e " , " f " ) ) ; list . add ( Arrays . asList ( " g " , " h " , " i " ) ) ; list . stream ( ) . map ( l -> l . stream ( ) . map ( s -> s . replace ( " a " , " A " ) ) . collect ( Collectors . toList ( ) ) ) . collect ( Collectors . toList ( ) ) ;
public void closeWindow ( ) { this . dispose ( ) ; }
public int getRowCount ( String tableName ) { int count = 0 ; try { Statement stmt = connection . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( " SELECT ▁ COUNT ( * ) ▁ FROM ▁ " + tableName ) ; rs . next ( ) ; count = rs . getInt ( 1 ) ; rs . close ( ) ; stmt . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return count ; }
List < List < Integer > > list = new ArrayList < > ( ) ; list . add ( Arrays . asList ( 1 , 2 , 3 ) ) ; list . add ( Arrays . asList ( 1 , 2 , 4 ) ) ; list . add ( Arrays . asList ( 1 , 2 , 5 ) ) ; Collections . sort ( list , new Comparator < List < Integer > > ( ) { @ Override public int compare ( List < Integer > o1 , List < Integer > o2 ) { for ( int i = 0 ; i < Math . min ( o1 . size ( ) , o2 . size ( ) ) ; i ++ ) { int cmp = Integer . compare ( o1 . get ( i ) , o2 . get ( i ) ) ; if ( cmp != 0 ) { return cmp ; } } return Integer . compare ( o1 . size ( ) , o2 . size ( ) ) ; } } ) ; System . out . println ( list ) ;
List < String > list1 = Arrays . asList ( " a " , " b " , " c " ) ; List < String > list2 = Arrays . asList ( " b " , " c " , " d " ) ; boolean anyMatch = list1 . stream ( ) . anyMatch ( list2 :: contains ) ;
import java . io . File ; import java . io . FileNotFoundException ; import java . util . Scanner ; public class ReadFiles { public static void main ( String [ ] args ) { File file = new File ( " / Users / joe / Desktop / test " ) ; readFiles ( file ) ; } public static void readFiles ( File file ) { if ( file . isDirectory ( ) ) { File [ ] files = file . listFiles ( ) ; for ( File f : files ) { readFiles ( f ) ; } } else { try { Scanner scanner = new Scanner ( file ) ; while ( scanner . hasNext ( ) ) { System . out . println ( scanner . nextLine ( ) ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } } }
String s = " String ▁ with ▁ ( words ) ▁ in ▁ parentheses " ; s = s . replaceAll ( " \\ ( . * ? \\ ) ▁ ? " , " " ) ;
List < String > list = Arrays . asList ( " a " , " b " , " c " , " d " , " e " , " f " , " g " , " h " , " i " , " j " , " k " , " l " , " m " , " n " , " o " , " p " , " q " , " r " , " s " , " t " , " u " , " v " , " w " , " x " , " y " , " z " ) ; Map < String , List < String > > grouped = list . stream ( ) . collect ( Collectors . groupingBy ( s -> s . substring ( 0 , 1 ) ) ) ; System . out . println ( grouped ) ;
public class SortList { public static void main ( String [ ] args ) { List < String > list = Arrays . asList ( " a " , " b " , " c " , " d " , " e " ) ; List < Integer > order = Arrays . asList ( 3 , 1 , 4 , 2 , 0 ) ; List < String > sorted = new ArrayList < > ( list . size ( ) ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { sorted . add ( null ) ; } for ( int i = 0 ; i < list . size ( ) ; i ++ ) { sorted . set ( order . get ( i ) , list . get ( i ) ) ; } System . out . println ( sorted ) ; } }
public static List < Integer > findAllPositionsOfMaxValue ( List < Integer > list ) { List < Integer > result = new ArrayList < > ( ) ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( list . get ( i ) > max ) { max = list . get ( i ) ; result . clear ( ) ; result . add ( i ) ; } else if ( list . get ( i ) == max ) { result . add ( i ) ; } } return result ; }
client . deleteFile ( " / path / to / file " ) ; client . deleteFolder ( " / path / to / folder " ) ;
WebElement element = driver . findElement ( By . xpath ( " // * [ contains ( @ onclick , ▁ ' clickMe ' ) ] " ) ) ; element . click ( ) ;
String str = " ▁ ▁ ▁ Hello ▁ World ▁ ▁ ▁ " ; str = str . replaceAll ( " \\ s + " , " " ) ;
public static void main ( String [ ] args ) { String [ ] numbers = "1.2.3.4.5.6.7.8.9.10" . split ( " \\ . " ) ; Arrays . sort ( numbers , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { return Integer . valueOf ( o1 ) . compareTo ( Integer . valueOf ( o2 ) ) ; } } ) ; System . out . println ( Arrays . toString ( numbers ) ) ; }
String regex = " ( \\ d + ) " ; String string = "12345" ; String subst = " $ 1a " ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( string ) ; String result = matcher . replaceAll ( subst ) ; System . out . println ( result ) ;
List < List < String > > listOfLists = new ArrayList < > ( ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ;
public static int countEnd ( String str , char c ) { int count = 0 ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == c ) { count ++ ; } else { break ; } } return count ; }
public static int sum ( int [ ] arr ) { int sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += Math . pow ( arr [ i ] , i ) ; } return sum ; }
import java . util . Random ; public class RandomColor { public static void main ( String [ ] args ) { Random random = new Random ( ) ; int r = random . nextInt ( 256 ) ; int g = random . nextInt ( 256 ) ; int b = random . nextInt ( 256 ) ; System . out . println ( " r ▁ = ▁ " + r ) ; System . out . println ( " g ▁ = ▁ " + g ) ; System . out . println ( " b ▁ = ▁ " + b ) ; } }
import org . jfree . chart . ChartFactory ; import org . jfree . chart . ChartPanel ; import org . jfree . chart . JFreeChart ; import org . jfree . chart . axis . AxisLocation ; import org . jfree . chart . axis . NumberAxis ; import org . jfree . chart . plot . PlotOrientation ; import org . jfree . chart . plot . XYPlot ; import org . jfree . data . xy . XYDataset ; import org . jfree . data . xy . XYSeries ; import org . jfree . data . xy . XYSeriesCollection ; import org . jfree . ui . ApplicationFrame ; import org . jfree . ui . RefineryUtilities ; public class XYPlotDemo2 extends ApplicationFrame { public XYPlotDemo2 ( String title ) { super ( title ) ; XYDataset dataset = createDataset ( ) ; JFreeChart chart = createChart ( dataset ) ; ChartPanel chartPanel = new ChartPanel ( chart ) ; chartPanel . setPreferredSize ( new java . awt . Dimension ( 500 , 270 ) ) ; setContentPane ( chartPanel ) ; } private XYDataset createDataset ( ) { XYSeries series1 = new XYSeries ( " First " ) ; series1 . add ( 1.0 , 1.0 ) ; series1 . add ( 2.0 , 4.0 ) ; series1 . add ( 3.0 , 3.0 ) ; series1 . add ( 4.0 , 5.0 ) ; series1 . add ( 5.0 , 5.0 ) ; series1 . add ( 6.0 , 7.0 ) ; series1 . add ( 7.0 , 7.0 ) ; series1 . add ( 8.0 , 8.0 ) ; XYSeries series2 = new XYSeries ( " Second " ) ; series2 . add ( 1.0 , 5.0 ) ; series2 . add ( 2.0 , 7.0 ) ; series2 . add ( 3.0 , 6.0 ) ; series2 . add ( 4.0 , 8.0 ) ;
String str = " Hello ▁ World " ; String result = str . replaceAll ( " \\ w * ( World ) \\ w * " , " $ 1" ) ;
List < String > list1 = Arrays . asList ( " A " , " B " , " C " ) ; List < String > list2 = Arrays . asList ( " D " , " E " , " F " ) ; List < String > list3 = Arrays . asList ( " G " , " H " , " I " ) ; List < String > result = Stream . of ( list1 , list2 , list3 ) . flatMap ( Collection :: stream ) . collect ( Collectors . toList ( ) ) ;
@ RequestMapping ( value = " / " , method = RequestMethod . GET ) public ResponseEntity < String > get ( ) { HttpHeaders headers = new HttpHeaders ( ) ; headers . add ( " Content - Type " , " application / json ; ▁ charset = utf - 8" ) ; return new ResponseEntity < String > ( " { \" message \" : ▁ \" Hello ▁ World \" } " , headers , HttpStatus . OK ) ; }
public static < T > List < List < T > > allCombinations ( List < List < T > > lists ) { List < List < T > > result = new ArrayList < > ( ) ; allCombinations ( lists , 0 , new ArrayList < > ( ) , result ) ; return result ; } private static < T > void allCombinations ( List < List < T > > lists , int depth , List < T > current , List < List < T > > result ) { if ( depth == lists . size ( ) ) { result . add ( current ) ; return ; } for ( T element : lists . get ( depth ) ) { List < T > copy = new ArrayList < > ( current ) ; copy . add ( element ) ; allCombinations ( lists , depth + 1 , copy , result ) ; } }
String fileName = " file . txt " ; String line = null ; StringBuilder sb = new StringBuilder ( ) ; try { FileReader fileReader = new FileReader ( fileName ) ; BufferedReader bufferedReader = new BufferedReader ( fileReader ) ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { sb . append ( line . replaceAll ( " \\ ^ M " , " " ) ) ; } bufferedReader . close ( ) ; } catch ( FileNotFoundException ex ) { System . out . println ( " Unable ▁ to ▁ open ▁ file ▁ ' " + fileName + " ' " ) ; } catch ( IOException ex ) { System . out . println ( " Error ▁ reading ▁ file ▁ ' " + fileName + " ' " ) ; }
String [ ] list = { " a " , " b " , " c " } ; String [ ] newList = new String [ list . length + 1 ] ; System . arraycopy ( list , 0 , newList , 0 , list . length ) ; newList [ list . length ] = " d " ;
public static void main ( String [ ] args ) { String str = " abcdabcd " ; Set < Character > set = new HashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { set . add ( str . charAt ( i ) ) ; } System . out . println ( set ) ; }
public class User { @ Id private String id ; @ Required private String name ; @ Required private String email ; @ Required private String password ; @ Required private String role ; @ Required private String status ; @ Required private String createdAt ; @ Required private String updatedAt ; }
public static float bytesToFloat ( byte [ ] bytes ) { return ByteBuffer . wrap ( bytes ) . getFloat ( ) ; }
Map < String , Object > map = new HashMap < > ( ) ; for ( Map . Entry < String , Object > entry : generator . entrySet ( ) ) { map . put ( entry . getKey ( ) , entry . getValue ( ) ) ; }
public class Binary4Tuple { public static void main ( String [ ] args ) { for ( int i = 0 ; i < 16 ; i ++ ) { System . out . println ( String . format ( " % 4s " , Integer . toBinaryString ( i ) ) . replace ( ' ▁ ' , '0' ) ) ; } } }
Arrays . sort ( arr , ( a , b ) -> { if ( a . equals ( b ) ) { return 0 ; } if ( a . length ( ) == b . length ( ) ) { return a . compareTo ( b ) ; } return a . length ( ) - b . length ( ) ; } ) ;
for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { System . out . println ( entry . getKey ( ) + " / " + entry . getValue ( ) ) ; }
import java . io . * ; import java . util . * ; import java . text . * ; import java . math . * ; import java . util . regex . * ; public class Solution { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; String [ ] arr = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = in . next ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( arr [ i ] ) ; } } }
public class Main { public static void main ( String [ ] args ) { Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; map . put ( " d " , 4 ) ; map . put ( " e " , 5 ) ; map . put ( " f " , 6 ) ; map . put ( " g " , 7 ) ; map . put ( " h " , 8 ) ; map . put ( " i " , 9 ) ; map . put ( " j " , 10 ) ; map . put ( " k " , 11 ) ; map . put ( " l " , 12 ) ; map . put ( " m " , 13 ) ; map . put ( " n " , 14 ) ; map . put ( " o " , 15 ) ; map . put ( " p " , 16 ) ; map . put ( " q " , 17 ) ; map . put ( " r " , 18 ) ; map . put ( " s " , 19 ) ; map . put ( " t " , 20 ) ; map . put ( " u " , 21 ) ; map . put ( " v " , 22 ) ; map . put ( " w " , 23 ) ; map . put ( " x " , 24 ) ; map . put ( " y " , 25 ) ; map . put ( " z " , 26 ) ; List < String > keys = new ArrayList < > ( map . keySet ( ) ) ; List < Integer > values = new ArrayList < > ( map . values ( ) ) ; System . out . println ( keys ) ; System . out . println ( values ) ; } }
String [ ] suffixes = { " a " , " b " , " c " } ; String str = " abc " ; for ( String suffix : suffixes ) { if ( str . endsWith ( suffix ) ) { System . out . println ( " String ▁ ends ▁ with ▁ " + suffix ) ; } }
class Student { private int id ; private String fname ; private double cgpa ; public Student ( int id , String fname , double cgpa ) { super ( ) ; this . id = id ; this . fname = fname ; this . cgpa = cgpa ; } public int getId ( ) { return id ; } public String getFname ( ) { return fname ; } public double getCgpa ( ) { return cgpa ; } } public class Solution { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int testCases = Integer . parseInt ( in . nextLine ( ) ) ; List < Student > studentList = new ArrayList < Student > ( ) ; while ( testCases > 0 ) { int id = in . nextInt ( ) ; String fname = in . next ( ) ; double cgpa = in . nextDouble ( ) ; Student st = new Student ( id , fname , cgpa ) ; studentList . add ( st ) ; testCases -- ; } Collections . sort ( studentList , new Comparator < Student > ( ) { @ Override public int compare ( Student s1 , Student s2 ) { if ( s1 . getCgpa ( ) == s2 . getCgpa ( ) ) { if ( s1 . getFname ( ) . equals ( s2 . getFname ( ) ) ) { return s1 . getId ( ) - s2 . getId ( ) ; } else { return s1 . getFname ( ) . compareTo ( s2 . getFname ( ) ) ; } } else { return ( int ) ( s2 . getCgpa ( ) - s1 . getCgpa ( ) ) ; } } } ) ; for ( Student st : studentList ) { System . out . println ( st . getFname ( ) ) ; } } }
public static int sumOfProductOfCombinations ( List < Integer > list ) { int sum = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < list . size ( ) ; j ++ ) { sum += list . get ( i ) * list . get ( j ) ; } } return sum ; }
File file = new File ( " file . txt " ) ; file . delete ( ) ;
Map < String , String > map = new HashMap < String , String > ( ) ; map . put ( " key1" , " value1" ) ; map . put ( " key2" , " value2" ) ; map . put ( " key3" , " value3" ) ; String value = map . get ( " key1" ) ;
DateFormat df = new SimpleDateFormat ( " yyyy - MM - dd " ) ; Date date = df . parse ( "2018-01-01" ) ;
public static < T > T nthToLast ( LinkedList < T > list , int n ) { if ( list . isEmpty ( ) ) { return null ; } LinkedList < T > reversed = new LinkedList < T > ( ) ; while ( ! list . isEmpty ( ) ) { reversed . addFirst ( list . removeFirst ( ) ) ; } T result = null ; for ( int i = 0 ; i < n ; i ++ ) { result = reversed . removeFirst ( ) ; } while ( ! reversed . isEmpty ( ) ) { list . addFirst ( reversed . removeFirst ( ) ) ; } return result ; }
public static < T > void sort ( List < T > list , List < ? extends Comparable < ? super T > > order ) { Map < T , Integer > index = new HashMap < T , Integer > ( ) ; for ( int i = 0 ; i < order . size ( ) ; i ++ ) { index . put ( order . get ( i ) , i ) ; } Collections . sort ( list , new Comparator < T > ( ) { @ Override public int compare ( T o1 , T o2 ) { return index . get ( o1 ) - index . get ( o2 ) ; } } ) ; }
List < String > list1 = Arrays . asList ( " a " , " b " , " c " ) ; List < String > list2 = Arrays . asList ( "1" , "2" , "3" ) ; List < String > list3 = Arrays . asList ( " x " , " y " , " z " ) ; List < List < String > > lists = Arrays . asList ( list1 , list2 , list3 ) ; List < String > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < list1 . size ( ) ; i ++ ) { for ( List < String > list : lists ) { result . add ( list . get ( i ) ) ; } } System . out . println ( result ) ;
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; for ( Map . Entry < String , Integer > entry : map . entrySet ( ) ) { System . out . println ( entry . getKey ( ) + " : ▁ " + entry . getValue ( ) ) ; }
public static void main ( String [ ] args ) { List < Integer > list1 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list2 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list3 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list4 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list5 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list6 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list7 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list8 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list9 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list10 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list11 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list12 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list13 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list14 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8
public class Book { private String name ; private List < Author > authors ; } public class Author { private String name ; private List < Book > books ; } public class BookRepository { public List < Book > findByAuthors ( List < Author > authors ) { } }
@ DELETE @ Path ( " / { id } " ) public Response delete ( @ PathParam ( " id " ) int id ) { try { User user = userService . findById ( id ) ; userService . delete ( user ) ; return Response . status ( Response . Status . OK ) . build ( ) ; } catch ( Exception e ) { return Response . status ( Response . Status . NOT_FOUND ) . build ( ) ; } }
List < Integer > list1 = Arrays . asList ( 1 , 2 , 3 ) ; List < Integer > list2 = Arrays . asList ( 4 , 5 , 6 ) ; List < Integer > list3 = new ArrayList < > ( ) ; for ( int i = 0 ; i < list1 . size ( ) ; i ++ ) { list3 . add ( list1 . get ( i ) + list2 . get ( i ) ) ; } System . out . println ( list3 ) ;
Map < String , Map < String , String > > map = list . stream ( ) . collect ( Collectors . groupingBy ( e -> e . get ( " id " ) , Collectors . toMap ( e -> e . get ( " key " ) , e -> e . get ( " value " ) ) ) ) ;
LocalDate today = LocalDate . now ( ) ; LocalDate other = LocalDate . of ( 2012 , Month . MARCH , 12 ) ; if ( today . equals ( other ) ) { System . out . println ( " Today ▁ and ▁ date ▁ are ▁ the ▁ same ▁ day ! " ) ; }
Map < String , String > map = new HashMap < String , String > ( ) ; for ( String [ ] array : list ) { map . put ( array [ 0 ] , array [ 1 ] ) ; }
String s = " ▁ ▁ Hello ▁ World ▁ ▁ " ; s = s . trim ( ) ;
String str = "30M1000N20M " ; String [ ] strs = str . split ( " ( ? < = \\ D ) ( ? = \\ d ) | ( ? < = \\ d ) ( ? = \\ D ) " ) ;
String name = " John ▁ Doe " ; Pattern pattern = Pattern . compile ( " ^ [ A - Z ] [ a - z ] + \\ s [ A - Z ] [ a - z ] + $ " ) ; Matcher matcher = pattern . matcher ( name ) ; if ( matcher . matches ( ) ) { System . out . println ( " Name ▁ is ▁ valid " ) ; } else { System . out . println ( " Name ▁ is ▁ invalid " ) ; }
int [ ] a = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; List < Integer > nonZeroIndices = new ArrayList < > ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] != 0 ) { nonZeroIndices . add ( i ) ; } }
Legend legend = chart . getLegend ( ) ; legend . setFrame ( BlockBorder . NONE ) ;
import java . awt . Color ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . geom . Ellipse2D ; import java . awt . geom . Line2D ; import javax . swing . JComponent ; public class PlotComponent extends JComponent { public void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Ellipse2D . Double circle = new Ellipse2D . Double ( 0 , 0 , 20 , 20 ) ; g2 . draw ( circle ) ; Line2D . Double line = new Line2D . Double ( 0 , 0 , 20 , 20 ) ; g2 . draw ( line ) ; } } ```NEW_LINE``` java import javax . swing . JFrame ; public class PlotFrame extends JFrame { public PlotFrame ( ) { setSize ( 300 , 400 ) ; setTitle ( " Plot ▁ Frame " ) ; PlotComponent component = new PlotComponent ( ) ; add ( component ) ; } } ```NEW_LINE``` java import javax . swing . JFrame ; public class PlotViewer { public static void main ( String [ ] args ) { JFrame frame = new PlotFrame ( ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; } }
import java . io . BufferedReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . URL ; import java . net . URLConnection ; public class Main { public static void main ( String [ ] args ) throws IOException { URL url = new URL ( " https : // jsonplaceholder . typicode . com / todos / 1" ) ; URLConnection connection = url . openConnection ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( connection . getInputStream ( ) ) ) ; String inputLine ; StringBuilder content = new StringBuilder ( ) ; while ( ( inputLine = in . readLine ( ) ) != null ) { content . append ( inputLine ) ; } in . close ( ) ; FileWriter fileWriter = new FileWriter ( " todo . json " ) ; fileWriter . write ( content . toString ( ) ) ; fileWriter . close ( ) ; } }
Collections . sort ( list , new Comparator < Tuple > ( ) { @ Override public int compare ( Tuple o1 , Tuple o2 ) { return o1 . getKey ( ) . compareTo ( o2 . getKey ( ) ) ; } } ) ;
List < String > list1 = Arrays . asList ( " a " , " b " , " c " ) ; List < String > list2 = Arrays . asList ( " d " , " e " , " f " ) ; List < String > list3 = new ArrayList < String > ( ) ; list3 . addAll ( list1 ) ; list3 . addAll ( list2 ) ;
List < Integer > list = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > greaterThanFive = list . stream ( ) . filter ( i -> i > 5 ) . collect ( Collectors . toList ( ) ) ;
public class Solution { public boolean isMatch ( String s , String p ) { if ( s == null || p == null ) { return false ; } boolean [ ] [ ] dp = new boolean [ s . length ( ) + 1 ] [ p . length ( ) + 1 ] ; dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < p . length ( ) ; i ++ ) { if ( p . charAt ( i ) == ' * ' && dp [ 0 ] [ i - 1 ] ) { dp [ 0 ] [ i + 1 ] = true ; } } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = 0 ; j < p . length ( ) ; j ++ ) { if ( p . charAt ( j ) == ' . ' ) { dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] ; } if ( p . charAt ( j ) == s . charAt ( i ) ) { dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] ; } if ( p . charAt ( j ) == ' * ' ) { if ( p . charAt ( j - 1 ) != s . charAt ( i ) && p . charAt ( j - 1 ) != ' . ' ) { dp [ i + 1 ] [ j + 1 ] = dp [ i + 1 ] [ j - 1 ] ; } else { dp [ i + 1 ] [ j + 1 ] = ( dp [ i + 1 ] [ j ] || dp [ i ] [ j + 1 ] || dp [ i + 1 ] [ j - 1 ] ) ; } } } } return dp [ s . length ( ) ] [ p . length ( ) ] ; } }
List < String > list = new ArrayList < String > ( ) ; list . add ( " item1" ) ; list . add ( " item2" ) ; list . add ( " item3" ) ;
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = scanner . nextInt ( ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( a [ i ] + a [ j ] + a [ k ] == 0 ) { count ++ ; } } } } System . out . println ( count ) ; } }
System . out . print ( " Hello " ) ; System . out . print ( " World " ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list .
Collections . sort ( list , new Comparator < List < Integer > > ( ) { @ Override public int compare ( List < Integer > o1 , List < Integer > o2 ) { if ( o1 . get ( 0 ) == o2 . get ( 0 ) ) { return o1 . get ( 1 ) - o2 . get ( 1 ) ; } else { return o1 . get ( 0 ) - o2 . get ( 0 ) ; } } } ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; List < String > copy = new ArrayList < > ( list ) ;
import java . net . URL ; import java . net . HttpURLConnection ; public class CheckURL { public static void main ( String [ ] args ) { try { URL url = new URL ( " http : // www . google . com " ) ; HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestMethod ( " GET " ) ; connection . connect ( ) ; int code = connection . getResponseCode ( ) ; System . out . println ( " Response ▁ code ▁ of ▁ the ▁ object ▁ is ▁ " + code ) ; if ( code == 200 ) { System . out . println ( " OK " ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
String [ ] array1 = { " a " , " b " , " c " , " d " , " e " , " f " } ; String [ ] array2 = { " b " , " d " , " f " } ; List < String > list = new ArrayList < String > ( Arrays . asList ( array1 ) ) ; list . removeAll ( Arrays . asList ( array2 ) ) ; array1 = list . toArray ( new String [ list . size ( ) ] ) ;
String s = " aabbccdd " ; s = s . replaceAll ( " ( . ) ( ? = . * \\ 1 ) " , " " ) ;
List < String > keys = new ArrayList < > ( ) ; for ( Map . Entry < String , Map < String , String > > entry : dict . entrySet ( ) ) { keys . addAll ( entry . getValue ( ) . keySet ( ) ) ; }
import java . io . File ; import java . text . SimpleDateFormat ; public class FileDate { public static void main ( String [ ] args ) { File file = new File ( " / tmp / foo . txt " ) ; SimpleDateFormat sdf = new SimpleDateFormat ( " MM / dd / yyyy ▁ HH : mm : ss " ) ; System . out . println ( " Last ▁ Modified ▁ Date : ▁ " + sdf . format ( file . lastModified ( ) ) ) ; System . out . println ( " Created ▁ Date : ▁ " + sdf . format ( file . lastModified ( ) ) ) ; } }
public static int nthOccurrence ( String str , char c , int n ) { int pos = str . indexOf ( c , 0 ) ; while ( n -- > 0 && pos != - 1 ) pos = str . indexOf ( c , pos + 1 ) ; return pos ; }
public class NullCoalescingOperator { public static void main ( String [ ] args ) { String s = null ; String s2 = " " ; String s3 = " Hello " ; String s4 = " World " ; String s5 = " ! " ; String s6 = null ; String s7 = " " ; String s8 = " Hello " ; String s9 = " World " ; String s10 = " ! " ; String s11 = null ; String s12 = " " ; String s13 = " Hello " ; String s14 = " World " ; String s15 = " ! " ; String s16 = null ; String s17 = " " ; String s18 = " Hello " ; String s19 = " World " ; String s20 = " ! " ; String s21 = null ; String s22 = " " ; String s23 = " Hello " ; String s24 = " World " ; String s25 = " ! " ; String s26 = null ; String s27 = " " ; String s28 = " Hello " ; String s29 = " World " ; String s30 = " ! " ; String s31 = null ; String s32 = " " ; String s33 = " Hello " ; String s34 = " World " ; String s35 = " ! " ; String s36 = null ; String s37 = " " ; String s38 = " Hello " ; String s39 = " World " ; String s40 = " ! " ; String s41 = null ; String s42 = " " ; String s43 = " Hello " ; String s44 = " World " ; String s45 = " ! " ; String s46 = null ; String s47 = " " ; String s48 = " Hello " ; String s49 = " World " ; String s50 = " ! " ; String s51 = null ; String s52 = " " ; String s53 = " Hello " ; String s54 = " World " ; String s55 = " ! " ;
import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { try { Process p = Runtime . getRuntime ( ) . exec ( " ls ▁ - l " ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { System . out . println ( line ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
List < String > list = new ArrayList < > ( ) ; list . add ( "1" ) ; list . add ( "2" ) ; list . add ( "3" ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . removeIf ( s -> ! s . matches ( " \\ d + " ) ) ;
String s = " Hello , ▁ World ! " ; s = s . replaceAll ( " \\ p { Punct } " , " " ) ;
public class Main { public static void main ( String [ ] args ) { Map < String , String > map = new HashMap < > ( ) ; map . put ( " key1" , " value1" ) ; map . put ( " key2" , " value2" ) ; map . put ( " key3" , " value3" ) ; System . out . println ( map ) ; } }
public static List < Integer > removeDuplicates ( List < Integer > list ) { List < Integer > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( i == 0 || list . get ( i ) != list . get ( i - 1 ) ) { result . add ( list . get ( i ) ) ; } } return result ; }
String s = " \\ x61 \\ x62 \\ x63" ; byte [ ] b = s . getBytes ( StandardCharsets . ISO_8859_1 ) ;
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; int max = 0 ; String maxKey = null ; for ( Map . Entry < String , Integer > entry : map . entrySet ( ) ) { if ( maxKey == null || entry . getValue ( ) > max ) { maxKey = entry . getKey ( ) ; max = entry . getValue ( ) ; } }
File file = new File ( " / path / to / file " ) ; if ( file . exists ( ) ) { }
String json = " { \" name \" : \" John \" , \" age \" : 30 , \" car \" : null } " ; JSONObject obj = new JSONObject ( json ) ; String name = obj . getString ( " name " ) ; int age = obj . getInt ( " age " ) ;
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; List < Map . Entry < String , Integer > > list = new ArrayList < > ( map . entrySet ( ) ) ; list . sort ( Map . Entry . comparingByValue ( ) ) ; for ( Map . Entry < String , Integer > entry : list ) { System . out . println ( entry . getKey ( ) + " : ▁ " + entry . getValue ( ) ) ; }
List < Integer > list = Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ; List < Integer > result = new ArrayList < > ( ) ; for ( Integer element : list ) { result . add ( element + 1 ) ; }
String url = " http : // www . example . com / index . html ? param1 = value1 & param2 = value2" ; String urlWithoutParams = url . split ( " \\ ? " ) [ 0 ] ;
String dateString = "2018-01-01T00:00:00.000Z " ; DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( " yyyy - MM - dd ' T ' HH : mm : ss . SSS ' Z ' " ) ; LocalDateTime dateTime = LocalDateTime . parse ( dateString , formatter ) ;
public static String removeFinalCharacters ( String str , int n ) { if ( str . length ( ) <= n ) { return " " ; } return removeFinalCharacters ( str . substring ( 0 , str . length ( ) - 1 ) , n ) ; }
String text = " " ; Elements elements = doc . select ( " div . class " ) ; for ( Element element : elements ) { text = element . text ( ) ; }
int largestIntLessThanX ( int x ) { return x - 1 ; }
List < Integer > numbers = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; boolean allEven = numbers . stream ( ) . allMatch ( n -> n % 2 == 0 ) ;
String [ ] cmd = { " / bin / sh " , " - c " , " echo ▁ ' hello ' ▁ | ▁ grep ▁ ' hello ' " } ; Process p = Runtime . getRuntime ( ) . exec ( cmd ) ;
String dateString = "2018-01-01" ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd " ) ; Date date = sdf . parse ( dateString ) ; sdf = new SimpleDateFormat ( " yyyyMMdd " ) ; String newDateString = sdf . format ( date ) ;
List < List < String > > listOfLists = new ArrayList < > ( ) ; List < String > list1 = new ArrayList < > ( ) ; list1 . add ( " a " ) ; list1 . add ( " b " ) ; list1 . add ( " c " ) ; List < String > list2 = new ArrayList < > ( ) ; list2 . add ( " a " ) ; list2 . add ( " b " ) ; list2 . add ( " c " ) ; listOfLists . add ( list1 ) ; listOfLists . add ( list2 ) ; List < String > result = listOfLists . stream ( ) . flatMap ( Collection :: stream ) . distinct ( ) . collect ( Collectors . toList ( ) ) ;
FileWriter fw = new FileWriter ( " output . txt " , true ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; bw . write ( " Hello ▁ World " ) ; bw . newLine ( ) ; bw . close ( ) ;
String sentence = " This ▁ is ▁ a ▁ sentence " ; String [ ] words = sentence . split ( " ▁ " ) ; int [ ] lengths = new int [ words . length ] ; for ( int i = 0 ; i < words . length ; i ++ ) { lengths [ i ] = words [ i ] . length ( ) ; }
public static List < Map < String , Object > > split ( Map < String , List < Object > > map ) { List < Map < String , Object > > result = new ArrayList < > ( ) ; for ( Map . Entry < String , List < Object > > entry : map . entrySet ( ) ) { for ( Object value : entry . getValue ( ) ) { Map < String , Object > item = new HashMap < > ( ) ; item . put ( entry . getKey ( ) , value ) ; result . add ( item ) ; } } return result ; }
if ( ! list . contains ( item ) ) { }
String str = " " ; if ( str . isEmpty ( ) ) { System . out . println ( " String ▁ is ▁ empty " ) ; }
public static List < Integer > add ( List < Integer > a , List < Integer > b ) { List < Integer > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { result . add ( a . get ( i ) + b . get ( i ) ) ; } return result ; }
String unicode = " \\ u0041 \\ u0042 \\ u0043" ; String normal = StringEscapeUtils . unescapeJava ( unicode ) ;
public static void main ( String [ ] args ) { List < String > tokens = Arrays . asList ( " a " , " b " , " c " ) ; List < String > result = new ArrayList < > ( ) ; generateAllStrings ( tokens , result , 0 , " " ) ; System . out . println ( result ) ; } private static void generateAllStrings ( List < String > tokens , List < String > result , int index , String current ) { if ( index == tokens . size ( ) ) { result . add ( current ) ; return ; } generateAllStrings ( tokens , result , index + 1 , current + tokens . get ( index ) ) ; generateAllStrings ( tokens , result , index + 1 , current ) ; }
int count = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( list . get ( i ) > 5 ) { count ++ ; } }
String url = " http : // www . example . com / index . html # top " ; String urlWithoutFragment = url . replaceAll ( " # . * " , " " ) ;
public static void main ( String [ ] args ) { int [ ] arr = new int [ 100 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = i ; } shuffleArray ( arr ) ; for ( int i = 0 ; i < 10 ; i ++ ) { System . out . println ( arr [ i ] ) ; } } static void shuffleArray ( int [ ] ar ) { Random rnd = ThreadLocalRandom . current ( ) ; for ( int i = ar . length - 1 ; i > 0 ; i -- ) { int index = rnd . nextInt ( i + 1 ) ; int a = ar [ index ] ; ar [ index ] = ar [ i ] ; ar [ i ] = a ; } }
public class Main { public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setSize ( 400 , 400 ) ; frame . setVisible ( true ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . toFront ( ) ; } }
String [ ] str = { "1" , "2" , "3" } ; List < Integer > list = new ArrayList < > ( ) ; for ( String s : str ) { list . add ( Integer . parseInt ( s ) ) ; }
public static int convert ( List < Integer > numbers ) { StringBuilder sb = new StringBuilder ( ) ; for ( int number : numbers ) { sb . append ( number ) ; } return Integer . parseInt ( sb . toString ( ) ) ; }
public static < T > Map < T , List < Tuple2 < T , T > >> splitByFirst ( List < Tuple2 < T , T > > list ) { Map < T , List < Tuple2 < T , T > > > map = new HashMap < > ( ) ; for ( Tuple2 < T , T > tuple : list ) { List < Tuple2 < T , T > > subList = map . get ( tuple . getFirst ( ) ) ; if ( subList == null ) { subList = new ArrayList < > ( ) ; map . put ( tuple . getFirst ( ) , subList ) ; } subList . add ( tuple ) ; } return map ; }
List < String > flatList = new ArrayList < > ( ) ; for ( List < String > list : listOfLists ) { flatList . addAll ( list ) ; }
import java . awt . Color ; import java . awt . Graphics2D ; import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import javax . imageio . ImageIO ; public class RemoveWhiteSpace { public static void main ( String [ ] args ) throws IOException { BufferedImage image = ImageIO . read ( new File ( " image . png " ) ) ; int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; int minX = width ; int minY = height ; int maxX = - 1 ; int maxY = - 1 ; for ( int y = 0 ; y < height ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { int pixel = image . getRGB ( x , y ) ; if ( pixel != Color . WHITE . getRGB ( ) ) { if ( minX > x ) minX = x ; if ( maxX < x ) maxX = x ; if ( minY > y ) minY = y ; if ( maxY < y ) maxY = y ; } } } BufferedImage result = new BufferedImage ( maxX - minX + 1 , maxY - minY + 1 , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = result . createGraphics ( ) ; g . drawImage ( image , 0 , 0 , result . getWidth ( ) , result . getHeight ( ) , minX , minY , maxX + 1 , maxY + 1 , null ) ; g . dispose ( ) ; ImageIO . write ( result , " png " , new File ( " result . png " ) ) ; } }
Map < String , String > map = new HashMap < > ( ) ; map . put ( " key " , " value " ) ; map . remove ( " key " ) ;
String str = " Hello \n World " ; str = str . replaceAll ( " \ \r | \ \n " , " " ) ;
String str = " Hello ▁ World " ; boolean contains = str . contains ( " Hello " ) ;
String regex = " \\ d + " ; String text = "123 ▁ 456 ▁ 789" ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( text ) ; while ( matcher . find ( ) ) { System . out . println ( matcher . group ( ) ) ; }
public static double average ( List < Integer > list ) { double sum = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { sum += list . get ( i ) ; } return sum / list . size ( ) ; }
String str = " { \" name \" : \" John \" , \" age \" : 30 , \" car \" : null } " ; JSONObject json = new JSONObject ( str ) ; String name = json . getString ( " name " ) ; int age = json . getInt ( " age " ) ; System . out . println ( name ) ; System . out . println ( age ) ;
public static int countElements ( Map < String , Object > map ) { int count = 0 ; for ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) instanceof Map ) { count += countElements ( ( Map < String , Object > ) entry . getValue ( ) ) ; } else if ( entry . getValue ( ) instanceof List ) { for ( Object o : ( List < Object > ) entry . getValue ( ) ) { if ( o instanceof Map ) { count += countElements ( ( Map < String , Object > ) o ) ; } else { count ++ ; } } } else { count ++ ; } } return count ; }
String str = " Hello ▁ World " ; str = str . replaceAll ( " [ ^ a - zA - Z0-9 ] " , " " ) ;
String input = "1 ▁ fish ▁ 2 ▁ fish ▁ red ▁ fish ▁ blue ▁ fish " ; Scanner s = new Scanner ( input ) . useDelimiter ( " \\ s * fish \\ s * " ) ; System . out . println ( s . nextInt ( ) ) ; System . out . println ( s . nextInt ( ) ) ; System . out . println ( s . next ( ) ) ; System . out . println ( s . next ( ) ) ; s . close ( ) ;
float f = Float . parseFloat ( "3.14" ) ; int i = Integer . parseInt ( "123" ) ;
int sum = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { sum += list . get ( i ) ; }
import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; public class MD5Checksum { public static byte [ ] createChecksum ( String filename ) throws NoSuchAlgorithmException , IOException { File file = new File ( filename ) ; FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ 1024 ] ; MessageDigest complete = MessageDigest . getInstance ( " MD5" ) ; int numRead ; do { numRead = fis . read ( buffer ) ; if ( numRead > 0 ) { complete . update ( buffer , 0 , numRead ) ; } } while ( numRead != - 1 ) ; fis . close ( ) ; return complete . digest ( ) ; } public static String getMD5Checksum ( String filename ) throws NoSuchAlgorithmException , IOException { byte [ ] b = createChecksum ( filename ) ; String result = " " ; for ( int i = 0 ; i < b . length ; i ++ ) { result += Integer . toString ( ( b [ i ] & 0xff ) + 0x100 , 16 ) . substring ( 1 ) ; } return result ; } public static void main ( String args [ ] ) { try { System . out . println ( getMD5Checksum ( " test . txt " ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
String str = " Hello ▁ World " ; String sub = str . substring ( str . indexOf ( " ▁ " ) + 1 ) ;
List < Integer > list1 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ; List < Integer > list2 = Arrays . asList ( 3 , 4 , 5 , 6 , 7 ) ; list1 . stream ( ) . filter ( i -> ! list2 . contains ( i ) ) . collect ( Collectors . toList ( ) ) ;
int sum = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { sum += list . get ( i ) ; }
int random = ( int ) ( Math . random ( ) * 3 ) ; System . out . println ( random ) ;
public class Child extends Base { public Child ( int x ) { super ( x ) ; } }
DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; LocalDateTime dateTime = LocalDateTime . parse ( "2017-12-03 ▁ 10:15:30" , formatter ) ;
public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { System . out . println ( arr [ i ] + " ▁ " + arr [ j ] ) ; } } }
String s = " Hello ▁ World " ; s = s . substring ( 0 , s . length ( ) - 1 ) ;
import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; public class WriteToFile { public static void main ( String [ ] args ) { String [ ] [ ] data = new String [ 3 ] [ 2 ] ; data [ 0 ] [ 0 ] = "1" ; data [ 0 ] [ 1 ] = "2" ; data [ 1 ] [ 0 ] = "3" ; data [ 1 ] [ 1 ] = "4" ; data [ 2 ] [ 0 ] = "5" ; data [ 2 ] [ 1 ] = "6" ; try { File file = new File ( " C : \\ Users \\ User \\ Desktop \\ test . txt " ) ; FileWriter writer = new FileWriter ( file ) ; for ( int i = 0 ; i < data . length ; i ++ ) { for ( int j = 0 ; j < data [ i ] . length ; j ++ ) { writer . write ( data [ i ] [ j ] + " ▁ " ) ; } writer . write ( " \r \n " ) ; } writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
Arrays . sort ( array , new Comparator < Map < String , Object > > ( ) { @ Override public int compare ( Map < String , Object > o1 , Map < String , Object > o2 ) { return o1 . get ( " name " ) . toString ( ) . compareTo ( o2 . get ( " name " ) . toString ( ) ) ; } } ) ;
public class Hierarchy { private final Map < String , List < String > > hierarchy ; public Hierarchy ( Map < String , List < String > > hierarchy ) { this . hierarchy = hierarchy ; } public List < String > getChildren ( String parent ) { return hierarchy . get ( parent ) ; } public List < String > getParents ( String child ) { return hierarchy . entrySet ( ) . stream ( ) . filter ( entry -> entry . getValue ( ) . contains ( child ) ) . map ( Map . Entry :: getKey ) . collect ( Collectors . toList ( ) ) ; } public List < String > getAncestors ( String child ) { List < String > ancestors = new ArrayList < > ( ) ; List < String > parents = getParents ( child ) ; ancestors . addAll ( parents ) ; parents . forEach ( parent -> ancestors . addAll ( getAncestors ( parent ) ) ) ; return ancestors ; } public List < String > getDescendants ( String parent ) { List < String > descendants = new ArrayList < > ( ) ; List < String > children = getChildren ( parent ) ; descendants . addAll ( children ) ; children . forEach ( child -> descendants . addAll ( getDescendants ( child ) ) ) ; return descendants ; } }
Date date = new Date ( ) ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; String formattedDate = sdf . format ( date ) ; System . out . println ( formattedDate ) ;
# The config file is located in the user 's home directory.NEW_LINE# The home directory is different on different platforms . # The following code is a cross - platform way to get the home directory . # Get the user 's home directory. home_dir = os . path . expanduser ( ' ~ ' ) # Get the full path to the config file . config_file_path = os . path . join ( home_dir , ' . config ' , ' my _ app ' , ' config . ini ' ) # Create the config parser object . config = configparser . ConfigParser ( ) # Read the config file . config . read ( config_file_path ) # Get the value of the " Server " setting in the " [ network ] " section . server = config . get ( ' network ' , ' server ' ) # Get the value of the " Port " setting in the " [ network ] " section . port = config . getint ( ' network ' , ' port ' ) # Get the value of the " Log ▁ File " setting in the " [ logging ] " section . log_file = config . get ( ' logging ' , ' log ▁ file ' ) # Get the value of the " Log ▁ Level " setting in the " [ logging ] " section . log_level = config . get ( ' logging ' , ' log ▁ level ' ) # Get the value of the " Log ▁ Format " setting in the " [ logging ] " section . log_format = config . get ( ' logging ' , ' log ▁ format ' ) # Print the values . print ( ' Server : ' , server ) print ( ' Port : ' , port ) print ( ' Log ▁ File : ' , log_file ) print ( ' Log ▁ Level : ' , log_level ) print ( ' Log ▁ Format : ' , log_format ) # Write the config file . with open ( config_file_path , ' w ' ) as config_file : config . write ( config_file )
public static int getMaxStringLength ( List < List < String > > list ) { int maxLength = 0 ; for ( List < String > subList : list ) { for ( String s : subList ) { if ( s . length ( ) > maxLength ) { maxLength = s . length ( ) ; } } } return maxLength ; }
public class ReverseString { public static void main ( String [ ] args ) { String str = " Hello ▁ World " ; StringBuilder sb = new StringBuilder ( str ) ; System . out . println ( sb . reverse ( ) . toString ( ) ) ; } }
float f = 1.23456789f ; System . out . println ( String . format ( " % .2f " , f ) ) ;
int maxIndex = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( list . get ( i ) . getValue ( ) > list . get ( maxIndex ) . getValue ( ) ) { maxIndex = i ; } }
import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Scanner ; public class Replace { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner console = new Scanner ( System . in ) ; System . out . print ( " Input ▁ file : ▁ " ) ; String inputFileName = console . next ( ) ; System . out . print ( " Output ▁ file : ▁ " ) ; String outputFileName = console . next ( ) ; System . out . print ( " Old : ▁ " ) ; String old = console . next ( ) ; System . out . print ( " New : ▁ " ) ; String replacement = console . next ( ) ; File inputFile = new File ( inputFileName ) ; Scanner in = new Scanner ( inputFile ) ; PrintWriter out = new PrintWriter ( outputFileName ) ; while ( in . hasNextLine ( ) ) { String line = in . nextLine ( ) ; line = line . replace ( old , replacement ) ; out . println ( line ) ; } in . close ( ) ; out . close ( ) ; } }
public static int max ( int [ ] list , int length ) { int max = list [ 0 ] ; for ( int i = 1 ; i < length ; i ++ ) { if ( list [ i ] > max ) { max = list [ i ] ; } } return max ; }
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; String value = list . get ( 1 ) ;
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; map . put ( " d " , 4 ) ; for ( Map . Entry < String , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) == 3 ) { System . out . println ( entry . getKey ( ) ) ; } }
String s = " " ; if ( s . isEmpty ( ) ) { System . out . println ( " String ▁ is ▁ empty " ) ; }
String str = " Hello ▁ World " ; str = str . replaceFirst ( " Hello " , " Hi " ) ;
List < String > list1 = new ArrayList < String > ( ) ; list1 . add ( " a " ) ; list1 . add ( " b " ) ; list1 . add ( " c " ) ; List < String > list2 = new ArrayList < String > ( ) ; list2 . add ( " a " ) ; list2 . add ( " b " ) ; list1 . removeAll ( list2 ) ;
try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; }
import java . awt . Font ; import java . awt . Color ; import java . awt . Dimension ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . RenderingHints ; import java . awt . geom . AffineTransform ; import javax . swing . JFrame ; import javax . swing . JPanel ; public class Main extends JPanel { private void doDrawing ( Graphics g ) { Graphics2D g2d = ( Graphics2D ) g ; g2d . setColor ( Color . blue ) ; RenderingHints rh = new RenderingHints ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; rh . put ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_QUALITY ) ; g2d . setRenderingHints ( rh ) ; Font font = new Font ( " Serif " , Font . PLAIN , 24 ) ; g2d . setFont ( font ) ; g2d . drawString ( " Java ▁ 2D " , 50 , 50 ) ; AffineTransform at = new AffineTransform ( ) ; at . rotate ( Math . PI / 4 ) ; Font f = font . deriveFont ( at ) ; g2d . setFont ( f ) ; g2d . drawString ( " Java ▁ 2D " , 50 , 150 ) ; } @ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; doDrawing ( g ) ; } public static void main ( String [ ] args ) { JFrame frame = new JFrame ( " Java ▁ 2D " ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . add ( new Main ( ) ) ; frame . setSize ( 350 , 250 ) ; frame . setLocationRelativeTo ( null ) ; frame . setVisible ( true ) ; } }
String [ ] array = { " a " , " b " , " c " } ; String result = Arrays . toString ( array ) ;
String currentDir = System . getProperty ( " user . dir " ) ; String fileDir = new File ( " . " ) . getAbsolutePath ( ) ;
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; map . put ( " d " , 4 ) ; List < Map . Entry < String , Integer > > list = new ArrayList < > ( map . entrySet ( ) ) ; list . sort ( Comparator . comparing ( Map . Entry :: getValue ) ) ; list . sort ( Comparator . comparing ( Map . Entry :: getKey ) ) ;
List < String > keys = new ArrayList < > ( ) ; for ( Map < String , Object > map : list ) { keys . addAll ( map . keySet ( ) ) ; }
Collections . sort ( list , new Comparator < Tuple > ( ) { @ Override public int compare ( Tuple o1 , Tuple o2 ) { if ( o1 . getFirst ( ) == o2 . getFirst ( ) ) { return o1 . getSecond ( ) . compareTo ( o2 . getSecond ( ) ) ; } return o1 . getFirst ( ) . compareTo ( o2 . getFirst ( ) ) ; } } ) ;
File [ ] files = new File ( " / path / to / directory " ) . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir , String name ) { return name . endsWith ( " . txt " ) ; } } ) ;
Map < String , Object > attributes = object . getAttributes ( ) ;
String s = " Hello , ▁ World ! " ; s = s . replaceAll ( " ▁ " , " " ) ;
public static boolean isNumeric ( String str ) { try { double d = Double . parseDouble ( str ) ; } catch ( NumberFormatException nfe ) { return false ; } return true ; }
String s = " Price ▁ is ▁ $ 25.99" ; double price = Double . parseDouble ( s . substring ( s . indexOf ( ' $ ' ) + 1 ) ) ;
public static void main ( String [ ] args ) throws Exception { Class . forName ( " org . sqlite . JDBC " ) ; Connection conn = DriverManager . getConnection ( " jdbc : sqlite : test . db " ) ; Statement stat = conn . createStatement ( ) ; ResultSet rs = stat . executeQuery ( " select ▁ * ▁ from ▁ tbl1 ; " ) ; ResultSetMetaData rsmd = rs . getMetaData ( ) ; int columnCount = rsmd . getColumnCount ( ) ; for ( int i = 1 ; i <= columnCount ; i ++ ) { String name = rsmd . getColumnName ( i ) ; System . out . println ( name ) ; } }
List < Integer > indexes = IntStream . range ( 0 , list . size ( ) ) . filter ( i -> list . get ( i ) ) . boxed ( ) . collect ( Collectors . toList ( ) ) ;
Random random = new Random ( ) ; int randomNumber = random . nextInt ( 100 ) ;
public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int random = ( int ) ( Math . random ( ) * arr . length ) ; System . out . println ( arr [ random ] ) ; }
public static String reverseInPairs ( String input ) { char [ ] chars = input . toCharArray ( ) ; for ( int i = 0 ; i < chars . length - 1 ; i += 2 ) { char temp = chars [ i ] ; chars [ i ] = chars [ i + 1 ] ; chars [ i + 1 ] = temp ; } return new String ( chars ) ; }
public E peek ( ) { return ( size == 0 ) ? null : elements [ 0 ] ; }
String s = " Hello " ; byte [ ] bytes = s . getBytes ( " UTF - 8" ) ;
import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { int [ ] [ ] ndarray = { { 1 , 2 , 3 } , { 4 , 5 , 6 } } ; int [ ] array = Arrays . stream ( ndarray ) . flatMapToInt ( Arrays :: stream ) . toArray ( ) ; System . out . println ( Arrays . toString ( array ) ) ; } }
String s = " aabfooaabfooabfoob " ; String [ ] tokens = s . split ( " a * b " ) ; for ( String token : tokens ) { System . out . println ( token ) ; }
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; map . put ( " d " , 4 ) ; map . put ( " e " , 5 ) ; map . entrySet ( ) . removeIf ( entry -> entry . getValue ( ) > 3 ) ;
String str = " This ▁ is ▁ a ▁ ' string ' " ; str = str . replace ( " ' " , " " ) ;
public static void main ( String [ ] args ) { List < Tuple > list = new ArrayList < > ( ) ; list . add ( new Tuple ( " a " , " b " ) ) ; list . add ( new Tuple ( " c " , " d " ) ) ; list . add ( new Tuple ( " e " , " f " ) ) ; list . add ( new Tuple ( " g " , " h " ) ) ; list . add ( new Tuple ( " i " , " j " ) ) ; list . add ( new Tuple ( " k " , " l " ) ) ; list . add ( new Tuple ( " m " , " n " ) ) ; list . add ( new Tuple ( " o " , " p " ) ) ; list . add ( new Tuple ( " q " , " r " ) ) ; list . add ( new Tuple ( " s " , " t " ) ) ; list . add ( new Tuple ( " u " , " v " ) ) ; list . add ( new Tuple ( " w " , " x " ) ) ; list . add ( new Tuple ( " y " , " z " ) ) ; list . add ( new Tuple ( "1" , "2" ) ) ; list . add ( new Tuple ( "3" , "4" ) ) ; list . add ( new Tuple ( "5" , "6" ) ) ; list . add ( new Tuple ( "7" , "8" ) ) ; list . add ( new Tuple ( "9" , "0" ) ) ; list . add ( new Tuple ( " ! " , " @ " ) ) ; list . add ( new Tuple ( " # " , " $ " ) ) ; list . add ( new Tuple ( " % " , " ^ " ) ) ; list . add ( new Tuple ( " & " , " * " ) ) ; list . add ( new Tuple ( " ( " , " ) " ) ) ; list . add ( new Tuple ( " - " , " _ " ) ) ; list . add ( new Tuple ( " = " , " + " ) ) ; list . add ( new Tuple ( " [ " , " ] " ) ) ; list . add ( new Tuple ( " { " , " } " ) ) ; list . add ( new Tuple ( " ; " , " : " ) ) ; list . add ( new Tuple ( " ' " , " \" " ) ) ; list . add ( new Tuple ( "<
List < List < Integer > > subLists = new ArrayList < > ( ) ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) { subLists . add ( list . subList ( i , Math . min ( i + 2 , list . size ( ) ) ) ) ; }
List < Tuple > list = new ArrayList < > ( ) ; list . add ( new Tuple ( 1 , 2 ) ) ;
byte [ ] key = " key " . getBytes ( ) ; byte [ ] value = " value " . getBytes ( ) ; client . put ( key , value ) ; byte [ ] result = client . get ( key ) ;
public static int [ ] maxLength ( List < List < String > > list ) { int [ ] maxLength = new int [ list . get ( 0 ) . size ( ) ] ; for ( List < String > row : list ) { for ( int i = 0 ; i < row . size ( ) ; i ++ ) { maxLength [ i ] = Math . max ( maxLength [ i ] , row . get ( i ) . length ( ) ) ; } } return maxLength ; }
Calendar cal = Calendar . getInstance ( ) ; cal . add ( Calendar . MONTH , 6 ) ; Date date = cal . getTime ( ) ;
public static double [ ] removeNan ( double [ ] array ) { List < Double > list = new ArrayList < > ( ) ; for ( double d : array ) { if ( ! Double . isNaN ( d ) ) { list . add ( d ) ; } } double [ ] result = new double [ list . size ( ) ] ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { result [ i ] = list . get ( i ) ; } return result ; }
List < User > users = new Select ( ) . from ( User . class ) . join ( Profile . class ) . on ( " user . profile _ id ▁ = ▁ profile . id " ) . orderBy ( " profile . name " ) . execute ( ) ;
int sum = 0 ; for ( List < List < Integer > > listOfLists : listOfListsOfLists ) { for ( List < Integer > list : listOfLists ) { sum += list . get ( 1 ) ; } }
List < String > list = Arrays . asList ( " a " , " b " , " c " ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . println ( i + " : ▁ " + list . get ( i ) ) ; }
public static String removeDuplicates ( String s ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( sb . indexOf ( String . valueOf ( s . charAt ( i ) ) ) == - 1 ) { sb . append ( s . charAt ( i ) ) ; } } return sb . toString ( ) ; }
public static boolean isNot ( String str , String regex ) { return ! str . matches ( regex ) ; }
List < String > dates = new ArrayList < > ( ) ; Collections . sort ( dates , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { return o1 . compareTo ( o2 ) ; } } ) ;
import java . util . ArrayList ; import java . util . List ; import org . apache . commons . math3 . linear . RealMatrix ; public class MatrixToList { public static List < Double > matrixToList ( RealMatrix matrix ) { List < Double > list = new ArrayList < Double > ( ) ; for ( int i = 0 ; i < matrix . getRowDimension ( ) ; i ++ ) { for ( int j = 0 ; j < matrix . getColumnDimension ( ) ; j ++ ) { list . add ( matrix . getEntry ( i , j ) ) ; } } return list ; } }
String s = " aabbccddeeff " ; StringBuilder sb = new StringBuilder ( ) ; char last = ' \0' ; for ( char c : s . toCharArray ( ) ) { if ( c != last ) { sb . append ( c ) ; last = c ; } } System . out . println ( sb . toString ( ) ) ;
String [ ] array = { " a " , " b " , " c " , " d " , " e " } ; String [ ] result = Arrays . stream ( array ) . map ( s -> s . substring ( 0 , 1 ) ) . toArray ( String [ ] :: new ) ;
import com . google . appengine . tools . cloudstorage . GcsFileOptions ; import com . google . appengine . tools . cloudstorage . GcsFilename ; import com . google . appengine . tools . cloudstorage . GcsOutputChannel ; import com . google . appengine . tools . cloudstorage . GcsService ; import com . google . appengine . tools . cloudstorage . GcsServiceFactory ; import com . google . appengine . tools . cloudstorage . RetryParams ; import java . io . IOException ; import java . nio . channels . Channels ; public class GcsExample { private static final String BUCKETNAME = " my - bucket " ; private final GcsService gcsService = GcsServiceFactory . createGcsService ( RetryParams . getDefaultInstance ( ) ) ; public void writeFile ( String filename , byte [ ] content ) throws IOException { GcsFileOptions instance = GcsFileOptions . getDefaultInstance ( ) ; GcsFilename gcsFilename = new GcsFilename ( BUCKETNAME , filename ) ; GcsOutputChannel outputChannel ; outputChannel = gcsService . createOrReplace ( gcsFilename , instance ) ; outputChannel . write ( ByteBuffer . wrap ( content ) ) ; outputChannel . close ( ) ; } }
public class Solution { public String [ ] reorderLogFiles ( String [ ] logs ) { Arrays . sort ( logs , ( log1 , log2 ) -> { String [ ] split1 = log1 . split ( " ▁ " , 2 ) ; String [ ] split2 = log2 . split ( " ▁ " , 2 ) ; boolean isDigit1 = Character . isDigit ( split1 [ 1 ] . charAt ( 0 ) ) ; boolean isDigit2 = Character . isDigit ( split2 [ 1 ] . charAt ( 0 ) ) ; if ( ! isDigit1 && ! isDigit2 ) { int cmp = split1 [ 1 ] . compareTo ( split2 [ 1 ] ) ; if ( cmp != 0 ) return cmp ; return split1 [ 0 ] . compareTo ( split2 [ 0 ] ) ; } return isDigit1 ? ( isDigit2 ? 0 : 1 ) : - 1 ; } ) ; return logs ; } }
import java . awt . Color ; import java . awt . Font ; import java . awt . FontMetrics ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . Rectangle ; import java . awt . geom . Rectangle2D ; import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import javax . imageio . ImageIO ; public class Legend { public static void main ( String [ ] args ) throws IOException { List < String > labels = new ArrayList < String > ( ) ; labels . add ( " A " ) ; labels . add ( " B " ) ; labels . add ( " C " ) ; labels . add ( " D " ) ; labels . add ( " E " ) ; labels . add ( " F " ) ; labels . add ( " G " ) ; labels . add ( " H " ) ; labels . add ( " I " ) ; labels . add ( " J " ) ; labels . add ( " K " ) ; labels . add ( " L " ) ; labels . add ( " M " ) ; labels . add ( " N " ) ; labels . add ( " O " ) ; labels . add ( " P " ) ; labels . add ( " Q " ) ; labels . add ( " R " ) ; labels . add ( " S " ) ; labels . add ( " T " ) ; labels . add ( " U " ) ; labels . add ( " V " ) ; labels . add ( " W " ) ; labels . add ( " X " ) ; labels . add ( " Y " ) ; labels . add ( " Z " ) ; labels . add ( " AA " ) ; labels . add ( " AB " ) ; labels . add ( " AC " ) ; labels . add ( " AD " ) ; labels . add ( " AE " ) ; labels . add ( " AF " ) ; labels . add ( " AG " ) ; labels . add ( " AH " ) ; labels . add ( " AI " ) ; labels . add ( " AJ " ) ; labels . add ( " AK " ) ; labels . add ( " AL " ) ; labels . add ( " AM " ) ; labels . add ( " AN " ) ; labels .
List < String > list = new ArrayList < String > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . add ( " d " ) ; list . add ( " e " ) ; list . add ( " f " ) ; list . add ( " g " ) ; list . add ( " h " ) ; list . add ( " i " ) ; list . add ( " j " ) ; list . add ( " k " ) ; list . add ( " l " ) ; list . add ( " m " ) ; list . add ( " n " ) ; list . add ( " o " ) ; list . add ( " p " ) ; list . add ( " q " ) ; list . add ( " r " ) ; list . add ( " s " ) ; list . add ( " t " ) ; list . add ( " u " ) ; list . add ( " v " ) ; list . add ( " w " ) ; list . add ( " x " ) ; list . add ( " y " ) ; list . add ( " z " ) ; List < String > subList = list . subList ( 0 , 5 ) ;
public static List < Map < String , Object > > sort ( List < Map < String , Object > > list , String order ) { List < Map < String , Object > > sortedList = new ArrayList < > ( ) ; for ( String key : order . split ( " , " ) ) { for ( Map < String , Object > map : list ) { if ( map . get ( " key " ) . equals ( key ) ) { sortedList . add ( map ) ; } } } return sortedList ; }
public class IpConverter { public static long ipToLong ( String ipAddress ) { String [ ] ipAddressInArray = ipAddress . split ( " \\ . " ) ; long result = 0 ; for ( int i = 0 ; i < ipAddressInArray . length ; i ++ ) { int power = 3 - i ; int ip = Integer . parseInt ( ipAddressInArray [ i ] ) ; result += ip * Math . pow ( 256 , power ) ; } return result ; } public static String longToIp ( long ip ) { return ( ( ip >> 24 ) & 0xFF ) + " . " + ( ( ip >> 16 ) & 0xFF ) + " . " + ( ( ip >> 8 ) & 0xFF ) + " . " + ( ip & 0xFF ) ; } }
List < Integer > hexBytes = Arrays . asList ( "0x01" , "0x02" , "0x03" ) ; List < Integer > hexInts = hexBytes . stream ( ) . map ( Integer :: decode ) . collect ( Collectors . toList ( ) ) ;
String str = " a , b , c , d , e , f , g " ; String [ ] strs = str . split ( " , " ) ;
public static String decrypt ( String encrypted , String key , String iv ) throws Exception { Cipher cipher = Cipher . getInstance ( " AES / CBC / PKCS5Padding " ) ; SecretKeySpec secretKeySpec = new SecretKeySpec ( key . getBytes ( " UTF - 8" ) , " AES " ) ; IvParameterSpec ivParameterSpec = new IvParameterSpec ( iv . getBytes ( " UTF - 8" ) ) ; cipher . init ( Cipher . DECRYPT_MODE , secretKeySpec , ivParameterSpec ) ; byte [ ] decodedEncryptedData = Base64 . getDecoder ( ) . decode ( encrypted ) ; byte [ ] original = cipher . doFinal ( decodedEncryptedData ) ; return new String ( original ) ; }
I ' m ▁ trying ▁ to ▁ create ▁ a ▁ MITM ▁ proxy ▁ over ▁ SSL . ▁ I ' m using the following code : < code > import socket import ssl def mitm_proxy ( client_socket , server_socket ) : while True : data = client_socket . recv ( 1024 ) if not data : break server_socket . sendall ( data ) data = server_socket . recv ( 1024 ) if not data : break client_socket . sendall ( data ) def main ( ) : server_socket = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) server_socket . bind ( ( '', 8443)) server_socket . listen ( 5 ) while True : client_socket , addr = server_socket . accept ( ) print ( ' Got ▁ connection ▁ from ' , addr ) server_socket = ssl . wrap_socket ( socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) ) server_socket . connect ( ( ' localhost ' , 8443 ) ) mitm_proxy ( client_socket , server_socket ) if __name__ == ' _ _ main _ _ ' : main ( ) < / code > I 'm using the following Java code to connect to the proxy: < code > import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . net . Socket ; import java . net . UnknownHostException ; import javax . net . ssl . SSLSocketFactory ; public class Client { public static void main ( String [ ] args ) throws UnknownHostException , IOException { Socket socket = SSLSocketFactory . getDefault ( ) . createSocket ( " localhost " , 8443 ) ; PrintWriter out = new PrintWriter ( socket . getOutputStream ( ) , true ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) ) ) ; BufferedReader stdIn = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String userInput ; while ( ( userInput = stdIn . readLine ( ) )
String str = "1 , , 3,4,5" ; String [ ] strArr = str . split ( " , " ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String s : strArr ) { if ( s . isEmpty ( ) ) { sb . append ( "0 , " ) ; } else { sb . append ( s ) . append ( " , " ) ; } } System . out . println ( sb . toString ( ) ) ;
List < String > stringList = Arrays . asList ( "1" , "2" , "3" ) ; List < Integer > integerList = new ArrayList < > ( ) ; for ( String s : stringList ) { integerList . add ( Integer . parseInt ( s ) ) ; }
import java . util . regex . Pattern ; import java . util . regex . Matcher ; public class RegexMatches { public static void main ( String args [ ] ) { String line = " This ▁ order ▁ was ▁ placed ▁ for ▁ QT3000 ! ▁ OK ? " ; String pattern = " ( . * ) ( \\ d + ) ( . * ) " ; Pattern r = Pattern . compile ( pattern ) ; Matcher m = r . matcher ( line ) ; if ( m . find ( ) ) { System . out . println ( " Found ▁ value : ▁ " + m . group ( 0 ) ) ; System . out . println ( " Found ▁ value : ▁ " + m . group ( 1 ) ) ; System . out . println ( " Found ▁ value : ▁ " + m . group ( 2 ) ) ; } else { System . out . println ( " NO ▁ MATCH " ) ; } } }
List < Integer > list = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > firstThree = list . subList ( 0 , 3 ) ; List < Integer > lastThree = list . subList ( list . size ( ) - 3 , list . size ( ) ) ;
import requests from bs4 import BeautifulSoup url = ' https : // www . monster . com / jobs / search / ? q = Software - Developer & where = Australia ' page = requests . get ( url ) soup = BeautifulSoup ( page . content , ' html . parser ' ) results = soup . find ( id = ' ResultsContainer ' ) print ( results . prettify ( ) )
public static void main ( String [ ] args ) { List < Integer > list = Arrays . asList ( 1 , - 1 , 2 , - 2 , 3 , - 3 , 4 , - 4 , 5 , - 5 ) ; Collections . sort ( list , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { if ( o1 < 0 && o2 < 0 ) { return o2 - o1 ; } else if ( o1 < 0 ) { return 1 ; } else if ( o2 < 0 ) { return - 1 ; } else { return o1 - o2 ; } } } ) ; System . out . println ( list ) ; }
String str = " Hello ▁ World " ; boolean contains = str . contains ( " Hello " ) ;
String s = " \\ u0041 \\ u0042 \\ u0043" ; System . out . println ( s ) ;
import java . awt . Font ; import java . awt . FontMetrics ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . RenderingHints ; import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import javax . imageio . ImageIO ; public class FontSize { public static void main ( String [ ] args ) throws IOException { List < String > labels = new ArrayList < > ( ) ; labels . add ( " A " ) ; labels . add ( " B " ) ; labels . add ( " C " ) ; labels . add ( " D " ) ; labels . add ( " E " ) ; labels . add ( " F " ) ; labels . add ( " G " ) ; labels . add ( " H " ) ; labels . add ( " I " ) ; labels . add ( " J " ) ; labels . add ( " K " ) ; labels . add ( " L " ) ; labels . add ( " M " ) ; labels . add ( " N " ) ; labels . add ( " O " ) ; labels . add ( " P " ) ; labels . add ( " Q " ) ; labels . add ( " R " ) ; labels . add ( " S " ) ; labels . add ( " T " ) ; labels . add ( " U " ) ; labels . add ( " V " ) ; labels . add ( " W " ) ; labels . add ( " X " ) ; labels . add ( " Y " ) ; labels . add ( " Z " ) ; labels . add ( " AA " ) ; labels . add ( " AB " ) ; labels . add ( " AC " ) ; labels . add ( " AD " ) ; labels . add ( " AE " ) ; labels . add ( " AF " ) ; labels . add ( " AG " ) ; labels . add ( " AH " ) ; labels . add ( " AI " ) ; labels . add ( " AJ " ) ; labels . add ( " AK " ) ; labels . add ( " AL " ) ; labels . add ( " AM " ) ; labels . add ( " AN " ) ; labels . add ( " AO " ) ; labels . add ( " AP " ) ; labels . add ( "AQ
public static double magnitudeSquared ( double [ ] vector ) { double sum = 0 ; for ( int i = 0 ; i < vector . length ; i ++ ) { sum += vector [ i ] * vector [ i ] ; } return sum ; }
Map < String , String > map = new HashMap < > ( ) ; map . put ( " foo " , " bar " ) ; map . put ( " foobar " , " baz " ) ; map . entrySet ( ) . stream ( ) . filter ( e -> e . getKey ( ) . contains ( " foo " ) ) . forEach ( e -> System . out . println ( e . getKey ( ) + " : ▁ " + e . getValue ( ) ) ) ;
List < Tuple3 < String , Integer , Integer > > list = new ArrayList < > ( ) ; list . add ( new Tuple3 < > ( " a " , 1 , 2 ) ) ; list . add ( new Tuple3 < > ( " b " , 2 , 3 ) ) ; list . add ( new Tuple3 < > ( " c " , 3 , 4 ) ) ; list . add ( new Tuple3 < > ( " d " , 4 , 5 ) ) ; list . add ( new Tuple3 < > ( " e " , 5 , 6 ) ) ; list . add ( new Tuple3 < > ( " f " , 6 , 7 ) ) ; list . add ( new Tuple3 < > ( " g " , 7 , 8 ) ) ; list . add ( new Tuple3 < > ( " h " , 8 , 9 ) ) ; list . add ( new Tuple3 < > ( " i " , 9 , 10 ) ) ; list . add ( new Tuple3 < > ( " j " , 10 , 11 ) ) ; list . sort ( Comparator . comparingInt ( t -> t . _2 ( ) + t . _3 ( ) ) ) ; list . forEach ( System . out :: println ) ;
public static void sort ( List < List < String > > list , int ... keys ) { Collections . sort ( list , new Comparator < List < String > > ( ) { @ Override public int compare ( List < String > o1 , List < String > o2 ) { for ( int key : keys ) { int cmp = o1 . get ( key ) . compareTo ( o2 . get ( key ) ) ; if ( cmp != 0 ) { return cmp ; } } return 0 ; } } ) ; }
List < String > list = new ArrayList < String > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; if ( list . contains ( " a " ) ) { System . out . println ( " a ▁ is ▁ in ▁ the ▁ list " ) ; }
public static String getDayOfWeek ( String dateString ) { SimpleDateFormat format = new SimpleDateFormat ( " yyyy - MM - dd " ) ; Date date = null ; try { date = format . parse ( dateString ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; int dayOfWeek = calendar . get ( Calendar . DAY_OF_WEEK ) ; String dayOfWeekString = " " ; switch ( dayOfWeek ) { case 1 : dayOfWeekString = " Sunday " ; break ; case 2 : dayOfWeekString = " Monday " ; break ; case 3 : dayOfWeekString = " Tuesday " ; break ; case 4 : dayOfWeekString = " Wednesday " ; break ; case 5 : dayOfWeekString = " Thursday " ; break ; case 6 : dayOfWeekString = " Friday " ; break ; case 7 : dayOfWeekString = " Saturday " ; break ; } return dayOfWeekString ; }
List < Integer > list = new ArrayList < Integer > ( ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; list . add ( 4 ) ; list . add ( 5 ) ; list . removeIf ( i -> i % 2 == 0 ) ; System . out . println ( list ) ;
public static void reverse ( List < Integer > list ) { for ( int i = 0 ; i < list . size ( ) / 2 ; i ++ ) { int temp = list . get ( i ) ; list . set ( i , list . get ( list . size ( ) - i - 1 ) ) ; list . set ( list . size ( ) - i - 1 , temp ) ; } }
String [ ] sentences = text . split ( " \\ . " ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < sentences . length && i < maxSentences ; i ++ ) { sb . append ( sentences [ i ] ) ; if ( i < sentences . length - 1 ) { sb . append ( " . " ) ; } }
List < String > list = new ArrayList < > ( ) ; list . size ( ) ;
import java . awt . Dimension ; import java . awt . Toolkit ; import javax . swing . JFrame ; public class Main { public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setSize ( new Dimension ( 300 , 300 ) ) ; frame . setLocationRelativeTo ( null ) ; frame . setVisible ( true ) ; } }
String s = " Hello " ; System . out . println ( s . charAt ( 0 ) ) ; System . out . println ( s . charAt ( 4 ) ) ;
List < List < List < Integer > > > list = new ArrayList < > ( ) ; List < List < Integer > > list1 = new ArrayList < > ( ) ; List < Integer > list11 = new ArrayList < > ( ) ; list11 . add ( 1 ) ; list11 . add ( 2 ) ; list11 . add ( 3 ) ; list1 . add ( list11 ) ; List < Integer > list12 = new ArrayList < > ( ) ; list12 . add ( 4 ) ; list12 . add ( 5 ) ; list12 . add ( 6 ) ; list1 . add ( list12 ) ; list . add ( list1 ) ; List < List < Integer > > list2 = new ArrayList < > ( ) ; List < Integer > list21 = new ArrayList < > ( ) ; list21 . add ( 7 ) ; list21 . add ( 8 ) ; list21 . add ( 9 ) ; list2 . add ( list21 ) ; List < Integer > list22 = new ArrayList < > ( ) ; list22 . add ( 10 ) ; list22 . add ( 11 ) ; list22 . add ( 12 ) ; list2 . add ( list22 ) ; list . add ( list2 ) ; for ( List < List < Integer > > l : list ) { for ( List < Integer > l1 : l ) { for ( Integer i : l1 ) { System . out . println ( i ) ; } } }
List < String > values = new ArrayList < > ( ) ; for ( Map < String , String > map : list ) { values . add ( map . get ( " key " ) ) ; }
int sum = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { sum += list . get ( i ) . get ( 1 ) ; }
List < Map < String , Object > > list = new ArrayList < > ( ) ; Map < String , Object > map = new HashMap < > ( ) ; map . put ( " name " , " John " ) ; map . put ( " age " , 30 ) ; list . add ( map ) ; String name = ( String ) list . get ( 0 ) . get ( " name " ) ; Integer age = ( Integer ) list . get ( 0 ) . get ( " age " ) ;
import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import javax . imageio . ImageIO ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedImage image = ImageIO . read ( new File ( " image . png " ) ) ; int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; int [ ] pixels = image . getRGB ( 0 , 0 , width , height , null , 0 , width ) ; for ( int i = 0 ; i < pixels . length ; i ++ ) { int alpha = ( pixels [ i ] >> 24 ) & 0xff ; System . out . println ( alpha ) ; } } }
public static boolean isSubset ( List < Integer > list , List < Integer > sublist ) { return sublist . stream ( ) . allMatch ( list :: contains ) ; }
public static Map < String , String > merge ( List < Map < String , String > > maps ) { Map < String , String > result = new HashMap < > ( ) ; for ( Map < String , String > map : maps ) { result . putAll ( map ) ; } return result ; }
public class Solution { public boolean isMatch ( String s , String p ) { if ( s == null || p == null ) { return false ; } boolean [ ] [ ] dp = new boolean [ s . length ( ) + 1 ] [ p . length ( ) + 1 ] ; dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < p . length ( ) ; i ++ ) { if ( p . charAt ( i ) == ' * ' && dp [ 0 ] [ i - 1 ] ) { dp [ 0 ] [ i + 1 ] = true ; } } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = 0 ; j < p . length ( ) ; j ++ ) { if ( p . charAt ( j ) == ' . ' ) { dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] ; } if ( p . charAt ( j ) == s . charAt ( i ) ) { dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] ; } if ( p . charAt ( j ) == ' * ' ) { if ( p . charAt ( j - 1 ) != s . charAt ( i ) && p . charAt ( j - 1 ) != ' . ' ) { dp [ i + 1 ] [ j + 1 ] = dp [ i + 1 ] [ j - 1 ] ; } else { dp [ i + 1 ] [ j + 1 ] = ( dp [ i + 1 ] [ j ] || dp [ i ] [ j + 1 ] || dp [ i + 1 ] [ j - 1 ] ) ; } } } } return dp [ s . length ( ) ] [ p . length ( ) ] ; } }
JButton button = new JButton ( " Click ▁ me " ) ; button . setBackground ( Color . RED ) ; button . setForeground ( Color . WHITE ) ;
List < String > list = Arrays . asList ( "1" , "2" , "3" ) ; List < Integer > intList = list . stream ( ) . map ( Integer :: parseInt ) . collect ( Collectors . toList ( ) ) ;
import java . awt . Color ; import java . awt . Dimension ; import java . awt . Font ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . RenderingHints ; import java . awt . geom . Ellipse2D ; import java . awt . geom . Line2D ; import java . awt . geom . Rectangle2D ; import java . util . ArrayList ; import java . util . List ; import javax . swing . JFrame ; import javax . swing . JPanel ; public class Plot extends JPanel { private static final long serialVersionUID = 1L ; private static final int MAX_SCORE = 20 ; private static final int PREF_W = 800 ; private static final int PREF_H = 650 ; private static final int BORDER_GAP = 30 ; private static final Color GRAPH_COLOR = Color . green ; private static final Color GRAPH_POINT_COLOR = new Color ( 150 , 50 , 50 , 180 ) ; private static final Stroke GRAPH_STROKE = new BasicStroke ( 3f ) ; private static final int GRAPH_POINT_WIDTH = 12 ; private static final int Y_HATCH_CNT = 10 ; private List < Integer > scores ; public Plot ( List < Integer > scores ) { this . scores = scores ; } @ Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; double xScale = ( ( double ) getWidth ( ) - 2 * BORDER_GAP ) / ( scores . size ( ) - 1 ) ; double yScale = ( ( double ) getHeight ( ) - 2 * BORDER_GAP ) / ( MAX_SCORE - 1 ) ;
String s = " abc \n " ; s = s . substring ( 0 , s . length ( ) - 1 ) ;
for ( int i = 0 ; i < set . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < set . size ( ) ; j ++ ) { } }
StringBuilder sb = new StringBuilder ( ) ; for ( byte b : bytes ) { sb . append ( String . format ( " % 02X ▁ " , b ) ) ; } System . out . println ( sb . toString ( ) ) ;
String dateString = "2018-01-01" ; DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( " yyyy - MM - dd " ) ; LocalDate date = LocalDate . parse ( dateString , formatter ) ;
int index = Collections . binarySearch ( list , value ) ; if ( index < 0 ) { index = - index - 1 ; }
List < Integer > list = new ArrayList < Integer > ( ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ;
String str = " Hello ▁ World " ; String firstTwoChars = str . substring ( 0 , 2 ) ;
String str = " Hello ▁ World " ; str = str . toLowerCase ( ) ;
@ RequestMapping ( value = " / { id } " , method = RequestMethod . GET ) public String get ( @ PathVariable ( " id " ) String id ) { return id ; }
public static int [ ] hex2Rgb ( String colorStr ) { return new int [ ] { Integer . valueOf ( colorStr . substring ( 1 , 3 ) , 16 ) , Integer . valueOf ( colorStr . substring ( 3 , 5 ) , 16 ) , Integer . valueOf ( colorStr . substring ( 5 , 7 ) , 16 ) } ; } public static String rgb2Hex ( int [ ] rgb ) { return String . format ( " # %02x % 02x % 02x " , rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; }
File file = new File ( " / path / to / file " ) ; File dir = new File ( " / path / to / dir " ) ; file . getCanonicalPath ( ) . startsWith ( dir . getCanonicalPath ( ) ) ;
import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import javax . imageio . ImageIO ; import javax . swing . ImageIcon ; import javax . swing . JFrame ; import javax . swing . JLabel ; public class DisplayImage { public static void main ( String [ ] args ) { BufferedImage img = null ; try { img = ImageIO . read ( new File ( " / Users / johndoe / Desktop / image . jpg " ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } ImageIcon icon = new ImageIcon ( img ) ; JFrame frame = new JFrame ( ) ; frame . setLayout ( new FlowLayout ( ) ) ; frame . setSize ( 200 , 300 ) ; JLabel lbl = new JLabel ( ) ; lbl . setIcon ( icon ) ; frame . add ( lbl ) ; frame . setVisible ( true ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; } }
String s = " Hello \n World " ; s = s . replace ( " \n " , " \r \n " ) ;
String [ ] strs = str . split ( " ▁ " ) ; int [ ] nums = new int [ strs . length ] ; for ( int i = 0 ; i < strs . length ; i ++ ) { nums [ i ] = Integer . parseInt ( strs [ i ] ) ; }
import java . awt . Dimension ; import java . awt . Toolkit ; public class Main { public static void main ( String [ ] args ) { Dimension screenSize = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; double width = screenSize . getWidth ( ) ; double height = screenSize . getHeight ( ) ; System . out . println ( " Screen ▁ resolution : ▁ " + width + " x " + height ) ; } }
public static int getClosest ( List < Integer > list , int given ) { int minDiff = Integer . MAX_VALUE ; int number = 0 ; for ( int num : list ) { int diff = Math . abs ( num - given ) ; if ( diff < minDiff ) { minDiff = diff ; number = num ; } } return number ; }
public Object lookup ( String name ) { Scope current = root ; while ( current != null ) { Object value = current . getAttribute ( name ) ; if ( value != null ) { return value ; } current = current . getParent ( ) ; } return null ; }
import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; public class DosLineBreaks { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new FileReader ( " file . txt " ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . endsWith ( " \r " ) ) { System . out . println ( " DOS ▁ line ▁ break ▁ detected " ) ; } } } }
