class Solution : NEW_LINE INDENT def combine ( self , n : int , k : int ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( s : int , path : List [ int ] ) -> None : NEW_LINE INDENT if len ( path ) == k : NEW_LINE INDENT ans . append ( path . copy ( ) ) NEW_LINE return NEW_LINE DEDENT for i in range ( s , n + 1 ) : NEW_LINE INDENT path . append ( i ) NEW_LINE dfs ( i + 1 , path ) NEW_LINE path . pop ( ) NEW_LINE DEDENT DEDENT dfs ( 1 , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Poly : NEW_LINE INDENT def __init__ ( self , term : str = None , coef : int = None ) : NEW_LINE INDENT if term and coef : NEW_LINE INDENT self . terms = Counter ( { term : coef } ) NEW_LINE DEDENT else : NEW_LINE INDENT self . terms = Counter ( ) NEW_LINE DEDENT DEDENT def __add__ ( self , other ) : NEW_LINE INDENT for term , coef in other . terms . items ( ) : NEW_LINE INDENT self . terms [ term ] += coef NEW_LINE DEDENT return self NEW_LINE DEDENT def __sub__ ( self , other ) : NEW_LINE INDENT for term , coef in other . terms . items ( ) : NEW_LINE INDENT self . terms [ term ] -= coef NEW_LINE DEDENT return self NEW_LINE DEDENT def __mul__ ( self , other ) : NEW_LINE INDENT res = Poly ( ) NEW_LINE for a , aCoef in self . terms . items ( ) : NEW_LINE INDENT for b , bCoef in other . terms . items ( ) : NEW_LINE INDENT res . terms [ self . _merge ( a , b ) ] += aCoef * bCoef NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def toList ( self ) -> List [ str ] : NEW_LINE INDENT for term in list ( self . terms . keys ( ) ) : NEW_LINE INDENT if not self . terms [ term ] : NEW_LINE INDENT del self . terms [ term ] NEW_LINE DEDENT DEDENT def cmp ( term : str ) -> tuple : NEW_LINE INDENT if term == '1' : NEW_LINE INDENT return ( 0 , ) NEW_LINE DEDENT var = term . split ( ' * ' ) NEW_LINE return ( - len ( var ) , term ) NEW_LINE DEDENT def concat ( term : str ) -> str : NEW_LINE INDENT if term == '1' : NEW_LINE INDENT return str ( self . terms [ term ] ) NEW_LINE DEDENT return str ( self . terms [ term ] ) + ' * ' + term NEW_LINE DEDENT terms = list ( self . terms . keys ( ) ) NEW_LINE terms . sort ( key = cmp ) NEW_LINE return [ concat ( term ) for term in terms ] NEW_LINE DEDENT def _merge ( self , a : str , b : str ) -> str : NEW_LINE INDENT if a == '1' : NEW_LINE INDENT return b NEW_LINE DEDENT if b == '1' : NEW_LINE INDENT return a NEW_LINE DEDENT res = [ ] NEW_LINE A = a . split ( ' * ' ) NEW_LINE B = b . split ( ' * ' ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( A ) and j < len ( B ) : NEW_LINE INDENT if A [ i ] < B [ j ] : NEW_LINE INDENT res . append ( A [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( B [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ' * ' . join ( res + A [ i : ] + B [ j : ] ) NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def basicCalculatorIV ( self , expression : str , evalvars : List [ str ] , evalints : List [ int ] ) -> List [ str ] : NEW_LINE INDENT tokens = list ( self . _getTokens ( expression ) ) NEW_LINE evalMap = { a : b for a , b in zip ( evalvars , evalints ) } NEW_LINE for i , token in enumerate ( tokens ) : NEW_LINE INDENT if token in evalMap : NEW_LINE INDENT tokens [ i ] = str ( evalMap [ token ] ) NEW_LINE DEDENT DEDENT postfix = self . _infixToPostfix ( tokens ) NEW_LINE return self . _evaluate ( postfix ) . toList ( ) NEW_LINE DEDENT def _getTokens ( self , s : str ) -> Iterator [ str ] : NEW_LINE INDENT i = 0 NEW_LINE for j , c in enumerate ( s ) : NEW_LINE INDENT if c == ' ‚ñÅ ' : NEW_LINE INDENT if i < j : NEW_LINE INDENT yield s [ i : j ] NEW_LINE DEDENT i = j + 1 NEW_LINE DEDENT elif c in ' ( ) + - * ' : NEW_LINE INDENT if i < j : NEW_LINE INDENT yield s [ i : j ] NEW_LINE DEDENT yield c NEW_LINE i = j + 1 NEW_LINE DEDENT DEDENT if i < len ( s ) : NEW_LINE INDENT yield s [ i : ] NEW_LINE DEDENT DEDENT def _infixToPostfix ( self , tokens : List [ str ] ) -> List [ str ] : NEW_LINE INDENT postfix = [ ] NEW_LINE ops = [ ] NEW_LINE def precedes ( prevOp : chr , currOp : chr ) -> bool : NEW_LINE INDENT if prevOp == ' ( ' : NEW_LINE INDENT return False NEW_LINE DEDENT return prevOp == ' * ' or currOp in ' + - ' NEW_LINE DEDENT for token in tokens : NEW_LINE INDENT if token == ' ( ' : NEW_LINE INDENT ops . append ( token ) NEW_LINE DEDENT elif token == ' ) ' : NEW_LINE INDENT while ops [ - 1 ] != ' ( ' : NEW_LINE INDENT postfix . append ( ops . pop ( ) ) NEW_LINE DEDENT ops . pop ( ) NEW_LINE DEDENT elif token in ' + - * ' : NEW_LINE INDENT while ops and precedes ( ops [ - 1 ] , token ) : NEW_LINE INDENT postfix . append ( ops . pop ( ) ) NEW_LINE DEDENT ops . append ( token ) NEW_LINE DEDENT else : NEW_LINE INDENT postfix . append ( token ) NEW_LINE DEDENT DEDENT return postfix + ops [ : : - 1 ] NEW_LINE DEDENT def _evaluate ( self , postfix : List [ str ] ) -> Poly : NEW_LINE INDENT polys : List [ Poly ] = [ ] NEW_LINE for token in postfix : NEW_LINE INDENT if token in ' + - * ' : NEW_LINE INDENT b = polys . pop ( ) NEW_LINE a = polys . pop ( ) NEW_LINE if token == ' + ' : NEW_LINE INDENT polys . append ( a + b ) NEW_LINE DEDENT elif token == ' - ' : NEW_LINE INDENT polys . append ( a - b ) NEW_LINE DEDENT else : NEW_LINE INDENT polys . append ( a * b ) NEW_LINE DEDENT DEDENT elif token . lstrip ( ' - ' ) . isnumeric ( ) : NEW_LINE INDENT polys . append ( Poly ( "1" , int ( token ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT polys . append ( Poly ( token , 1 ) ) NEW_LINE DEDENT DEDENT return polys [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numJewelsInStones ( self , J : str , S : str ) -> int : NEW_LINE INDENT jewels = set ( J ) NEW_LINE return sum ( s in jewels for s in S ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def calculate ( self , s : str ) -> int : NEW_LINE INDENT nums = [ ] NEW_LINE ops = [ ] NEW_LINE def calc ( ) : NEW_LINE INDENT b = nums . pop ( ) NEW_LINE a = nums . pop ( ) NEW_LINE op = ops . pop ( ) NEW_LINE if op == ' + ' : NEW_LINE INDENT nums . append ( a + b ) NEW_LINE DEDENT elif op == ' - ' : NEW_LINE INDENT nums . append ( a - b ) NEW_LINE DEDENT elif op == ' * ' : NEW_LINE INDENT nums . append ( a * b ) NEW_LINE DEDENT else : NEW_LINE INDENT nums . append ( int ( a / b ) ) NEW_LINE DEDENT DEDENT def precedes ( prevOp : chr , currOp : chr ) -> bool : NEW_LINE INDENT if prevOp == ' ( ' : NEW_LINE INDENT return False NEW_LINE DEDENT return prevOp in ' * / ' or currOp in ' + - ' NEW_LINE DEDENT i = 0 NEW_LINE hasPrevNum = False NEW_LINE while i < len ( s ) : NEW_LINE INDENT c = s [ i ] NEW_LINE if c . isdigit ( ) : NEW_LINE INDENT num = ord ( c ) - ord ( '0' ) NEW_LINE while i + 1 < len ( s ) and s [ i + 1 ] . isdigit ( ) : NEW_LINE INDENT num = num * 10 + ( ord ( s [ i + 1 ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT nums . append ( num ) NEW_LINE hasPrevNum = True NEW_LINE DEDENT elif c == ' ( ' : NEW_LINE INDENT ops . append ( ' ( ' ) NEW_LINE hasPrevNum = False NEW_LINE DEDENT elif c == ' ) ' : NEW_LINE INDENT while ops [ - 1 ] != ' ( ' : NEW_LINE INDENT calc ( ) NEW_LINE DEDENT ops . pop ( ) NEW_LINE DEDENT elif c in ' + - * / ' : NEW_LINE INDENT if not hasPrevNum : NEW_LINE INDENT num . append ( 0 ) NEW_LINE DEDENT while ops and precedes ( ops [ - 1 ] , c ) : NEW_LINE INDENT calc ( ) NEW_LINE DEDENT ops . append ( c ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while ops : NEW_LINE INDENT calc ( ) NEW_LINE DEDENT return nums . pop ( ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minmaxGasDist ( self , stations : List [ int ] , k : int ) -> float : NEW_LINE INDENT kErr = 1e-6 NEW_LINE l = 0 NEW_LINE r = stations [ - 1 ] - stations [ 0 ] NEW_LINE def possible ( k : int , m : float ) -> bool : NEW_LINE INDENT for a , b in zip ( stations , stations [ 1 : ] ) : NEW_LINE INDENT diff = b - a NEW_LINE if diff > m : NEW_LINE INDENT k -= ceil ( diff / m ) - 1 NEW_LINE if k < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT while r - l > kErr : NEW_LINE INDENT m = ( l + r ) / 2 NEW_LINE if possible ( k , m ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isIdealPermutation ( self , A : List [ int ] ) -> bool : NEW_LINE INDENT for i , a in enumerate ( A ) : NEW_LINE INDENT if abs ( a - i ) > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def splitBST ( self , root : Optional [ TreeNode ] , target : int ) -> List [ Optional [ TreeNode ] ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return None , None NEW_LINE DEDENT if root . val > target : NEW_LINE INDENT left , right = self . splitBST ( root . left , target ) NEW_LINE root . left = right NEW_LINE return left , root NEW_LINE DEDENT else : NEW_LINE INDENT left , right = self . splitBST ( root . right , target ) NEW_LINE root . right = left NEW_LINE return root , right NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def subsets ( self , nums : List [ int ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( s : int , path : List [ int ] ) -> None : NEW_LINE INDENT ans . append ( path ) NEW_LINE for i in range ( s , len ( nums ) ) : NEW_LINE INDENT dfs ( i + 1 , path + [ nums [ i ] ] ) NEW_LINE DEDENT DEDENT dfs ( 0 , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reachingPoints ( self , sx : int , sy : int , tx : int , ty : int ) -> bool : NEW_LINE INDENT while sx < tx and sy < ty : NEW_LINE INDENT tx , ty = tx % ty , ty % tx NEW_LINE DEDENT return sx == tx and sy <= ty and ( ty - sy ) % tx == 0 or sy == ty and sx <= tx and ( tx - sx ) % ty == 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numRabbits ( self , answers : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = Counter ( ) NEW_LINE for answer in answers : NEW_LINE INDENT if count [ answer ] % ( answer + 1 ) == 0 : NEW_LINE INDENT ans += answer + 1 NEW_LINE DEDENT count [ answer ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def movesToChessboard ( self , board : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( board ) NEW_LINE if any ( board [ 0 ] [ 0 ] ^ board [ i ] [ 0 ] ^ board [ 0 ] [ j ] ^ board [ i ] [ j ] for i in range ( n ) for j in range ( n ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT rowSum = sum ( board [ 0 ] ) NEW_LINE colSum = sum ( board [ i ] [ 0 ] for i in range ( n ) ) NEW_LINE if rowSum != n // 2 and rowSum != ( n + 1 ) // 2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if colSum != n // 2 and colSum != ( n + 1 ) // 2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT rowSwaps = sum ( board [ i ] [ 0 ] == ( i & 1 ) for i in range ( n ) ) NEW_LINE colSwaps = sum ( board [ 0 ] [ i ] == ( i & 1 ) for i in range ( n ) ) NEW_LINE if n & 1 : NEW_LINE INDENT if rowSwaps & 1 : NEW_LINE INDENT rowSwaps = n - rowSwaps NEW_LINE DEDENT if colSwaps & 1 : NEW_LINE INDENT colSwaps = n - colSwaps NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT rowSwaps = min ( rowSwaps , n - rowSwaps ) NEW_LINE colSwaps = min ( colSwaps , n - colSwaps ) NEW_LINE DEDENT return ( rowSwaps + colSwaps ) // 2 NEW_LINE DEDENT DEDENT
from enum import Enum NEW_LINE class Color ( Enum ) : NEW_LINE INDENT WHITE = 0 NEW_LINE RED = 1 NEW_LINE GREEN = 2 NEW_LINE DEDENT class Solution : NEW_LINE INDENT def isBipartite ( self , graph : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT colors = [ Color . WHITE ] * len ( graph ) NEW_LINE for i in range ( len ( graph ) ) : NEW_LINE INDENT if colors [ i ] != Color . WHITE : NEW_LINE INDENT continue NEW_LINE DEDENT colors [ i ] = Color . RED NEW_LINE q = deque ( [ i ] ) NEW_LINE while q : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT if colors [ v ] == colors [ u ] : NEW_LINE INDENT return False NEW_LINE DEDENT if colors [ v ] == Color . WHITE : NEW_LINE INDENT colors [ v ] = Color . RED if colors [ u ] == Color . GREEN else Color . GREEN NEW_LINE q . append ( v ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def kthSmallestPrimeFraction ( self , A : List [ int ] , K : int ) -> List [ int ] : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = [ 0 , 1 ] NEW_LINE l = 0 NEW_LINE r = 1 NEW_LINE while True : NEW_LINE INDENT m = ( l + r ) / 2 NEW_LINE ans [ 0 ] = 0 NEW_LINE count = 0 NEW_LINE j = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j < n and A [ i ] > m * A [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT count += n - j NEW_LINE if j == n : NEW_LINE INDENT break NEW_LINE DEDENT if ans [ 0 ] * A [ j ] < ans [ 1 ] * A [ i ] : NEW_LINE INDENT ans [ 0 ] = A [ i ] NEW_LINE ans [ 1 ] = A [ j ] NEW_LINE DEDENT DEDENT if count < K : NEW_LINE INDENT l = m NEW_LINE DEDENT elif count > K : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def findCheapestPrice ( self , n : int , flights : List [ List [ int ] ] , src : int , dst : int , k : int ) -> int : NEW_LINE INDENT graph = [ [ ] for _ in range ( n ) ] NEW_LINE minHeap = [ ( 0 , src , k + 1 ) ] NEW_LINE dist = [ [ math . inf ] * ( k + 2 ) for _ in range ( n ) ] NEW_LINE for u , v , w in flights : NEW_LINE INDENT graph [ u ] . append ( ( v , w ) ) NEW_LINE DEDENT while minHeap : NEW_LINE INDENT d , u , stops = heapq . heappop ( minHeap ) NEW_LINE if u == dst : NEW_LINE INDENT return d NEW_LINE DEDENT if stops > 0 : NEW_LINE INDENT for v , w in graph [ u ] : NEW_LINE INDENT newDist = d + w NEW_LINE if newDist < dist [ v ] [ stops - 1 ] : NEW_LINE INDENT dist [ v ] [ stops - 1 ] = newDist NEW_LINE heapq . heappush ( minHeap , ( newDist , v , stops - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rotatedDigits ( self , N : int ) -> int : NEW_LINE INDENT def isGoodNumber ( i : int ) -> bool : NEW_LINE INDENT isRotated = False NEW_LINE for c in str ( i ) : NEW_LINE INDENT if c == '0' or c == '1' or c == '8' : NEW_LINE INDENT continue NEW_LINE DEDENT if c == '2' or c == '5' or c == '6' or c == '9' : NEW_LINE INDENT isRotated = True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return isRotated NEW_LINE DEDENT return sum ( isGoodNumber ( i ) for i in range ( 1 , N + 1 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def escapeGhosts ( self , ghosts : List [ List [ int ] ] , target : List [ int ] ) -> bool : NEW_LINE INDENT ghostSteps = min ( abs ( x - target [ 0 ] ) + abs ( y - target [ 1 ] ) for x , y in ghosts ) NEW_LINE return abs ( target [ 0 ] ) + abs ( target [ 1 ] ) < ghostSteps NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def exist ( self , board : List [ List [ str ] ] , word : str ) -> bool : NEW_LINE INDENT m = len ( board ) NEW_LINE n = len ( board [ 0 ] ) NEW_LINE def dfs ( i : int , j : int , s : int ) -> bool : NEW_LINE INDENT if i < 0 or i == m or j < 0 or j == n : NEW_LINE INDENT return False NEW_LINE DEDENT if board [ i ] [ j ] != word [ s ] or board [ i ] [ j ] == ' * ' : NEW_LINE INDENT return False NEW_LINE DEDENT if s == len ( word ) - 1 : NEW_LINE INDENT return True NEW_LINE DEDENT cache = board [ i ] [ j ] NEW_LINE board [ i ] [ j ] = ' * ' NEW_LINE isExist = dfs ( i + 1 , j , s + 1 ) or dfs ( i - 1 , j , s + 1 ) or dfs ( i , j + 1 , s + 1 ) or dfs ( i , j - 1 , s + 1 ) NEW_LINE board [ i ] [ j ] = cache NEW_LINE return isExist NEW_LINE DEDENT return any ( dfs ( i , j , 0 ) for i in range ( m ) for j in range ( n ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numTilings ( self , N : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE dp = [ 0 , 1 , 2 , 5 ] + [ 0 ] * 997 NEW_LINE for i in range ( 4 , N + 1 ) : NEW_LINE INDENT dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 3 ] NEW_LINE DEDENT return dp [ N ] % kMod NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def customSortString ( self , S : str , T : str ) -> str : NEW_LINE INDENT ans = " " NEW_LINE count = [ 0 ] * 26 NEW_LINE for c in T : NEW_LINE INDENT count [ ord ( c ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for c in S : NEW_LINE INDENT while count [ ord ( c ) - ord ( ' a ' ) ] > 0 : NEW_LINE INDENT ans += c NEW_LINE count [ ord ( c ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT DEDENT for c in string . ascii_lowercase : NEW_LINE INDENT for _ in range ( count [ ord ( c ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT ans += c NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numMatchingSubseq ( self , s : str , words : List [ str ] ) -> int : NEW_LINE INDENT root = { } NEW_LINE def insert ( word : str ) -> None : NEW_LINE INDENT node = root NEW_LINE for c in word : NEW_LINE INDENT if c not in node : NEW_LINE INDENT node [ c ] = { ' count ' : 0 } NEW_LINE DEDENT node = node [ c ] NEW_LINE DEDENT node [ ' count ' ] += 1 NEW_LINE DEDENT for word in words : NEW_LINE INDENT insert ( word ) NEW_LINE DEDENT def dfs ( s : str , i : int , node : dict ) -> int : NEW_LINE INDENT ans = node [ ' count ' ] if ' count ' in node else 0 NEW_LINE if i >= len ( s ) : NEW_LINE INDENT return ans NEW_LINE DEDENT for c in string . ascii_lowercase : NEW_LINE INDENT if c in node : NEW_LINE INDENT try : NEW_LINE INDENT index = s . index ( c , i ) NEW_LINE ans += dfs ( s , index + 1 , node [ c ] ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT return dfs ( s , 0 , root ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def validTicTacToe ( self , board : List [ str ] ) -> bool : NEW_LINE INDENT def isWin ( c : chr ) -> bool : NEW_LINE INDENT return any ( row . count ( c ) == 3 for row in board ) or any ( row . count ( c ) == 3 for row in list ( zip ( * board ) ) ) or all ( board [ i ] [ i ] == c for i in range ( 3 ) ) or all ( board [ i ] [ 2 - i ] == c for i in range ( 3 ) ) NEW_LINE DEDENT countX = sum ( row . count ( ' X ' ) for row in board ) NEW_LINE countO = sum ( row . count ( ' O ' ) for row in board ) NEW_LINE if countX < countO or countX - countO > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if isWin ( ' X ' ) and countX == countO or isWin ( ' O ' ) and countX != countO : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numSubarrayBoundedMax ( self , A : List [ int ] , L : int , R : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE l = - 1 NEW_LINE r = - 1 NEW_LINE for i , a in enumerate ( A ) : NEW_LINE INDENT if a > R : NEW_LINE INDENT l = i NEW_LINE DEDENT if a >= L : NEW_LINE INDENT r = i NEW_LINE DEDENT ans += r - l NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def allPathsSourceTarget ( self , graph : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( u : int , path : List [ int ] ) -> None : NEW_LINE INDENT if u == len ( graph ) - 1 : NEW_LINE INDENT ans . append ( path ) NEW_LINE return NEW_LINE DEDENT for v in graph [ u ] : NEW_LINE INDENT dfs ( v , path + [ v ] ) NEW_LINE DEDENT DEDENT dfs ( 0 , [ 0 ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def myAtoi ( self , s : str ) -> int : NEW_LINE INDENT s = s . strip ( ) NEW_LINE if not s : NEW_LINE INDENT return 0 NEW_LINE DEDENT sign = - 1 if s [ 0 ] == ' - ' else 1 NEW_LINE if s [ 0 ] in { ' - ' , ' + ' } : NEW_LINE INDENT s = s [ 1 : ] NEW_LINE DEDENT num = 0 NEW_LINE for c in s : NEW_LINE INDENT if not c . isdigit ( ) : NEW_LINE INDENT break NEW_LINE DEDENT num = num * 10 + ord ( c ) - ord ( '0' ) NEW_LINE if sign * num <= - 2 ** 31 : NEW_LINE INDENT return - 2 ** 31 NEW_LINE DEDENT if sign * num >= 2 ** 31 - 1 : NEW_LINE INDENT return 2 ** 31 - 1 NEW_LINE DEDENT DEDENT return sign * num NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeDuplicates ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT i = 0 NEW_LINE for num in nums : NEW_LINE INDENT if i < 2 or num != nums [ i - 2 ] : NEW_LINE INDENT nums [ i ] = num NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minSwap ( self , A : List [ int ] , B : List [ int ] ) -> int : NEW_LINE INDENT keepAt = [ math . inf ] * len ( A ) NEW_LINE swapAt = [ math . inf ] * len ( A ) NEW_LINE keepAt [ 0 ] = 0 NEW_LINE swapAt [ 0 ] = 1 NEW_LINE for i in range ( 1 , len ( A ) ) : NEW_LINE INDENT if A [ i ] > A [ i - 1 ] and B [ i ] > B [ i - 1 ] : NEW_LINE INDENT keepAt [ i ] = keepAt [ i - 1 ] NEW_LINE swapAt [ i ] = swapAt [ i - 1 ] + 1 NEW_LINE DEDENT if A [ i ] > B [ i - 1 ] and B [ i ] > A [ i - 1 ] : NEW_LINE INDENT keepAt [ i ] = min ( keepAt [ i ] , swapAt [ i - 1 ] ) NEW_LINE swapAt [ i ] = min ( swapAt [ i ] , keepAt [ i - 1 ] + 1 ) NEW_LINE DEDENT DEDENT return min ( keepAt [ - 1 ] , swapAt [ - 1 ] ) NEW_LINE DEDENT DEDENT
from enum import Enum NEW_LINE class State ( Enum ) : NEW_LINE INDENT INIT = 0 NEW_LINE VISITING = 1 NEW_LINE VISITED = 2 NEW_LINE DEDENT class Solution : NEW_LINE INDENT def eventualSafeNodes ( self , graph : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT state = [ State . INIT ] * len ( graph ) NEW_LINE def hasCycle ( u : int ) -> bool : NEW_LINE INDENT if state [ u ] == State . VISITING : NEW_LINE INDENT return True NEW_LINE DEDENT if state [ u ] == State . VISITED : NEW_LINE INDENT return False NEW_LINE DEDENT state [ u ] = State . VISITING NEW_LINE if any ( hasCycle ( v ) for v in graph [ u ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT state [ u ] = State . VISITED NEW_LINE DEDENT return [ i for i in range ( len ( graph ) ) if not hasCycle ( i ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def uniqueMorseRepresentations ( self , words : List [ str ] ) -> int : NEW_LINE INDENT morse = [ " . - " , " - . . . " , " - . - . " , " - . . " , " . " , " . . - . " , " - - . " , " . . . . " , " . . " , " . - - - " , " - . - " , " . - . . " , " - - " , " - . " , " - - - " , " . - - . " , " - - . - " , " . - . " , " . . . " , " - " , " . . - " , " . . . - " , " . - - " , " - . . - " , " - . - - " , " - - . . " ] NEW_LINE transformations = set ( ) NEW_LINE for word in words : NEW_LINE INDENT transformation = ' ' . join ( morse [ ord ( c ) - ord ( ' a ' ) ] for c in word ) NEW_LINE transformations . add ( transformation ) NEW_LINE DEDENT return len ( transformations ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def splitArraySameAverage ( self , A : List [ int ] ) -> bool : NEW_LINE INDENT n = len ( A ) NEW_LINE summ = sum ( A ) NEW_LINE if not any ( i * summ % n == 0 for i in range ( 1 , n // 2 + 1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT sums = [ set ( ) for _ in range ( n // 2 + 1 ) ] NEW_LINE sums [ 0 ] . add ( 0 ) NEW_LINE for a in A : NEW_LINE INDENT for i in range ( n // 2 , 0 , - 1 ) : NEW_LINE INDENT for val in sums [ i - 1 ] : NEW_LINE INDENT sums [ i ] . add ( a + val ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT if i * summ % n == 0 and i * summ // n in sums [ i ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxIncreaseKeepingSkyline ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT rowMax = list ( map ( max , grid ) ) NEW_LINE colMax = list ( map ( max , zip ( * grid ) ) ) NEW_LINE return sum ( min ( i , j ) for i in rowMax for j in colMax ) - sum ( map ( sum , grid ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def soupServings ( self , N : int ) -> float : NEW_LINE INDENT def dfs ( a : int , b : int ) -> float : NEW_LINE INDENT if a <= 0 and b <= 0 : NEW_LINE INDENT return 0.5 NEW_LINE DEDENT if a <= 0 : NEW_LINE INDENT return 1.0 NEW_LINE DEDENT if b <= 0 : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT if memo [ a ] [ b ] > 0 : NEW_LINE INDENT return memo [ a ] [ b ] NEW_LINE DEDENT memo [ a ] [ b ] = 0.25 * ( dfs ( a - 4 , b ) + dfs ( a - 3 , b - 1 ) + dfs ( a - 2 , b - 2 ) + dfs ( a - 1 , b - 3 ) ) NEW_LINE return memo [ a ] [ b ] NEW_LINE DEDENT memo = [ [ 0.0 ] * 192 for _ in range ( 192 ) ] NEW_LINE return 1 if N >= 4800 else dfs ( ( N + 24 ) // 25 , ( N + 24 ) // 25 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def expressiveWords ( self , S : str , words : List [ str ] ) -> int : NEW_LINE INDENT def isStretchy ( word : str ) -> bool : NEW_LINE INDENT n = len ( S ) NEW_LINE m = len ( word ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if j < m and S [ i ] == word [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif i > 1 and S [ i ] == S [ i - 1 ] == S [ i - 2 ] : NEW_LINE INDENT continue NEW_LINE DEDENT elif 0 < i < n - 1 and S [ i - 1 ] == S [ i ] == S [ i + 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return j == m NEW_LINE DEDENT return sum ( isStretchy ( word ) for word in words ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def search ( self , nums : List [ int ] , target : int ) -> bool : NEW_LINE INDENT l = 0 NEW_LINE r = len ( nums ) - 1 NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if nums [ m ] == target : NEW_LINE INDENT return True NEW_LINE DEDENT if nums [ l ] == nums [ m ] == nums [ r ] : NEW_LINE INDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT elif nums [ l ] <= nums [ m ] : NEW_LINE INDENT if nums [ l ] <= target < nums [ m ] : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if nums [ m ] < target <= nums [ r ] : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def xorGame ( self , nums : List [ int ] ) -> bool : NEW_LINE INDENT return functools . reduce ( operator . xor , nums ) == 0 or len ( nums ) % 2 == 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def subdomainVisits ( self , cpdomains : List [ str ] ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE count = Counter ( ) NEW_LINE for cpdomain in cpdomains : NEW_LINE INDENT num , domains = cpdomain . split ( ) NEW_LINE num , domains = int ( num ) , domains . split ( ' . ' ) NEW_LINE for i in reversed ( range ( len ( domains ) ) ) : NEW_LINE INDENT count [ ' . ' . join ( domains [ i : ] ) ] += num NEW_LINE DEDENT DEDENT return [ str ( freq ) + ' ‚ñÅ ' + domain for domain , freq in count . items ( ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestTriangleArea ( self , points : List [ List [ int ] ] ) -> float : NEW_LINE INDENT ans = 0 NEW_LINE for Ax , Ay in points : NEW_LINE INDENT for Bx , By in points : NEW_LINE INDENT for Cx , Cy in points : NEW_LINE INDENT ans = max ( ans , 0.5 * abs ( ( Bx - Ax ) * ( Cy - Ay ) - ( Cx - Ax ) * ( By - Ay ) ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def pruneTree ( self , root : Optional [ TreeNode ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return None NEW_LINE DEDENT root . left = self . pruneTree ( root . left ) NEW_LINE root . right = self . pruneTree ( root . right ) NEW_LINE if not root . left and not root . right and not root . val : NEW_LINE INDENT return None NEW_LINE DEDENT return root NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numBusesToDestination ( self , routes : List [ List [ int ] ] , S : int , T : int ) -> int : NEW_LINE INDENT if S == T : NEW_LINE INDENT return 0 NEW_LINE DEDENT graph = defaultdict ( list ) NEW_LINE usedBuses = set ( ) NEW_LINE for i in range ( len ( routes ) ) : NEW_LINE INDENT for route in routes [ i ] : NEW_LINE INDENT graph [ route ] . append ( i ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE q = deque ( [ S ] ) NEW_LINE while q : NEW_LINE INDENT ans += 1 NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT for bus in graph [ q . popleft ( ) ] : NEW_LINE INDENT if bus in usedBuses : NEW_LINE INDENT continue NEW_LINE DEDENT usedBuses . add ( bus ) NEW_LINE for nextRoute in routes [ bus ] : NEW_LINE INDENT if nextRoute == T : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( nextRoute ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def ambiguousCoordinates ( self , S : str ) -> List [ str ] : NEW_LINE INDENT def splits ( S : str ) -> List [ str ] : NEW_LINE INDENT if not S or len ( S ) > 1 and S [ 0 ] == S [ - 1 ] == '0' : NEW_LINE INDENT return [ ] NEW_LINE DEDENT if S [ - 1 ] == '0' : NEW_LINE INDENT return [ S ] NEW_LINE DEDENT if S [ 0 ] == '0' : NEW_LINE INDENT return [ S [ 0 ] + ' . ' + S [ 1 : ] ] NEW_LINE DEDENT return [ S ] + [ S [ : i ] + ' . ' + S [ i : ] for i in range ( 1 , len ( S ) ) ] NEW_LINE DEDENT ans = [ ] NEW_LINE S = S [ 1 : - 1 ] NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT for x in splits ( S [ : i ] ) : NEW_LINE INDENT for y in splits ( S [ i : ] ) : NEW_LINE INDENT ans . append ( ' ( % s , ‚ñÅ % s ) ' % ( x , y ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numComponents ( self , head : ListNode , G : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE G = set ( G ) NEW_LINE while head : NEW_LINE INDENT if head . val in G and ( head . next == None or head . next . val not in G ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT head = head . next NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mostCommonWord ( self , paragraph : str , banned : List [ str ] ) -> str : NEW_LINE INDENT banned = set ( banned ) NEW_LINE words = re . findall ( r ' \w + ' , paragraph . lower ( ) ) NEW_LINE return Counter ( word for word in words if word not in banned ) . most_common ( 1 ) [ 0 ] [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def deleteDuplicates ( self , head : ListNode ) -> ListNode : NEW_LINE INDENT dummy = ListNode ( 0 , head ) NEW_LINE prev = dummy NEW_LINE while head : NEW_LINE INDENT while head . next and head . val == head . next . val : NEW_LINE INDENT head = head . next NEW_LINE DEDENT if prev . next == head : NEW_LINE INDENT prev = prev . next NEW_LINE DEDENT else : NEW_LINE INDENT prev . next = head . next NEW_LINE DEDENT head = head . next NEW_LINE DEDENT return dummy . next NEW_LINE DEDENT DEDENT
class TrieNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . children : Dict [ str , TrieNode ] = defaultdict ( TrieNode ) NEW_LINE self . depth = 0 NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def minimumLengthEncoding ( self , words : List [ str ] ) -> int : NEW_LINE INDENT root = TrieNode ( ) NEW_LINE leaves = [ ] NEW_LINE def insert ( word : str ) -> TrieNode : NEW_LINE INDENT node = root NEW_LINE for c in reversed ( word ) : NEW_LINE INDENT if c not in node . children : NEW_LINE INDENT node . children [ c ] = TrieNode ( ) NEW_LINE DEDENT node = node . children [ c ] NEW_LINE DEDENT node . depth = len ( word ) NEW_LINE return node NEW_LINE DEDENT for word in set ( words ) : NEW_LINE INDENT leaves . append ( insert ( word ) ) NEW_LINE DEDENT return sum ( leaf . depth + 1 for leaf in leaves if not len ( leaf . children ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def flipgame ( self , fronts : List [ int ] , backs : List [ int ] ) -> int : NEW_LINE INDENT same = { f for f , b in zip ( fronts , backs ) if f == b } NEW_LINE return min ( [ num for num in fronts + backs if num not in same ] or [ 0 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numFactoredBinaryTrees ( self , arr : List [ int ] ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE n = len ( arr ) NEW_LINE dp = [ 1 ] * n NEW_LINE arr . sort ( ) NEW_LINE numToIndex = { a : i for i , a in enumerate ( arr ) } NEW_LINE for i , root in enumerate ( arr ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if root % arr [ j ] == 0 : NEW_LINE INDENT right = root // arr [ j ] NEW_LINE if right in numToIndex : NEW_LINE INDENT dp [ i ] += dp [ j ] * dp [ numToIndex [ right ] ] NEW_LINE dp [ i ] %= kMod NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum ( dp ) % kMod NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def toGoatLatin ( self , S : str ) -> str : NEW_LINE INDENT ans = ' ' NEW_LINE vowels = ' aeiouAEIOU ' NEW_LINE words = S . split ( ) NEW_LINE i = 1 NEW_LINE for word in words : NEW_LINE INDENT if i > 1 : NEW_LINE INDENT ans += ' ‚ñÅ ' NEW_LINE DEDENT if word [ 0 ] in vowels : NEW_LINE INDENT ans += word NEW_LINE DEDENT else : NEW_LINE INDENT ans += word [ 1 : ] + word [ 0 ] NEW_LINE DEDENT ans += ' ma ' + ' a ' * i NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numFriendRequests ( self , ages : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = [ 0 ] * 121 NEW_LINE for age in ages : NEW_LINE INDENT count [ age ] += 1 NEW_LINE DEDENT for i in range ( 15 , 121 ) : NEW_LINE INDENT ans += count [ i ] * ( count [ i ] - 1 ) NEW_LINE DEDENT for i in range ( 15 , 121 ) : NEW_LINE INDENT for j in range ( i // 2 + 8 , i ) : NEW_LINE INDENT ans += count [ i ] * count [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxProfitAssignment ( self , difficulty : List [ int ] , profit : List [ int ] , worker : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE jobs = sorted ( zip ( difficulty , profit ) ) NEW_LINE worker . sort ( reverse = 1 ) NEW_LINE i = 0 NEW_LINE maxProfit = 0 NEW_LINE for w in sorted ( worker ) : NEW_LINE INDENT while i < len ( jobs ) and w >= jobs [ i ] [ 0 ] : NEW_LINE INDENT maxProfit = max ( maxProfit , jobs [ i ] [ 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT ans += maxProfit NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def uniqueLetterString ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE lastCount = [ 0 ] * 26 NEW_LINE lastSeen = [ - 1 ] * 26 NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT c = ord ( c ) - ord ( ' A ' ) NEW_LINE currentCount = i - lastSeen [ c ] NEW_LINE count = count - lastCount [ c ] + currentCount NEW_LINE lastCount [ c ] = currentCount NEW_LINE lastSeen [ c ] = i NEW_LINE ans += count NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def consecutiveNumbersSum ( self , N : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE i = 1 NEW_LINE triangleNum = 1 NEW_LINE while triangleNum <= N : NEW_LINE INDENT if ( N - triangleNum ) % i == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT i += 1 NEW_LINE triangleNum += i NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def deleteDuplicates ( self , head : ListNode ) -> ListNode : NEW_LINE INDENT curr = head NEW_LINE while curr : NEW_LINE INDENT while curr . next and curr . val == curr . next . val : NEW_LINE INDENT curr . next = curr . next . next NEW_LINE DEDENT curr = curr . next NEW_LINE DEDENT return head NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largeGroupPositions ( self , S : str ) -> List [ List [ int ] ] : NEW_LINE INDENT n = len ( S ) NEW_LINE ans = [ ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < n : NEW_LINE INDENT while j < n and S [ j ] == S [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if j - i >= 3 : NEW_LINE INDENT ans . append ( [ i , j - 1 ] ) NEW_LINE DEDENT i = j NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maskPII ( self , S : str ) -> str : NEW_LINE INDENT atIndex = S . find ( ' @ ' ) NEW_LINE if atIndex != - 1 : NEW_LINE INDENT S = S . lower ( ) NEW_LINE return S [ 0 ] + ' * ' * 5 + S [ atIndex - 1 : ] NEW_LINE DEDENT ans = ' ' . join ( c for c in S if c . isdigit ( ) ) NEW_LINE if len ( ans ) == 10 : NEW_LINE INDENT return ' * * * - * * * - ' + ans [ - 4 : ] NEW_LINE DEDENT return ' + ' + ' * ' * ( len ( ans ) - 10 ) + ' - * * * - * * * - ' + ans [ - 4 : ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def flipAndInvertImage ( self , A : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT n = len ( A ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( ( n + 2 ) // 2 ) : NEW_LINE INDENT A [ i ] [ j ] , A [ i ] [ n - j - 2 ] = A [ i ] [ n - j - 1 ] ^ 2 , A [ i ] [ j ] ^ 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findReplaceString ( self , s : str , indexes : List [ int ] , sources : List [ str ] , targets : List [ str ] ) -> str : NEW_LINE INDENT for index , source , target in sorted ( zip ( indexes , sources , targets ) , reverse = True ) : NEW_LINE INDENT if s [ index : index + len ( source ) ] == source : NEW_LINE INDENT s = s [ : index ] + target + s [ index + len ( source ) : ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sumOfDistancesInTree ( self , N : int , edges : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * N NEW_LINE count = [ 1 ] * N NEW_LINE tree = defaultdict ( set ) NEW_LINE for u , v in edges : NEW_LINE INDENT tree [ u ] . add ( v ) NEW_LINE tree [ v ] . add ( u ) NEW_LINE DEDENT def postorder ( node , parent = None ) : NEW_LINE INDENT for child in tree [ node ] : NEW_LINE INDENT if child == parent : NEW_LINE INDENT continue NEW_LINE DEDENT postorder ( child , node ) NEW_LINE count [ node ] += count [ child ] NEW_LINE ans [ node ] += ans [ child ] + count [ child ] NEW_LINE DEDENT DEDENT def preorder ( node , parent = None ) : NEW_LINE INDENT for child in tree [ node ] : NEW_LINE INDENT if child == parent : NEW_LINE INDENT continue NEW_LINE DEDENT ans [ child ] = ans [ node ] - count [ child ] + ( N - count [ child ] ) NEW_LINE preorder ( child , node ) NEW_LINE DEDENT DEDENT postorder ( 0 ) NEW_LINE preorder ( 0 ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestOverlap ( self , A : List [ List [ int ] ] , B : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( A ) NEW_LINE magic = 100 NEW_LINE onesA = [ ] NEW_LINE onesB = [ ] NEW_LINE dict = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if A [ i ] [ j ] == 1 : NEW_LINE INDENT onesA . append ( [ i , j ] ) NEW_LINE DEDENT if B [ i ] [ j ] == 1 : NEW_LINE INDENT onesB . append ( [ i , j ] ) NEW_LINE DEDENT DEDENT DEDENT for a in onesA : NEW_LINE INDENT for b in onesB : NEW_LINE INDENT dict [ ( a [ 0 ] - b [ 0 ] ) * magic + ( a [ 1 ] - b [ 1 ] ) ] += 1 NEW_LINE DEDENT DEDENT return max ( dict . values ( ) ) if dict else 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isRectangleOverlap ( self , rec1 : List [ int ] , rec2 : List [ int ] ) -> bool : NEW_LINE INDENT return rec1 [ 0 ] < rec2 [ 2 ] and rec2 [ 0 ] < rec1 [ 2 ] and rec1 [ 1 ] < rec2 [ 3 ] and rec2 [ 1 ] < rec1 [ 3 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def new21Game ( self , n : int , k : int , maxPts : int ) -> float : NEW_LINE INDENT if k == 0 or n >= k - 1 + maxPts : NEW_LINE INDENT return 1.0 NEW_LINE DEDENT ans = 0.0 NEW_LINE dp = [ 1.0 ] + [ 0 ] * n NEW_LINE windowSum = dp [ 0 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] = windowSum / maxPts NEW_LINE if i < k : NEW_LINE INDENT windowSum += dp [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += dp [ i ] NEW_LINE DEDENT if i - maxPts >= 0 : NEW_LINE INDENT windowSum -= dp [ i - maxPts ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def pushDominoes ( self , dominoes : str ) -> str : NEW_LINE INDENT ans = list ( dominoes ) NEW_LINE L = - 1 NEW_LINE R = - 1 NEW_LINE for i in range ( len ( dominoes ) + 1 ) : NEW_LINE INDENT if i == len ( dominoes ) or dominoes [ i ] == ' R ' : NEW_LINE INDENT if L < R : NEW_LINE INDENT while R < i : NEW_LINE INDENT ans [ R ] = ' R ' NEW_LINE R += 1 NEW_LINE DEDENT DEDENT R = i NEW_LINE DEDENT elif dominoes [ i ] == ' L ' : NEW_LINE INDENT if R < L or ( L , R ) == ( - 1 , - 1 ) : NEW_LINE INDENT if ( L , R ) == ( - 1 , - 1 ) : NEW_LINE INDENT L += 1 NEW_LINE DEDENT while L < i : NEW_LINE INDENT ans [ L ] = ' L ' NEW_LINE L += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT l = R + 1 NEW_LINE r = i - 1 NEW_LINE while l < r : NEW_LINE INDENT ans [ l ] = ' R ' NEW_LINE ans [ r ] = ' L ' NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT L = i NEW_LINE DEDENT DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestRectangleArea ( self , heights : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE stack = [ ] NEW_LINE for i in range ( len ( heights ) + 1 ) : NEW_LINE INDENT while stack and ( i == len ( heights ) or heights [ stack [ - 1 ] ] > heights [ i ] ) : NEW_LINE INDENT h = heights [ stack . pop ( ) ] NEW_LINE w = i - stack [ - 1 ] - 1 if stack else i NEW_LINE ans = max ( ans , h * w ) NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numMagicSquaresInside ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT def isMagic ( i : int , j : int ) -> int : NEW_LINE INDENT s = " " . join ( str ( grid [ i + num // 3 ] [ j + num % 3 ] ) for num in [ 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 ] ) NEW_LINE return s in "43816729" * 2 or s in "43816729" [ : : - 1 ] * 2 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( grid ) - 2 ) : NEW_LINE INDENT for j in range ( len ( grid [ 0 ] ) - 2 ) : NEW_LINE INDENT if grid [ i ] [ j ] % 2 == 0 and grid [ i + 1 ] [ j + 1 ] == 5 : NEW_LINE INDENT ans += isMagic ( i , j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canVisitAllRooms ( self , rooms : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT seen = [ False ] * len ( rooms ) NEW_LINE def dfs ( node : int ) -> None : NEW_LINE INDENT seen [ node ] = True NEW_LINE for child in rooms [ node ] : NEW_LINE INDENT if not seen [ child ] : NEW_LINE INDENT dfs ( child ) NEW_LINE DEDENT DEDENT DEDENT dfs ( 0 ) NEW_LINE return all ( seen ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findSecretWord ( self , wordlist : List [ str ] , master : ' Master ' ) -> None : NEW_LINE INDENT def getMatches ( s1 : str , s2 : str ) -> int : NEW_LINE INDENT matches = 0 NEW_LINE for c1 , c2 in zip ( s1 , s2 ) : NEW_LINE INDENT if c1 == c2 : NEW_LINE INDENT matches += 1 NEW_LINE DEDENT DEDENT return matches NEW_LINE DEDENT for _ in range ( 10 ) : NEW_LINE INDENT guessedWord = wordlist [ randint ( 0 , len ( wordlist ) - 1 ) ] NEW_LINE matches = master . guess ( guessedWord ) NEW_LINE if matches == 6 : NEW_LINE INDENT break NEW_LINE DEDENT wordlist = [ word for word in wordlist if getMatches ( guessedWord , word ) == matches ] NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestMountain ( self , A : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE i = 0 NEW_LINE while i + 1 < len ( A ) : NEW_LINE INDENT while i + 1 < len ( A ) and A [ i ] == A [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT increasing = 0 NEW_LINE decreasing = 0 NEW_LINE while i + 1 < len ( A ) and A [ i ] < A [ i + 1 ] : NEW_LINE INDENT increasing += 1 NEW_LINE i += 1 NEW_LINE DEDENT while i + 1 < len ( A ) and A [ i ] > A [ i + 1 ] : NEW_LINE INDENT decreasing += 1 NEW_LINE i += 1 NEW_LINE DEDENT if increasing > 0 and decreasing > 0 : NEW_LINE INDENT ans = max ( ans , increasing + decreasing + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isNStraightHand ( self , hand : List [ int ] , W : int ) -> bool : NEW_LINE INDENT count = Counter ( hand ) NEW_LINE for start in sorted ( count ) : NEW_LINE INDENT value = count [ start ] NEW_LINE if value > 0 : NEW_LINE INDENT for i in range ( start , start + W ) : NEW_LINE INDENT count [ i ] -= value NEW_LINE if count [ i ] < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def shortestPathLength ( self , graph : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( graph ) NEW_LINE goal = ( 1 << n ) - 1 NEW_LINE ans = 0 NEW_LINE q = deque ( ) NEW_LINE seen = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT q . append ( ( i , 1 << i ) ) NEW_LINE DEDENT while q : NEW_LINE INDENT for _ in range ( len ( q ) ) : NEW_LINE INDENT u , state = q . popleft ( ) NEW_LINE if state == goal : NEW_LINE INDENT return ans NEW_LINE DEDENT if ( u , state ) in seen : NEW_LINE INDENT continue NEW_LINE DEDENT seen . add ( ( u , state ) ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT q . append ( ( v , state | ( 1 << v ) ) ) NEW_LINE DEDENT DEDENT ans += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def shiftingLetters ( self , s : str , shifts : List [ int ] ) -> str : NEW_LINE INDENT ans = [ ] NEW_LINE for i in reversed ( range ( len ( shifts ) - 1 ) ) : NEW_LINE INDENT shifts [ i ] += shifts [ i + 1 ] NEW_LINE DEDENT for c , shift in zip ( s , shifts ) : NEW_LINE INDENT ans . append ( chr ( ( ord ( c ) - ord ( ' a ' ) + shift ) % 26 + ord ( ' a ' ) ) ) NEW_LINE DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxDistToClosest ( self , seats : List [ int ] ) -> int : NEW_LINE INDENT n = len ( seats ) NEW_LINE ans = 0 NEW_LINE j = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if seats [ i ] == 1 : NEW_LINE INDENT ans = i if j == - 1 else max ( ans , ( i - j ) // 2 ) NEW_LINE j = i NEW_LINE DEDENT DEDENT return max ( ans , n - j - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximalRectangle ( self , matrix : List [ List [ str ] ] ) -> int : NEW_LINE INDENT if not matrix : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE hist = [ 0 ] * len ( matrix [ 0 ] ) NEW_LINE def largestRectangleArea ( heights : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE stack = [ ] NEW_LINE for i in range ( len ( heights ) + 1 ) : NEW_LINE INDENT while stack and ( i == len ( heights ) or heights [ stack [ - 1 ] ] > heights [ i ] ) : NEW_LINE INDENT h = heights [ stack . pop ( ) ] NEW_LINE w = i - stack [ - 1 ] - 1 if stack else i NEW_LINE ans = max ( ans , h * w ) NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT for row in matrix : NEW_LINE INDENT for i , num in enumerate ( row ) : NEW_LINE INDENT hist [ i ] = 0 if num == '0' else hist [ i ] + 1 NEW_LINE DEDENT ans = max ( ans , largestRectangleArea ( hist ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rectangleArea ( self , rectangles : List [ List [ int ] ] ) -> int : NEW_LINE INDENT events = [ ] NEW_LINE for x1 , y1 , x2 , y2 in rectangles : NEW_LINE INDENT events . append ( ( x1 , y1 , y2 , ' s ' ) ) NEW_LINE events . append ( ( x2 , y1 , y2 , ' e ' ) ) NEW_LINE DEDENT events . sort ( key = lambda x : x [ 0 ] ) NEW_LINE ans = 0 NEW_LINE prevX = 0 NEW_LINE yPairs = [ ] NEW_LINE def getHeight ( yPairs : List [ Tuple [ int , int ] ] ) -> int : NEW_LINE INDENT height = 0 NEW_LINE prevY = 0 NEW_LINE for y1 , y2 in yPairs : NEW_LINE INDENT prevY = max ( prevY , y1 ) NEW_LINE if y2 > prevY : NEW_LINE INDENT height += y2 - prevY NEW_LINE prevY = y2 NEW_LINE DEDENT DEDENT return height NEW_LINE DEDENT for currX , y1 , y2 , type in events : NEW_LINE INDENT if currX > prevX : NEW_LINE INDENT width = currX - prevX NEW_LINE ans += width * getHeight ( yPairs ) NEW_LINE prevX = currX NEW_LINE DEDENT if type == ' s ' : NEW_LINE INDENT yPairs . append ( ( y1 , y2 ) ) NEW_LINE yPairs . sort ( ) NEW_LINE DEDENT else : NEW_LINE INDENT yPairs . remove ( ( y1 , y2 ) ) NEW_LINE DEDENT DEDENT return ans % ( 10 ** 9 + 7 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def loudAndRich ( self , richer : List [ List [ int ] ] , quiet : List [ int ] ) -> List [ int ] : NEW_LINE INDENT graph = [ [ ] for _ in range ( len ( quiet ) ) ] NEW_LINE for u , v in richer : NEW_LINE INDENT graph [ v ] . append ( u ) NEW_LINE DEDENT @ functools . lru_cache ( None ) NEW_LINE def dfs ( u : int ) -> int : NEW_LINE INDENT ans = u NEW_LINE for v in graph [ u ] : NEW_LINE INDENT res = dfs ( v ) NEW_LINE if quiet [ res ] < quiet [ ans ] : NEW_LINE INDENT ans = res NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return map ( dfs , range ( len ( graph ) ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def peakIndexInMountainArray ( self , arr : List [ int ] ) -> int : NEW_LINE INDENT l = 0 NEW_LINE r = len ( arr ) - 1 NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if arr [ m ] < arr [ m + 1 ] : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def carFleet ( self , target : int , position : List [ int ] , speed : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE times = [ float ( target - p ) / s for p , s in sorted ( zip ( position , speed ) , reverse = True ) ] NEW_LINE maxTime = 0 NEW_LINE for time in times : NEW_LINE INDENT if time > maxTime : NEW_LINE INDENT maxTime = time NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def kSimilarity ( self , s1 : str , s2 : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE q = deque ( [ s1 ] ) NEW_LINE seen = { s1 } NEW_LINE while q : NEW_LINE INDENT for _ in range ( len ( q ) ) : NEW_LINE INDENT curr = q . popleft ( ) NEW_LINE if curr == s2 : NEW_LINE INDENT return ans NEW_LINE DEDENT for child in self . _getChildren ( curr , s2 ) : NEW_LINE INDENT if child in seen : NEW_LINE INDENT continue NEW_LINE DEDENT q . append ( child ) NEW_LINE seen . add ( child ) NEW_LINE DEDENT DEDENT ans += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def _getChildren ( self , curr : str , target : str ) -> List [ str ] : NEW_LINE INDENT children = [ ] NEW_LINE s = list ( curr ) NEW_LINE i = 0 NEW_LINE while curr [ i ] == target [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if s [ j ] == target [ i ] : NEW_LINE INDENT s [ i ] , s [ j ] = s [ j ] , s [ i ] NEW_LINE children . append ( ' ' . join ( s ) ) NEW_LINE s [ i ] , s [ j ] = s [ j ] , s [ i ] NEW_LINE DEDENT DEDENT return children NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def scoreOfParentheses ( self , S : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE layer = 0 NEW_LINE for a , b in zip ( S , S [ 1 : ] ) : NEW_LINE INDENT if a + b == ' ( ) ' : NEW_LINE INDENT ans += 1 << layer NEW_LINE DEDENT layer += 1 if a == ' ( ' else - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mincostToHireWorkers ( self , quality : List [ int ] , wage : List [ int ] , k : int ) -> float : NEW_LINE INDENT ans = math . inf NEW_LINE qualitySum = 0 NEW_LINE workers = sorted ( ( w / q , q ) for q , w in zip ( quality , wage ) ) NEW_LINE maxHeap = [ ] NEW_LINE for wagePerQuality , q in workers : NEW_LINE INDENT heapq . heappush ( maxHeap , - q ) NEW_LINE qualitySum += q NEW_LINE if len ( maxHeap ) > k : NEW_LINE INDENT qualitySum += heapq . heappop ( maxHeap ) NEW_LINE DEDENT if len ( maxHeap ) == k : NEW_LINE INDENT ans = min ( ans , qualitySum * wagePerQuality ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mirrorReflection ( self , p : int , q : int ) -> int : NEW_LINE INDENT m = 1 NEW_LINE n = 1 NEW_LINE while m * p != n * q : NEW_LINE INDENT n += 1 NEW_LINE m = n * q // p NEW_LINE DEDENT if m % 2 == 0 and n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if m % 2 == 1 and n % 2 == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if m % 2 == 1 and n % 2 == 0 : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def buddyStrings ( self , A : str , B : str ) -> bool : NEW_LINE INDENT if len ( A ) != len ( B ) : NEW_LINE INDENT return False NEW_LINE DEDENT if A == B and len ( set ( A ) ) < len ( A ) : NEW_LINE INDENT return True NEW_LINE DEDENT diff = [ ( a , b ) for a , b in zip ( A , B ) if a != b ] NEW_LINE return len ( diff ) == 2 and diff [ 0 ] == diff [ 1 ] [ : : - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def partition ( self , head : ListNode , x : int ) -> ListNode : NEW_LINE INDENT beforeHead = ListNode ( 0 ) NEW_LINE afterHead = ListNode ( 0 ) NEW_LINE before = beforeHead NEW_LINE after = afterHead NEW_LINE while head : NEW_LINE INDENT if head . val < x : NEW_LINE INDENT before . next = head NEW_LINE before = head NEW_LINE DEDENT else : NEW_LINE INDENT after . next = head NEW_LINE after = head NEW_LINE DEDENT head = head . next NEW_LINE DEDENT after . next = None NEW_LINE before . next = afterHead . next NEW_LINE return beforeHead . next NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def matrixScore ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT for row in grid : NEW_LINE INDENT if row [ 0 ] == 0 : NEW_LINE INDENT self . _flip ( row ) NEW_LINE DEDENT DEDENT for j , col in enumerate ( list ( zip ( * grid ) ) ) : NEW_LINE INDENT if sum ( col ) * 2 < len ( grid ) : NEW_LINE INDENT self . _flipCol ( grid , j ) NEW_LINE DEDENT DEDENT return sum ( self . _binary ( row ) for row in grid ) NEW_LINE DEDENT def _flip ( self , row : List [ int ] ) -> None : NEW_LINE INDENT for i in range ( len ( row ) ) : NEW_LINE INDENT row [ i ] ^= 1 NEW_LINE DEDENT DEDENT def _flipCol ( self , grid : List [ List [ int ] ] , j : int ) -> None : NEW_LINE INDENT for i in range ( len ( grid ) ) : NEW_LINE INDENT grid [ i ] [ j ] ^= 1 NEW_LINE DEDENT DEDENT def _binary ( self , row : List [ int ] ) -> int : NEW_LINE INDENT res = row [ 0 ] NEW_LINE for j in range ( 1 , len ( row ) ) : NEW_LINE INDENT res = res * 2 + row [ j ] NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def shortestSubarray ( self , A : List [ int ] , K : int ) -> int : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = n + 1 NEW_LINE q = deque ( ) NEW_LINE prefix = [ 0 ] + list ( itertools . accumulate ( A ) ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT while q and prefix [ i ] - prefix [ q [ 0 ] ] >= K : NEW_LINE INDENT ans = min ( ans , i - q . popleft ( ) ) NEW_LINE DEDENT while q and prefix [ i ] <= prefix [ q [ - 1 ] ] : NEW_LINE INDENT q . pop ( ) NEW_LINE DEDENT q . append ( i ) NEW_LINE DEDENT return ans if ans <= n else - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def primePalindrome ( self , N : int ) -> int : NEW_LINE INDENT def getPalindromes ( n : int ) -> int : NEW_LINE INDENT length = n // 2 NEW_LINE for i in range ( 10 ** ( length - 1 ) , 10 ** length ) : NEW_LINE INDENT s = str ( i ) NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT yield int ( s + str ( j ) + s [ : : - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def isPrime ( num : int ) -> bool : NEW_LINE INDENT return not any ( num % i == 0 for i in range ( 2 , int ( num ** 0.5 + 1 ) ) ) NEW_LINE DEDENT if N <= 2 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if N == 3 : NEW_LINE INDENT return 3 NEW_LINE DEDENT if N <= 5 : NEW_LINE INDENT return 5 NEW_LINE DEDENT if N <= 7 : NEW_LINE INDENT return 7 NEW_LINE DEDENT if N <= 11 : NEW_LINE INDENT return 11 NEW_LINE DEDENT n = len ( str ( N ) ) NEW_LINE while True : NEW_LINE INDENT for num in getPalindromes ( n ) : NEW_LINE INDENT if num >= N and isPrime ( num ) : NEW_LINE INDENT return num NEW_LINE DEDENT DEDENT n += 1 NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def transpose ( self , A : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ [ 0 ] * len ( A ) for _ in range ( len ( A [ 0 ] ) ) ] NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT for j in range ( len ( A [ 0 ] ) ) : NEW_LINE INDENT ans [ j ] [ i ] = A [ i ] [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def binaryGap ( self , n : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE d = - 32 NEW_LINE while n : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT ans = max ( ans , d ) NEW_LINE d = 0 NEW_LINE DEDENT n //= 2 NEW_LINE d += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reorderedPowerOf2 ( self , N : int ) -> bool : NEW_LINE INDENT count = Counter ( str ( N ) ) NEW_LINE return any ( Counter ( str ( 1 << i ) ) == count for i in range ( 30 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isScramble ( self , s1 : str , s2 : str ) -> bool : NEW_LINE INDENT if s1 == s2 : NEW_LINE INDENT return True NEW_LINE DEDENT if len ( s1 ) != len ( s2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if Counter ( s1 ) != Counter ( s2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 1 , len ( s1 ) ) : NEW_LINE INDENT if self . isScramble ( s1 [ : i ] , s2 [ : i ] ) and self . isScramble ( s1 [ i : ] , s2 [ i : ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT if self . isScramble ( s1 [ : i ] , s2 [ len ( s2 ) - i : ] ) and self . isScramble ( s1 [ i : ] , s2 [ : len ( s2 ) - i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
from sortedcontainers import SortedList NEW_LINE class Solution : NEW_LINE INDENT def advantageCount ( self , A : List [ int ] , B : List [ int ] ) -> List [ int ] : NEW_LINE INDENT sl = SortedList ( A ) NEW_LINE for i , b in enumerate ( B ) : NEW_LINE INDENT index = 0 if sl [ - 1 ] <= b else sl . bisect_right ( b ) NEW_LINE A [ i ] = sl [ index ] NEW_LINE del sl [ index ] NEW_LINE DEDENT return A NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minRefuelStops ( self , target : int , startFuel : int , stations : List [ List [ int ] ] ) -> int : NEW_LINE INDENT dp = [ startFuel ] + [ 0 ] * len ( stations ) NEW_LINE for i , station in enumerate ( stations ) : NEW_LINE INDENT for j in range ( i + 1 , 0 , - 1 ) : NEW_LINE INDENT if dp [ j - 1 ] >= station [ 0 ] : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , dp [ j - 1 ] + station [ 1 ] ) NEW_LINE DEDENT DEDENT DEDENT for i , d in enumerate ( dp ) : NEW_LINE INDENT if d >= target : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def leafSimilar ( self , root1 : Optional [ TreeNode ] , root2 : Optional [ TreeNode ] ) -> bool : NEW_LINE INDENT def dfs ( root : Optional [ TreeNode ] ) -> None : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT if not root . left and not root . right : NEW_LINE INDENT yield root . val NEW_LINE return NEW_LINE DEDENT yield from dfs ( root . left ) NEW_LINE yield from dfs ( root . right ) NEW_LINE DEDENT return list ( dfs ( root1 ) ) == list ( dfs ( root2 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def lenLongestFibSubseq ( self , A : List [ int ] ) -> int : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE numToIndex = { a : i for i , a in enumerate ( A ) } NEW_LINE dp = [ [ 2 ] * n for _ in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT ai = A [ k ] - A [ j ] NEW_LINE if ai < A [ j ] and ai in numToIndex : NEW_LINE INDENT i = numToIndex [ ai ] NEW_LINE dp [ j ] [ k ] = dp [ i ] [ j ] + 1 NEW_LINE ans = max ( ans , dp [ j ] [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def robotSim ( self , commands : List [ int ] , obstacles : List [ List [ int ] ] ) -> int : NEW_LINE INDENT dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE ans = 0 NEW_LINE d = 0 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE obstaclesSet = { ( x , y ) for x , y in obstacles } NEW_LINE for c in commands : NEW_LINE INDENT if c == - 1 : NEW_LINE INDENT d = ( d + 1 ) % 4 NEW_LINE DEDENT elif c == - 2 : NEW_LINE INDENT d = ( d + 3 ) % 4 NEW_LINE DEDENT else : NEW_LINE INDENT for _ in range ( c ) : NEW_LINE INDENT if ( x + dirs [ d ] , y + dirs [ d + 1 ] ) in obstaclesSet : NEW_LINE INDENT break NEW_LINE DEDENT x += dirs [ d ] NEW_LINE y += dirs [ d + 1 ] NEW_LINE DEDENT DEDENT ans = max ( ans , x * x + y * y ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minEatingSpeed ( self , piles : List [ int ] , h : int ) -> int : NEW_LINE INDENT l = 1 NEW_LINE r = max ( piles ) NEW_LINE def eatHours ( m : int ) -> int : NEW_LINE INDENT return sum ( ( pile - 1 ) // m + 1 for pile in piles ) NEW_LINE DEDENT while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if eatHours ( m ) <= h : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def middleNode ( self , head : ListNode ) -> ListNode : NEW_LINE INDENT slow = head NEW_LINE fast = head NEW_LINE while fast and fast . next : NEW_LINE INDENT slow = slow . next NEW_LINE fast = fast . next . next NEW_LINE DEDENT return slow NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def stoneGame ( self , piles : List [ int ] ) -> bool : NEW_LINE INDENT n = len ( piles ) NEW_LINE dp = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE for i , pile in enumerate ( piles ) : NEW_LINE INDENT dp [ i ] [ i ] = pile NEW_LINE DEDENT for d in range ( 1 , n ) : NEW_LINE INDENT for i in range ( n - d ) : NEW_LINE INDENT j = i + d NEW_LINE dp [ i ] [ j ] = max ( piles [ i ] - dp [ i + 1 ] [ j ] , piles [ j ] - dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ 0 ] [ n - 1 ] > 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nthMagicalNumber ( self , n : int , a : int , b : int ) -> int : NEW_LINE INDENT lcm = a * b // math . gcd ( a , b ) NEW_LINE l = min ( a , b ) NEW_LINE r = min ( a , b ) * n NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if m // a + m // b - m // lcm >= n : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l % ( 10 ** 9 + 7 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def merge ( self , nums1 : List [ int ] , m : int , nums2 : List [ int ] , n : int ) -> None : NEW_LINE INDENT i = m - 1 NEW_LINE j = n - 1 NEW_LINE k = m + n - 1 NEW_LINE while j >= 0 : NEW_LINE INDENT if i >= 0 and nums1 [ i ] > nums2 [ j ] : NEW_LINE INDENT nums1 [ k ] = nums1 [ i ] NEW_LINE k -= 1 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT nums1 [ k ] = nums2 [ j ] NEW_LINE k -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def decodeAtIndex ( self , s : str , k : int ) -> str : NEW_LINE INDENT size = 0 NEW_LINE for c in s : NEW_LINE INDENT if c . isdigit ( ) : NEW_LINE INDENT size *= int ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT size += 1 NEW_LINE DEDENT DEDENT for c in reversed ( s ) : NEW_LINE INDENT k %= size NEW_LINE if k == 0 and c . isalpha ( ) : NEW_LINE INDENT return c NEW_LINE DEDENT if c . isdigit ( ) : NEW_LINE INDENT size //= int ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT size -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def numRescueBoats ( self , people : List [ int ] , limit : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE i = 0 NEW_LINE j = len ( people ) - 1 NEW_LINE people . sort ( ) NEW_LINE while i <= j : NEW_LINE INDENT remain = limit - people [ j ] NEW_LINE j -= 1 NEW_LINE if people [ i ] <= remain : NEW_LINE INDENT i += 1 NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reachableNodes ( self , edges : List [ List [ int ] ] , maxMoves : int , n : int ) -> int : NEW_LINE INDENT graph = [ [ ] for _ in range ( n ) ] NEW_LINE minHeap = [ ( 0 , 0 ) ] NEW_LINE dist = [ maxMoves + 1 ] * n NEW_LINE dist [ 0 ] = 0 NEW_LINE for u , v , cnt in edges : NEW_LINE INDENT graph [ u ] . append ( ( v , cnt ) ) NEW_LINE graph [ v ] . append ( ( u , cnt ) ) NEW_LINE DEDENT while minHeap : NEW_LINE INDENT d , u = heapq . heappop ( minHeap ) NEW_LINE if dist [ u ] >= maxMoves : NEW_LINE INDENT break NEW_LINE DEDENT for v , w in graph [ u ] : NEW_LINE INDENT newDist = d + w + 1 NEW_LINE if newDist < dist [ v ] : NEW_LINE INDENT dist [ v ] = newDist NEW_LINE heapq . heappush ( minHeap , ( newDist , v ) ) NEW_LINE DEDENT DEDENT DEDENT reachableNodes = sum ( d <= maxMoves for d in dist ) NEW_LINE reachableSubnodes = 0 NEW_LINE for u , v , cnt in edges : NEW_LINE INDENT a = 0 if dist [ u ] > maxMoves else min ( maxMoves - dist [ u ] , cnt ) NEW_LINE b = 0 if dist [ v ] > maxMoves else min ( maxMoves - dist [ v ] , cnt ) NEW_LINE reachableSubnodes += min ( a + b , cnt ) NEW_LINE DEDENT return reachableNodes + reachableSubnodes NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def projectionArea ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT return sum ( a > 0 for row in grid for a in row ) + sum ( max ( row ) for row in grid ) + sum ( max ( col ) for col in zip ( * grid ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def uncommonFromSentences ( self , A : str , B : str ) -> List [ str ] : NEW_LINE INDENT count = Counter ( ( A + ' ‚ñÅ ' + B ) . split ( ) ) NEW_LINE return [ word for word , freq in count . items ( ) if freq == 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def spiralMatrixIII ( self , R : int , C : int , r0 : int , c0 : int ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ [ r0 , c0 ] ] NEW_LINE dx = [ 1 , 0 , - 1 , 0 ] NEW_LINE dy = [ 0 , 1 , 0 , - 1 ] NEW_LINE i = 0 NEW_LINE while len ( ans ) < R * C : NEW_LINE INDENT for _ in range ( i // 2 + 1 ) : NEW_LINE INDENT r0 += dy [ i % 4 ] NEW_LINE c0 += dx [ i % 4 ] NEW_LINE if 0 <= r0 < R and 0 <= c0 < C : NEW_LINE INDENT ans . append ( [ r0 , c0 ] ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
from enum import Enum NEW_LINE class Color ( Enum ) : NEW_LINE INDENT WHITE = 0 NEW_LINE RED = 1 NEW_LINE GREEN = 2 NEW_LINE DEDENT class Solution : NEW_LINE INDENT def possibleBipartition ( self , n : int , dislikes : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT graph = [ [ ] for _ in range ( n + 1 ) ] NEW_LINE colors = [ Color . WHITE ] * ( n + 1 ) NEW_LINE for u , v in dislikes : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT def isValidColor ( u : int , color : Color ) -> bool : NEW_LINE INDENT if colors [ u ] != Color . WHITE : NEW_LINE INDENT return colors [ u ] == color NEW_LINE DEDENT colors [ u ] = color NEW_LINE childrenColor = Color . RED if colors [ u ] == Color . GREEN else Color . GREEN NEW_LINE return all ( isValidColor ( v , childrenColor ) for v in graph [ u ] ) NEW_LINE DEDENT return all ( colors [ i ] != Color . WHITE or isValidColor ( i , Color . RED ) for i in range ( 1 , n + 1 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def fairCandySwap ( self , A : List [ int ] , B : List [ int ] ) -> List [ int ] : NEW_LINE INDENT diff = ( sum ( A ) - sum ( B ) ) // 2 NEW_LINE B = set ( B ) NEW_LINE for a in A : NEW_LINE INDENT if a - diff in B : NEW_LINE INDENT return [ a , a - diff ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def constructFromPrePost ( self , pre : List [ int ] , post : List [ int ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT postToIndex = { num : i for i , num in enumerate ( post ) } NEW_LINE def build ( preStart : int , preEnd : int , postStart : int , postEnd : int ) -> Optional [ TreeNode ] : NEW_LINE INDENT if preStart > preEnd : NEW_LINE INDENT return None NEW_LINE DEDENT if preStart == preEnd : NEW_LINE INDENT return TreeNode ( pre [ preStart ] ) NEW_LINE DEDENT rootVal = pre [ preStart ] NEW_LINE leftRootVal = pre [ preStart + 1 ] NEW_LINE leftRootPostIndex = postToIndex [ leftRootVal ] NEW_LINE leftSize = leftRootPostIndex - postStart + 1 NEW_LINE root = TreeNode ( rootVal ) NEW_LINE root . left = build ( preStart + 1 , preStart + leftSize , postStart , leftRootPostIndex ) NEW_LINE root . right = build ( preStart + leftSize + 1 , preEnd , leftRootPostIndex + 1 , postEnd - 1 ) NEW_LINE return root NEW_LINE DEDENT return build ( 0 , len ( pre ) - 1 , 0 , len ( post ) - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def grayCode ( self , n : int ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in reversed ( range ( len ( ans ) ) ) : NEW_LINE INDENT ans . append ( ans [ j ] | 1 << i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findAndReplacePattern ( self , words : List [ str ] , pattern : str ) -> List [ str ] : NEW_LINE INDENT def isIsomorphic ( w : str , p : str ) -> bool : NEW_LINE INDENT return [ * map ( w . index , w ) ] == [ * map ( p . index , p ) ] NEW_LINE DEDENT return [ word for word in words if isIsomorphic ( word , pattern ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sumSubseqWidths ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE n = len ( nums ) NEW_LINE ans = 0 NEW_LINE exp = 1 NEW_LINE nums . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += ( nums [ i ] - nums [ n - i - 1 ] ) * exp NEW_LINE ans %= kMod NEW_LINE exp = exp * 2 % kMod NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def surfaceArea ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( grid ) ) : NEW_LINE INDENT for j in range ( len ( grid ) ) : NEW_LINE INDENT if grid [ i ] [ j ] : NEW_LINE INDENT ans += grid [ i ] [ j ] * 4 + 2 NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT ans -= min ( grid [ i ] [ j ] , grid [ i - 1 ] [ j ] ) * 2 NEW_LINE DEDENT if j > 0 : NEW_LINE INDENT ans -= min ( grid [ i ] [ j ] , grid [ i ] [ j - 1 ] ) * 2 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numSpecialEquivGroups ( self , A : List [ str ] ) -> int : NEW_LINE INDENT return len ( { ' ' . join ( sorted ( s [ : : 2 ] ) ) + ' ' . join ( sorted ( s [ 1 : : 2 ] ) ) for s in A } ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def allPossibleFBT ( self , n : int ) -> List [ Optional [ TreeNode ] ] : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return [ TreeNode ( 0 ) ] NEW_LINE DEDENT ans = [ ] NEW_LINE for leftCount in range ( n ) : NEW_LINE INDENT rightCount = n - 1 - leftCount NEW_LINE for left in self . allPossibleFBT ( leftCount ) : NEW_LINE INDENT for right in self . allPossibleFBT ( rightCount ) : NEW_LINE INDENT ans . append ( TreeNode ( 0 ) ) NEW_LINE ans [ - 1 ] . left = left NEW_LINE ans [ - 1 ] . right = right NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class FreqStack : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . maxFreq = 0 NEW_LINE self . count = Counter ( ) NEW_LINE self . countToStack = defaultdict ( list ) NEW_LINE DEDENT def push ( self , val : int ) -> None : NEW_LINE INDENT self . count [ val ] += 1 NEW_LINE self . countToStack [ self . count [ val ] ] . append ( val ) NEW_LINE self . maxFreq = max ( self . maxFreq , self . count [ val ] ) NEW_LINE DEDENT def pop ( self ) -> int : NEW_LINE INDENT val = self . countToStack [ self . maxFreq ] . pop ( ) NEW_LINE self . count [ val ] -= 1 NEW_LINE if not self . countToStack [ self . maxFreq ] : NEW_LINE INDENT self . maxFreq -= 1 NEW_LINE DEDENT return val NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isMonotonic ( self , A : List [ int ] ) -> bool : NEW_LINE INDENT increasing = True NEW_LINE decreasing = True NEW_LINE for i in range ( 1 , len ( A ) ) : NEW_LINE INDENT increasing &= A [ i - 1 ] <= A [ i ] NEW_LINE decreasing &= A [ i - 1 ] >= A [ i ] NEW_LINE DEDENT return increasing or decreasing NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def increasingBST ( self , root : TreeNode , tail : TreeNode = None ) -> TreeNode : NEW_LINE INDENT if not root : NEW_LINE INDENT return tail NEW_LINE DEDENT res = self . increasingBST ( root . left , root ) NEW_LINE root . left = None NEW_LINE root . right = self . increasingBST ( root . right , tail ) NEW_LINE return res NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def orderlyQueue ( self , S : str , K : int ) -> str : NEW_LINE INDENT return ' ' . join ( sorted ( S ) ) if K > 1 else min ( S [ i : ] + S [ : i ] for i in range ( len ( S ) ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isPalindrome ( self , x : int ) -> bool : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT rev = 0 NEW_LINE y = x NEW_LINE while y : NEW_LINE INDENT rev = rev * 10 + y % 10 NEW_LINE y //= 10 NEW_LINE DEDENT return rev == x NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def subsetsWithDup ( self , nums : List [ int ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( s : int , path : List [ int ] ) -> None : NEW_LINE INDENT ans . append ( path ) NEW_LINE if s == len ( nums ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( s , len ( nums ) ) : NEW_LINE INDENT if i > s and nums [ i ] == nums [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( i + 1 , path + [ nums [ i ] ] ) NEW_LINE DEDENT DEDENT nums . sort ( ) NEW_LINE dfs ( 0 , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class RLEIterator : NEW_LINE INDENT def __init__ ( self , A : List [ int ] ) : NEW_LINE INDENT self . A = A NEW_LINE self . index = 0 NEW_LINE DEDENT def next ( self , n : int ) -> int : NEW_LINE INDENT while self . index < len ( self . A ) and self . A [ self . index ] < n : NEW_LINE INDENT n -= self . A [ self . index ] NEW_LINE self . index += 2 NEW_LINE DEDENT if self . index == len ( self . A ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT self . A [ self . index ] -= n NEW_LINE return self . A [ self . index + 1 ] NEW_LINE DEDENT DEDENT
class StockSpanner : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE DEDENT def next ( self , price : int ) -> int : NEW_LINE INDENT span = 1 NEW_LINE while self . stack and self . stack [ - 1 ] [ 0 ] <= price : NEW_LINE INDENT span += self . stack . pop ( ) [ 1 ] NEW_LINE DEDENT self . stack . append ( ( price , span ) ) NEW_LINE return span NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def atMostNGivenDigitSet ( self , D : List [ str ] , N : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE num = str ( N ) NEW_LINE for i in range ( 1 , len ( num ) ) : NEW_LINE INDENT ans += len ( D ) ** i NEW_LINE DEDENT for i , c in enumerate ( num ) : NEW_LINE INDENT dHasSameNum = False NEW_LINE for digit in D : NEW_LINE INDENT if digit < c : NEW_LINE INDENT ans += len ( D ) ** ( len ( num ) - i - 1 ) NEW_LINE DEDENT elif digit == c : NEW_LINE INDENT dHasSameNum = True NEW_LINE DEDENT DEDENT if not dHasSameNum : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def totalFruit ( self , tree : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = defaultdict ( int ) NEW_LINE l = 0 NEW_LINE for r , t in enumerate ( tree ) : NEW_LINE INDENT count [ t ] += 1 NEW_LINE while len ( count ) > 2 : NEW_LINE INDENT count [ tree [ l ] ] -= 1 NEW_LINE if count [ tree [ l ] ] == 0 : NEW_LINE INDENT del count [ tree [ l ] ] NEW_LINE DEDENT l += 1 NEW_LINE DEDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sortArrayByParity ( self , A : List [ int ] ) -> List [ int ] : NEW_LINE INDENT l = 0 NEW_LINE r = len ( A ) - 1 NEW_LINE while l < r : NEW_LINE INDENT if A [ l ] % 2 == 1 and A [ r ] % 2 == 0 : NEW_LINE INDENT A [ l ] , A [ r ] = A [ r ] , A [ l ] NEW_LINE DEDENT if A [ l ] % 2 == 0 : NEW_LINE INDENT l += 1 NEW_LINE DEDENT if A [ r ] % 2 == 1 : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def superpalindromesInRange ( self , left : str , right : str ) -> int : NEW_LINE INDENT def nextPalindrome ( num : int ) -> int : NEW_LINE INDENT s = str ( num ) NEW_LINE n = len ( s ) NEW_LINE half = s [ 0 : ( n + 1 ) // 2 ] NEW_LINE reversedHalf = half [ : n // 2 ] [ : : - 1 ] NEW_LINE candidate = int ( half + reversedHalf ) NEW_LINE if candidate >= num : NEW_LINE INDENT return candidate NEW_LINE DEDENT half = str ( int ( half ) + 1 ) NEW_LINE reversedHalf = half [ : n // 2 ] [ : : - 1 ] NEW_LINE return int ( half + reversedHalf ) NEW_LINE DEDENT def isPalindrome ( num : int ) -> bool : NEW_LINE INDENT s = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( s ) - 1 NEW_LINE while l < r : NEW_LINE INDENT if s [ l ] != s [ r ] : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT ans = 0 NEW_LINE l = int ( left ) NEW_LINE r = int ( right ) NEW_LINE i = int ( sqrt ( l ) ) NEW_LINE while i * i <= r : NEW_LINE INDENT palindrome = nextPalindrome ( i ) NEW_LINE squared = palindrome ** 2 NEW_LINE if squared <= r and isPalindrome ( squared ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT i = palindrome + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sumSubarrayMins ( self , arr : List [ int ] ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE n = len ( arr ) NEW_LINE ans = 0 NEW_LINE prev = [ - 1 ] * n NEW_LINE next = [ n ] * n NEW_LINE stack = [ ] NEW_LINE for i , a in enumerate ( arr ) : NEW_LINE INDENT while stack and arr [ stack [ - 1 ] ] > a : NEW_LINE INDENT index = stack . pop ( ) NEW_LINE next [ index ] = i NEW_LINE DEDENT if stack : NEW_LINE INDENT prev [ i ] = stack [ - 1 ] NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT for i , a in enumerate ( arr ) : NEW_LINE INDENT ans += a * ( i - prev [ i ] ) * ( next [ i ] - i ) NEW_LINE ans %= kMod NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestRangeI ( self , A : List [ int ] , K : int ) -> int : NEW_LINE INDENT return max ( 0 , max ( A ) - min ( A ) - 2 * K ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def snakesAndLadders ( self , board : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( board ) NEW_LINE ans = 0 NEW_LINE q = deque ( [ 1 ] ) NEW_LINE seen = set ( ) NEW_LINE A = [ 0 ] * ( 1 + n * n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT A [ ( n - 1 - i ) * n + ( j + 1 if n - i & 1 else n - j ) ] = board [ i ] [ j ] NEW_LINE DEDENT DEDENT while q : NEW_LINE INDENT ans += 1 NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT curr = q . popleft ( ) NEW_LINE for next in range ( curr + 1 , min ( curr + 6 , n * n ) + 1 ) : NEW_LINE INDENT dest = A [ next ] if A [ next ] > 0 else next NEW_LINE if dest == n * n : NEW_LINE INDENT return ans NEW_LINE DEDENT if dest in seen : NEW_LINE INDENT continue NEW_LINE DEDENT q . append ( dest ) NEW_LINE seen . add ( dest ) NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numDecodings ( self , s : str ) -> int : NEW_LINE INDENT n = len ( s ) NEW_LINE dp = [ 0 ] * n + [ 1 ] NEW_LINE def isValid ( a : chr , b = None ) -> bool : NEW_LINE INDENT if b : NEW_LINE INDENT return a == '1' or a == '2' and b < '7' NEW_LINE DEDENT return a != '0' NEW_LINE DEDENT if isValid ( s [ - 1 ] ) : NEW_LINE INDENT dp [ n - 1 ] = 1 NEW_LINE DEDENT for i in reversed ( range ( n - 1 ) ) : NEW_LINE INDENT if isValid ( s [ i ] ) : NEW_LINE INDENT dp [ i ] += dp [ i + 1 ] NEW_LINE DEDENT if isValid ( s [ i ] , s [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] += dp [ i + 2 ] NEW_LINE DEDENT DEDENT return dp [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestRangeII ( self , A : List [ int ] , K : int ) -> int : NEW_LINE INDENT A . sort ( ) NEW_LINE ans = A [ - 1 ] - A [ 0 ] NEW_LINE left = A [ 0 ] + K NEW_LINE right = A [ - 1 ] - K NEW_LINE for a , b in zip ( A , A [ 1 : ] ) : NEW_LINE INDENT mini = min ( left , b - K ) NEW_LINE maxi = max ( right , a + K ) NEW_LINE ans = min ( ans , maxi - mini ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class TopVotedCandidate : NEW_LINE INDENT def __init__ ( self , persons : List [ int ] , times : List [ int ] ) : NEW_LINE INDENT self . times = times NEW_LINE self . timeToLead = { } NEW_LINE count = Counter ( ) NEW_LINE lead = - 1 NEW_LINE for person , time in zip ( persons , times ) : NEW_LINE INDENT count [ person ] += 1 NEW_LINE if count [ person ] >= count [ lead ] : NEW_LINE INDENT lead = person NEW_LINE DEDENT self . timeToLead [ time ] = lead NEW_LINE DEDENT DEDENT def q ( self , t : int ) -> int : NEW_LINE INDENT i = bisect_right ( self . times , t ) NEW_LINE return self . timeToLead [ self . times [ i - 1 ] ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sortArray ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT def mergeSort ( A : List [ int ] , l : int , r : int ) -> None : NEW_LINE INDENT if l >= r : NEW_LINE INDENT return NEW_LINE DEDENT def merge ( A : List [ int ] , l : int , m : int , r : int ) -> None : NEW_LINE INDENT sorted = [ 0 ] * ( r - l + 1 ) NEW_LINE k = 0 NEW_LINE i = l NEW_LINE j = m + 1 NEW_LINE while i <= m and j <= r : NEW_LINE INDENT if A [ i ] < A [ j ] : NEW_LINE INDENT sorted [ k ] = A [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sorted [ k ] = A [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while i <= m : NEW_LINE INDENT sorted [ k ] = A [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT while j <= r : NEW_LINE INDENT sorted [ k ] = A [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT A [ l : l + len ( sorted ) ] = sorted NEW_LINE DEDENT m = ( l + r ) // 2 NEW_LINE mergeSort ( A , l , m ) NEW_LINE mergeSort ( A , m + 1 , r ) NEW_LINE merge ( A , l , m , r ) NEW_LINE DEDENT mergeSort ( nums , 0 , len ( nums ) - 1 ) NEW_LINE return nums NEW_LINE DEDENT DEDENT
from enum import IntEnum NEW_LINE class State ( IntEnum ) : NEW_LINE INDENT DRAW = 0 NEW_LINE MOUSE_WIN = 1 NEW_LINE CAT_WIN = 2 NEW_LINE DEDENT class Solution : NEW_LINE INDENT def catMouseGame ( self , graph : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( graph ) NEW_LINE states = [ [ [ 0 ] * 2 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE outDegree = [ [ [ 0 ] * 2 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE q = deque ( ) NEW_LINE for cat in range ( n ) : NEW_LINE INDENT for mouse in range ( n ) : NEW_LINE INDENT outDegree [ cat ] [ mouse ] [ 0 ] = len ( graph [ mouse ] ) NEW_LINE outDegree [ cat ] [ mouse ] [ 1 ] = len ( graph [ cat ] ) - graph [ cat ] . count ( 0 ) NEW_LINE DEDENT DEDENT for cat in range ( 1 , n ) : NEW_LINE INDENT for move in range ( 2 ) : NEW_LINE INDENT states [ cat ] [ 0 ] [ move ] = int ( State . MOUSE_WIN ) NEW_LINE q . append ( ( cat , 0 , move , int ( State . MOUSE_WIN ) ) ) NEW_LINE states [ cat ] [ cat ] [ move ] = int ( State . CAT_WIN ) NEW_LINE q . append ( ( cat , cat , move , int ( State . CAT_WIN ) ) ) NEW_LINE DEDENT DEDENT while q : NEW_LINE INDENT cat , mouse , move , state = q . popleft ( ) NEW_LINE if cat == 2 and mouse == 1 and move == 0 : NEW_LINE INDENT return state NEW_LINE DEDENT prevMove = move ^ 1 NEW_LINE for prev in graph [ cat if prevMove else mouse ] : NEW_LINE INDENT prevCat = prev if prevMove else cat NEW_LINE if prevCat == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT prevMouse = mouse if prevMove else prev NEW_LINE if states [ prevCat ] [ prevMouse ] [ prevMove ] : NEW_LINE INDENT continue NEW_LINE DEDENT if prevMove == 0 and state == int ( State . MOUSE_WIN ) or prevMove == 1 and state == int ( State . CAT_WIN ) : NEW_LINE INDENT states [ prevCat ] [ prevMouse ] [ prevMove ] = state NEW_LINE q . append ( ( prevCat , prevMouse , prevMove , state ) ) NEW_LINE DEDENT else : NEW_LINE INDENT outDegree [ prevCat ] [ prevMouse ] [ prevMove ] -= 1 NEW_LINE if outDegree [ prevCat ] [ prevMouse ] [ prevMove ] == 0 : NEW_LINE INDENT states [ prevCat ] [ prevMouse ] [ prevMove ] = state NEW_LINE q . append ( ( prevCat , prevMouse , prevMove , state ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return states [ 2 ] [ 1 ] [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def hasGroupsSizeX ( self , deck : List [ int ] ) -> bool : NEW_LINE INDENT count = Counter ( deck ) NEW_LINE return functools . reduce ( math . gcd , count . values ( ) ) >= 2 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def partitionDisjoint ( self , A : List [ int ] ) -> int : NEW_LINE INDENT n = len ( A ) NEW_LINE mini = [ 0 ] * ( n - 1 ) + [ A [ - 1 ] ] NEW_LINE maxi = - math . inf NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mini [ i ] = min ( mini [ i + 1 ] , A [ i ] ) NEW_LINE DEDENT for i , a in enumerate ( A ) : NEW_LINE INDENT maxi = max ( maxi , a ) NEW_LINE if maxi <= mini [ i + 1 ] : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def wordSubsets ( self , A : List [ str ] , B : List [ str ] ) -> List [ str ] : NEW_LINE INDENT count = Counter ( ) NEW_LINE for b in B : NEW_LINE INDENT count = count | Counter ( b ) NEW_LINE DEDENT return [ a for a in A if Counter ( a ) & count == count ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reverseOnlyLetters ( self , S : str ) -> str : NEW_LINE INDENT S = list ( S ) NEW_LINE i = 0 NEW_LINE j = len ( S ) - 1 NEW_LINE while i < j : NEW_LINE INDENT while i < j and not S [ i ] . isalpha ( ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while i < j and not S [ j ] . isalpha ( ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT S [ i ] , S [ j ] = S [ j ] , S [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return ' ' . join ( S ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxSubarraySumCircular ( self , A : List [ int ] ) -> int : NEW_LINE INDENT totalSum = 0 NEW_LINE currMaxSum = 0 NEW_LINE currMinSum = 0 NEW_LINE maxSum = - math . inf NEW_LINE minSum = math . inf NEW_LINE for a in A : NEW_LINE INDENT totalSum += a NEW_LINE currMaxSum = max ( currMaxSum + a , a ) NEW_LINE currMinSum = min ( currMinSum + a , a ) NEW_LINE maxSum = max ( maxSum , currMaxSum ) NEW_LINE minSum = min ( minSum , currMinSum ) NEW_LINE DEDENT return maxSum if maxSum < 0 else max ( maxSum , totalSum - minSum ) NEW_LINE DEDENT DEDENT
class CBTInserter : NEW_LINE INDENT def __init__ ( self , root : Optional [ TreeNode ] ) : NEW_LINE INDENT self . tree = [ root ] NEW_LINE for node in self . tree : NEW_LINE INDENT if node . left : NEW_LINE INDENT self . tree . append ( node . left ) NEW_LINE DEDENT if node . right : NEW_LINE INDENT self . tree . append ( node . right ) NEW_LINE DEDENT DEDENT DEDENT def insert ( self , v : int ) -> int : NEW_LINE INDENT n = len ( self . tree ) NEW_LINE self . tree . append ( TreeNode ( v ) ) NEW_LINE parent = self . tree [ ( n - 1 ) // 2 ] NEW_LINE if n & 1 : NEW_LINE INDENT parent . left = self . tree [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT parent . right = self . tree [ - 1 ] NEW_LINE DEDENT return parent . val NEW_LINE DEDENT def get_root ( self ) -> Optional [ TreeNode ] : NEW_LINE INDENT return self . tree [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reverseBetween ( self , head : Optional [ ListNode ] , left : int , right : int ) -> Optional [ ListNode ] : NEW_LINE INDENT if left == 1 : NEW_LINE INDENT return self . reverseN ( head , right ) NEW_LINE DEDENT head . next = self . reverseBetween ( head . next , left - 1 , right - 1 ) NEW_LINE return head NEW_LINE DEDENT def reverseN ( self , head : Optional [ ListNode ] , n : int ) -> Optional [ ListNode ] : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return head NEW_LINE DEDENT newHead = self . reverseN ( head . next , n - 1 ) NEW_LINE headNext = head . next NEW_LINE head . next = headNext . next NEW_LINE headNext . next = head NEW_LINE return newHead NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minAddToMakeValid ( self , s : str ) -> int : NEW_LINE INDENT l = 0 NEW_LINE r = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == ' ( ' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if l == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT else : NEW_LINE INDENT l -= 1 NEW_LINE DEDENT DEDENT DEDENT return l + r NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sortArrayByParityII ( self , A : List [ int ] ) -> List [ int ] : NEW_LINE INDENT n = len ( A ) NEW_LINE i = 0 NEW_LINE j = 1 NEW_LINE while i < n : NEW_LINE INDENT while i < n and A [ i ] % 2 == 0 : NEW_LINE INDENT i += 2 NEW_LINE DEDENT while j < n and A [ j ] % 2 == 1 : NEW_LINE INDENT j += 2 NEW_LINE DEDENT if i < n : NEW_LINE INDENT A [ i ] , A [ j ] = A [ j ] , A [ i ] NEW_LINE DEDENT i += 2 NEW_LINE j += 2 NEW_LINE DEDENT return A NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isLongPressedName ( self , name : str , typed : str ) -> bool : NEW_LINE INDENT i = 0 NEW_LINE for j , t in enumerate ( typed ) : NEW_LINE INDENT if i < len ( name ) and name [ i ] == t : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif j == 0 or t != typed [ j - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return i == len ( name ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minFlipsMonoIncr ( self , S : str ) -> int : NEW_LINE INDENT dp = [ 0 ] * 2 NEW_LINE for i , c in enumerate ( S ) : NEW_LINE INDENT dp [ 0 ] , dp [ 1 ] = dp [ 0 ] + ( c == '1' ) , min ( dp [ 0 ] , dp [ 1 ] ) + ( c == '0' ) NEW_LINE DEDENT return min ( dp [ 0 ] , dp [ 1 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def threeEqualParts ( self , A : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ones = sum ( a == 1 for a in A ) NEW_LINE if ones == 0 : NEW_LINE INDENT return [ 0 , len ( A ) - 1 ] NEW_LINE DEDENT if ones % 3 != 0 : NEW_LINE INDENT return [ - 1 , - 1 ] NEW_LINE DEDENT k = ones // 3 NEW_LINE i = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ i ] == 1 : NEW_LINE INDENT first = i NEW_LINE break NEW_LINE DEDENT DEDENT gapOnes = k NEW_LINE for j in range ( i + 1 , len ( A ) ) : NEW_LINE INDENT if A [ j ] == 1 : NEW_LINE INDENT gapOnes -= 1 NEW_LINE if gapOnes == 0 : NEW_LINE INDENT second = j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT gapOnes = k NEW_LINE for i in range ( j + 1 , len ( A ) ) : NEW_LINE INDENT if A [ i ] == 1 : NEW_LINE INDENT gapOnes -= 1 NEW_LINE if gapOnes == 0 : NEW_LINE INDENT third = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT while third < len ( A ) and A [ first ] == A [ second ] == A [ third ] : NEW_LINE INDENT first += 1 NEW_LINE second += 1 NEW_LINE third += 1 NEW_LINE DEDENT if third == len ( A ) : NEW_LINE INDENT return [ first - 1 , second ] NEW_LINE DEDENT return [ - 1 , - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numUniqueEmails ( self , emails : List [ str ] ) -> int : NEW_LINE INDENT seen = set ( ) NEW_LINE for email in emails : NEW_LINE INDENT local , domain = email . split ( ' @ ' ) NEW_LINE local = local . split ( ' + ' ) [ 0 ] . replace ( ' . ' , ' ' ) NEW_LINE seen . add ( local + ' @ ' + domain ) NEW_LINE DEDENT return len ( seen ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def restoreIpAddresses ( self , s : str ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( start : int , path : List [ int ] ) -> None : NEW_LINE INDENT if len ( path ) == 4 and start == len ( s ) : NEW_LINE INDENT ans . append ( path [ 0 ] + ' . ' + path [ 1 ] + ' . ' + path [ 2 ] + ' . ' + path [ 3 ] ) NEW_LINE return NEW_LINE DEDENT if len ( path ) == 4 or start == len ( s ) : NEW_LINE INDENT return NEW_LINE DEDENT for length in range ( 1 , 4 ) : NEW_LINE INDENT if start + length > len ( s ) : NEW_LINE INDENT return NEW_LINE DEDENT if length > 1 and s [ start ] == '0' : NEW_LINE INDENT return NEW_LINE DEDENT num = s [ start : start + length ] NEW_LINE if int ( num ) > 255 : NEW_LINE INDENT return NEW_LINE DEDENT dfs ( start + length , path + [ num ] ) NEW_LINE DEDENT DEDENT dfs ( 0 , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numSubarraysWithSum ( self , A : List [ int ] , S : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prefix = 0 NEW_LINE count = Counter ( { 0 : 1 } ) NEW_LINE for a in A : NEW_LINE INDENT prefix += a NEW_LINE ans += count [ prefix - S ] NEW_LINE count [ prefix ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minFallingPathSum ( self , A : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( A ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT mini = math . inf NEW_LINE for k in range ( max ( 0 , j - 1 ) , min ( n , j + 2 ) ) : NEW_LINE INDENT mini = min ( mini , A [ i - 1 ] [ k ] ) NEW_LINE DEDENT A [ i ] [ j ] += mini NEW_LINE DEDENT DEDENT return min ( A [ - 1 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def beautifulArray ( self , n : int ) -> List [ int ] : NEW_LINE INDENT A = [ i for i in range ( 1 , n + 1 ) ] NEW_LINE def partition ( l : int , r : int , mask : int ) -> int : NEW_LINE INDENT nextSwapped = l NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if A [ i ] & mask : NEW_LINE INDENT A [ i ] , A [ nextSwapped ] = A [ nextSwapped ] , A [ i ] NEW_LINE nextSwapped += 1 NEW_LINE DEDENT DEDENT return nextSwapped - 1 NEW_LINE DEDENT def divide ( l : int , r : int , mask : int ) -> None : NEW_LINE INDENT if l >= r : NEW_LINE INDENT return NEW_LINE DEDENT m = partition ( l , r , mask ) NEW_LINE divide ( l , m , mask << 1 ) NEW_LINE divide ( m + 1 , r , mask << 1 ) NEW_LINE DEDENT divide ( 0 , n - 1 , 1 ) NEW_LINE return A NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def knightDialer ( self , n : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE dirs = [ ( - 2 , 1 ) , ( - 1 , 2 ) , ( 1 , 2 ) , ( 2 , 1 ) , ( 2 , - 1 ) , ( 1 , - 2 ) , ( - 1 , - 2 ) , ( - 2 , - 1 ) ] NEW_LINE dp = [ [ 1 ] * 3 for _ in range ( 4 ) ] NEW_LINE dp [ 3 ] [ 0 ] = dp [ 3 ] [ 2 ] = 0 NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT newDp = [ [ 0 ] * 3 for _ in range ( 4 ) ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT if ( i , j ) in ( ( 3 , 0 ) , ( 3 , 2 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT for dx , dy in dirs : NEW_LINE INDENT x = i + dx NEW_LINE y = j + dy NEW_LINE if x < 0 or x >= 4 or y < 0 or y >= 3 : NEW_LINE INDENT continue NEW_LINE DEDENT if ( x , y ) in ( ( 3 , 0 ) , ( 3 , 2 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT newDp [ x ] [ y ] = ( newDp [ x ] [ y ] + dp [ i ] [ j ] ) % kMod NEW_LINE DEDENT DEDENT DEDENT dp = newDp NEW_LINE DEDENT return sum ( map ( sum , dp ) ) % kMod NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def movesToStamp ( self , stamp : str , target : str ) -> List [ int ] : NEW_LINE INDENT def stampify ( s : int ) -> int : NEW_LINE INDENT stampified = len ( stamp ) NEW_LINE for i , st in enumerate ( stamp ) : NEW_LINE INDENT if target [ s + i ] == ' * ' : NEW_LINE INDENT stampified -= 1 NEW_LINE DEDENT elif target [ s + i ] != st : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT for i in range ( s , s + len ( stamp ) ) : NEW_LINE INDENT target [ i ] = ' * ' NEW_LINE DEDENT return stampified NEW_LINE DEDENT ans = [ ] NEW_LINE target = list ( target ) NEW_LINE stamped = [ False ] * len ( target ) NEW_LINE stampedCount = 0 NEW_LINE while stampedCount < len ( target ) : NEW_LINE INDENT isStamped = False NEW_LINE for i in range ( len ( target ) - len ( stamp ) + 1 ) : NEW_LINE INDENT if stamped [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT stampified = stampify ( i ) NEW_LINE if stampified == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT stampedCount += stampified NEW_LINE isStamped = True NEW_LINE stamped [ i ] = True NEW_LINE ans . append ( i ) NEW_LINE DEDENT if not isStamped : NEW_LINE INDENT return [ ] NEW_LINE DEDENT DEDENT return ans [ : : - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reorderLogFiles ( self , logs : List [ str ] ) -> List [ str ] : NEW_LINE INDENT digitLogs = [ ] NEW_LINE letterLogs = [ ] NEW_LINE for log in logs : NEW_LINE INDENT i = log . index ( ' ‚ñÅ ' ) NEW_LINE if log [ i + 1 ] . isdigit ( ) : NEW_LINE INDENT digitLogs . append ( log ) NEW_LINE DEDENT else : NEW_LINE INDENT letterLogs . append ( ( log [ : i ] , log [ i + 1 : ] ) ) NEW_LINE DEDENT DEDENT letterLogs . sort ( key = lambda l : ( l [ 1 ] , l [ 0 ] ) ) NEW_LINE return [ identifier + ' ‚ñÅ ' + letters for identifier , letters in letterLogs ] + digitLogs NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minAreaRect ( self , points : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = math . inf NEW_LINE xToYs = defaultdict ( set ) NEW_LINE for x , y in points : NEW_LINE INDENT xToYs [ x ] . add ( y ) NEW_LINE DEDENT for i in range ( len ( points ) ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT x1 , y1 = points [ i ] NEW_LINE x2 , y2 = points [ j ] NEW_LINE if x1 == x2 or y1 == y2 : NEW_LINE INDENT continue NEW_LINE DEDENT if y2 in xToYs [ x1 ] and y1 in xToYs [ x2 ] : NEW_LINE INDENT ans = min ( ans , abs ( x1 - x2 ) * abs ( y1 - y2 ) ) NEW_LINE DEDENT DEDENT DEDENT return ans if ans < math . inf else 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def inorderTraversal ( self , root : Optional [ TreeNode ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE stack = [ ] NEW_LINE while root or stack : NEW_LINE INDENT while root : NEW_LINE INDENT stack . append ( root ) NEW_LINE root = root . left NEW_LINE DEDENT root = stack . pop ( ) NEW_LINE ans . append ( root . val ) NEW_LINE root = root . right NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def distinctSubseqII ( self , s : str ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE endsWith = [ 0 ] * 26 NEW_LINE for c in s : NEW_LINE INDENT endsWith [ ord ( c ) - ord ( ' a ' ) ] = ( sum ( endsWith ) + 1 ) % kMod NEW_LINE DEDENT return sum ( endsWith ) % kMod NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def validMountainArray ( self , A : List [ int ] ) -> bool : NEW_LINE INDENT if len ( A ) < 3 : NEW_LINE INDENT return False NEW_LINE DEDENT l = 0 NEW_LINE r = len ( A ) - 1 NEW_LINE while l + 1 < len ( A ) and A [ l ] < A [ l + 1 ] : NEW_LINE INDENT l += 1 NEW_LINE DEDENT while r > 0 and A [ r ] < A [ r - 1 ] : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT return l > 0 and r < len ( A ) - 1 and l == r NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def diStringMatch ( self , S : str ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE mini = 0 NEW_LINE maxi = len ( S ) NEW_LINE for c in S : NEW_LINE INDENT if c == ' I ' : NEW_LINE INDENT ans . append ( mini ) NEW_LINE mini += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( maxi ) NEW_LINE maxi -= 1 NEW_LINE DEDENT DEDENT ans . append ( mini ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minIncrementForUnique ( self , A : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE minAvailable = 0 NEW_LINE A . sort ( ) NEW_LINE for a in A : NEW_LINE INDENT ans += max ( minAvailable - a , 0 ) NEW_LINE minAvailable = max ( minAvailable , a ) + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def validateStackSequences ( self , pushed : List [ int ] , popped : List [ int ] ) -> bool : NEW_LINE INDENT stack = [ ] NEW_LINE i = 0 NEW_LINE for x in pushed : NEW_LINE INDENT stack . append ( x ) NEW_LINE while stack and stack [ - 1 ] == popped [ i ] : NEW_LINE INDENT stack . pop ( ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return not stack NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def bagOfTokensScore ( self , tokens : List [ int ] , power : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE score = 0 NEW_LINE q = deque ( sorted ( tokens ) ) NEW_LINE while q and ( power >= q [ 0 ] or score ) : NEW_LINE INDENT while q and power >= q [ 0 ] : NEW_LINE INDENT power -= q . popleft ( ) NEW_LINE score += 1 NEW_LINE DEDENT ans = max ( ans , score ) NEW_LINE if q and score : NEW_LINE INDENT power += q . pop ( ) NEW_LINE score -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestTimeFromDigits ( self , A : List [ int ] ) -> str : NEW_LINE INDENT for time in itertools . permutations ( sorted ( A , reverse = True ) ) : NEW_LINE INDENT if time [ : 2 ] < ( 2 , 4 ) and time [ 2 ] < 6 : NEW_LINE INDENT return ' % d % d : % d % d ' % time NEW_LINE DEDENT DEDENT return ' ' NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def generateTrees ( self , n : int ) -> List [ TreeNode ] : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT def generateTrees ( mini : int , maxi : int ) -> List [ Optional [ int ] ] : NEW_LINE INDENT if mini > maxi : NEW_LINE INDENT return [ None ] NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( mini , maxi + 1 ) : NEW_LINE INDENT for left in generateTrees ( mini , i - 1 ) : NEW_LINE INDENT for right in generateTrees ( i + 1 , maxi ) : NEW_LINE INDENT ans . append ( TreeNode ( i ) ) NEW_LINE ans [ - 1 ] . left = left NEW_LINE ans [ - 1 ] . right = right NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT return generateTrees ( 1 , n ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def deckRevealedIncreasing ( self , deck : List [ int ] ) -> List [ int ] : NEW_LINE INDENT q = deque ( ) NEW_LINE for card in reversed ( sorted ( deck ) ) : NEW_LINE INDENT q . rotate ( ) NEW_LINE q . appendleft ( card ) NEW_LINE DEDENT return list ( q ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def flipEquiv ( self , root1 : Optional [ TreeNode ] , root2 : Optional [ TreeNode ] ) -> bool : NEW_LINE INDENT if not root1 : NEW_LINE INDENT return not root2 NEW_LINE DEDENT if not root2 : NEW_LINE INDENT return not root1 NEW_LINE DEDENT if root1 . val != root2 . val : NEW_LINE INDENT return False NEW_LINE DEDENT return self . flipEquiv ( root1 . left , root2 . left ) and self . flipEquiv ( root1 . right , root2 . right ) or self . flipEquiv ( root1 . left , root2 . right ) and self . flipEquiv ( root1 . right , root2 . left ) NEW_LINE DEDENT DEDENT
class UnionFind : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . id = [ i for i in range ( n + 1 ) ] NEW_LINE DEDENT def union ( self , u : int , v : int ) -> bool : NEW_LINE INDENT i = self . find ( u ) NEW_LINE j = self . find ( v ) NEW_LINE if i == j : NEW_LINE INDENT return False NEW_LINE DEDENT self . id [ i ] = j NEW_LINE return True NEW_LINE DEDENT def find ( self , u : int ) -> int : NEW_LINE INDENT if self . id [ u ] != u : NEW_LINE INDENT self . id [ u ] = self . find ( self . id [ u ] ) NEW_LINE DEDENT return self . id [ u ] NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def largestComponentSize ( self , A : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE uf = UnionFind ( max ( A ) ) NEW_LINE count = Counter ( ) NEW_LINE for a in A : NEW_LINE INDENT for num in range ( 2 , int ( sqrt ( a ) + 1 ) ) : NEW_LINE INDENT if a % num == 0 : NEW_LINE INDENT uf . union ( a , num ) NEW_LINE uf . union ( a , a // num ) NEW_LINE DEDENT DEDENT DEDENT for a in A : NEW_LINE INDENT pa = uf . find ( a ) NEW_LINE count [ pa ] += 1 NEW_LINE ans = max ( ans , count [ pa ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isAlienSorted ( self , words : List [ str ] , order : str ) -> bool : NEW_LINE INDENT dict = { c : i for i , c in enumerate ( order ) } NEW_LINE words = [ [ dict [ c ] for c in word ] for word in words ] NEW_LINE return all ( w1 <= w2 for w1 , w2 in zip ( words , words [ 1 : ] ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canReorderDoubled ( self , A : List [ int ] ) -> bool : NEW_LINE INDENT count = Counter ( A ) NEW_LINE for key in sorted ( count , key = abs ) : NEW_LINE INDENT if count [ key ] > count [ 2 * key ] : NEW_LINE INDENT return False NEW_LINE DEDENT count [ 2 * key ] -= count [ key ] NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def prisonAfterNDays ( self , cells : List [ int ] , N : int ) -> List [ int ] : NEW_LINE INDENT nextDayCells = [ 0 ] * len ( cells ) NEW_LINE day = 0 NEW_LINE while N > 0 : NEW_LINE INDENT N -= 1 NEW_LINE for i in range ( 1 , len ( cells ) - 1 ) : NEW_LINE INDENT nextDayCells [ i ] = 1 if cells [ i - 1 ] == cells [ i + 1 ] else 0 NEW_LINE DEDENT if day == 0 : NEW_LINE INDENT firstDayCells = nextDayCells . copy ( ) NEW_LINE DEDENT elif nextDayCells == firstDayCells : NEW_LINE INDENT N %= day NEW_LINE DEDENT cells = nextDayCells . copy ( ) NEW_LINE day += 1 NEW_LINE DEDENT return cells NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numTrees ( self , n : int ) -> int : NEW_LINE INDENT G = [ 1 , 1 ] + [ 0 ] * ( n - 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT G [ i ] += G [ j ] * G [ i - j - 1 ] NEW_LINE DEDENT DEDENT return G [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def repeatedNTimes ( self , A : List [ int ] ) -> int : NEW_LINE INDENT for i in range ( len ( A ) - 2 ) : NEW_LINE INDENT if A [ i ] == A [ i + 1 ] or A [ i ] == A [ i + 2 ] : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT DEDENT return A [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxWidthRamp ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE stack = [ ] NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT if stack == [ ] or num <= nums [ stack [ - 1 ] ] : NEW_LINE INDENT stack . append ( i ) NEW_LINE DEDENT DEDENT for i , num in reversed ( list ( enumerate ( nums ) ) ) : NEW_LINE INDENT while stack and num >= nums [ stack [ - 1 ] ] : NEW_LINE INDENT ans = max ( ans , i - stack . pop ( ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minAreaFreeRect ( self , points : List [ List [ int ] ] ) -> float : NEW_LINE INDENT ans = math . inf NEW_LINE centerToPoints = defaultdict ( list ) NEW_LINE for ax , ay in points : NEW_LINE INDENT for bx , by in points : NEW_LINE INDENT center = ( ( ax + bx ) / 2 , ( ay + by ) / 2 ) NEW_LINE centerToPoints [ center ] . append ( ( ax , ay , bx , by ) ) NEW_LINE DEDENT DEDENT def dist ( px : int , py : int , qx : int , qy : int ) -> float : NEW_LINE INDENT return ( px - qx ) ** 2 + ( py - qy ) ** 2 NEW_LINE DEDENT for points in centerToPoints . values ( ) : NEW_LINE INDENT for ax , ay , _ , _ in points : NEW_LINE INDENT for cx , cy , dx , dy in points : NEW_LINE INDENT if ( cx - ax ) * ( dx - ax ) + ( cy - ay ) * ( dy - ay ) == 0 : NEW_LINE INDENT squaredArea = dist ( ax , ay , cx , cy ) * dist ( ax , ay , dx , dy ) NEW_LINE if squaredArea > 0 : NEW_LINE INDENT ans = min ( ans , squaredArea ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return 0 if ans == math . inf else sqrt ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def leastOpsExpressTarget ( self , x : int , target : int ) -> int : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def dfs ( target ) : NEW_LINE INDENT if x > target : NEW_LINE INDENT return min ( 2 * target - 1 , 2 * ( x - target ) ) NEW_LINE DEDENT if x == target : NEW_LINE INDENT return 0 NEW_LINE DEDENT prod = x NEW_LINE n = 0 NEW_LINE while prod < target : NEW_LINE INDENT prod *= x NEW_LINE n += 1 NEW_LINE DEDENT if prod == target : NEW_LINE INDENT return n NEW_LINE DEDENT ans = dfs ( target - prod // x ) + n NEW_LINE if prod < 2 * target : NEW_LINE INDENT ans = min ( ans , dfs ( prod - target ) + n + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT return dfs ( target ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def spellchecker ( self , wordlist : List [ str ] , queries : List [ str ] ) -> List [ str ] : NEW_LINE INDENT def lowerKey ( word : str ) -> str : NEW_LINE INDENT return ' $ ' + ' ' . join ( [ c . lower ( ) for c in word ] ) NEW_LINE DEDENT def vowelKey ( word : str ) -> str : NEW_LINE INDENT return ' ' . join ( [ ' * ' if c . lower ( ) in ' aeiou ' else c . lower ( ) for c in word ] ) NEW_LINE DEDENT ans = [ ] NEW_LINE dict = { } NEW_LINE for word in wordlist : NEW_LINE INDENT dict . setdefault ( word , word ) NEW_LINE dict . setdefault ( lowerKey ( word ) , word ) NEW_LINE dict . setdefault ( vowelKey ( word ) , word ) NEW_LINE DEDENT for q in queries : NEW_LINE INDENT if q in dict : NEW_LINE INDENT ans . append ( dict [ q ] ) NEW_LINE DEDENT elif lowerKey ( q ) in dict : NEW_LINE INDENT ans . append ( dict [ lowerKey ( q ) ] ) NEW_LINE DEDENT elif vowelKey ( q ) in dict : NEW_LINE INDENT ans . append ( dict [ vowelKey ( q ) ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( ' ' ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def pancakeSort ( self , A : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE for target in range ( len ( A ) , 0 , - 1 ) : NEW_LINE INDENT index = A . index ( target ) NEW_LINE A [ : index + 1 ] = A [ : index + 1 ] [ : : - 1 ] NEW_LINE A [ : target ] = A [ : target ] [ : : - 1 ] NEW_LINE ans . append ( index + 1 ) NEW_LINE ans . append ( target ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isInterleave ( self , s1 : str , s2 : str , s3 : str ) -> bool : NEW_LINE INDENT m = len ( s1 ) NEW_LINE n = len ( s2 ) NEW_LINE if m + n != len ( s3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT dp = [ [ False ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = True NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] and s1 [ i - 1 ] == s3 [ i - 1 ] NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] and s2 [ j - 1 ] == s3 [ j - 1 ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] and s1 [ i - 1 ] == s3 [ i + j - 1 ] ) or ( dp [ i ] [ j - 1 ] and s2 [ j - 1 ] == s3 [ i + j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def powerfulIntegers ( self , x : int , y : int , bound : int ) -> List [ int ] : NEW_LINE INDENT xs = { x ** i for i in range ( 20 ) if x ** i < bound } NEW_LINE ys = { y ** i for i in range ( 20 ) if y ** i < bound } NEW_LINE return list ( { i + j for i in xs for j in ys if i + j <= bound } ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isRationalEqual ( self , S : str , T : str ) -> bool : NEW_LINE INDENT def valueOf ( s : str ) -> float : NEW_LINE INDENT if s . find ( ' ( ' ) == - 1 : NEW_LINE INDENT return float ( s ) NEW_LINE DEDENT integer_nonRepeating = float ( s [ : s . find ( ' ( ' ) ] ) NEW_LINE nonRepeatingLength = s . find ( ' ( ' ) - s . find ( ' . ' ) - 1 NEW_LINE repeating = float ( s [ s . find ( ' ( ' ) + 1 : s . find ( ' ) ' ) ] ) NEW_LINE repeatingLength = s . find ( ' ) ' ) - s . find ( ' ( ' ) - 1 NEW_LINE return integer_nonRepeating + repeating * 0.1 ** nonRepeatingLength * ratios [ repeatingLength ] NEW_LINE DEDENT ratios = [ 1 , 1 / 9 , 1 / 99 , 1 / 999 , 1 / 9999 ] NEW_LINE return abs ( valueOf ( S ) - valueOf ( T ) ) < 1e-9 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def kClosest ( self , points : List [ List [ int ] ] , K : int ) -> List [ List [ int ] ] : NEW_LINE INDENT maxHeap = [ ] NEW_LINE for x , y in points : NEW_LINE INDENT heapq . heappush ( maxHeap , ( - x * x - y * y , [ x , y ] ) ) NEW_LINE if len ( maxHeap ) > K : NEW_LINE INDENT heapq . heappop ( maxHeap ) NEW_LINE DEDENT DEDENT return [ pair [ 1 ] for pair in maxHeap ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def subarraysDivByK ( self , A : List [ int ] , K : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prefix = 0 NEW_LINE count = [ 1 ] + [ 0 ] * ( K - 1 ) NEW_LINE for a in A : NEW_LINE INDENT prefix = ( prefix + a ) % K NEW_LINE ans += count [ prefix ] NEW_LINE count [ prefix ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestPerimeter ( self , A : List [ int ] ) -> int : NEW_LINE INDENT A = sorted ( A ) NEW_LINE for i in range ( len ( A ) - 1 , 1 , - 1 ) : NEW_LINE INDENT if A [ i - 2 ] + A [ i - 1 ] > A [ i ] : NEW_LINE INDENT return A [ i - 2 ] + A [ i - 1 ] + A [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sortedSquares ( self , A : List [ int ] ) -> List [ int ] : NEW_LINE INDENT n = len ( A ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE ans = [ 0 ] * n NEW_LINE while n : NEW_LINE INDENT n -= 1 NEW_LINE if abs ( A [ l ] ) > abs ( A [ r ] ) : NEW_LINE INDENT ans [ n ] = A [ l ] * A [ l ] NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ n ] = A [ r ] * A [ r ] NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxTurbulenceSize ( self , A : List [ int ] ) -> int : NEW_LINE INDENT ans = 1 NEW_LINE increasing = 1 NEW_LINE decreasing = 1 NEW_LINE for i in range ( 1 , len ( A ) ) : NEW_LINE INDENT if A [ i ] > A [ i - 1 ] : NEW_LINE INDENT increasing = decreasing + 1 NEW_LINE decreasing = 1 NEW_LINE DEDENT elif A [ i ] < A [ i - 1 ] : NEW_LINE INDENT decreasing = increasing + 1 NEW_LINE increasing = 1 NEW_LINE DEDENT else : NEW_LINE INDENT increasing = 1 NEW_LINE decreasing = 1 NEW_LINE DEDENT ans = max ( ans , max ( increasing , decreasing ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isValidBST ( self , root : Optional [ TreeNode ] ) -> bool : NEW_LINE INDENT def isValidBST ( root : Optional [ TreeNode ] , minNode : Optional [ TreeNode ] , maxNode : Optional [ TreeNode ] ) -> bool : NEW_LINE INDENT if not root : NEW_LINE INDENT return True NEW_LINE DEDENT if minNode and root . val <= minNode . val : NEW_LINE INDENT return False NEW_LINE DEDENT if maxNode and root . val >= maxNode . val : NEW_LINE INDENT return False NEW_LINE DEDENT return isValidBST ( root . left , minNode , root ) and isValidBST ( root . right , root , maxNode ) NEW_LINE DEDENT return isValidBST ( root , None , None ) NEW_LINE DEDENT DEDENT
class TimeMap : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . values = defaultdict ( list ) NEW_LINE self . timestamps = defaultdict ( list ) NEW_LINE DEDENT def set ( self , key : str , value : str , timestamp : int ) -> None : NEW_LINE INDENT self . values [ key ] . append ( value ) NEW_LINE self . timestamps [ key ] . append ( timestamp ) NEW_LINE DEDENT def get ( self , key : str , timestamp : int ) -> str : NEW_LINE INDENT if key not in self . timestamps : NEW_LINE INDENT return ' ' NEW_LINE DEDENT i = bisect . bisect ( self . timestamps [ key ] , timestamp ) NEW_LINE return self . values [ key ] [ i - 1 ] if i > 0 else ' ' NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mincostTickets ( self , days : List [ int ] , costs : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE last7 = deque ( ) NEW_LINE last30 = deque ( ) NEW_LINE for day in days : NEW_LINE INDENT while last7 and last7 [ 0 ] [ 0 ] + 7 <= day : NEW_LINE INDENT last7 . popleft ( ) NEW_LINE DEDENT while last30 and last30 [ 0 ] [ 0 ] + 30 <= day : NEW_LINE INDENT last30 . popleft ( ) NEW_LINE DEDENT last7 . append ( [ day , ans + costs [ 1 ] ] ) NEW_LINE last30 . append ( [ day , ans + costs [ 2 ] ] ) NEW_LINE ans = min ( ans + costs [ 0 ] , last7 [ 0 ] [ 1 ] , last30 [ 0 ] [ 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sumEvenAfterQueries ( self , A : List [ int ] , queries : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE summ = sum ( a for a in A if a % 2 == 0 ) NEW_LINE for q in queries : NEW_LINE INDENT if A [ q [ 1 ] ] % 2 == 0 : NEW_LINE INDENT summ -= A [ q [ 1 ] ] NEW_LINE DEDENT A [ q [ 1 ] ] += q [ 0 ] NEW_LINE if A [ q [ 1 ] ] % 2 == 0 : NEW_LINE INDENT summ += A [ q [ 1 ] ] NEW_LINE DEDENT ans . append ( summ ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def intervalIntersection ( self , firstList : List [ List [ int ] ] , secondList : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( firstList ) and j < len ( secondList ) : NEW_LINE INDENT lo = max ( firstList [ i ] [ 0 ] , secondList [ j ] [ 0 ] ) NEW_LINE hi = min ( firstList [ i ] [ 1 ] , secondList [ j ] [ 1 ] ) NEW_LINE if lo <= hi : NEW_LINE INDENT ans . append ( [ lo , hi ] ) NEW_LINE DEDENT if firstList [ i ] [ 1 ] < secondList [ j ] [ 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def verticalTraversal ( self , root : Optional [ TreeNode ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE xToNodes = defaultdict ( list ) NEW_LINE def dfs ( node : Optional [ TreeNode ] , x : int , y : int ) -> None : NEW_LINE INDENT if not node : NEW_LINE INDENT return NEW_LINE DEDENT xToNodes [ x ] . append ( ( - y , node . val ) ) NEW_LINE dfs ( node . left , x - 1 , y - 1 ) NEW_LINE dfs ( node . right , x + 1 , y - 1 ) NEW_LINE DEDENT dfs ( root , 0 , 0 ) NEW_LINE for _ , nodes in sorted ( xToNodes . items ( ) , key = lambda item : item [ 0 ] ) : NEW_LINE INDENT ans . append ( [ val for _ , val in sorted ( nodes ) ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def addToArrayForm ( self , num : List [ int ] , k : int ) -> List [ int ] : NEW_LINE INDENT for i in reversed ( range ( len ( num ) ) ) : NEW_LINE INDENT k , num [ i ] = divmod ( num [ i ] + k , 10 ) NEW_LINE DEDENT while k > 0 : NEW_LINE INDENT num = [ k % 10 ] + num NEW_LINE k //= 10 NEW_LINE DEDENT return num NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def recoverTree ( self , root : Optional [ TreeNode ] ) -> None : NEW_LINE INDENT def swap ( x : Optional [ TreeNode ] , y : Optional [ TreeNode ] ) -> None : NEW_LINE INDENT temp = x . val NEW_LINE x . val = y . val NEW_LINE y . val = temp NEW_LINE DEDENT def inorder ( root : Optional [ TreeNode ] ) -> None : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( root . left ) NEW_LINE if self . pred and root . val < self . pred . val : NEW_LINE INDENT self . y = root NEW_LINE if not self . x : NEW_LINE INDENT self . x = self . pred NEW_LINE DEDENT else : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT self . pred = root NEW_LINE inorder ( root . right ) NEW_LINE DEDENT inorder ( root ) NEW_LINE swap ( self . x , self . y ) NEW_LINE DEDENT pred = None NEW_LINE x = None NEW_LINE y = None NEW_LINE DEDENT
class UnionFind : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . id = list ( range ( n ) ) NEW_LINE DEDENT def union ( self , u : int , v : int ) -> None : NEW_LINE INDENT self . id [ self . find ( u ) ] = self . find ( v ) NEW_LINE DEDENT def find ( self , u : int ) -> int : NEW_LINE INDENT if self . id [ u ] != u : NEW_LINE INDENT self . id [ u ] = self . find ( self . id [ u ] ) NEW_LINE DEDENT return self . id [ u ] NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def equationsPossible ( self , equations : List [ str ] ) -> bool : NEW_LINE INDENT uf = UnionFind ( 26 ) NEW_LINE for x , op , _ , y in equations : NEW_LINE INDENT if op == ' = ' : NEW_LINE INDENT uf . union ( ord ( x ) - ord ( ' a ' ) , ord ( y ) - ord ( ' a ' ) ) NEW_LINE DEDENT DEDENT return all ( uf . find ( ord ( x ) - ord ( ' a ' ) ) != uf . find ( ord ( y ) - ord ( ' a ' ) ) for x , op , _ , y in equations if op == ' ! ' ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def brokenCalc ( self , X : int , Y : int ) -> int : NEW_LINE INDENT ops = 0 NEW_LINE while X < Y : NEW_LINE INDENT if Y % 2 == 0 : NEW_LINE INDENT Y //= 2 NEW_LINE DEDENT else : NEW_LINE INDENT Y += 1 NEW_LINE DEDENT ops += 1 NEW_LINE DEDENT return ops + X - Y NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def subarraysWithKDistinct ( self , A : List [ int ] , K : int ) -> int : NEW_LINE INDENT def subarraysWithAtMostKDistinct ( K : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = Counter ( ) NEW_LINE l = 0 NEW_LINE for r , a in enumerate ( A ) : NEW_LINE INDENT count [ a ] += 1 NEW_LINE if count [ a ] == 1 : NEW_LINE INDENT K -= 1 NEW_LINE DEDENT while K < 0 : NEW_LINE INDENT count [ A [ l ] ] -= 1 NEW_LINE if count [ A [ l ] ] == 0 : NEW_LINE INDENT K += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT ans += r - l + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT return subarraysWithAtMostKDistinct ( K ) - subarraysWithAtMostKDistinct ( K - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minKBitFlips ( self , A : List [ int ] , K : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE flippedTime = 0 NEW_LINE for r , a in enumerate ( A ) : NEW_LINE INDENT if r >= K and A [ r - K ] == 2 : NEW_LINE INDENT flippedTime -= 1 NEW_LINE DEDENT if flippedTime % 2 == a : NEW_LINE INDENT if r + K > len ( A ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans += 1 NEW_LINE flippedTime += 1 NEW_LINE A [ r ] = 2 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numSquarefulPerms ( self , A : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE used = [ False ] * len ( A ) NEW_LINE def isSquare ( num : int ) -> bool : NEW_LINE INDENT root = int ( sqrt ( num ) ) NEW_LINE return root * root == num NEW_LINE DEDENT def dfs ( path : List [ int ] ) -> None : NEW_LINE INDENT nonlocal ans NEW_LINE if len ( path ) > 1 and not isSquare ( path [ - 1 ] + path [ - 2 ] ) : NEW_LINE INDENT return NEW_LINE DEDENT if len ( path ) == len ( A ) : NEW_LINE INDENT ans += 1 NEW_LINE return NEW_LINE DEDENT for i , a in enumerate ( A ) : NEW_LINE INDENT if used [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT if i > 0 and A [ i ] == A [ i - 1 ] and not used [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT used [ i ] = True NEW_LINE dfs ( path + [ a ] ) NEW_LINE used [ i ] = False NEW_LINE DEDENT DEDENT A . sort ( ) NEW_LINE dfs ( [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findJudge ( self , n : int , trust : List [ List [ int ] ] ) -> int : NEW_LINE INDENT count = [ 0 ] * ( n + 1 ) NEW_LINE for a , b in trust : NEW_LINE INDENT count [ a ] -= 1 NEW_LINE count [ b ] += 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if count [ i ] == n - 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def insertIntoMaxTree ( self , root : Optional [ TreeNode ] , val : int ) -> Optional [ TreeNode ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return TreeNode ( val ) NEW_LINE DEDENT if root . val < val : NEW_LINE INDENT return TreeNode ( val , root , None ) NEW_LINE DEDENT root . right = self . insertIntoMaxTree ( root . right , val ) NEW_LINE return root NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numRookCaptures ( self , board : List [ List [ str ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT for j in range ( 8 ) : NEW_LINE INDENT if board [ i ] [ j ] == ' R ' : NEW_LINE INDENT i0 = i NEW_LINE j0 = j NEW_LINE DEDENT DEDENT DEDENT for d in [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] : NEW_LINE INDENT i = i0 + d [ 0 ] NEW_LINE j = j0 + d [ 1 ] NEW_LINE while 0 <= i < 8 and 0 <= j < 8 : NEW_LINE INDENT if board [ i ] [ j ] == ' p ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if board [ i ] [ j ] != ' . ' : NEW_LINE INDENT break NEW_LINE DEDENT i += d [ 0 ] NEW_LINE j += d [ 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
