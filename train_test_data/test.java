class Solution { public List < List < Integer > > combine ( int n , int k ) { List < List < Integer > > ans = new ArrayList < > ( ) ; dfs ( n , k , 1 , new ArrayList < > ( ) , ans ) ; return ans ; } private void dfs ( int n , int k , int s , List < Integer > path , List < List < Integer > > ans ) { if ( path . size ( ) == k ) { ans . add ( new ArrayList < > ( path ) ) ; return ; } for ( int i = s ; i <= n ; ++ i ) { path . add ( i ) ; dfs ( n , k , i + 1 , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; } } }
class Poly { public Poly add ( Poly o ) { for ( final String term : o . terms . keySet ( ) ) terms . merge ( term , o . terms . get ( term ) , Integer :: sum ) ; return this ; } public Poly minus ( Poly o ) { for ( final String term : o . terms . keySet ( ) ) terms . merge ( term , - o . terms . get ( term ) , Integer :: sum ) ; return this ; } public Poly mult ( Poly o ) { Poly res = new Poly ( ) ; for ( final String a : terms . keySet ( ) ) for ( final String b : o . terms . keySet ( ) ) res . terms . merge ( merge ( a , b ) , terms . get ( a ) * o . terms . get ( b ) , Integer :: sum ) ; return res ; } public List < String > toList ( ) { List < String > res = new ArrayList < > ( ) ; List < String > keys = new ArrayList < > ( terms . keySet ( ) ) ; Collections . sort ( keys , new Comparator < String > ( ) { @ Override public int compare ( final String a , final String b ) { if ( a . equals ( "1" ) ) return 1 ; if ( b . equals ( "1" ) ) return - 1 ; String [ ] as = a . split ( " \\ * " ) ; String [ ] bs = b . split ( " \\ * " ) ; return as . length == bs . length ? a . compareTo ( b ) : bs . length - as . length ; } } ) ; for ( final String key : keys ) if ( terms . get ( key ) != 0 ) res . add ( concat ( key ) ) ; return res ; } public Poly ( ) { } public Poly ( final String term , int coef ) { terms . put ( term , coef ) ; } private Map < String , Integer > terms = new HashMap < > ( ) ; private static String merge ( final String a , final String b ) { if ( a . equals ( "1" ) ) return b ; if ( b . equals ( "1" ) ) return a ; StringBuilder sb = new StringBuilder ( ) ; String [ ] A = a . split ( " \\ * " ) ; String [ ] B = b . split ( " \\ * " ) ; int i = 0 ; int j = 0 ; while ( i < A . length && j < B . length ) if ( A [ i ] . compareTo ( B [ j ] ) < 0 ) sb . append ( " * " ) . append ( A [ i ++ ] ) ; else sb . append ( " * " ) . append ( B [ j ++ ] ) ; while ( i < A . length ) sb . append ( " * " ) . append ( A [ i ++ ] ) ; while ( j < B . length ) sb . append ( " * " ) . append ( B [ j ++ ] ) ; return sb . substring ( 1 ) . toString ( ) ; } private String concat ( final String term ) { if ( term . equals ( "1" ) ) return String . valueOf ( terms . get ( term ) ) ; return new StringBuilder ( ) . append ( terms . get ( term ) ) . append ( ' * ' ) . append ( term ) . toString ( ) ; } } class Solution { public List < String > basicCalculatorIV ( String expression , String [ ] evalvars , int [ ] evalints ) { List < String > tokens = getTokens ( expression ) ; Map < String , Integer > evalMap = new HashMap < > ( ) ; for ( int i = 0 ; i < evalvars . length ; ++ i ) evalMap . put ( evalvars [ i ] , evalints [ i ] ) ; for ( int i = 0 ; i < tokens . size ( ) ; ++ i ) if ( evalMap . containsKey ( tokens . get ( i ) ) ) tokens . set ( i , String . valueOf ( evalMap . get ( tokens . get ( i ) ) ) ) ; List < String > postfix = infixToPostfix ( tokens ) ; return evaluate ( postfix ) . toList ( ) ; } private List < String > getTokens ( final String s ) { List < String > tokens = new ArrayList < > ( ) ; int i = 0 ; for ( int j = 0 ; j < s . length ( ) ; ++ j ) if ( s . charAt ( j ) == ' ▁ ' ) { if ( i < j ) tokens . add ( s . substring ( i , j ) ) ; i = j + 1 ; } else if ( " ( ) + - * " . contains ( s . substring ( j , j + 1 ) ) ) { if ( i < j ) tokens . add ( s . substring ( i , j ) ) ; tokens . add ( s . substring ( j , j + 1 ) ) ; i = j + 1 ; } if ( i < s . length ( ) ) tokens . add ( s . substring ( i ) ) ; return tokens ; } private boolean isOperator ( final String token ) { return token . equals ( " + " ) || token . equals ( " - " ) || token . equals ( " * " ) ; } private boolean precedes ( final String prevOp , final String currOp ) { if ( prevOp . equals ( " ( " ) ) return false ; return prevOp . equals ( " * " ) || currOp . equals ( " + " ) || currOp . equals ( " - " ) ; } private List < String > infixToPostfix ( List < String > tokens ) { List < String > postfix = new ArrayList < > ( ) ; Deque < String > ops = new ArrayDeque < > ( ) ; for ( final String token : tokens ) if ( token . equals ( " ( " ) ) { ops . push ( token ) ; } else if ( token . equals ( " ) " ) ) { while ( ! ops . peek ( ) . equals ( " ( " ) ) postfix . add ( ops . pop ( ) ) ; ops . pop ( ) ; } else if ( isOperator ( token ) ) { while ( ! ops . isEmpty ( ) && precedes ( ops . peek ( ) , token ) ) postfix . add ( ops . pop ( ) ) ; ops . push ( token ) ; } else { postfix . add ( token ) ; } while ( ! ops . isEmpty ( ) ) postfix . add ( ops . pop ( ) ) ; return postfix ; } private Poly evaluate ( List < String > postfix ) { LinkedList < Poly > polys = new LinkedList < > ( ) ; for ( final String token : postfix ) if ( isOperator ( token ) ) { final Poly b = polys . removeLast ( ) ; final Poly a = polys . removeLast ( ) ; if ( token . equals ( " + " ) ) polys . add ( a . add ( b ) ) ; else if ( token . equals ( " - " ) ) polys . add ( a . minus ( b ) ) ; else polys . add ( a . mult ( b ) ) ; } else if ( token . charAt ( 0 ) == ' - ' || token . chars ( ) . allMatch ( c -> Character . isDigit ( c ) ) ) { polys . add ( new Poly ( "1" , Integer . parseInt ( token ) ) ) ; } else { polys . add ( new Poly ( token , 1 ) ) ; } return polys . getFirst ( ) ; } }
class Solution { public int numJewelsInStones ( String J , String S ) { int ans = 0 ; Set < Character > jewels = new HashSet < > ( ) ; for ( char j : J . toCharArray ( ) ) jewels . add ( j ) ; for ( final char s : S . toCharArray ( ) ) if ( jewels . contains ( s ) ) ++ ans ; return ans ; } }
class Solution { public int calculate ( String s ) { Deque < Integer > nums = new ArrayDeque < > ( ) ; Deque < Character > ops = new ArrayDeque < > ( ) ; boolean hasPrevNum = false ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { final char c = s . charAt ( i ) ; if ( Character . isDigit ( c ) ) { int num = c - '0' ; while ( i + 1 < s . length ( ) && Character . isDigit ( s . charAt ( i + 1 ) ) ) num = num * 10 + ( s . charAt ( i ++ + 1 ) - '0' ) ; nums . push ( num ) ; hasPrevNum = true ; } else if ( c == ' ( ' ) { ops . push ( ' ( ' ) ; hasPrevNum = false ; } else if ( c == ' ) ' ) { while ( ops . peek ( ) != ' ( ' ) calc ( nums , ops ) ; ops . pop ( ) ; } else if ( c == ' + ' || c == ' - ' || c == ' * ' || c == ' / ' ) { if ( ! hasPrevNum ) nums . push ( 0 ) ; while ( ! ops . isEmpty ( ) && precedes ( ops . peek ( ) , c ) ) calc ( nums , ops ) ; ops . push ( c ) ; } } while ( ! ops . isEmpty ( ) ) calc ( nums , ops ) ; return nums . peek ( ) ; } private void calc ( Deque < Integer > nums , Deque < Character > ops ) { final int b = nums . pop ( ) ; final int a = nums . pop ( ) ; final char op = ops . pop ( ) ; if ( op == ' + ' ) nums . push ( a + b ) ; else if ( op == ' - ' ) nums . push ( a - b ) ; else if ( op == ' * ' ) nums . push ( a * b ) ; else nums . push ( a / b ) ; } private boolean precedes ( char prevOp , char currOp ) { if ( prevOp == ' ( ' ) return false ; return prevOp == ' * ' || prevOp == ' / ' || currOp == ' + ' || currOp == ' - ' ; } }
class Solution { public double minmaxGasDist ( int [ ] stations , int k ) { final double kErr = 1e-6 ; double l = 0 ; double r = stations [ stations . length - 1 ] - stations [ 0 ] ; while ( r - l > kErr ) { final double m = ( l + r ) / 2 ; if ( check ( stations , k , m ) ) r = m ; else l = m ; } return l ; } private boolean check ( int [ ] stations , int k , double m ) { for ( int i = 1 ; i < stations . length ; ++ i ) { final int diff = stations [ i ] - stations [ i - 1 ] ; if ( diff > m ) { k -= Math . ceil ( diff / m ) - 1 ; if ( k < 0 ) return false ; } } return true ; } ; }
class Solution { public boolean isIdealPermutation ( int [ ] A ) { int max = - 1 ; for ( int i = 0 ; i + 2 < A . length ; ++ i ) { max = Math . max ( max , A [ i ] ) ; if ( max > A [ i + 2 ] ) return false ; } return true ; } }
class Solution { public TreeNode [ ] splitBST ( TreeNode root , int target ) { if ( root == null ) return new TreeNode [ ] { null , null } ; if ( root . val > target ) { TreeNode [ ] res = splitBST ( root . left , target ) ; root . left = res [ 1 ] ; return new TreeNode [ ] { res [ 0 ] , root } ; } else { root . val <= target TreeNode [ ] res = splitBST ( root . right , target ) ; root . right = res [ 0 ] ; return new TreeNode [ ] { root , res [ 1 ] } ; } } }
class Solution { public List < List < Integer > > subsets ( int [ ] nums ) { List < List < Integer > > ans = new ArrayList < > ( ) ; dfs ( nums , 0 , new ArrayList < > ( ) , ans ) ; return ans ; } private void dfs ( int [ ] nums , int s , List < Integer > path , List < List < Integer > > ans ) { ans . add ( new ArrayList < > ( path ) ) ; for ( int i = s ; i < nums . length ; ++ i ) { path . add ( nums [ i ] ) ; dfs ( nums , i + 1 , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; } } }
class Solution { public boolean reachingPoints ( int sx , int sy , int tx , int ty ) { while ( sx < tx && sy < ty ) if ( tx > ty ) tx %= ty ; else ty %= tx ; return sx == tx && sy <= ty && ( ty - sy ) % tx == 0 || sy == ty && sx <= tx && ( tx - sx ) % ty == 0 ; } }
class Solution { public int numRabbits ( int [ ] answers ) { int ans = 0 ; int [ ] count = new int [ 1000 ] ; for ( final int answer : answers ) { if ( count [ answer ] % ( answer + 1 ) == 0 ) ans += answer + 1 ; ++ count [ answer ] ; } return ans ; } }
class Solution { public int movesToChessboard ( int [ ] [ ] board ) { final int n = board . length ; int rowSum = 0 ; int colSum = 0 ; int rowSwaps = 0 ; int colSwaps = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( ( board [ 0 ] [ 0 ] ^ board [ i ] [ 0 ] ^ board [ 0 ] [ j ] ^ board [ i ] [ j ] ) == 1 ) return - 1 ; for ( int i = 0 ; i < n ; ++ i ) { rowSum += board [ 0 ] [ i ] ; colSum += board [ i ] [ 0 ] ; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return - 1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return - 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( board [ i ] [ 0 ] == ( i & 1 ) ) ++ rowSwaps ; if ( board [ 0 ] [ i ] == ( i & 1 ) ) ++ colSwaps ; } if ( n % 2 == 1 ) { if ( rowSwaps % 2 == 1 ) rowSwaps = n - rowSwaps ; if ( colSwaps % 2 == 1 ) colSwaps = n - colSwaps ; } else { rowSwaps = Math . min ( rowSwaps , n - rowSwaps ) ; colSwaps = Math . min ( colSwaps , n - colSwaps ) ; } return ( rowSwaps + colSwaps ) / 2 ; } }
enum Color { WHITE , RED , GREEN } class Solution { public boolean isBipartite ( int [ ] [ ] graph ) { Color [ ] colors = new Color [ graph . length ] ; Arrays . fill ( colors , Color . WHITE ) ; for ( int i = 0 ; i < graph . length ; ++ i ) { if ( colors [ i ] != Color . WHITE ) continue ; colors [ i ] = Color . RED ; Queue < Integer > q = new ArrayDeque < > ( Arrays . asList ( i ) ) ; while ( ! q . isEmpty ( ) ) { for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int u = q . poll ( ) ; for ( final int v : graph [ u ] ) { if ( colors [ v ] == colors [ u ] ) return false ; if ( colors [ v ] == Color . WHITE ) { colors [ v ] = colors [ u ] == Color . RED ? Color . GREEN : Color . RED ; q . offer ( v ) ; } } } } } return true ; } }
class Solution { public int [ ] kthSmallestPrimeFraction ( int [ ] A , int K ) { final int n = A . length ; double l = 0.0 ; double r = 1.0 ; while ( l < r ) { final double m = ( l + r ) / 2.0 ; int fractionsNoGreaterThanM = 0 ; int p = 0 ; int q = 1 ; for ( int i = 0 , j = 1 ; i < n ; ++ i ) { while ( j < n && A [ i ] > m * A [ j ] ) ++ j ; if ( j == n ) break ; fractionsNoGreaterThanM += n - j ; if ( p * A [ j ] < q * A [ i ] ) { p = A [ i ] ; q = A [ j ] ; } } if ( fractionsNoGreaterThanM == K ) return new int [ ] { p , q } ; if ( fractionsNoGreaterThanM > K ) r = m ; else l = m ; } throw new IllegalArgumentException ( ) ; } }
class Solution { public int findCheapestPrice ( int n , int [ ] [ ] flights , int src , int dst , int k ) { List < Pair < Integer , Integer > > [ ] graph = new List [ n ] ; Queue < int [ ] > minHeap = new PriorityQueue < > ( ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; int [ ] [ ] dist = new int [ n ] [ k + 2 ] ; Arrays . stream ( dist ) . forEach ( A -> Arrays . fill ( A , Integer . MAX_VALUE ) ) ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] f : flights ) { final int u = f [ 0 ] ; final int v = f [ 1 ] ; final int w = f [ 2 ] ; graph [ u ] . add ( new Pair < > ( v , w ) ) ; } minHeap . offer ( new int [ ] { 0 , src , k + 1 } ) ; dist [ src ] [ k + 1 ] = 0 ; while ( ! minHeap . isEmpty ( ) ) { final int d = minHeap . peek ( ) [ 0 ] ; final int u = minHeap . peek ( ) [ 1 ] ; final int stops = minHeap . poll ( ) [ 2 ] ; if ( u == dst ) return d ; if ( stops > 0 ) for ( Pair < Integer , Integer > node : graph [ u ] ) { final int v = node . getKey ( ) ; final int w = node . getValue ( ) ; final int newDist = d + w ; if ( newDist < dist [ v ] [ stops - 1 ] ) { dist [ v ] [ stops - 1 ] = newDist ; minHeap . offer ( new int [ ] { d + w , v , stops - 1 } ) ; } } } return - 1 ; } }
class Solution { public int rotatedDigits ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; ++ i ) if ( isGoodNumber ( i ) ) ++ ans ; return ans ; } private boolean isGoodNumber ( int i ) { boolean isRotated = false ; for ( final char c : String . valueOf ( i ) . toCharArray ( ) ) { if ( c == '0' || c == '1' || c == '8' ) continue ; if ( c == '2' || c == '5' || c == '6' || c == '9' ) isRotated = true ; else return false ; } return isRotated ; } }
class Solution { public boolean escapeGhosts ( int [ ] [ ] ghosts , int [ ] target ) { final int d = Math . abs ( target [ 0 ] ) + Math . abs ( target [ 1 ] ) ; for ( int [ ] ghost : ghosts ) if ( d >= Math . abs ( ghost [ 0 ] - target [ 0 ] ) + Math . abs ( ghost [ 1 ] - target [ 1 ] ) ) return false ; return true ; } }
class Solution { public boolean exist ( char [ ] [ ] board , String word ) { for ( int i = 0 ; i < board . length ; ++ i ) for ( int j = 0 ; j < board [ 0 ] . length ; ++ j ) if ( dfs ( board , word , i , j , 0 ) ) return true ; return false ; } private boolean dfs ( char [ ] [ ] board , String word , int i , int j , int s ) { if ( i < 0 || i == board . length || j < 0 || j == board [ 0 ] . length ) return false ; if ( board [ i ] [ j ] != word . charAt ( s ) || board [ i ] [ j ] == ' * ' ) return false ; if ( s == word . length ( ) - 1 ) return true ; final char cache = board [ i ] [ j ] ; board [ i ] [ j ] = ' * ' ; final boolean isExist = dfs ( board , word , i + 1 , j , s + 1 ) || dfs ( board , word , i - 1 , j , s + 1 ) || dfs ( board , word , i , j + 1 , s + 1 ) || dfs ( board , word , i , j - 1 , s + 1 ) ; board [ i ] [ j ] = cache ; return isExist ; } }
class Solution { public int numTilings ( int N ) { final int kMod = 1_000_000_007 ; long [ ] dp = new long [ 1001 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 5 ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 3 ] ) % kMod ; return ( int ) dp [ N ] ; } }
class Solution { public String customSortString ( final String S , final String T ) { StringBuilder sb = new StringBuilder ( ) ; int [ ] count = new int [ 128 ] ; for ( final char c : T . toCharArray ( ) ) ++ count [ c ] ; for ( final char c : S . toCharArray ( ) ) while ( count [ c ] -- > 0 ) sb . append ( c ) ; for ( char c = ' a ' ; c <= ' z ' ; ++ c ) while ( count [ c ] -- > 0 ) sb . append ( c ) ; return sb . toString ( ) ; } }
class TrieNode { public TrieNode [ ] children = new TrieNode [ 26 ] ; public int count = 0 ; } class Solution { public int numMatchingSubseq ( String S , String [ ] words ) { for ( final String word : words ) insert ( word ) ; return dfs ( S , 0 , root ) ; } private TrieNode root = new TrieNode ( ) ; private void insert ( final String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ( ) ) { final int i = c - ' a ' ; if ( node . children [ i ] == null ) node . children [ i ] = new TrieNode ( ) ; node = node . children [ i ] ; } ++ node . count ; } private int dfs ( final String s , int i , TrieNode node ) { int ans = node . count ; if ( i >= s . length ( ) ) return ans ; for ( int j = 0 ; j < 26 ; ++ j ) if ( node . children [ j ] != null ) { final int index = s . indexOf ( ' a ' + j , i ) ; if ( index != - 1 ) ans += dfs ( s , index + 1 , node . children [ j ] ) ; } return ans ; } }
class Solution { public boolean validTicTacToe ( String [ ] board ) { final int countX = sum ( board , ' X ' ) ; final int countO = sum ( board , ' O ' ) ; if ( countX < countO || countX - countO > 1 ) return false ; if ( isWinned ( board , ' X ' ) && countX == countO || isWinned ( board , ' O ' ) && countX != countO ) return false ; return true ; } private int sum ( final String [ ] board , char c ) { int ans = 0 ; for ( final String row : board ) ans += row . chars ( ) . filter ( i -> i == c ) . count ( ) ; return ans ; } private boolean isWinned ( final String [ ] board , char c ) { String [ ] rotated = rotate ( board ) ; return Arrays . stream ( board ) . anyMatch ( row -> row . chars ( ) . filter ( i -> i == c ) . count ( ) == 3 ) || Arrays . stream ( rotated ) . anyMatch ( row -> row . chars ( ) . filter ( i -> i == c ) . count ( ) == 3 ) || board [ 0 ] . charAt ( 0 ) == c && board [ 1 ] . charAt ( 1 ) == c && board [ 2 ] . charAt ( 2 ) == c || board [ 0 ] . charAt ( 2 ) == c && board [ 1 ] . charAt ( 1 ) == c && board [ 2 ] . charAt ( 0 ) == c ; } private String [ ] rotate ( final String [ ] board ) { String [ ] rotated = new String [ 3 ] ; for ( final String row : board ) for ( int i = 0 ; i < 3 ; ++ i ) rotated [ i ] += row . charAt ( i ) ; return rotated ; } }
class Solution { public int numSubarrayBoundedMax ( int [ ] A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . length ; ++ i ) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } }
class Solution { public List < List < Integer > > allPathsSourceTarget ( int [ ] [ ] graph ) { List < List < Integer > > ans = new ArrayList < > ( ) ; dfs ( graph , 0 , new ArrayList < > ( Arrays . asList ( 0 ) ) , ans ) ; return ans ; } private void dfs ( int [ ] [ ] graph , int u , List < Integer > path , List < List < Integer > > ans ) { if ( u == graph . length - 1 ) { ans . add ( new ArrayList < > ( path ) ) ; return ; } for ( final int v : graph [ u ] ) { path . add ( v ) ; dfs ( graph , v , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; } } }
class Solution { public int myAtoi ( String s ) { s = s . strip ( ) ; if ( s . isEmpty ( ) ) return 0 ; final int sign = s . charAt ( 0 ) == ' - ' ? - 1 : 1 ; if ( s . charAt ( 0 ) == ' + ' || s . charAt ( 0 ) == ' - ' ) s = s . substring ( 1 ) ; long num = 0 ; for ( final char c : s . toCharArray ( ) ) { if ( ! Character . isDigit ( c ) ) break ; num = num * 10 + ( c - '0' ) ; if ( sign * num <= Integer . MIN_VALUE ) return Integer . MIN_VALUE ; if ( sign * num >= Integer . MAX_VALUE ) return Integer . MAX_VALUE ; } return sign * ( int ) num ; } }
class Solution { public int removeDuplicates ( int [ ] nums ) { int i = 0 ; for ( final int num : nums ) if ( i < 2 || num > nums [ i - 2 ] ) nums [ i ++ ] = num ; return i ; } }
class Solution { public int minSwap ( int [ ] A , int [ ] B ) { final int n = A . length ; int [ ] keepAt = new int [ n ] ; int [ ] swapAt = new int [ n ] ; Arrays . fill ( keepAt , Integer . MAX_VALUE ) ; Arrays . fill ( swapAt , Integer . MAX_VALUE ) ; keepAt [ 0 ] = 0 ; swapAt [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) { if ( A [ i ] > A [ i - 1 ] && B [ i ] > B [ i - 1 ] ) { keepAt [ i ] = keepAt [ i - 1 ] ; swapAt [ i ] = swapAt [ i - 1 ] + 1 ; } if ( A [ i ] > B [ i - 1 ] && B [ i ] > A [ i - 1 ] ) { keepAt [ i ] = Math . min ( keepAt [ i ] , swapAt [ i - 1 ] ) ; swapAt [ i ] = Math . min ( swapAt [ i ] , keepAt [ i - 1 ] + 1 ) ; } } return Math . min ( keepAt [ n - 1 ] , swapAt [ n - 1 ] ) ; } }
enum State { INIT , VISITING , VISITED } class Solution { public List < Integer > eventualSafeNodes ( int [ ] [ ] graph ) { List < Integer > ans = new ArrayList < > ( ) ; State [ ] state = new State [ graph . length ] ; for ( int i = 0 ; i < graph . length ; ++ i ) if ( ! hasCycle ( graph , i , state ) ) ans . add ( i ) ; return ans ; } private boolean hasCycle ( int [ ] [ ] graph , int u , State [ ] state ) { if ( state [ u ] == State . VISITING ) return true ; if ( state [ u ] == State . VISITED ) return false ; state [ u ] = State . VISITING ; for ( final int v : graph [ u ] ) if ( hasCycle ( graph , v , state ) ) return true ; state [ u ] = State . VISITED ; return false ; } }
class Solution { public int uniqueMorseRepresentations ( String [ ] words ) { final String [ ] morse = { " . - " , " - . . . " , " - . - . " , " - . . " , " . " , " . . - . " , " - - . " , " . . . . " , " . . " , " . - - - " , " - . - " , " . - . . " , " - - " , " - . " , " - - - " , " . - - . " , " - - . - " , " . - . " , " . . . " , " - " , " . . - " , " . . . - " , " . - - " , " - . . - " , " - . - - " , " - - . . " } ; Set < String > transformations = new HashSet < > ( ) ; for ( final String word : words ) { StringBuilder transformation = new StringBuilder ( ) ; for ( final char c : word . toCharArray ( ) ) transformation . append ( morse [ c - ' a ' ] ) ; transformations . add ( transformation . toString ( ) ) ; } return transformations . size ( ) ; } }
class Solution { public boolean splitArraySameAverage ( int [ ] A ) { final int n = A . length ; final int sum = Arrays . stream ( A ) . sum ( ) ; if ( ! isPossible ( sum , n ) ) return false ; List < Set < Integer > > sums = new ArrayList < > ( ) ; for ( int i = 0 ; i < n / 2 + 1 ; ++ i ) sums . add ( new HashSet < > ( ) ) ; sums . get ( 0 ) . add ( 0 ) ; for ( final int a : A ) for ( int i = n / 2 ; i > 0 ; -- i ) for ( final int num : sums . get ( i - 1 ) ) sums . get ( i ) . add ( a + num ) ; for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 && sums . get ( i ) . contains ( i * sum / n ) ) return true ; return false ; } private boolean isPossible ( int sum , int n ) { for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 ) return true ; return false ; } }
class Solution { public int maxIncreaseKeepingSkyline ( int [ ] [ ] grid ) { final int n = grid . length ; int ans = 0 ; int [ ] rowMax = new int [ n ] ; int [ ] colMax = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { rowMax [ i ] = Math . max ( rowMax [ i ] , grid [ i ] [ j ] ) ; colMax [ j ] = Math . max ( colMax [ j ] , grid [ i ] [ j ] ) ; } for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans += Math . min ( rowMax [ i ] , colMax [ j ] ) - grid [ i ] [ j ] ; return ans ; } }
class Solution { public double soupServings ( int N ) { return N >= 4800 ? 1.0 : dfs ( ( N + 24 ) / 25 , ( N + 24 ) / 25 ) ; } private double [ ] [ ] memo = new double [ 4800 / 25 ] [ 4800 / 25 ] ; private double dfs ( int a , int b ) { if ( a <= 0 && b <= 0 ) return 0.5 ; if ( a <= 0 ) return 1.0 ; if ( b <= 0 ) return 0.0 ; if ( memo [ a ] [ b ] > 0 ) return memo [ a ] [ b ] ; return memo [ a ] [ b ] = 0.25 * ( dfs ( a - 4 , b ) + dfs ( a - 3 , b - 1 ) + dfs ( a - 2 , b - 2 ) + dfs ( a - 1 , b - 3 ) ) ; } }
class Solution { public int expressiveWords ( String S , String [ ] words ) { int ans = 0 ; for ( final String word : words ) if ( isStretchy ( S , word ) ) ++ ans ; return ans ; } private boolean isStretchy ( final String S , final String word ) { final int n = S . length ( ) ; final int m = word . length ( ) ; int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( j < m && S . charAt ( i ) == word . charAt ( j ) ) ++ j ; else if ( i > 1 && S . charAt ( i ) == S . charAt ( i - 1 ) && S . charAt ( i - 1 ) == S . charAt ( i - 2 ) ) continue ; else if ( 0 < i && i + 1 < n && S . charAt ( i - 1 ) == S . charAt ( i ) && S . charAt ( i ) == S . charAt ( i + 1 ) ) continue ; else return false ; return j == m ; } }
class Solution { public boolean search ( int [ ] nums , int target ) { int l = 0 ; int r = nums . length - 1 ; while ( l <= r ) { final int m = ( l + r ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ] ) { ++ l ; -- r ; } else if ( nums [ l ] <= nums [ m ] ) { if ( nums [ l ] <= target && target < nums [ m ] ) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ] ) l = m + 1 ; else r = m - 1 ; } } return false ; } }
class Solution { public boolean xorGame ( int [ ] nums ) { final int xors = Arrays . stream ( nums ) . reduce ( ( a , b ) -> a ^ b ) . getAsInt ( ) ; return xors == 0 || nums . length % 2 == 0 ; } }
class Solution { public List < String > subdomainVisits ( String [ ] cpdomains ) { List < String > ans = new ArrayList < > ( ) ; Map < String , Integer > count = new HashMap < > ( ) ; for ( final String cpdomain : cpdomains ) { final int space = cpdomain . indexOf ( ' ▁ ' ) ; final int num = Integer . valueOf ( cpdomain . substring ( 0 , space ) ) ; final String domain = cpdomain . substring ( space + 1 ) ; count . put ( domain , count . getOrDefault ( domain , 0 ) + num ) ; for ( int i = 0 ; i < domain . length ( ) ; ++ i ) if ( domain . charAt ( i ) == ' . ' ) { String subdomain = domain . substring ( i + 1 ) ; count . put ( subdomain , count . getOrDefault ( subdomain , 0 ) + num ) ; } } for ( final String subdomain : count . keySet ( ) ) ans . add ( String . valueOf ( count . get ( subdomain ) ) + ' ▁ ' + subdomain ) ; return ans ; } }
class Solution { public double largestTriangleArea ( int [ ] [ ] points ) { double ans = 0 ; for ( int [ ] A : points ) for ( int [ ] B : points ) for ( int [ ] C : points ) ans = Math . max ( ans , 0.5 * Math . abs ( ( B [ 0 ] - A [ 0 ] ) * ( C [ 1 ] - A [ 1 ] ) - ( C [ 0 ] - A [ 0 ] ) * ( B [ 1 ] - A [ 1 ] ) ) ) ; return ans ; } }
class Solution { public TreeNode pruneTree ( TreeNode root ) { if ( root == null ) return null ; root . left = pruneTree ( root . left ) ; root . right = pruneTree ( root . right ) ; if ( root . left == null && root . right == null && root . val == 0 ) return null ; return root ; } }
class Solution { public int numBusesToDestination ( int [ ] [ ] routes , int S , int T ) { if ( S == T ) return 0 ; Map < Integer , List < Integer > > graph = new HashMap < > ( ) ; Set < Integer > usedBuses = new HashSet < > ( ) ; for ( int i = 0 ; i < routes . length ; ++ i ) for ( final int route : routes [ i ] ) { graph . putIfAbsent ( route , new ArrayList < > ( ) ) ; graph . get ( route ) . add ( i ) ; } int ans = 0 ; Queue < Integer > q = new ArrayDeque < > ( Arrays . asList ( S ) ) ; while ( ! q . isEmpty ( ) ) { ++ ans ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { for ( final int bus : graph . get ( q . poll ( ) ) ) if ( usedBuses . add ( bus ) ) for ( final int nextRoute : routes [ bus ] ) if ( nextRoute == T ) return ans ; else q . offer ( nextRoute ) ; } } return - 1 ; } }
class Solution { public List < String > ambiguousCoordinates ( String S ) { List < String > ans = new ArrayList < > ( ) ; S = S . substring ( 1 , S . length ( ) - 1 ) ; for ( int i = 1 ; i < S . length ( ) ; ++ i ) for ( final String x : splits ( S . substring ( 0 , i ) ) ) for ( final String y : splits ( S . substring ( i ) ) ) ans . add ( " ( " + x + " , ▁ " + y + " ) " ) ; return ans ; } private List < String > splits ( final String S ) { if ( S . isEmpty ( ) || S . length ( ) > 1 && S . charAt ( 0 ) == '0' && S . charAt ( S . length ( ) - 1 ) == '0' ) return new ArrayList < > ( ) ; if ( S . charAt ( S . length ( ) - 1 ) == '0' ) return new ArrayList < > ( Arrays . asList ( S ) ) ; if ( S . charAt ( 0 ) == '0' ) return new ArrayList < > ( Arrays . asList ( "0 . " + S . substring ( 1 ) ) ) ; List < String > res = new ArrayList < > ( Arrays . asList ( S ) ) ; for ( int i = 1 ; i < S . length ( ) ; ++ i ) res . add ( S . substring ( 0 , i ) + " . " + S . substring ( i ) ) ; return res ; } }
class Solution { public int numComponents ( ListNode head , int [ ] G ) { int ans = 0 ; Set < Integer > setG = new HashSet < > ( ) ; for ( final int g : G ) setG . add ( g ) ; for ( ; head != null ; head = head . next ) if ( setG . contains ( head . val ) && ( head . next == null || ! setG . contains ( head . next . val ) ) ) ++ ans ; return ans ; } }
class Solution { public String mostCommonWord ( String paragraph , String [ ] banned ) { Pair < String , Integer > ans = new Pair < > ( " " , 0 ) ; Set < String > bannedSet = new HashSet < > ( Arrays . asList ( banned ) ) ; Map < String , Integer > count = new HashMap < > ( ) ; String [ ] words = paragraph . replaceAll ( " \\ W + " , " ▁ " ) . toLowerCase ( ) . split ( " \\ s + " ) ; for ( final String word : words ) if ( ! bannedSet . contains ( word ) ) { count . put ( word , count . getOrDefault ( word , 0 ) + 1 ) ; if ( count . get ( word ) > ans . getValue ( ) ) ans = new Pair < > ( word , count . get ( word ) ) ; } return ans . getKey ( ) ; } }
class Solution { public ListNode deleteDuplicates ( ListNode head ) { ListNode dummy = new ListNode ( 0 , head ) ; ListNode prev = dummy ; while ( head != null ) { while ( head . next != null && head . val == head . next . val ) head = head . next ; if ( prev . next == head ) prev = prev . next ; else prev . next = head . next ; head = head . next ; } return dummy . next ; } }
class TrieNode { public TrieNode [ ] children = new TrieNode [ 26 ] ; public int depth = 0 ; } class Solution { public int minimumLengthEncoding ( String [ ] words ) { int ans = 0 ; TrieNode root = new TrieNode ( ) ; List < TrieNode > heads = new ArrayList < > ( ) ; for ( final String word : new HashSet < > ( Arrays . asList ( words ) ) ) heads . add ( insert ( root , word ) ) ; for ( TrieNode head : heads ) if ( Arrays . stream ( head . children ) . allMatch ( child -> child == null ) ) ans += head . depth + 1 ; return ans ; } private TrieNode insert ( TrieNode root , final String word ) { TrieNode node = root ; for ( final char c : new StringBuilder ( word ) . reverse ( ) . toString ( ) . toCharArray ( ) ) { final int i = c - ' a ' ; if ( node . children [ i ] == null ) node . children [ i ] = new TrieNode ( ) ; node = node . children [ i ] ; } node . depth = word . length ( ) ; return node ; } }
class Solution { public int flipgame ( int [ ] fronts , int [ ] backs ) { int ans = 2001 ; Set < Integer > same = new HashSet < > ( ) ; for ( int i = 0 ; i < fronts . length ; ++ i ) if ( fronts [ i ] == backs [ i ] ) same . add ( fronts [ i ] ) ; for ( final int f : fronts ) if ( ! same . contains ( f ) ) ans = Math . min ( ans , f ) ; for ( final int b : backs ) if ( ! same . contains ( b ) ) ans = Math . min ( ans , b ) ; return ans == 2001 ? 0 : ans ; } }
class Solution { public int numFactoredBinaryTrees ( int [ ] arr ) { final int kMod = 1_000_000_007 ; final int n = arr . length ; long [ ] dp = new long [ n ] ; Map < Integer , Integer > numToIndex = new HashMap < > ( ) ; Arrays . sort ( arr ) ; Arrays . fill ( dp , 1 ) ; for ( int i = 0 ; i < n ; ++ i ) numToIndex . put ( arr [ i ] , i ) ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( arr [ i ] % arr [ j ] == 0 ) { final int right = arr [ i ] / arr [ j ] ; if ( numToIndex . containsKey ( right ) ) { dp [ i ] += dp [ j ] * dp [ numToIndex . get ( right ) ] ; dp [ i ] %= kMod ; } } return ( int ) ( Arrays . stream ( dp ) . sum ( ) % kMod ) ; } }
class Solution { public String toGoatLatin ( String S ) { String ans = " " ; final String vowels = " aeiouAEIOU " ; final String [ ] words = S . split ( " ▁ " ) ; int i = 1 ; for ( final String word : words ) { if ( i > 1 ) ans += " ▁ " ; if ( vowels . contains ( " " + word . charAt ( 0 ) ) ) ans += word ; else ans += word . substring ( 1 ) + word . charAt ( 0 ) ; ans += " ma " + " a " . repeat ( i ++ ) ; } return ans ; } }
class Solution { public int numFriendRequests ( int [ ] ages ) { int ans = 0 ; int [ ] count = new int [ 121 ] ; for ( final int age : ages ) ++ count [ age ] ; for ( int ageA = 1 ; ageA <= 120 ; ++ ageA ) for ( int ageB = 1 ; ageB <= 120 ; ++ ageB ) { final int countA = count [ ageA ] ; final int countB = count [ ageB ] ; if ( countA > 0 && countB > 0 && request ( ageA , ageB ) ) if ( ageA == ageB ) ans += countA * ( countB - 1 ) ; else ans += countA * countB ; } return ans ; } private boolean request ( int ageA , int ageB ) { return ! ( ageB <= 0.5 * ageA + 7 || ageB > ageA || ageB > 100 && ageA < 100 ) ; } }
class Solution { public int maxProfitAssignment ( int [ ] difficulty , int [ ] profit , int [ ] worker ) { int ans = 0 ; List < Pair < Integer , Integer > > jobs = new ArrayList < > ( ) ; for ( int i = 0 ; i < difficulty . length ; ++ i ) jobs . add ( new Pair < > ( difficulty [ i ] , profit [ i ] ) ) ; Collections . sort ( jobs , Comparator . comparing ( Pair :: getKey ) ) ; Arrays . sort ( worker ) ; int i = 0 ; int maxProfit = 0 ; for ( final int w : worker ) { for ( ; i < jobs . size ( ) && w >= jobs . get ( i ) . getKey ( ) ; ++ i ) maxProfit = Math . max ( maxProfit , jobs . get ( i ) . getValue ( ) ) ; ans += maxProfit ; } return ans ; } }
class Solution { public int uniqueLetterString ( String s ) { int ans = 0 ; int count = 0 ; int [ ] lastCount = new int [ 26 ] ; int [ ] lastSeen = new int [ 26 ] ; Arrays . fill ( lastSeen , - 1 ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { final int c = s . charAt ( i ) - ' A ' ; final int currentCount = i - lastSeen [ c ] ; count = count - lastCount [ c ] + currentCount ; lastCount [ c ] = currentCount ; lastSeen [ c ] = i ; ans += count ; } return ans ; } }
class Solution { public int consecutiveNumbersSum ( int N ) { int ans = 0 ; for ( int i = 1 , triangleNum = i ; triangleNum <= N ; ++ i , triangleNum += i ) if ( ( N - triangleNum ) % i == 0 ) ++ ans ; return ans ; } }
class Solution { public ListNode deleteDuplicates ( ListNode head ) { ListNode curr = head ; while ( curr != null ) { while ( curr . next != null && curr . val == curr . next . val ) curr . next = curr . next . next ; curr = curr . next ; } return head ; } }
class Solution { public List < List < Integer > > largeGroupPositions ( String S ) { final int n = S . length ( ) ; List < List < Integer > > ans = new ArrayList < > ( ) ; for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S . charAt ( j ) == S . charAt ( i ) ) ++ j ; if ( j - i >= 3 ) ans . add ( Arrays . asList ( i , j - 1 ) ) ; } return ans ; } }
class Solution { public String maskPII ( String S ) { final int atIndex = S . indexOf ( ' @ ' ) ; if ( atIndex > 0 ) { S = S . toLowerCase ( ) ; return S . charAt ( 0 ) + " * * * * * " + S . substring ( atIndex - 1 ) ; } StringBuilder sb = new StringBuilder ( ) ; for ( final char c : S . toCharArray ( ) ) if ( Character . isDigit ( c ) ) sb . append ( c ) ; if ( sb . length ( ) == 10 ) return " * * * - * * * - " + sb . substring ( sb . length ( ) - 4 ) . toString ( ) ; return ' + ' + " * " . repeat ( sb . length ( ) - 10 ) + " - * * * - * * * - " + sb . substring ( sb . length ( ) - 4 ) . toString ( ) ; } }
class Solution { public int [ ] [ ] flipAndInvertImage ( int [ ] [ ] A ) { final int n = A . length ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; ++ j ) { final int temp = A [ i ] [ j ] ; A [ i ] [ j ] = A [ i ] [ n - j - 1 ] ^ 1 ; A [ i ] [ n - j - 1 ] = temp ^ 1 ; } return A ; } }
class Solution { public String findReplaceString ( String s , int [ ] indices , String [ ] sources , String [ ] targets ) { List < Pair < Integer , Integer > > sortedIndices = new ArrayList < > ( ) ; for ( int i = 0 ; i < indices . length ; ++ i ) sortedIndices . add ( new Pair < > ( indices [ i ] , i ) ) ; Collections . sort ( sortedIndices , ( a , b ) -> b . getKey ( ) - a . getKey ( ) ) ; for ( Pair < Integer , Integer > sortedIndex : sortedIndices ) { final int index = sortedIndex . getKey ( ) ; final int i = sortedIndex . getValue ( ) ; final String source = sources [ i ] ; final String target = targets [ i ] ; if ( s . substring ( index , index + source . length ( ) ) . equals ( source ) ) s = s . substring ( 0 , index ) + target + s . substring ( index + source . length ( ) ) ; } return s ; } }
class Solution { public int [ ] sumOfDistancesInTree ( int N , int [ ] [ ] edges ) { int [ ] ans = new int [ N ] ; int [ ] count = new int [ N ] ; Set < Integer > [ ] tree = new Set [ N ] ; Arrays . fill ( count , 1 ) ; for ( int i = 0 ; i < N ; ++ i ) tree [ i ] = new HashSet < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; tree [ u ] . add ( v ) ; tree [ v ] . add ( u ) ; } postorder ( tree , 0 , - 1 , count , ans ) ; preorder ( tree , 0 , - 1 , count , ans ) ; return ans ; } private void postorder ( Set < Integer > [ ] tree , int node , int parent , int [ ] count , int [ ] ans ) { for ( final int child : tree [ node ] ) { if ( child == parent ) continue ; postorder ( tree , child , node , count , ans ) ; count [ node ] += count [ child ] ; ans [ node ] += ans [ child ] + count [ child ] ; } } private void preorder ( Set < Integer > [ ] tree , int node , int parent , int [ ] count , int [ ] ans ) { for ( final int child : tree [ node ] ) { if ( child == parent ) continue ; ans [ child ] = ans [ node ] - count [ child ] + ( tree . length - count [ child ] ) ; preorder ( tree , child , node , count , ans ) ; } } }
class Solution { public int largestOverlap ( int [ ] [ ] A , int [ ] [ ] B ) { final int n = A . length ; final int magic = 100 ; int ans = 0 ; List < int [ ] > onesA = new ArrayList < > ( ) ; List < int [ ] > onesB = new ArrayList < > ( ) ; Map < Integer , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ] [ j ] == 1 ) onesA . add ( new int [ ] { i , j } ) ; if ( B [ i ] [ j ] == 1 ) onesB . add ( new int [ ] { i , j } ) ; } for ( int [ ] a : onesA ) for ( int [ ] b : onesB ) { final int key = ( a [ 0 ] - b [ 0 ] ) * magic + a [ 1 ] - b [ 1 ] ; map . put ( key , map . getOrDefault ( key , 0 ) + 1 ) ; } for ( final int value : map . values ( ) ) ans = Math . max ( ans , value ) ; return ans ; } }
class Solution { public boolean isRectangleOverlap ( int [ ] rec1 , int [ ] rec2 ) { return rec1 [ 0 ] < rec2 [ 2 ] && rec2 [ 0 ] < rec1 [ 2 ] && rec1 [ 1 ] < rec2 [ 3 ] && rec2 [ 1 ] < rec1 [ 3 ] ; } }
class Solution { public double new21Game ( int n , int k , int maxPts ) { if ( k == 0 || n >= k - 1 + maxPts ) return 1.0 ; double ans = 0.0 ; double [ ] dp = new double [ n + 1 ] ; dp [ 0 ] = 1.0 ; double windowSum = dp [ 0 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i ] = windowSum / maxPts ; if ( i < k ) windowSum += dp [ i ] ; else ans += dp [ i ] ; if ( i - maxPts >= 0 ) windowSum -= dp [ i - maxPts ] ; } return ans ; } }
class Solution { public String pushDominoes ( String dominoes ) { char [ ] s = dominoes . toCharArray ( ) ; int L = - 1 ; int R = - 1 ; for ( int i = 0 ; i <= dominoes . length ( ) ; ++ i ) if ( i == dominoes . length ( ) || s [ i ] == ' R ' ) { if ( L < R ) while ( R < i ) s [ R ++ ] = ' R ' ; R = i ; } else if ( s [ i ] == ' L ' ) { if ( R < L || L == - 1 && R == - 1 ) { if ( L == - 1 && R == - 1 ) ++ L ; while ( L < i ) s [ L ++ ] = ' L ' ; } else { int l = R + 1 ; int r = i - 1 ; while ( l < r ) { s [ l ++ ] = ' R ' ; s [ r -- ] = ' L ' ; } } L = i ; } return new String ( s ) ; } }
class Solution { public int largestRectangleArea ( int [ ] heights ) { int ans = 0 ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i <= heights . length ; ++ i ) { while ( ! stack . isEmpty ( ) && ( i == heights . length || heights [ stack . peek ( ) ] > heights [ i ] ) ) { final int h = heights [ stack . pop ( ) ] ; final int w = stack . isEmpty ( ) ? i : i - stack . peek ( ) - 1 ; ans = Math . max ( ans , h * w ) ; } stack . push ( i ) ; } return ans ; } }
class Solution { public int numMagicSquaresInside ( int [ ] [ ] grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . length ; ++ i ) for ( int j = 0 ; j + 2 < grid [ 0 ] . length ; ++ j ) if ( grid [ i ] [ j ] % 2 == 0 && grid [ i + 1 ] [ j + 1 ] == 5 ) if ( isMagic ( grid , i , j ) ) ++ ans ; return ans ; } private boolean isMagic ( int [ ] [ ] grid , int i , int j ) { String s = new String ( " " ) ; for ( final int num : new int [ ] { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 } ) s += Integer . toString ( grid [ i + num / 3 ] [ j + num % 3 ] ) ; return new String ( "4381672943816729" ) . contains ( s ) || new String ( "9276183492761834" ) . contains ( s ) ; } }
class Solution { public boolean canVisitAllRooms ( List < List < Integer > > rooms ) { int [ ] seen = new int [ rooms . size ( ) ] ; dfs ( rooms , 0 , seen ) ; return Arrays . stream ( seen ) . allMatch ( a -> a == 1 ) ; } private void dfs ( List < List < Integer > > rooms , int node , int [ ] seen ) { seen [ node ] = 1 ; for ( final int child : rooms . get ( node ) ) if ( seen [ child ] == 0 ) dfs ( rooms , child , seen ) ; } }
class Solution { public void findSecretWord ( String [ ] wordlist , Master master ) { Random rand = new Random ( ) ; for ( int i = 0 ; i < 10 ; ++ i ) { final String guessedWord = wordlist [ rand . nextInt ( wordlist . length ) ] ; final int matches = master . guess ( guessedWord ) ; if ( matches == 6 ) break ; List < String > updated = new ArrayList < > ( ) ; for ( final String word : wordlist ) if ( getMatches ( guessedWord , word ) == matches ) updated . add ( word ) ; wordlist = updated . toArray ( new String [ 0 ] ) ; } } private int getMatches ( final String s1 , final String s2 ) { int matches = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; ++ i ) if ( s1 . charAt ( i ) == s2 . charAt ( i ) ) ++ matches ; return matches ; } }
class Solution { public int longestMountain ( int [ ] A ) { int ans = 0 ; for ( int i = 0 ; i + 1 < A . length ; ) { while ( i + 1 < A . length && A [ i ] == A [ i + 1 ] ) ++ i ; int increasing = 0 ; int decreasing = 0 ; while ( i + 1 < A . length && A [ i ] < A [ i + 1 ] ) { ++ increasing ; ++ i ; } while ( i + 1 < A . length && A [ i ] > A [ i + 1 ] ) { ++ decreasing ; ++ i ; } if ( increasing > 0 && decreasing > 0 ) ans = Math . max ( ans , increasing + decreasing + 1 ) ; } return ans ; } }
class Solution { public boolean isNStraightHand ( int [ ] hand , int W ) { TreeMap < Integer , Integer > count = new TreeMap < > ( ) ; for ( final int card : hand ) count . put ( card , count . getOrDefault ( card , 0 ) + 1 ) ; for ( final int start : count . keySet ( ) ) { final int value = count . getOrDefault ( start , 0 ) ; if ( value > 0 ) for ( int i = start ; i < start + W ; ++ i ) { count . put ( i , count . getOrDefault ( i , 0 ) - value ) ; if ( count . get ( i ) < 0 ) return false ; } } return true ; } }
class Solution { public int shortestPathLength ( int [ ] [ ] graph ) { final int n = graph . length ; final int goal = ( 1 << n ) - 1 ; int ans = 0 ; Queue < Pair < Integer , Integer > > q = new ArrayDeque < > ( ) ; boolean [ ] [ ] seen = new boolean [ n ] [ 1 << n ] ; for ( int i = 0 ; i < n ; ++ i ) q . offer ( new Pair < > ( i , 1 << i ) ) ; while ( ! q . isEmpty ( ) ) { for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int u = q . peek ( ) . getKey ( ) ; final int state = q . poll ( ) . getValue ( ) ; if ( state == goal ) return ans ; if ( seen [ u ] [ state ] ) continue ; seen [ u ] [ state ] = true ; for ( final int v : graph [ u ] ) q . offer ( new Pair < > ( v , state | ( 1 << v ) ) ) ; } ++ ans ; } return - 1 ; } }
class Solution { public String shiftingLetters ( String s , int [ ] shifts ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = shifts . length - 2 ; i >= 0 ; -- i ) shifts [ i ] = ( shifts [ i ] + shifts [ i + 1 ] ) % 26 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) sb . append ( ( char ) ( ( s . charAt ( i ) - ' a ' + shifts [ i ] ) % 26 + ' a ' ) ) ; return sb . toString ( ) ; } }
class Solution { public int maxDistToClosest ( int [ ] seats ) { final int n = seats . length ; int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; ++ i ) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : Math . max ( ans , ( i - j ) / 2 ) ; j = i ; } return Math . max ( ans , n - j - 1 ) ; } }
class Solution { public int maximalRectangle ( char [ ] [ ] matrix ) { if ( matrix . length == 0 ) return 0 ; int ans = 0 ; int [ ] hist = new int [ matrix [ 0 ] . length ] ; for ( char [ ] row : matrix ) { for ( int i = 0 ; i < row . length ; ++ i ) hist [ i ] = row [ i ] == '0' ? 0 : hist [ i ] + 1 ; ans = Math . max ( ans , largestRectangleArea ( hist ) ) ; } return ans ; } private int largestRectangleArea ( int [ ] heights ) { int ans = 0 ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i <= heights . length ; ++ i ) { while ( ! stack . isEmpty ( ) && ( i == heights . length || heights [ stack . peek ( ) ] > heights [ i ] ) ) { final int h = heights [ stack . pop ( ) ] ; final int w = stack . isEmpty ( ) ? i : i - stack . peek ( ) - 1 ; ans = Math . max ( ans , h * w ) ; } stack . push ( i ) ; } return ans ; } }
class Event { public int x ; public int y1 ; public int y2 ; public char type ; public Event ( int x , int y1 , int y2 , char type ) { this . x = x ; this . y1 = y1 ; this . y2 = y2 ; this . type = type ; } } class Solution { public int rectangleArea ( int [ ] [ ] rectangles ) { final int kMod = 1_000_000_007 ; List < Event > events = new ArrayList < > ( ) ; for ( int [ ] r : rectangles ) { events . add ( new Event ( r [ 0 ] , r [ 1 ] , r [ 3 ] , ' s ' ) ) ; events . add ( new Event ( r [ 2 ] , r [ 1 ] , r [ 3 ] , ' e ' ) ) ; } Collections . sort ( events , ( a , b ) -> a . x - b . x ) ; long ans = 0 ; int prevX = 0 ; List < Pair < Integer , Integer > > yPairs = new ArrayList < > ( ) ; for ( Event e : events ) { if ( e . x > prevX ) { final int width = e . x - prevX ; ans = ( ans + width * getHeight ( yPairs ) ) % kMod ; prevX = e . x ; } if ( e . type == ' s ' ) { yPairs . add ( new Pair < > ( e . y1 , e . y2 ) ) ; Collections . sort ( yPairs , Comparator . comparing ( Pair :: getKey ) ) ; } else { yPairs . remove ( new Pair < > ( e . y1 , e . y2 ) ) ; } } return ( int ) ( ans % kMod ) ; } private long getHeight ( List < Pair < Integer , Integer > > yPairs ) { int height = 0 ; int prevY = 0 ; for ( Pair < Integer , Integer > pair : yPairs ) { final int y1 = pair . getKey ( ) ; final int y2 = pair . getValue ( ) ; prevY = Math . max ( prevY , y1 ) ; if ( y2 > prevY ) { height += y2 - prevY ; prevY = y2 ; } } return height ; } }
class Solution { public int [ ] loudAndRich ( int [ ] [ ] richer , int [ ] quiet ) { int [ ] ans = new int [ quiet . length ] ; List < Integer > [ ] graph = new List [ quiet . length ] ; Arrays . fill ( ans , - 1 ) ; for ( int i = 0 ; i < graph . length ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : richer ) graph [ e [ 1 ] ] . add ( e [ 0 ] ) ; for ( int i = 0 ; i < graph . length ; ++ i ) dfs ( graph , i , quiet , ans ) ; return ans ; } private int dfs ( List < Integer > [ ] graph , int u , int [ ] quiet , int [ ] ans ) { if ( ans [ u ] != - 1 ) return ans [ u ] ; ans [ u ] = u ; for ( final int v : graph [ u ] ) { final int res = dfs ( graph , v , quiet , ans ) ; if ( quiet [ res ] < quiet [ ans [ u ] ] ) ans [ u ] = res ; } return ans [ u ] ; } }
class Solution { public int peakIndexInMountainArray ( int [ ] arr ) { int l = 0 ; int r = arr . length - 1 ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( arr [ m ] < arr [ m + 1 ] ) l = m + 1 ; else r = m ; } return l ; } }
class Car { public int pos ; public double time ; public Car ( int pos , double time ) { this . pos = pos ; this . time = time ; } } class Solution { public int carFleet ( int target , int [ ] position , int [ ] speed ) { int ans = 0 ; Car [ ] cars = new Car [ position . length ] ; for ( int i = 0 ; i < position . length ; ++ i ) cars [ i ] = new Car ( position [ i ] , ( double ) ( target - position [ i ] ) / speed [ i ] ) ; Arrays . sort ( cars , ( a , b ) -> b . pos - a . pos ) ; double maxTime = 0 ; for ( Car car : cars ) if ( car . time > maxTime ) { maxTime = car . time ; ++ ans ; } return ans ; } }
class Solution { public int kSimilarity ( String s1 , String s2 ) { int ans = 0 ; Queue < String > q = new ArrayDeque < > ( Arrays . asList ( s1 ) ) ; Set < String > seen = new HashSet < > ( Arrays . asList ( s1 ) ) ; while ( ! q . isEmpty ( ) ) { for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final String curr = q . poll ( ) ; if ( curr . equals ( s2 ) ) return ans ; for ( final String child : getChildren ( curr , s2 ) ) { if ( seen . contains ( child ) ) continue ; q . offer ( child ) ; seen . add ( child ) ; } } ++ ans ; } return - 1 ; } private List < String > getChildren ( final String curr , final String target ) { List < String > children = new ArrayList < > ( ) ; char [ ] charArray = curr . toCharArray ( ) ; int i = 0 ; while ( curr . charAt ( i ) == target . charAt ( i ) ) ++ i ; for ( int j = i + 1 ; j < charArray . length ; ++ j ) if ( curr . charAt ( j ) == target . charAt ( i ) ) { swap ( charArray , i , j ) ; children . add ( String . valueOf ( charArray ) ) ; swap ( charArray , i , j ) ; } return children ; } private void swap ( char [ ] charArray , int i , int j ) { final char temp = charArray [ i ] ; charArray [ i ] = charArray [ j ] ; charArray [ j ] = temp ; } }
class Solution { public int scoreOfParentheses ( String S ) { int ans = 0 ; int layer = 0 ; for ( int i = 0 ; i + 1 < S . length ( ) ; ++ i ) { final char a = S . charAt ( i ) ; final char b = S . charAt ( i + 1 ) ; if ( a == ' ( ' && b == ' ) ' ) ans += 1 << layer ; layer += a == ' ( ' ? 1 : - 1 ; } return ans ; } }
class Solution { public double mincostToHireWorkers ( int [ ] quality , int [ ] wage , int k ) { double ans = Double . MAX_VALUE ; int qualitySum = 0 ; Pair < Double , Integer > [ ] workers = new Pair [ quality . length ] ; Queue < Integer > maxHeap = new PriorityQueue < > ( ( a , b ) -> b - a ) ; for ( int i = 0 ; i < quality . length ; ++ i ) workers [ i ] = new Pair < > ( ( double ) wage [ i ] / quality [ i ] , quality [ i ] ) ; Arrays . sort ( workers , ( a , b ) -> Double . compare ( a . getKey ( ) , b . getKey ( ) ) ) ; for ( Pair < Double , Integer > worker : workers ) { final double wagePerQuality = worker . getKey ( ) ; final int q = worker . getValue ( ) ; maxHeap . offer ( q ) ; qualitySum += q ; if ( maxHeap . size ( ) > k ) qualitySum -= maxHeap . poll ( ) ; if ( maxHeap . size ( ) == k ) ans = Math . min ( ans , qualitySum * wagePerQuality ) ; } return ans ; } }
class Solution { public int mirrorReflection ( int p , int q ) { int m = 1 ; int n = 1 ; while ( m * p != n * q ) m = ++ n * q / p ; if ( n % 2 == 0 ) return 2 ; if ( m % 2 == 0 ) return 0 ; if ( m % 2 == 1 ) return 1 ; throw new IllegalArgumentException ( ) ; } }
class Solution { public boolean buddyStrings ( String A , String B ) { if ( A . length ( ) != B . length ( ) ) return false ; if ( A . equals ( B ) ) { Set < Character > set = new HashSet < > ( ) ; for ( char c : A . toCharArray ( ) ) set . add ( c ) ; return set . size ( ) < A . length ( ) ; } List < Integer > diff = new ArrayList < > ( ) ; for ( int i = 0 ; i < A . length ( ) ; ++ i ) if ( A . charAt ( i ) != B . charAt ( i ) ) diff . add ( i ) ; return diff . size ( ) == 2 && A . charAt ( diff . get ( 0 ) ) == B . charAt ( diff . get ( 1 ) ) && A . charAt ( diff . get ( 1 ) ) == B . charAt ( diff . get ( 0 ) ) ; } }
class Solution { public ListNode partition ( ListNode head , int x ) { ListNode beforeHead = new ListNode ( 0 ) ; ListNode afterHead = new ListNode ( 0 ) ; ListNode before = beforeHead ; ListNode after = afterHead ; for ( ; head != null ; head = head . next ) if ( head . val < x ) { before . next = head ; before = head ; } else { after . next = head ; after = head ; } after . next = null ; before . next = afterHead . next ; return beforeHead . next ; } }
class Solution { public int matrixScore ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int ans = 0 ; for ( int [ ] row : grid ) if ( row [ 0 ] == 0 ) flip ( row ) ; for ( int j = 0 ; j < n ; ++ j ) if ( onesColCount ( grid , j ) * 2 < m ) flipCol ( grid , j ) ; for ( int [ ] row : grid ) ans += binary ( row ) ; return ans ; } private void flip ( int [ ] row ) { for ( int i = 0 ; i < row . length ; ++ i ) row [ i ] ^= 1 ; } private int onesColCount ( int [ ] [ ] grid , int j ) { int ones = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) ones += grid [ i ] [ j ] ; return ones ; } private void flipCol ( int [ ] [ ] grid , int j ) { for ( int i = 0 ; i < grid . length ; ++ i ) grid [ i ] [ j ] ^= 1 ; } private int binary ( int [ ] row ) { int res = row [ 0 ] ; for ( int j = 1 ; j < row . length ; ++ j ) res = res * 2 + row [ j ] ; return res ; } }
class Solution { public int shortestSubarray ( int [ ] A , int K ) { final int n = A . length ; int ans = n + 1 ; Deque < Integer > q = new ArrayDeque < > ( ) ; long [ ] prefix = new long [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) prefix [ i + 1 ] = ( long ) A [ i ] + prefix [ i ] ; for ( int i = 0 ; i < n + 1 ; ++ i ) { while ( ! q . isEmpty ( ) && prefix [ i ] - prefix [ q . getFirst ( ) ] >= K ) ans = Math . min ( ans , i - q . pollFirst ( ) ) ; while ( ! q . isEmpty ( ) && prefix [ i ] <= prefix [ q . getLast ( ) ] ) q . pollLast ( ) ; q . addLast ( i ) ; } return ans <= n ? ans : - 1 ; } }
class Solution { public int primePalindrome ( int N ) { if ( N <= 2 ) return 2 ; if ( N == 3 ) return 3 ; if ( N <= 5 ) return 5 ; if ( N <= 7 ) return 7 ; if ( N <= 11 ) return 11 ; int n = String . valueOf ( N ) . length ( ) ; while ( true ) { for ( int num : getPalindromes ( n ) ) if ( num >= N && isPrime ( num ) ) return num ; ++ n ; } } private List < Integer > getPalindromes ( int n ) { List < Integer > palindromes = new ArrayList < > ( ) ; int length = n / 2 ; for ( int i = ( int ) Math . pow ( 10 , length - 1 ) ; i < ( int ) Math . pow ( 10 , length ) ; ++ i ) { String s = String . valueOf ( i ) ; String reversedS = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; for ( int j = 0 ; j < 10 ; ++ j ) palindromes . add ( Integer . valueOf ( s + String . valueOf ( j ) + reversedS ) ) ; } return palindromes ; } private boolean isPrime ( int num ) { for ( int i = 2 ; i < ( int ) Math . sqrt ( num ) + 1 ; ++ i ) if ( num % i == 0 ) return false ; return true ; } }
class Solution { public int [ ] [ ] transpose ( int [ ] [ ] A ) { int [ ] [ ] ans = new int [ A [ 0 ] . length ] [ A . length ] ; for ( int i = 0 ; i < A . length ; ++ i ) for ( int j = 0 ; j < A [ 0 ] . length ; ++ j ) ans [ j ] [ i ] = A [ i ] [ j ] ; return ans ; } }
class Solution { public int binaryGap ( int n ) { int ans = 0 ; for ( int d = - 32 ; n > 0 ; n /= 2 , ++ d ) if ( ( n & 1 ) == 1 ) { ans = Math . max ( ans , d ) ; d = 0 ; } return ans ; } }
class Solution { public boolean reorderedPowerOf2 ( int N ) { int count = counter ( N ) ; for ( int i = 0 ; i < 30 ; ++ i ) if ( counter ( 1 << i ) == count ) return true ; return false ; } private int counter ( int n ) { int count = 0 ; for ( ; n > 0 ; n /= 10 ) count += Math . pow ( 10 , n % 10 ) ; return count ; } }
class Solution { public boolean isScramble ( String s1 , String s2 ) { if ( s1 . equals ( s2 ) ) return true ; if ( s1 . length ( ) != s2 . length ( ) ) return false ; final String hashedKey = s1 + " + " + s2 ; if ( memo . containsKey ( hashedKey ) ) return memo . get ( hashedKey ) ; int [ ] count = new int [ 128 ] ; for ( int i = 0 ; i < s1 . length ( ) ; ++ i ) { ++ count [ s1 . charAt ( i ) ] ; -- count [ s2 . charAt ( i ) ] ; } for ( final int c : count ) if ( c != 0 ) { memo . put ( hashedKey , false ) ; return false ; } for ( int i = 1 ; i < s1 . length ( ) ; ++ i ) { if ( isScramble ( s1 . substring ( 0 , i ) , s2 . substring ( 0 , i ) ) && isScramble ( s1 . substring ( i ) , s2 . substring ( i ) ) ) { memo . put ( hashedKey , true ) ; return true ; } if ( isScramble ( s1 . substring ( 0 , i ) , s2 . substring ( s2 . length ( ) - i ) ) && isScramble ( s1 . substring ( i ) , s2 . substring ( 0 , s2 . length ( ) - i ) ) ) { memo . put ( hashedKey , true ) ; return true ; } } memo . put ( hashedKey , false ) ; return false ; } private Map < String , Boolean > memo = new HashMap < > ( ) ; }
class Solution { public int [ ] advantageCount ( int [ ] A , int [ ] B ) { TreeMap < Integer , Integer > map = new TreeMap < > ( ) ; for ( int a : A ) map . put ( a , map . getOrDefault ( a , 0 ) + 1 ) ; for ( int i = 0 ; i < B . length ; i ++ ) { Integer key = map . higherKey ( B [ i ] ) ; if ( key == null ) key = map . firstKey ( ) ; map . put ( key , map . get ( key ) - 1 ) ; if ( map . get ( key ) == 0 ) map . remove ( key ) ; A [ i ] = key ; } return A ; } }
class Solution { public int minRefuelStops ( int target , int startFuel , int [ ] [ ] stations ) { long dp [ ] = new long [ stations . length + 1 ] ; dp [ 0 ] = startFuel ; for ( int i = 0 ; i < stations . length ; ++ i ) for ( int j = i + 1 ; j > 0 ; -- j ) if ( dp [ j - 1 ] >= stations [ i ] [ 0 ] ) dp [ j ] = Math . max ( dp [ j ] , dp [ j - 1 ] + stations [ i ] [ 1 ] ) ; for ( int i = 0 ; i < dp . length ; ++ i ) if ( dp [ i ] >= target ) return i ; return - 1 ; } }
class Solution { public boolean leafSimilar ( TreeNode root1 , TreeNode root2 ) { List < Integer > leaves1 = new ArrayList < > ( ) ; List < Integer > leaves2 = new ArrayList < > ( ) ; dfs ( root1 , leaves1 ) ; dfs ( root2 , leaves2 ) ; return leaves1 . equals ( leaves2 ) ; } public void dfs ( TreeNode node , List < Integer > leaves ) { if ( node == null ) return ; if ( node . left == null && node . right == null ) { leaves . add ( node . val ) ; return ; } dfs ( node . left , leaves ) ; dfs ( node . right , leaves ) ; } }
class Solution { public int lenLongestFibSubseq ( int [ ] A ) { final int n = A . length ; int ans = 0 ; int [ ] [ ] dp = new int [ n ] [ n ] ; Arrays . stream ( dp ) . forEach ( row -> Arrays . fill ( row , 2 ) ) ; Map < Integer , Integer > numToIndex = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) numToIndex . put ( A [ i ] , i ) ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { final int ai = A [ k ] - A [ j ] ; if ( ai < A [ j ] && numToIndex . containsKey ( ai ) ) { final int i = numToIndex . get ( ai ) ; dp [ j ] [ k ] = dp [ i ] [ j ] + 1 ; ans = Math . max ( ans , dp [ j ] [ k ] ) ; } } return ans ; } }
class Solution { public int robotSim ( int [ ] commands , int [ ] [ ] obstacles ) { final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; int ans = 0 ; int d = 0 ; int x = 0 ; int y = 0 ; Set < Pair < Integer , Integer > > obstaclesSet = new HashSet < > ( ) ; for ( int [ ] o : obstacles ) obstaclesSet . add ( new Pair < > ( o [ 0 ] , o [ 1 ] ) ) ; for ( final int c : commands ) { if ( c == - 1 ) { d = ( d + 1 ) % 4 ; } else if ( c == - 2 ) { d = ( d + 3 ) % 4 ; } else { for ( int step = 0 ; step < c ; ++ step ) { if ( obstaclesSet . contains ( new Pair < > ( x + dirs [ d ] , y + dirs [ d + 1 ] ) ) ) break ; x += dirs [ d ] ; y += dirs [ d + 1 ] ; } } ans = Math . max ( ans , x * x + y * y ) ; } return ans ; } }
class Solution { public int minEatingSpeed ( int [ ] piles , int h ) { int l = 1 ; int r = Arrays . stream ( piles ) . max ( ) . getAsInt ( ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( eatHours ( piles , m ) <= h ) r = m ; else l = m + 1 ; } return l ; } private int eatHours ( int [ ] piles , int m ) { return Arrays . stream ( piles ) . reduce ( 0 , ( subtotal , pile ) -> subtotal + ( pile - 1 ) / m + 1 ) ; } }
class Solution { public ListNode middleNode ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } return slow ; } }
class Solution { public boolean stoneGame ( int [ ] piles ) { final int n = piles . length ; int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ] [ i ] = piles [ i ] ; for ( int d = 1 ; d < n ; ++ d ) for ( int i = 0 ; i + d < n ; ++ i ) { final int j = i + d ; dp [ i ] [ j ] = Math . max ( piles [ i ] - dp [ i + 1 ] [ j ] , piles [ j ] - dp [ i ] [ j - 1 ] ) ; } return dp [ 0 ] [ n - 1 ] > 0 ; } }
class Solution { public int nthMagicalNumber ( long n , long a , long b ) { final int kMod = 1_000_000_007 ; final long lcm = a * b / gcd ( a , b ) ; long l = Math . min ( a , b ) ; long r = Math . min ( a , b ) * n ; while ( l < r ) { final long m = ( l + r ) / 2 ; if ( m / a + m / b - m / lcm >= n ) r = m ; else l = m + 1 ; } return ( int ) ( l % kMod ) ; } private long gcd ( long a , long b ) { return b == 0 ? a : gcd ( b , a % b ) ; } }
class Solution { public void merge ( int [ ] nums1 , int m , int [ ] nums2 , int n ) { int i = m - 1 ; int j = n - 1 ; int k = m + n - 1 ; while ( j >= 0 ) if ( i >= 0 && nums1 [ i ] > nums2 [ j ] ) nums1 [ k -- ] = nums1 [ i -- ] ; else nums1 [ k -- ] = nums2 [ j -- ] ; } }
class Solution { public String decodeAtIndex ( String s , int k ) { long size = 0 ; for ( final char c : s . toCharArray ( ) ) if ( Character . isDigit ( c ) ) size *= c - '0' ; else ++ size ; for ( int i = s . length ( ) - 1 ; i >= 0 ; -- i ) { k %= size ; if ( k == 0 && Character . isAlphabetic ( s . charAt ( i ) ) ) return s . substring ( i , i + 1 ) ; if ( Character . isDigit ( s . charAt ( i ) ) ) size /= s . charAt ( i ) - '0' ; else -- size ; } throw new IllegalArgumentException ( ) ; } }
class Solution { public int numRescueBoats ( int [ ] people , int limit ) { int ans = 0 ; Arrays . sort ( people ) ; for ( int i = 0 , j = people . length - 1 ; i <= j ; ++ ans ) { int remain = limit - people [ j -- ] ; if ( people [ i ] <= remain ) ++ i ; } return ans ; } }
class Solution { public int reachableNodes ( int [ ] [ ] edges , int maxMoves , int n ) { List < Pair < Integer , Integer > > [ ] graph = new List [ n ] ; Queue < int [ ] > minHeap = new PriorityQueue < > ( ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; int [ ] dist = new int [ n ] ; Arrays . fill ( dist , maxMoves + 1 ) ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; final int cnt = e [ 2 ] ; graph [ u ] . add ( new Pair < > ( v , cnt ) ) ; graph [ v ] . add ( new Pair < > ( u , cnt ) ) ; } minHeap . offer ( new int [ ] { 0 , 0 } ) ; dist [ 0 ] = 0 ; while ( ! minHeap . isEmpty ( ) ) { final int d = minHeap . peek ( ) [ 0 ] ; final int u = minHeap . poll ( ) [ 1 ] ; if ( d >= maxMoves ) break ; for ( Pair < Integer , Integer > node : graph [ u ] ) { final int v = node . getKey ( ) ; final int w = node . getValue ( ) ; final int newDist = d + w + 1 ; if ( newDist < dist [ v ] ) { dist [ v ] = newDist ; minHeap . offer ( new int [ ] { newDist , v } ) ; } } } final int reachableNodes = ( int ) Arrays . stream ( dist ) . filter ( d -> d <= maxMoves ) . count ( ) ; int reachableSubnodes = 0 ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; final int cnt = e [ 2 ] ; final int a = dist [ u ] > maxMoves ? 0 : Math . min ( maxMoves - dist [ u ] , cnt ) ; final int b = dist [ v ] > maxMoves ? 0 : Math . min ( maxMoves - dist [ v ] , cnt ) ; reachableSubnodes += Math . min ( a + b , cnt ) ; } return reachableNodes + reachableSubnodes ; } }
class Solution { public int projectionArea ( int [ ] [ ] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) { int maxOfRow = 0 ; int maxOfCol = 0 ; for ( int j = 0 ; j < grid . length ; ++ j ) { maxOfRow = Math . max ( maxOfRow , grid [ i ] [ j ] ) ; maxOfCol = Math . max ( maxOfCol , grid [ j ] [ i ] ) ; if ( grid [ i ] [ j ] > 0 ) ++ ans ; } ans += maxOfRow + maxOfCol ; } return ans ; } }
class Solution { public String [ ] uncommonFromSentences ( String A , String B ) { List < String > ans = new ArrayList < > ( ) ; Map < String , Integer > count = new HashMap < > ( ) ; for ( final String word : ( A + ' ▁ ' + B ) . split ( " ▁ " ) ) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ) ; for ( final String word : count . keySet ( ) ) if ( count . get ( word ) == 1 ) ans . add ( word ) ; return ans . toArray ( new String [ 0 ] ) ; } }
class Solution { public int [ ] [ ] spiralMatrixIII ( int R , int C , int r0 , int c0 ) { List < int [ ] > ans = new ArrayList < > ( ) ; final int [ ] dx = { 1 , 0 , - 1 , 0 } ; final int [ ] dy = { 0 , 1 , 0 , - 1 } ; ans . add ( new int [ ] { r0 , c0 } ) ; for ( int i = 0 ; ans . size ( ) < R * C ; ++ i ) for ( int step = 0 ; step < i / 2 + 1 ; ++ step ) { r0 += dy [ i % 4 ] ; c0 += dx [ i % 4 ] ; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . add ( new int [ ] { r0 , c0 } ) ; } return ans . toArray ( new int [ ans . size ( ) ] [ ] ) ; } }
enum Color { WHITE , RED , GREEN } class Solution { public boolean possibleBipartition ( int n , int [ ] [ ] dislikes ) { List < Integer > [ ] graph = new List [ n + 1 ] ; Color [ ] colors = new Color [ n + 1 ] ; Arrays . fill ( colors , Color . WHITE ) ; for ( int i = 1 ; i <= n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] d : dislikes ) { final int u = d [ 0 ] ; final int v = d [ 1 ] ; graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } for ( int i = 1 ; i <= n ; ++ i ) if ( colors [ i ] == Color . WHITE && ! isValidColor ( graph , i , colors , Color . RED ) ) return false ; return true ; } private boolean isValidColor ( List < Integer > [ ] graph , int u , Color [ ] colors , Color color ) { if ( colors [ u ] != Color . WHITE ) return colors [ u ] == color ; colors [ u ] = color ; for ( final int v : graph [ u ] ) if ( ! isValidColor ( graph , v , colors , color == Color . RED ? Color . GREEN : Color . RED ) ) return false ; return true ; } }
class Solution { public int [ ] fairCandySwap ( int [ ] A , int [ ] B ) { int diff = ( IntStream . of ( A ) . sum ( ) - IntStream . of ( B ) . sum ( ) ) / 2 ; Set < Integer > set = new HashSet < > ( ) ; for ( int b : B ) set . add ( b ) ; for ( int a : A ) if ( set . contains ( a - diff ) ) return new int [ ] { a , a - diff } ; throw new IllegalArgumentException ( ) ; } }
class Solution { public TreeNode constructFromPrePost ( int [ ] pre , int [ ] post ) { Map < Integer , Integer > postToIndex = new HashMap < > ( ) ; for ( int i = 0 ; i < post . length ; ++ i ) postToIndex . put ( post [ i ] , i ) ; return build ( pre , 0 , pre . length - 1 , post , 0 , post . length - 1 , postToIndex ) ; } private TreeNode build ( int [ ] pre , int preStart , int preEnd , int [ ] post , int postStart , int postEnd , Map < Integer , Integer > postToIndex ) { if ( preStart > preEnd ) return null ; if ( preStart == preEnd ) return new TreeNode ( pre [ preStart ] ) ; final int rootVal = pre [ preStart ] ; final int leftRootVal = pre [ preStart + 1 ] ; final int leftRootPostIndex = postToIndex . get ( leftRootVal ) ; final int leftSize = leftRootPostIndex - postStart + 1 ; TreeNode root = new TreeNode ( rootVal ) ; root . left = build ( pre , preStart + 1 , preStart + leftSize , post , postStart , leftRootPostIndex , postToIndex ) ; root . right = build ( pre , preStart + leftSize + 1 , preEnd , post , leftRootPostIndex + 1 , postEnd - 1 , postToIndex ) ; return root ; } }
class Solution { public List < Integer > grayCode ( int n ) { List < Integer > ans = new ArrayList < > ( ) ; ans . add ( 0 ) ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = ans . size ( ) - 1 ; j >= 0 ; -- j ) ans . add ( ans . get ( j ) | 1 << i ) ; return ans ; } }
class Solution { public List < String > findAndReplacePattern ( String [ ] words , String pattern ) { List < String > ans = new ArrayList < > ( ) ; for ( final String word : words ) if ( isIsomorphic ( word , pattern ) ) ans . add ( word ) ; return ans ; } private boolean isIsomorphic ( final String w , final String p ) { Map < Character , Integer > map_w = new HashMap < > ( ) ; Map < Character , Integer > map_p = new HashMap < > ( ) ; for ( Integer i = 0 ; i < w . length ( ) ; ++ i ) if ( map_w . put ( w . charAt ( i ) , i ) != map_p . put ( p . charAt ( i ) , i ) ) return false ; return true ; } }
class Solution { public int sumSubseqWidths ( int [ ] nums ) { final int kMod = 1_000_000_007 ; final int n = nums . length ; long ans = 0 ; long exp = 1 ; Arrays . sort ( nums ) ; for ( int i = 0 ; i < n ; ++ i , exp = exp * 2 % kMod ) { ans += ( nums [ i ] - nums [ n - i - 1 ] ) * exp ; ans %= kMod ; } return ( int ) ans ; } }
class Solution { public int surfaceArea ( int [ ] [ ] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid . length ; ++ j ) { if ( grid [ i ] [ j ] > 0 ) ans += grid [ i ] [ j ] * 4 + 2 ; if ( i > 0 ) ans -= Math . min ( grid [ i ] [ j ] , grid [ i - 1 ] [ j ] ) * 2 ; if ( j > 0 ) ans -= Math . min ( grid [ i ] [ j ] , grid [ i ] [ j - 1 ] ) * 2 ; } return ans ; } }
class Solution { public int numSpecialEquivGroups ( String [ ] A ) { Set < String > set = new HashSet < > ( ) ; for ( final String s : A ) { String even = " " ; String odd = " " ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( i % 2 == 0 ) even += s . charAt ( i ) ; else odd += s . charAt ( i ) ; char [ ] evenCharArray = even . toCharArray ( ) ; char [ ] oddCharArray = odd . toCharArray ( ) ; Arrays . sort ( evenCharArray ) ; Arrays . sort ( oddCharArray ) ; set . add ( new String ( evenCharArray ) + new String ( oddCharArray ) ) ; } return set . size ( ) ; } }
class Solution { public List < TreeNode > allPossibleFBT ( int n ) { if ( n % 2 == 0 ) return new ArrayList < > ( ) ; if ( n == 1 ) return Arrays . asList ( new TreeNode ( 0 ) ) ; if ( memo . containsKey ( n ) ) return memo . get ( n ) ; List < TreeNode > ans = new ArrayList < > ( ) ; for ( int leftCount = 0 ; leftCount < n ; ++ leftCount ) { final int rightCount = n - 1 - leftCount ; for ( TreeNode left : allPossibleFBT ( leftCount ) ) for ( TreeNode right : allPossibleFBT ( rightCount ) ) { ans . add ( new TreeNode ( 0 ) ) ; ans . get ( ans . size ( ) - 1 ) . left = left ; ans . get ( ans . size ( ) - 1 ) . right = right ; } } memo . put ( n , ans ) ; return ans ; } private Map < Integer , List < TreeNode > > memo = new HashMap < > ( ) ; }
class FreqStack { public void push ( int val ) { count . merge ( val , 1 , Integer :: sum ) ; countToStack . putIfAbsent ( count . get ( val ) , new ArrayDeque < > ( ) ) ; countToStack . get ( count . get ( val ) ) . push ( val ) ; maxFreq = Math . max ( maxFreq , count . get ( val ) ) ; } public int pop ( ) { final int val = countToStack . get ( maxFreq ) . pop ( ) ; count . merge ( val , - 1 , Integer :: sum ) ; if ( countToStack . get ( maxFreq ) . isEmpty ( ) ) -- maxFreq ; return val ; } private int maxFreq = 0 ; private Map < Integer , Integer > count = new HashMap < > ( ) ; private Map < Integer , Deque < Integer > > countToStack = new HashMap < > ( ) ; }
class Solution { public boolean isMonotonic ( int [ ] A ) { boolean increasing = true ; boolean decreasing = true ; for ( int i = 1 ; i < A . length ; ++ i ) { increasing &= A [ i ] >= A [ i - 1 ] ; decreasing &= A [ i ] <= A [ i - 1 ] ; } return increasing || decreasing ; } }
class Solution { public TreeNode increasingBST ( TreeNode root ) { return increasingBST ( root , null ) ; } private TreeNode increasingBST ( TreeNode root , TreeNode tail ) { if ( root == null ) return tail ; TreeNode ans = increasingBST ( root . left , root ) ; root . left = null ; root . right = increasingBST ( root . right , tail ) ; return ans ; } }
class Solution { public String orderlyQueue ( String S , int K ) { if ( K > 1 ) { char [ ] chars = S . toCharArray ( ) ; Arrays . sort ( chars ) ; return String . valueOf ( chars ) ; } String ans = S ; for ( int i = 1 ; i < S . length ( ) ; ++ i ) { String S2 = S . substring ( i ) + S . substring ( 0 , i ) ; if ( ans . compareTo ( S2 ) > 0 ) ans = S2 ; } return ans ; } }
class Solution { public boolean isPalindrome ( int x ) { if ( x < 0 ) return false ; long reversed = 0 ; int y = x ; while ( y > 0 ) { reversed = reversed * 10 + y % 10 ; y /= 10 ; } return reversed == x ; } }
class Solution { public List < List < Integer > > subsetsWithDup ( int [ ] nums ) { List < List < Integer > > ans = new ArrayList < > ( ) ; Arrays . sort ( nums ) ; dfs ( nums , 0 , new ArrayList < > ( ) , ans ) ; return ans ; } private void dfs ( int [ ] nums , int s , List < Integer > path , List < List < Integer > > ans ) { ans . add ( new ArrayList < > ( path ) ) ; for ( int i = s ; i < nums . length ; ++ i ) { if ( i > s && nums [ i ] == nums [ i - 1 ] ) continue ; path . add ( nums [ i ] ) ; dfs ( nums , i + 1 , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; } } }
class RLEIterator { public RLEIterator ( int [ ] A ) { this . A = A ; } public int next ( int n ) { while ( index < A . length && A [ index ] < n ) { n -= A [ index ] ; index += 2 ; } if ( index == A . length ) return - 1 ; A [ index ] -= n ; return A [ index + 1 ] ; } private int index = 0 ; private int [ ] A ; }
class StockSpanner { public int next ( int price ) { int span = 1 ; while ( ! stack . isEmpty ( ) && stack . peek ( ) . getKey ( ) <= price ) span += stack . pop ( ) . getValue ( ) ; stack . push ( new Pair < > ( price , span ) ) ; return span ; } private Stack < Pair < Integer , Integer > > stack = new Stack < > ( ) ; }
class Solution { public int atMostNGivenDigitSet ( String [ ] D , int N ) { int ans = 0 ; String num = String . valueOf ( N ) ; for ( int i = 1 ; i < num . length ( ) ; ++ i ) ans += Math . pow ( D . length , i ) ; for ( int i = 0 ; i < num . length ( ) ; ++ i ) { boolean dHasSameNum = false ; for ( final String digit : D ) { if ( digit . charAt ( 0 ) < num . charAt ( i ) ) ans += Math . pow ( D . length , num . length ( ) - i - 1 ) ; else if ( digit . charAt ( 0 ) == num . charAt ( i ) ) dHasSameNum = true ; } if ( ! dHasSameNum ) return ans ; } return ans + 1 ; } }
class Solution { public int totalFruit ( int [ ] tree ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( int l = 0 , r = 0 ; r < tree . length ; ++ r ) { count . put ( tree [ r ] , count . getOrDefault ( tree [ r ] , 0 ) + 1 ) ; while ( count . size ( ) > 2 ) { count . put ( tree [ l ] , count . get ( tree [ l ] ) - 1 ) ; count . remove ( tree [ l ] , 0 ) ; ++ l ; } ans = Math . max ( ans , r - l + 1 ) ; } return ans ; } }
class Solution { public int [ ] sortArrayByParity ( int [ ] A ) { int l = 0 ; int r = A . length - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } if ( A [ l ] % 2 == 0 ) ++ l ; if ( A [ r ] % 2 == 1 ) -- r ; } return A ; } }
class Solution { public int superpalindromesInRange ( String left , String right ) { int ans = 0 ; Long l = Long . valueOf ( left ) ; Long r = Long . valueOf ( right ) ; for ( long i = ( long ) Math . sqrt ( l ) ; i * i <= r ; ) { long palindrome = nextPalindrome ( i ) ; long squared = palindrome * palindrome ; if ( squared <= r && isPalindrome ( squared ) ) ++ ans ; i = palindrome + 1 ; } return ans ; } private long nextPalindrome ( long num ) { final String s = String . valueOf ( num ) ; final int n = s . length ( ) ; String half = s . substring ( 0 , ( n + 1 ) / 2 ) ; String reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 ) ) . reverse ( ) . toString ( ) ; final long candidate = Long . valueOf ( half + reversedHalf ) ; if ( candidate >= num ) return candidate ; half = String . valueOf ( Long . valueOf ( half ) + 1 ) ; reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 ) ) . reverse ( ) . toString ( ) ; return Long . valueOf ( half + reversedHalf ) ; } private boolean isPalindrome ( long num ) { final String s = String . valueOf ( num ) ; int l = 0 ; int r = s . length ( ) - 1 ; while ( l < r ) if ( s . charAt ( l ++ ) != s . charAt ( r -- ) ) return false ; return true ; } }
class Solution { public int sumSubarrayMins ( int [ ] arr ) { final int kMod = 1_000_000_007 ; final int n = arr . length ; long ans = 0 ; int [ ] prev = new int [ n ] ; int [ ] next = new int [ n ] ; Deque < Integer > stack = new ArrayDeque < > ( ) ; Arrays . fill ( prev , - 1 ) ; Arrays . fill ( next , n ) ; for ( int i = 0 ; i < arr . length ; ++ i ) { while ( ! stack . isEmpty ( ) && arr [ stack . peek ( ) ] > arr [ i ] ) { final int index = stack . pop ( ) ; next [ index ] = i ; } if ( ! stack . isEmpty ( ) ) prev [ i ] = stack . peek ( ) ; stack . push ( i ) ; } for ( int i = 0 ; i < arr . length ; ++ i ) { ans += ( long ) arr [ i ] * ( i - prev [ i ] ) * ( next [ i ] - i ) ; ans %= kMod ; } return ( int ) ans ; } }
class Solution { public int smallestRangeI ( int [ ] A , int K ) { int max = Arrays . stream ( A ) . max ( ) . getAsInt ( ) ; int min = Arrays . stream ( A ) . min ( ) . getAsInt ( ) ; return Math . max ( 0 , max - min - 2 * K ) ; } }
class Solution { public int snakesAndLadders ( int [ ] [ ] board ) { final int n = board . length ; int ans = 0 ; Queue < Integer > q = new ArrayDeque < > ( Arrays . asList ( 1 ) ) ; boolean [ ] seen = new boolean [ 1 + n * n ] ; int [ ] A = new int [ 1 + n * n ] ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) A [ ( n - 1 - i ) * n + ( ( n - i & 1 ) == 1 ? j + 1 : n - j ) ] = board [ i ] [ j ] ; while ( ! q . isEmpty ( ) ) { ++ ans ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int curr = q . poll ( ) ; for ( int next = curr + 1 ; next <= Math . min ( curr + 6 , n * n ) ; ++ next ) { final int dest = A [ next ] > 0 ? A [ next ] : next ; if ( dest == n * n ) return ans ; if ( seen [ dest ] ) continue ; q . offer ( dest ) ; seen [ dest ] = true ; } } } return - 1 ; } }
class Solution { public int numDecodings ( String s ) { final int n = s . length ( ) ; int [ ] dp = new int [ n + 1 ] ; dp [ n ] = 1 ; dp [ n - 1 ] = isValid ( s . charAt ( n - 1 ) ) ? 1 : 0 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( isValid ( s . charAt ( i ) ) ) dp [ i ] += dp [ i + 1 ] ; if ( isValid ( s . charAt ( i ) , s . charAt ( i + 1 ) ) ) dp [ i ] += dp [ i + 2 ] ; } return dp [ 0 ] ; } private boolean isValid ( char c ) { return c != '0' ; } private boolean isValid ( char c1 , char c2 ) { return c1 == '1' || c1 == '2' && c2 < '7' ; } }
class Solution { public int smallestRangeII ( int [ ] A , int K ) { Arrays . sort ( A ) ; int ans = A [ A . length - 1 ] - A [ 0 ] ; int left = A [ 0 ] + K ; int right = A [ A . length - 1 ] - K ; for ( int i = 0 ; i + 1 < A . length ; ++ i ) { int min = Math . min ( left , A [ i + 1 ] - K ) ; int max = Math . max ( right , A [ i ] + K ) ; ans = Math . min ( ans , max - min ) ; } return ans ; } }
class TopVotedCandidate { public TopVotedCandidate ( int [ ] persons , int [ ] times ) { this . times = times ; int lead = - 1 ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( int i = 0 ; i < persons . length ; ++ i ) { count . merge ( persons [ i ] , 1 , Integer :: sum ) ; if ( count . get ( persons [ i ] ) >= count . getOrDefault ( lead , 0 ) ) lead = persons [ i ] ; timeToLead . put ( times [ i ] , lead ) ; } } public int q ( int t ) { final int i = Arrays . binarySearch ( times , t ) ; return i < 0 ? timeToLead . get ( times [ - i - 2 ] ) : timeToLead . get ( times [ i ] ) ; } private final int [ ] times ; private Map < Integer , Integer > timeToLead = new HashMap < > ( ) ; }
class Solution { public int [ ] sortArray ( int [ ] nums ) { mergeSort ( nums , 0 , nums . length - 1 ) ; return nums ; } private void mergeSort ( int [ ] A , int l , int r ) { if ( l >= r ) return ; final int m = ( l + r ) / 2 ; mergeSort ( A , l , m ) ; mergeSort ( A , m + 1 , r ) ; merge ( A , l , m , r ) ; } private void merge ( int [ ] A , int l , int m , int r ) { int [ ] sorted = new int [ r - l + 1 ] ; int k = 0 ; int i = l ; int j = m + 1 ; while ( i <= m && j <= r ) if ( A [ i ] < A [ j ] ) sorted [ k ++ ] = A [ i ++ ] ; else sorted [ k ++ ] = A [ j ++ ] ; while ( i <= m ) sorted [ k ++ ] = A [ i ++ ] ; while ( j <= r ) sorted [ k ++ ] = A [ j ++ ] ; System . arraycopy ( sorted , 0 , A , l , sorted . length ) ; } }
enum State { DRAW , MOUSE_WIN , CAT_WIN } class Solution { public int catMouseGame ( int [ ] [ ] graph ) { final int n = graph . length ; int [ ] [ ] [ ] states = new int [ n ] [ n ] [ 2 ] ; int [ ] [ ] [ ] outDegree = new int [ n ] [ n ] [ 2 ] ; Queue < int [ ] > q = new ArrayDeque < > ( ) ; for ( int cat = 0 ; cat < n ; ++ cat ) for ( int mouse = 0 ; mouse < n ; ++ mouse ) { outDegree [ cat ] [ mouse ] [ 0 ] = graph [ mouse ] . length ; outDegree [ cat ] [ mouse ] [ 1 ] = graph [ cat ] . length - ( Arrays . stream ( graph [ cat ] ) . anyMatch ( v -> v == 0 ) ? 1 : 0 ) ; } for ( int cat = 1 ; cat < n ; ++ cat ) for ( int move = 0 ; move < 2 ; ++ move ) { states [ cat ] [ 0 ] [ move ] = State . MOUSE_WIN . ordinal ( ) ; q . offer ( new int [ ] { cat , 0 , move , State . MOUSE_WIN . ordinal ( ) } ) ; states [ cat ] [ cat ] [ move ] = State . CAT_WIN . ordinal ( ) ; q . offer ( new int [ ] { cat , cat , move , State . CAT_WIN . ordinal ( ) } ) ; } while ( ! q . isEmpty ( ) ) { final int cat = q . peek ( ) [ 0 ] ; final int mouse = q . peek ( ) [ 1 ] ; final int move = q . peek ( ) [ 2 ] ; final int state = q . poll ( ) [ 3 ] ; if ( cat == 2 && mouse == 1 && move == 0 ) return state ; final int prevMove = move ^ 1 ; for ( final int prev : graph [ prevMove == 0 ? mouse : cat ] ) { final int prevCat = prevMove == 0 ? cat : prev ; if ( prevCat == 0 ) continue ; final int prevMouse = prevMove == 0 ? prev : mouse ; if ( states [ prevCat ] [ prevMouse ] [ prevMove ] > 0 ) continue ; if ( prevMove == 0 && state == State . MOUSE_WIN . ordinal ( ) || prevMove == 1 && state == State . CAT_WIN . ordinal ( ) || -- outDegree [ prevCat ] [ prevMouse ] [ prevMove ] == 0 ) { states [ prevCat ] [ prevMouse ] [ prevMove ] = state ; q . offer ( new int [ ] { prevCat , prevMouse , prevMove , state } ) ; } } } return states [ 2 ] [ 1 ] [ 0 ] ; } }
class Solution { public boolean hasGroupsSizeX ( int [ ] deck ) { Map < Integer , Integer > count = new HashMap < > ( ) ; int gcd = 0 ; for ( int d : deck ) count . put ( d , count . getOrDefault ( d , 0 ) + 1 ) ; for ( int value : count . values ( ) ) gcd = __gcd ( gcd , value ) ; return gcd >= 2 ; } private int __gcd ( int a , int b ) { return b > 0 ? __gcd ( b , a % b ) : a ; } }
class Solution { public int partitionDisjoint ( int [ ] A ) { final int n = A . length ; int [ ] min = new int [ n ] ; min [ n - 1 ] = A [ n - 1 ] ; int max = Integer . MIN_VALUE ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = Math . min ( min [ i + 1 ] , A [ i ] ) ; for ( int i = 0 ; i < n ; ++ i ) { max = Math . max ( max , A [ i ] ) ; if ( max <= min [ i + 1 ] ) return i + 1 ; } throw new IllegalArgumentException ( ) ; } }
class Solution { public List < String > wordSubsets ( String [ ] A , String [ ] B ) { List < String > ans = new ArrayList < > ( ) ; int [ ] countB = new int [ 26 ] ; for ( final String b : B ) { int [ ] temp = counter ( b ) ; for ( int i = 0 ; i < 26 ; ++ i ) countB [ i ] = Math . max ( countB [ i ] , temp [ i ] ) ; } for ( final String a : A ) if ( isUniversal ( counter ( a ) , countB ) ) ans . add ( a ) ; return ans ; } private int [ ] counter ( final String s ) { int [ ] count = new int [ 26 ] ; for ( char c : s . toCharArray ( ) ) ++ count [ c - ' a ' ] ; return count ; } private boolean isUniversal ( int [ ] countA , int [ ] countB ) { for ( int i = 0 ; i < 26 ; ++ i ) if ( countA [ i ] < countB [ i ] ) return false ; return true ; } }
class Solution { public String reverseOnlyLetters ( String S ) { StringBuilder sb = new StringBuilder ( S ) ; for ( int i = 0 , j = S . length ( ) - 1 ; i < j ; ++ i , -- j ) { while ( i < j && ! Character . isLetter ( S . charAt ( i ) ) ) ++ i ; while ( i < j && ! Character . isLetter ( S . charAt ( j ) ) ) -- j ; sb . setCharAt ( i , S . charAt ( j ) ) ; sb . setCharAt ( j , S . charAt ( i ) ) ; } return sb . toString ( ) ; } }
class Solution { public int maxSubarraySumCircular ( int [ ] A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = Integer . MIN_VALUE ; int minSum = Integer . MAX_VALUE ; for ( int a : A ) { totalSum += a ; currMaxSum = Math . max ( currMaxSum + a , a ) ; currMinSum = Math . min ( currMinSum + a , a ) ; maxSum = Math . max ( maxSum , currMaxSum ) ; minSum = Math . min ( minSum , currMinSum ) ; } return maxSum < 0 ? maxSum : Math . max ( maxSum , totalSum - minSum ) ; } }
class CBTInserter { public CBTInserter ( TreeNode root ) { tree . add ( root ) ; for ( int i = 0 ; i < tree . size ( ) ; ++ i ) { TreeNode node = tree . get ( i ) ; if ( node . left != null ) tree . add ( node . left ) ; if ( node . right != null ) tree . add ( node . right ) ; } } public int insert ( int v ) { final int n = tree . size ( ) ; TreeNode node = new TreeNode ( v ) ; TreeNode parent = tree . get ( ( n - 1 ) / 2 ) ; tree . add ( node ) ; if ( n % 2 == 1 ) parent . left = node ; else parent . right = node ; return parent . val ; } public TreeNode get_root ( ) { return tree . get ( 0 ) ; } private List < TreeNode > tree = new ArrayList < > ( ) ; }
class Solution { public ListNode reverseBetween ( ListNode head , int left , int right ) { if ( left == 1 ) return reverseN ( head , right ) ; head . next = reverseBetween ( head . next , left - 1 , right - 1 ) ; return head ; } private ListNode reverseN ( ListNode head , int n ) { if ( n == 1 ) return head ; ListNode newHead = reverseN ( head . next , n - 1 ) ; ListNode headNext = head . next ; head . next = headNext . next ; headNext . next = head ; return newHead ; } }
class Solution { public int minAddToMakeValid ( String s ) { int l = 0 ; int r = 0 ; for ( final char c : s . toCharArray ( ) ) if ( c == ' ( ' ) { ++ l ; } else { if ( l == 0 ) ++ r ; else -- l ; } return l + r ; } }
class Solution { public int [ ] sortArrayByParityII ( int [ ] A ) { final int n = A . length ; for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) { int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } } return A ; } }
class Solution { public boolean isLongPressedName ( String name , String typed ) { int i = 0 ; for ( int j = 0 ; j < typed . length ( ) ; ++ j ) if ( i < name . length ( ) && name . charAt ( i ) == typed . charAt ( j ) ) ++ i ; else if ( j == 0 || typed . charAt ( j ) != typed . charAt ( j - 1 ) ) return false ; return i == name . length ( ) ; } }
class Solution { public int minFlipsMonoIncr ( String S ) { int [ ] dp = new int [ 2 ] ; for ( int i = 0 ; i < S . length ( ) ; ++ i ) { int temp = dp [ 0 ] + ( S . charAt ( i ) == '1' ? 1 : 0 ) ; dp [ 1 ] = Math . min ( dp [ 0 ] , dp [ 1 ] ) + ( S . charAt ( i ) == '0' ? 1 : 0 ) ; dp [ 0 ] = temp ; } return Math . min ( dp [ 0 ] , dp [ 1 ] ) ; } }
class Solution { public int [ ] threeEqualParts ( int [ ] A ) { int ones = 0 ; for ( int a : A ) if ( a == 1 ) ++ ones ; if ( ones == 0 ) return new int [ ] { 0 , A . length - 1 } ; if ( ones % 3 != 0 ) return new int [ ] { - 1 , - 1 } ; int k = ones / 3 ; int i = 0 ; int j = 0 ; int first = 0 ; int second = 0 ; int third = 0 ; for ( i = 0 ; i < A . length ; ++ i ) if ( A [ i ] == 1 ) { first = i ; break ; } int gapOnes = k ; for ( j = i + 1 ; j < A . length ; ++ j ) if ( A [ j ] == 1 && -- gapOnes == 0 ) { second = j ; break ; } gapOnes = k ; for ( i = j + 1 ; i < A . length ; ++ i ) if ( A [ i ] == 1 && -- gapOnes == 0 ) { third = i ; break ; } while ( third < A . length && A [ first ] == A [ second ] && A [ second ] == A [ third ] ) { ++ first ; ++ second ; ++ third ; } if ( third == A . length ) return new int [ ] { first - 1 , second } ; return new int [ ] { - 1 , - 1 } ; } }
class Solution { public int numUniqueEmails ( String [ ] emails ) { Set < String > normalized = new HashSet < > ( ) ; for ( final String email : emails ) { String [ ] parts = email . split ( " @ " ) ; String [ ] local = parts [ 0 ] . split ( " \\ + " ) ; normalized . add ( local [ 0 ] . replace ( " . " , " " ) + " @ " + parts [ 1 ] ) ; } return normalized . size ( ) ; } }
class Solution { public List < String > restoreIpAddresses ( final String s ) { List < String > ans = new ArrayList < > ( ) ; dfs ( s , 0 , new ArrayList < > ( ) , ans ) ; return ans ; } private void dfs ( final String s , int start , List < String > path , List < String > ans ) { if ( path . size ( ) == 4 && start == s . length ( ) ) { ans . add ( String . join ( " . " , path ) ) ; return ; } if ( path . size ( ) == 4 || start == s . length ( ) ) return ; for ( int length = 1 ; length <= 3 ; ++ length ) { if ( start + length > s . length ( ) ) return ; if ( length > 1 && s . charAt ( start ) == '0' ) return ; final String num = s . substring ( start , start + length ) ; if ( Integer . parseInt ( num ) > 255 ) return ; path . add ( num ) ; dfs ( s , start + length , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; } } }
class Solution { public int numSubarraysWithSum ( int [ ] A , int S ) { int ans = 0 ; int prefix = 0 ; Map < Integer , Integer > count = new HashMap < > ( ) ; count . put ( 0 , 1 ) ; for ( int a : A ) { prefix += a ; if ( count . containsKey ( prefix - S ) ) ans += count . get ( prefix - S ) ; count . put ( prefix , count . getOrDefault ( prefix , 0 ) + 1 ) ; } return ans ; } }
class Solution { public int minFallingPathSum ( int [ ] [ ] A ) { final int n = A . length ; for ( int i = 1 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int min = Integer . MAX_VALUE ; for ( int k = Math . max ( 0 , j - 1 ) ; k < Math . min ( n , j + 2 ) ; ++ k ) min = Math . min ( min , A [ i - 1 ] [ k ] ) ; A [ i ] [ j ] += min ; } return Arrays . stream ( A [ n - 1 ] ) . min ( ) . getAsInt ( ) ; } }
class Solution { public int [ ] beautifulArray ( int n ) { int [ ] A = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) A [ i ] = i + 1 ; divide ( A , 0 , n - 1 , 1 ) ; return A ; } private void divide ( int [ ] A , int l , int r , int mask ) { if ( l >= r ) return ; final int m = partition ( A , l , r , mask ) ; divide ( A , l , m , mask << 1 ) ; divide ( A , m + 1 , r , mask << 1 ) ; } private int partition ( int [ ] A , int l , int r , int mask ) { int nextSwapped = l ; for ( int i = l ; i <= r ; ++ i ) if ( ( A [ i ] & mask ) > 0 ) swap ( A , i , nextSwapped ++ ) ; return nextSwapped - 1 ; } private void swap ( int [ ] A , int i , int j ) { final int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } }
class Solution { public int knightDialer ( int n ) { final int kMod = 1_000_000_007 ; final int [ ] [ ] dirs = { { - 2 , 1 } , { - 1 , 2 } , { 1 , 2 } , { 2 , 1 } , { 2 , - 1 } , { 1 , - 2 } , { - 1 , - 2 } , { - 2 , - 1 } } ; int [ ] [ ] dp = new int [ 4 ] [ 3 ] ; Arrays . stream ( dp ) . forEach ( row -> Arrays . fill ( row , 1 ) ) ; dp [ 3 ] [ 0 ] = dp [ 3 ] [ 2 ] = 0 ; for ( int k = 0 ; k < n - 1 ; ++ k ) { int [ ] [ ] newDp = new int [ 4 ] [ 3 ] ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 3 ; ++ j ) { if ( isNotNumericCell ( i , j ) ) continue ; for ( int [ ] dir : dirs ) { final int x = i + dir [ 0 ] ; final int y = j + dir [ 1 ] ; if ( x < 0 || x >= 4 || y < 0 || y >= 3 ) continue ; if ( isNotNumericCell ( x , y ) ) continue ; newDp [ i ] [ j ] = ( newDp [ i ] [ j ] + dp [ x ] [ y ] ) % kMod ; } } dp = newDp ; } int ans = 0 ; for ( int [ ] row : dp ) for ( final int a : row ) ans = ( ans + a ) % kMod ; return ans ; } private boolean isNotNumericCell ( int i , int j ) { return i == 3 && ( j == 0 || j == 2 ) ; } }
class Solution { public int [ ] movesToStamp ( String stamp , String target ) { List < Integer > ans = new ArrayList < > ( ) ; char [ ] T = target . toCharArray ( ) ; boolean [ ] stamped = new boolean [ target . length ( ) ] ; int stampedCount = 0 ; while ( stampedCount < T . length ) { boolean isStamped = false ; for ( int i = 0 ; i <= T . length - stamp . length ( ) ; ++ i ) { if ( stamped [ i ] ) continue ; final int stampified = stampify ( stamp , T , i ) ; if ( stampified == 0 ) continue ; stampedCount += stampified ; isStamped = true ; stamped [ i ] = true ; ans . add ( i ) ; } if ( ! isStamped ) return new int [ ] { } ; } Collections . reverse ( ans ) ; return ans . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; } private int stampify ( final String stamp , char [ ] T , int s ) { int stampified = stamp . length ( ) ; for ( int i = 0 ; i < stamp . length ( ) ; ++ i ) if ( T [ s + i ] == ' * ' ) -- stampified ; else if ( T [ s + i ] != stamp . charAt ( i ) ) return 0 ; Arrays . fill ( T , s , s + stamp . length ( ) , ' * ' ) ; return stampified ; } }
class Solution { public String [ ] reorderLogFiles ( String [ ] logs ) { List < String > ans = new ArrayList < > ( ) ; List < String > digitLogs = new ArrayList < > ( ) ; List < String [ ] > letterLogs = new ArrayList < > ( ) ; for ( final String log : logs ) { final int i = log . indexOf ( ' ▁ ' ) ; if ( Character . isDigit ( log . charAt ( i + 1 ) ) ) digitLogs . add ( log ) ; else letterLogs . add ( new String [ ] { log . substring ( 0 , i ) , log . substring ( i + 1 ) } ) ; } Collections . sort ( letterLogs , new Comparator < String [ ] > ( ) { @ Override public int compare ( String [ ] l1 , String [ ] l2 ) { return l1 [ 1 ] . compareTo ( l2 [ 1 ] ) == 0 ? l1 [ 0 ] . compareTo ( l2 [ 0 ] ) : l1 [ 1 ] . compareTo ( l2 [ 1 ] ) ; } } ) ; for ( String [ ] letterLog : letterLogs ) ans . add ( letterLog [ 0 ] + " ▁ " + letterLog [ 1 ] ) ; for ( final String digitLog : digitLogs ) ans . add ( digitLog ) ; return ans . toArray ( new String [ 0 ] ) ; } }
class Solution { public int minAreaRect ( int [ ] [ ] points ) { int ans = Integer . MAX_VALUE ; Map < Integer , Set < Integer > > xToYs = new HashMap < > ( ) ; for ( int [ ] p : points ) { xToYs . putIfAbsent ( p [ 0 ] , new HashSet < > ( ) ) ; xToYs . get ( p [ 0 ] ) . add ( p [ 1 ] ) ; } for ( int i = 1 ; i < points . length ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { int [ ] p = points [ i ] ; int [ ] q = points [ j ] ; if ( p [ 0 ] == q [ 0 ] || p [ 1 ] == q [ 1 ] ) continue ; if ( xToYs . get ( p [ 0 ] ) . contains ( q [ 1 ] ) && xToYs . get ( q [ 0 ] ) . contains ( p [ 1 ] ) ) ans = Math . min ( ans , Math . abs ( p [ 0 ] - q [ 0 ] ) * Math . abs ( p [ 1 ] - q [ 1 ] ) ) ; } return ans == Integer . MAX_VALUE ? 0 : ans ; } }
class Solution { public List < Integer > inorderTraversal ( TreeNode root ) { List < Integer > ans = new ArrayList < > ( ) ; Deque < TreeNode > stack = new ArrayDeque < > ( ) ; while ( root != null || ! stack . isEmpty ( ) ) { while ( root != null ) { stack . push ( root ) ; root = root . left ; } root = stack . pop ( ) ; ans . add ( root . val ) ; root = root . right ; } return ans ; } }
class Solution { public int distinctSubseqII ( String s ) { final int kMod = 1_000_000_007 ; long [ ] endsWith = new long [ 26 ] ; for ( final char c : s . toCharArray ( ) ) endsWith [ c - ' a ' ] = ( Arrays . stream ( endsWith ) . sum ( ) + 1 ) % kMod ; return ( int ) ( Arrays . stream ( endsWith ) . sum ( ) % kMod ) ; } }
class Solution { public boolean validMountainArray ( int [ ] A ) { if ( A . length < 3 ) return false ; int l = 0 ; int r = A . length - 1 ; while ( l + 1 < A . length && A [ l ] < A [ l + 1 ] ) ++ l ; while ( r > 0 && A [ r ] < A [ r - 1 ] ) -- r ; return l > 0 && r < A . length - 1 && l == r ; } }
class Solution { public int [ ] diStringMatch ( String S ) { final int n = S . length ( ) ; int [ ] ans = new int [ n + 1 ] ; int min = 0 ; int max = n ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = S . charAt ( i ) == ' I ' ? min ++ : max -- ; ans [ n ] = min ; return ans ; } }
class Solution { public int minIncrementForUnique ( int [ ] A ) { int ans = 0 ; int minAvailable = 0 ; Arrays . sort ( A ) ; for ( int a : A ) { ans += Math . max ( minAvailable - a , 0 ) ; minAvailable = Math . max ( minAvailable , a ) + 1 ; } return ans ; } }
class Solution { public boolean validateStackSequences ( int [ ] pushed , int [ ] popped ) { Deque < Integer > stack = new ArrayDeque < > ( ) ; int i = 0 ; for ( final int x : pushed ) { stack . push ( x ) ; while ( ! stack . isEmpty ( ) && stack . peek ( ) == popped [ i ] ) { stack . pop ( ) ; ++ i ; } } return stack . isEmpty ( ) ; } }
class Solution { public int bagOfTokensScore ( int [ ] tokens , int power ) { int ans = 0 ; int score = 0 ; int i = 0 ; int j = tokens . length - 1 ; Arrays . sort ( tokens ) ; while ( i <= j && ( power >= tokens [ i ] || score > 0 ) ) { while ( i <= j && power >= tokens [ i ] ) { power -= tokens [ i ++ ] ; ++ score ; } ans = Math . max ( ans , score ) ; if ( i <= j && score > 0 ) { power += tokens [ j -- ] ; -- score ; } } return ans ; } }
class Solution { public String largestTimeFromDigits ( int [ ] A ) { String ans = " " ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) for ( int k = 0 ; k < 4 ; ++ k ) { if ( i == j || i == k || j == k ) continue ; String hours = " " + A [ i ] + A [ j ] ; String minutes = " " + A [ k ] + A [ 6 - i - j - k ] ; String time = hours + ' : ' + minutes ; if ( hours . compareTo ( "24" ) < 0 && minutes . compareTo ( "60" ) < 0 && ans . compareTo ( time ) < 0 ) ans = time ; } return ans ; } }
class Solution { public List < TreeNode > generateTrees ( int n ) { if ( n == 0 ) return new ArrayList < > ( ) ; return generateTrees ( 1 , n ) ; } private List < TreeNode > generateTrees ( int min , int max ) { if ( min > max ) return Arrays . asList ( ( TreeNode ) null ) ; List < TreeNode > ans = new ArrayList < > ( ) ; for ( int i = min ; i <= max ; ++ i ) for ( TreeNode left : generateTrees ( min , i - 1 ) ) for ( TreeNode right : generateTrees ( i + 1 , max ) ) { ans . add ( new TreeNode ( i ) ) ; ans . get ( ans . size ( ) - 1 ) . left = left ; ans . get ( ans . size ( ) - 1 ) . right = right ; } return ans ; } }
class Solution { public int [ ] deckRevealedIncreasing ( int [ ] deck ) { final int n = deck . length ; Arrays . sort ( deck ) ; Deque < Integer > q = new ArrayDeque < > ( ) ; q . addFirst ( deck [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; -- i ) { q . addFirst ( q . getLast ( ) ) ; q . pollLast ( ) ; q . addFirst ( deck [ i ] ) ; } for ( int i = 0 ; i < n ; ++ i ) deck [ i ] = q . pollFirst ( ) ; return deck ; } }
class Solution { public boolean flipEquiv ( TreeNode root1 , TreeNode root2 ) { if ( root1 == null ) return root2 == null ; if ( root2 == null ) return root1 == null ; if ( root1 . val != root2 . val ) return false ; return flipEquiv ( root1 . left , root2 . left ) && flipEquiv ( root1 . right , root2 . right ) || flipEquiv ( root1 . left , root2 . right ) && flipEquiv ( root1 . right , root2 . left ) ; } }
class UnionFind { public UnionFind ( int n ) { id = new int [ n + 1 ] ; for ( int i = 0 ; i < id . length ; ++ i ) id [ i ] = i ; } public void union ( int u , int v ) { id [ find ( u ) ] = find ( v ) ; } public int find ( int u ) { return id [ u ] == u ? u : ( id [ u ] = find ( id [ u ] ) ) ; } private int [ ] id ; } class Solution { public int largestComponentSize ( int [ ] A ) { final int n = Arrays . stream ( A ) . max ( ) . getAsInt ( ) ; int ans = 0 ; UnionFind uf = new UnionFind ( n ) ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( int a : A ) for ( int num = 2 ; num <= ( int ) Math . sqrt ( a ) ; ++ num ) if ( a % num == 0 ) { uf . union ( a , num ) ; uf . union ( a , a / num ) ; } for ( int a : A ) { int pa = uf . find ( a ) ; count . put ( pa , count . getOrDefault ( pa , 0 ) + 1 ) ; ans = Math . max ( ans , count . get ( pa ) ) ; } return ans ; } }
class Solution { public boolean isAlienSorted ( String [ ] words , String order ) { char [ ] map = new char [ 26 ] ; for ( int i = 0 ; i < 26 ; ++ i ) map [ order . charAt ( i ) - ' a ' ] = ( char ) ( i + ' a ' ) ; for ( int i = 0 ; i + 1 < words . length ; ++ i ) if ( bigger ( words [ i ] , words [ i + 1 ] , map ) ) return false ; return true ; } private boolean bigger ( final String s1 , final String s2 , final char [ ] map ) { for ( int i = 0 ; i < s1 . length ( ) && i < s2 . length ( ) ; ++ i ) if ( s1 . charAt ( i ) != s2 . charAt ( i ) ) return map [ s1 . charAt ( i ) - ' a ' ] > map [ s2 . charAt ( i ) - ' a ' ] ; return s1 . length ( ) > s2 . length ( ) ; } }
class Solution { public boolean canReorderDoubled ( int [ ] A ) { Map < Integer , Integer > count = new HashMap < > ( ) ; for ( final int a : A ) count . merge ( a , 1 , Integer :: sum ) ; A = Arrays . stream ( A ) . boxed ( ) . sorted ( ( a , b ) -> Math . abs ( a ) - Math . abs ( b ) ) . mapToInt ( i -> i ) . toArray ( ) ; for ( final int a : A ) { if ( count . get ( a ) == 0 ) continue ; if ( count . getOrDefault ( 2 * a , 0 ) == 0 ) return false ; count . merge ( a , - 1 , Integer :: sum ) ; count . merge ( 2 * a , - 1 , Integer :: sum ) ; } return true ; } }
class Solution { public int [ ] prisonAfterNDays ( int [ ] cells , int N ) { int [ ] firstDayCells = new int [ cells . length ] ; int [ ] nextDayCells = new int [ cells . length ] ; for ( int day = 0 ; N -- > 0 ; cells = nextDayCells . clone ( ) , ++ day ) { for ( int i = 1 ; i + 1 < cells . length ; ++ i ) nextDayCells [ i ] = cells [ i - 1 ] == cells [ i + 1 ] ? 1 : 0 ; if ( day == 0 ) firstDayCells = nextDayCells . clone ( ) ; else if ( Arrays . equals ( nextDayCells , firstDayCells ) ) N %= day ; } return cells ; } }
class Solution { public int numTrees ( int n ) { int [ ] G = new int [ n + 1 ] ; G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) G [ i ] += G [ j ] * G [ i - j - 1 ] ; return G [ n ] ; } }
class Solution { public int repeatedNTimes ( int [ ] A ) { for ( int i = 0 ; i + 2 < A . length ; ++ i ) if ( A [ i ] == A [ i + 1 ] || A [ i ] == A [ i + 2 ] ) return A [ i ] ; return A [ A . length - 1 ] ; } }
class Solution { public int maxWidthRamp ( int [ ] nums ) { int ans = 0 ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) if ( stack . isEmpty ( ) || nums [ i ] < nums [ stack . peek ( ) ] ) stack . push ( i ) ; for ( int i = nums . length - 1 ; i > ans ; -- i ) while ( ! stack . isEmpty ( ) && nums [ i ] >= nums [ stack . peek ( ) ] ) ans = Math . max ( ans , i - stack . pop ( ) ) ; return ans ; } }
class Solution { public double minAreaFreeRect ( int [ ] [ ] points ) { Long ans = Long . MAX_VALUE ; Map < Integer , List < int [ ] > > centerToPoints = new HashMap < > ( ) ; for ( int [ ] A : points ) for ( int [ ] B : points ) { int center = hash ( A , B ) ; if ( centerToPoints . get ( center ) == null ) centerToPoints . put ( center , new ArrayList < > ( ) ) ; centerToPoints . get ( center ) . add ( new int [ ] { A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] } ) ; } for ( List < int [ ] > pointPairs : centerToPoints . values ( ) ) for ( int [ ] ab : pointPairs ) for ( int [ ] cd : pointPairs ) { final int ax = ab [ 0 ] , ay = ab [ 1 ] ; final int cx = cd [ 0 ] , cy = cd [ 1 ] ; final int dx = cd [ 2 ] , dy = cd [ 3 ] ; if ( ( cx - ax ) * ( dx - ax ) + ( cy - ay ) * ( dy - ay ) == 0 ) { Long squaredArea = dist ( ax , ay , cx , cy ) * dist ( ax , ay , dx , dy ) ; if ( squaredArea > 0 ) ans = Math . min ( ans , squaredArea ) ; } } return ans == Long . MAX_VALUE ? 0 : Math . sqrt ( ans ) ; } private int hash ( int [ ] p , int [ ] q ) { return ( ( p [ 0 ] + q [ 0 ] ) << 16 ) + ( p [ 1 ] + q [ 1 ] ) ; } private Long dist ( long px , long py , long qx , long qy ) { return ( px - qx ) * ( px - qx ) + ( py - qy ) * ( py - qy ) ; } }
class Solution { public int leastOpsExpressTarget ( int x , int target ) { return dfs ( x , target ) ; } private Map < Integer , Integer > memo = new HashMap < > ( ) ; private int dfs ( int x , int target ) { if ( memo . containsKey ( target ) ) return memo . get ( target ) ; if ( x > target ) return Math . min ( 2 * target - 1 , 2 * ( x - target ) ) ; if ( x == target ) return 0 ; long prod = x ; int n = 0 ; while ( prod < target ) { prod *= x ; ++ n ; } if ( prod == target ) { memo . put ( target , n ) ; return memo . get ( target ) ; } int ans = dfs ( x , target - ( int ) ( prod / ( long ) x ) ) + n ; if ( prod < 2 * target ) ans = Math . min ( ans , dfs ( x , ( int ) ( prod - ( long ) target ) ) + n + 1 ) ; memo . put ( target , ans ) ; return ans ; } }
class Solution { public String [ ] spellchecker ( String [ ] wordlist , String [ ] queries ) { List < String > ans = new ArrayList < > ( ) ; Map < String , String > dict = new HashMap < > ( ) ; for ( final String word : wordlist ) { dict . putIfAbsent ( word , word ) ; dict . putIfAbsent ( lowerKey ( word ) , word ) ; dict . putIfAbsent ( vowelKey ( word ) , word ) ; } for ( final String q : queries ) if ( dict . containsKey ( q ) ) ans . add ( dict . get ( q ) ) ; else if ( dict . containsKey ( lowerKey ( q ) ) ) ans . add ( dict . get ( lowerKey ( q ) ) ) ; else if ( dict . containsKey ( vowelKey ( q ) ) ) ans . add ( dict . get ( vowelKey ( q ) ) ) ; else ans . add ( " " ) ; return ans . toArray ( new String [ 0 ] ) ; } private String lowerKey ( final String word ) { return " $ " + word . toLowerCase ( ) ; } private String vowelKey ( final String word ) { String s = " " ; for ( char c : word . toCharArray ( ) ) s += isVowel ( c ) ? ' * ' : Character . toLowerCase ( c ) ; return s ; } private boolean isVowel ( char c ) { c = Character . toLowerCase ( c ) ; return c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ; } }
class Solution { public List < Integer > pancakeSort ( int [ ] A ) { List < Integer > ans = new ArrayList < > ( ) ; for ( int target = A . length ; target >= 1 ; -- target ) { int index = find ( A , target ) ; reverse ( A , 0 , index ) ; reverse ( A , 0 , target - 1 ) ; ans . add ( index + 1 ) ; ans . add ( target ) ; } return ans ; } private int find ( int [ ] A , int target ) { for ( int i = 0 ; i < A . length ; ++ i ) if ( A [ i ] == target ) return i ; throw new IllegalArgumentException ( ) ; } private void reverse ( int [ ] A , int l , int r ) { while ( l < r ) swap ( A , l ++ , r -- ) ; } private void swap ( int [ ] A , int l , int r ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } }
class Solution { public boolean isInterleave ( String s1 , String s2 , String s3 ) { final int m = s1 . length ( ) ; final int n = s2 . length ( ) ; if ( m + n != s3 . length ( ) ) return false ; boolean [ ] [ ] dp = new boolean [ m + 1 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = true ; for ( int i = 1 ; i <= m ; ++ i ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] && s1 . charAt ( i - 1 ) == s3 . charAt ( i - 1 ) ; for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] && s2 . charAt ( j - 1 ) == s3 . charAt ( j - 1 ) ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] && s1 . charAt ( i - 1 ) == s3 . charAt ( i + j - 1 ) || dp [ i ] [ j - 1 ] && s2 . charAt ( j - 1 ) == s3 . charAt ( i + j - 1 ) ; return dp [ m ] [ n ] ; } }
class Solution { public List < Integer > powerfulIntegers ( int x , int y , int bound ) { Set < Integer > ans = new HashSet < > ( ) ; for ( int i = 1 ; i < bound ; i *= x ) { for ( int j = 1 ; i + j <= bound ; j *= y ) { ans . add ( i + j ) ; if ( y == 1 ) break ; } if ( x == 1 ) break ; } return new ArrayList < > ( ans ) ; } }
class Solution { public boolean isRationalEqual ( String S , String T ) { return Math . abs ( valueOf ( S ) - valueOf ( T ) ) < 1e-9 ; } private double [ ] ratios = new double [ ] { 1.0 , 1.0 / 9 , 1.0 / 99 , 1.0 / 999 , 1.0 / 9999 } ; private double valueOf ( final String s ) { if ( ! s . contains ( " ( " ) ) return Double . valueOf ( s ) ; double integer_nonRepeating = Double . valueOf ( s . substring ( 0 , s . indexOf ( ' ( ' ) ) ) ; int nonRepeatingLength = s . indexOf ( ' ( ' ) - s . indexOf ( ' . ' ) - 1 ; int repeating = Integer . parseInt ( s . substring ( s . indexOf ( ' ( ' ) + 1 , s . indexOf ( ' ) ' ) ) ) ; int repeatingLength = s . indexOf ( ' ) ' ) - s . indexOf ( ' ( ' ) - 1 ; return integer_nonRepeating + repeating * Math . pow ( 0.1 , nonRepeatingLength ) * ratios [ repeatingLength ] ; } }
class Solution { public int [ ] [ ] kClosest ( int [ ] [ ] points , int K ) { int [ ] [ ] ans = new int [ K ] [ 2 ] ; PriorityQueue < int [ ] > maxHeap = new PriorityQueue < > ( ( a , b ) -> squareDist ( b ) - squareDist ( a ) ) ; for ( int [ ] p : points ) { maxHeap . offer ( p ) ; if ( maxHeap . size ( ) > K ) maxHeap . poll ( ) ; } int i = K ; while ( ! maxHeap . isEmpty ( ) ) ans [ -- i ] = maxHeap . poll ( ) ; return ans ; } private int squareDist ( int [ ] p ) { return p [ 0 ] * p [ 0 ] + p [ 1 ] * p [ 1 ] ; } }
class Solution { public int subarraysDivByK ( int [ ] A , int K ) { int ans = 0 ; int prefix = 0 ; int [ ] count = new int [ K ] ; count [ 0 ] = 1 ; for ( int a : A ) { prefix = ( prefix + a % K + K ) % K ; ans += count [ prefix ] ; ++ count [ prefix ] ; } return ans ; } }
class Solution { public int largestPerimeter ( int [ ] A ) { Arrays . sort ( A ) ; for ( int i = A . length - 1 ; i > 1 ; -- i ) if ( A [ i - 2 ] + A [ i - 1 ] > A [ i ] ) return A [ i - 2 ] + A [ i - 1 ] + A [ i ] ; return 0 ; } }
class Solution { public int [ ] sortedSquares ( int [ ] A ) { final int n = A . length ; int [ ] ans = new int [ n ] ; int i = n - 1 ; for ( int l = 0 , r = n - 1 ; l <= r ; ) if ( Math . abs ( A [ l ] ) > Math . abs ( A [ r ] ) ) ans [ i -- ] = A [ l ] * A [ l ++ ] ; else ans [ i -- ] = A [ r ] * A [ r -- ] ; return ans ; } }
class Solution { public int maxTurbulenceSize ( int [ ] A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . length ; ++ i ) { if ( A [ i ] > A [ i - 1 ] ) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ] ) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = Math . max ( ans , Math . max ( increasing , decreasing ) ) ; } return ans ; } }
class Solution { public boolean isValidBST ( TreeNode root ) { return isValidBST ( root , null , null ) ; } private boolean isValidBST ( TreeNode root , TreeNode minNode , TreeNode maxNode ) { if ( root == null ) return true ; if ( minNode != null && root . val <= minNode . val ) return false ; if ( maxNode != null && root . val >= maxNode . val ) return false ; return isValidBST ( root . left , minNode , root ) && isValidBST ( root . right , root , maxNode ) ; } }
class T { public String value ; public int timestamp ; public T ( String value , int timestamp ) { this . value = value ; this . timestamp = timestamp ; } } class TimeMap { public void set ( String key , String value , int timestamp ) { map . putIfAbsent ( key , new ArrayList < > ( ) ) ; map . get ( key ) . add ( new T ( value , timestamp ) ) ; } public String get ( String key , int timestamp ) { List < T > A = map . get ( key ) ; if ( A == null ) return " " ; int l = 0 ; int r = A . size ( ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A . get ( m ) . timestamp > timestamp ) r = m ; else l = m + 1 ; } return l == 0 ? " " : A . get ( l - 1 ) . value ; } private Map < String , List < T > > map = new HashMap < > ( ) ; }
class Solution { public int mincostTickets ( int [ ] days , int [ ] costs ) { int ans = 0 ; Queue < int [ ] > last7 = new ArrayDeque < > ( ) ; Queue < int [ ] > last30 = new ArrayDeque < > ( ) ; for ( int day : days ) { while ( ! last7 . isEmpty ( ) && last7 . peek ( ) [ 0 ] + 7 <= day ) last7 . poll ( ) ; while ( ! last30 . isEmpty ( ) && last30 . peek ( ) [ 0 ] + 30 <= day ) last30 . poll ( ) ; last7 . offer ( new int [ ] { day , ans + costs [ 1 ] } ) ; last30 . offer ( new int [ ] { day , ans + costs [ 2 ] } ) ; ans = Math . min ( ans + costs [ 0 ] , Math . min ( last7 . peek ( ) [ 1 ] , last30 . peek ( ) [ 1 ] ) ) ; } return ans ; } }
class Solution { public int [ ] sumEvenAfterQueries ( int [ ] A , int [ ] [ ] queries ) { int [ ] ans = new int [ queries . length ] ; int sum = 0 ; for ( int a : A ) sum += a % 2 == 0 ? a : 0 ; for ( int i = 0 ; i < queries . length ; ++ i ) { if ( A [ queries [ i ] [ 1 ] ] % 2 == 0 ) sum -= A [ queries [ i ] [ 1 ] ] ; A [ queries [ i ] [ 1 ] ] += queries [ i ] [ 0 ] ; if ( A [ queries [ i ] [ 1 ] ] % 2 == 0 ) sum += A [ queries [ i ] [ 1 ] ] ; ans [ i ] = sum ; } return ans ; } }
class Solution { public int [ ] [ ] intervalIntersection ( int [ ] [ ] firstList , int [ ] [ ] secondList ) { List < int [ ] > ans = new ArrayList < > ( ) ; short i = 0 ; short j = 0 ; while ( i < firstList . length && j < secondList . length ) { final int lo = Math . max ( firstList [ i ] [ 0 ] , secondList [ j ] [ 0 ] ) ; final int hi = Math . min ( firstList [ i ] [ 1 ] , secondList [ j ] [ 1 ] ) ; if ( lo <= hi ) ans . add ( new int [ ] { lo , hi } ) ; if ( firstList [ i ] [ 1 ] < secondList [ j ] [ 1 ] ) ++ i ; else ++ j ; } return ans . toArray ( new int [ ans . size ( ) ] [ ] ) ; } }
class Solution { public List < List < Integer > > verticalTraversal ( TreeNode root ) { List < List < Integer > > ans = new ArrayList < > ( ) ; TreeMap < Integer , List < int [ ] > > xToSortedPairs = new TreeMap < > ( ) ; dfs ( root , 0 , 0 , xToSortedPairs ) ; for ( List < int [ ] > pairs : xToSortedPairs . values ( ) ) { Collections . sort ( pairs , ( a , b ) -> a [ 0 ] == b [ 0 ] ? a [ 1 ] - b [ 1 ] : a [ 0 ] - b [ 0 ] ) ; List < Integer > vals = new ArrayList < > ( ) ; for ( int [ ] pair : pairs ) vals . add ( pair [ 1 ] ) ; ans . add ( vals ) ; } return ans ; } private void dfs ( TreeNode root , int x , int y , TreeMap < Integer , List < int [ ] > > xToSortedPairs ) { if ( root == null ) return ; xToSortedPairs . putIfAbsent ( x , new ArrayList < > ( ) ) ; xToSortedPairs . get ( x ) . add ( new int [ ] { y , root . val } ) ; dfs ( root . left , x - 1 , y + 1 , xToSortedPairs ) ; dfs ( root . right , x + 1 , y + 1 , xToSortedPairs ) ; } }
class Solution { public List < Integer > addToArrayForm ( int [ ] num , int k ) { List < Integer > ans = new LinkedList < > ( ) ; for ( int i = num . length - 1 ; i >= 0 ; -- i ) { ans . add ( 0 , ( num [ i ] + k ) % 10 ) ; k = ( num [ i ] + k ) / 10 ; } while ( k > 0 ) { ans . add ( 0 , k % 10 ) ; k /= 10 ; } return ans ; } }
class Solution { public void recoverTree ( TreeNode root ) { inorder ( root ) ; swap ( x , y ) ; } private TreeNode pred = null ; private TreeNode x = null ; private TreeNode y = null ; private void inorder ( TreeNode root ) { if ( root == null ) return ; inorder ( root . left ) ; if ( pred != null && root . val < pred . val ) { y = root ; if ( x == null ) x = pred ; else return ; } pred = root ; inorder ( root . right ) ; } private void swap ( TreeNode x , TreeNode y ) { final int temp = x . val ; x . val = y . val ; y . val = temp ; } }
class UnionFind { public int [ ] id ; public UnionFind ( int n ) { id = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) id [ i ] = i ; } public void union ( int u , int v ) { id [ find ( u ) ] = find ( v ) ; } public int find ( int u ) { return id [ u ] == u ? u : ( id [ u ] = find ( id [ u ] ) ) ; } } class Solution { public boolean equationsPossible ( String [ ] equations ) { UnionFind uf = new UnionFind ( 26 ) ; for ( final String e : equations ) if ( e . charAt ( 1 ) == ' = ' ) { final int x = e . charAt ( 0 ) - ' a ' ; final int y = e . charAt ( 3 ) - ' a ' ; uf . union ( x , y ) ; } for ( final String e : equations ) if ( e . charAt ( 1 ) == ' ! ' ) { final int x = e . charAt ( 0 ) - ' a ' ; final int y = e . charAt ( 3 ) - ' a ' ; if ( uf . find ( x ) == uf . find ( y ) ) return false ; } return true ; } }
class Solution { public int brokenCalc ( int X , int Y ) { int ops = 0 ; while ( X < Y ) { if ( Y % 2 == 0 ) Y /= 2 ; else Y += 1 ; ++ ops ; } return ops + X - Y ; } }
class Solution { public int subarraysWithKDistinct ( int [ ] A , int K ) { return subarraysWithAtMostKDistinct ( A , K ) - subarraysWithAtMostKDistinct ( A , K - 1 ) ; } private int subarraysWithAtMostKDistinct ( int [ ] A , int K ) { int ans = 0 ; int [ ] count = new int [ A . length + 1 ] ; for ( int l = 0 , r = 0 ; r < A . length ; ++ r ) { if ( ++ count [ A [ r ] ] == 1 ) -- K ; while ( K == - 1 ) if ( -- count [ A [ l ++ ] ] == 0 ) ++ K ; ans += r - l + 1 ; } return ans ; } }
class Solution { public int minKBitFlips ( int [ ] A , int K ) { int ans = 0 ; int flippedTime = 0 ; for ( int r = 0 ; r < A . length ; ++ r ) { if ( r >= K && A [ r - K ] == 2 ) -- flippedTime ; if ( flippedTime % 2 == A [ r ] ) { if ( r + K > A . length ) return - 1 ; ++ ans ; ++ flippedTime ; A [ r ] = 2 ; } } return ans ; } }
class Solution { public int numSquarefulPerms ( int [ ] A ) { boolean [ ] used = new boolean [ A . length ] ; Arrays . sort ( A ) ; dfs ( A , used , new ArrayList < > ( ) ) ; return ans ; } private int ans = 0 ; private void dfs ( int [ ] A , boolean [ ] used , List < Integer > path ) { if ( path . size ( ) > 1 && ! isSquare ( path . get ( path . size ( ) - 1 ) + path . get ( path . size ( ) - 2 ) ) ) return ; if ( path . size ( ) == A . length ) { ++ ans ; return ; } for ( int i = 0 ; i < A . length ; ++ i ) { if ( used [ i ] ) continue ; if ( i > 0 && A [ i ] == A [ i - 1 ] && ! used [ i - 1 ] ) continue ; used [ i ] = true ; path . add ( A [ i ] ) ; dfs ( A , used , path ) ; path . remove ( path . size ( ) - 1 ) ; used [ i ] = false ; } } private boolean isSquare ( int num ) { int root = ( int ) Math . sqrt ( num ) ; return root * root == num ; } }
class Solution { public int findJudge ( int n , int [ ] [ ] trust ) { int [ ] count = new int [ n + 1 ] ; for ( int [ ] t : trust ) { -- count [ t [ 0 ] ] ; ++ count [ t [ 1 ] ] ; } for ( int i = 1 ; i < n + 1 ; ++ i ) if ( count [ i ] == n - 1 ) return i ; return - 1 ; } }
class Solution { public TreeNode insertIntoMaxTree ( TreeNode root , int val ) { if ( root == null ) return new TreeNode ( val ) ; if ( root . val < val ) return new TreeNode ( val , root , null ) ; root . right = insertIntoMaxTree ( root . right , val ) ; return root ; } }
class Solution { public int numRookCaptures ( char [ ] [ ] board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) for ( int j = 0 ; j < 8 ; ++ j ) if ( board [ i ] [ j ] == ' R ' ) { i0 = i ; j0 = j ; } for ( int [ ] d : new int [ ] [ ] { { 1 , 0 } , { 0 , 1 } , { - 1 , 0 } , { 0 , - 1 } } ) for ( int i = i0 + d [ 0 ] , j = j0 + d [ 1 ] ; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ] , j += d [ 1 ] ) { if ( board [ i ] [ j ] == ' p ' ) ++ ans ; if ( board [ i ] [ j ] != ' . ' ) break ; } return ans ; } }
