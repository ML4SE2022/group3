class Solution : NEW_LINE INDENT def combine ( self , n : int , k : int ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( s : int , path : List [ int ] ) -> None : NEW_LINE INDENT if len ( path ) == k : NEW_LINE INDENT ans . append ( path . copy ( ) ) NEW_LINE return NEW_LINE DEDENT for i in range ( s , n + 1 ) : NEW_LINE INDENT path . append ( i ) NEW_LINE dfs ( i + 1 , path ) NEW_LINE path . pop ( ) NEW_LINE DEDENT DEDENT dfs ( 1 , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Poly : NEW_LINE INDENT def __init__ ( self , term : str = None , coef : int = None ) : NEW_LINE INDENT if term and coef : NEW_LINE INDENT self . terms = Counter ( { term : coef } ) NEW_LINE DEDENT else : NEW_LINE INDENT self . terms = Counter ( ) NEW_LINE DEDENT DEDENT def __add__ ( self , other ) : NEW_LINE INDENT for term , coef in other . terms . items ( ) : NEW_LINE INDENT self . terms [ term ] += coef NEW_LINE DEDENT return self NEW_LINE DEDENT def __sub__ ( self , other ) : NEW_LINE INDENT for term , coef in other . terms . items ( ) : NEW_LINE INDENT self . terms [ term ] -= coef NEW_LINE DEDENT return self NEW_LINE DEDENT def __mul__ ( self , other ) : NEW_LINE INDENT res = Poly ( ) NEW_LINE for a , aCoef in self . terms . items ( ) : NEW_LINE INDENT for b , bCoef in other . terms . items ( ) : NEW_LINE INDENT res . terms [ self . _merge ( a , b ) ] += aCoef * bCoef NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def toList ( self ) -> List [ str ] : NEW_LINE INDENT for term in list ( self . terms . keys ( ) ) : NEW_LINE INDENT if not self . terms [ term ] : NEW_LINE INDENT del self . terms [ term ] NEW_LINE DEDENT DEDENT def cmp ( term : str ) -> tuple : NEW_LINE INDENT if term == '1' : NEW_LINE INDENT return ( 0 , ) NEW_LINE DEDENT var = term . split ( ' * ' ) NEW_LINE return ( - len ( var ) , term ) NEW_LINE DEDENT def concat ( term : str ) -> str : NEW_LINE INDENT if term == '1' : NEW_LINE INDENT return str ( self . terms [ term ] ) NEW_LINE DEDENT return str ( self . terms [ term ] ) + ' * ' + term NEW_LINE DEDENT terms = list ( self . terms . keys ( ) ) NEW_LINE terms . sort ( key = cmp ) NEW_LINE return [ concat ( term ) for term in terms ] NEW_LINE DEDENT def _merge ( self , a : str , b : str ) -> str : NEW_LINE INDENT if a == '1' : NEW_LINE INDENT return b NEW_LINE DEDENT if b == '1' : NEW_LINE INDENT return a NEW_LINE DEDENT res = [ ] NEW_LINE A = a . split ( ' * ' ) NEW_LINE B = b . split ( ' * ' ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( A ) and j < len ( B ) : NEW_LINE INDENT if A [ i ] < B [ j ] : NEW_LINE INDENT res . append ( A [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( B [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ' * ' . join ( res + A [ i : ] + B [ j : ] ) NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def basicCalculatorIV ( self , expression : str , evalvars : List [ str ] , evalints : List [ int ] ) -> List [ str ] : NEW_LINE INDENT tokens = list ( self . _getTokens ( expression ) ) NEW_LINE evalMap = { a : b for a , b in zip ( evalvars , evalints ) } NEW_LINE for i , token in enumerate ( tokens ) : NEW_LINE INDENT if token in evalMap : NEW_LINE INDENT tokens [ i ] = str ( evalMap [ token ] ) NEW_LINE DEDENT DEDENT postfix = self . _infixToPostfix ( tokens ) NEW_LINE return self . _evaluate ( postfix ) . toList ( ) NEW_LINE DEDENT def _getTokens ( self , s : str ) -> Iterator [ str ] : NEW_LINE INDENT i = 0 NEW_LINE for j , c in enumerate ( s ) : NEW_LINE INDENT if c == ' ‚ñÅ ' : NEW_LINE INDENT if i < j : NEW_LINE INDENT yield s [ i : j ] NEW_LINE DEDENT i = j + 1 NEW_LINE DEDENT elif c in ' ( ) + - * ' : NEW_LINE INDENT if i < j : NEW_LINE INDENT yield s [ i : j ] NEW_LINE DEDENT yield c NEW_LINE i = j + 1 NEW_LINE DEDENT DEDENT if i < len ( s ) : NEW_LINE INDENT yield s [ i : ] NEW_LINE DEDENT DEDENT def _infixToPostfix ( self , tokens : List [ str ] ) -> List [ str ] : NEW_LINE INDENT postfix = [ ] NEW_LINE ops = [ ] NEW_LINE def precedes ( prevOp : chr , currOp : chr ) -> bool : NEW_LINE INDENT if prevOp == ' ( ' : NEW_LINE INDENT return False NEW_LINE DEDENT return prevOp == ' * ' or currOp in ' + - ' NEW_LINE DEDENT for token in tokens : NEW_LINE INDENT if token == ' ( ' : NEW_LINE INDENT ops . append ( token ) NEW_LINE DEDENT elif token == ' ) ' : NEW_LINE INDENT while ops [ - 1 ] != ' ( ' : NEW_LINE INDENT postfix . append ( ops . pop ( ) ) NEW_LINE DEDENT ops . pop ( ) NEW_LINE DEDENT elif token in ' + - * ' : NEW_LINE INDENT while ops and precedes ( ops [ - 1 ] , token ) : NEW_LINE INDENT postfix . append ( ops . pop ( ) ) NEW_LINE DEDENT ops . append ( token ) NEW_LINE DEDENT else : NEW_LINE INDENT postfix . append ( token ) NEW_LINE DEDENT DEDENT return postfix + ops [ : : - 1 ] NEW_LINE DEDENT def _evaluate ( self , postfix : List [ str ] ) -> Poly : NEW_LINE INDENT polys : List [ Poly ] = [ ] NEW_LINE for token in postfix : NEW_LINE INDENT if token in ' + - * ' : NEW_LINE INDENT b = polys . pop ( ) NEW_LINE a = polys . pop ( ) NEW_LINE if token == ' + ' : NEW_LINE INDENT polys . append ( a + b ) NEW_LINE DEDENT elif token == ' - ' : NEW_LINE INDENT polys . append ( a - b ) NEW_LINE DEDENT else : NEW_LINE INDENT polys . append ( a * b ) NEW_LINE DEDENT DEDENT elif token . lstrip ( ' - ' ) . isnumeric ( ) : NEW_LINE INDENT polys . append ( Poly ( "1" , int ( token ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT polys . append ( Poly ( token , 1 ) ) NEW_LINE DEDENT DEDENT return polys [ 0 ] NEW_LINE DEDENT DEDENT
