import sys , math NEW_LINE n = 3 if len ( sys . argv ) == 1 else int ( sys . argv [ 1 ] ) NEW_LINE s = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT s += math . gcd ( x , y ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE
doors = [ False ] * 100 NEW_LINE for i in range ( 100 ) : NEW_LINE INDENT for j in range ( i , 100 , i + 1 ) : NEW_LINE INDENT doors [ j ] = not doors [ j ] NEW_LINE DEDENT print ( " Door ▁ % d : " % ( i + 1 ) , ' open ' if doors [ i ] else ' close ' ) NEW_LINE DEDENT
def play_random ( n ) : NEW_LINE INDENT pardoned = 0 NEW_LINE in_drawer = list ( range ( 100 ) ) NEW_LINE sampler = list ( range ( 100 ) ) NEW_LINE for _round in range ( n ) : NEW_LINE INDENT random . shuffle ( in_drawer ) NEW_LINE found = False NEW_LINE for prisoner in range ( 100 ) : NEW_LINE INDENT found = False NEW_LINE for reveal in random . sample ( sampler , 50 ) : NEW_LINE INDENT card = in_drawer [ reveal ] NEW_LINE if card == prisoner : NEW_LINE INDENT found = True NEW_LINE break NEW_LINE DEDENT DEDENT if not found : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if found : NEW_LINE INDENT pardoned += 1 NEW_LINE DEDENT DEDENT return pardoned / n * 100 NEW_LINE DEDENT
def play_optimal ( n ) : NEW_LINE INDENT pardoned = 0 NEW_LINE in_drawer = list ( range ( 100 ) ) NEW_LINE for _round in range ( n ) : NEW_LINE INDENT random . shuffle ( in_drawer ) NEW_LINE for prisoner in range ( 100 ) : NEW_LINE INDENT reveal = prisoner NEW_LINE found = False NEW_LINE for go in range ( 50 ) : NEW_LINE INDENT card = in_drawer [ reveal ] NEW_LINE if card == prisoner : NEW_LINE INDENT found = True NEW_LINE break NEW_LINE DEDENT reveal = card NEW_LINE DEDENT if not found : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if found : NEW_LINE INDENT pardoned += 1 NEW_LINE DEDENT DEDENT return pardoned / n * 100 NEW_LINE DEDENT
from random import randint NEW_LINE class Puzzle : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . items = { } NEW_LINE self . position = None NEW_LINE DEDENT def main_frame ( self ) : NEW_LINE INDENT d = self . items NEW_LINE print ( ' + - - - - - + - - - - - + - - - - - + - - - - - + ' ) NEW_LINE print ( ' | % s | % s | % s | % s | ' % ( d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] ) ) NEW_LINE print ( ' + - - - - - + - - - - - + - - - - - + - - - - - + ' ) NEW_LINE print ( ' | % s | % s | % s | % s | ' % ( d [ 5 ] , d [ 6 ] , d [ 7 ] , d [ 8 ] ) ) NEW_LINE print ( ' + - - - - - + - - - - - + - - - - - + - - - - - + ' ) NEW_LINE print ( ' | % s | % s | % s | % s | ' % ( d [ 9 ] , d [ 10 ] , d [ 11 ] , d [ 12 ] ) ) NEW_LINE print ( ' + - - - - - + - - - - - + - - - - - + - - - - - + ' ) NEW_LINE print ( ' | % s | % s | % s | % s | ' % ( d [ 13 ] , d [ 14 ] , d [ 15 ] , d [ 16 ] ) ) NEW_LINE print ( ' + - - - - - + - - - - - + - - - - - + - - - - - + ' ) NEW_LINE DEDENT def format ( self , ch ) : NEW_LINE INDENT ch = ch . strip ( ) NEW_LINE if len ( ch ) == 1 : NEW_LINE INDENT return ' ▁ ▁ ' + ch + ' ▁ ▁ ' NEW_LINE DEDENT elif len ( ch ) == 2 : NEW_LINE INDENT return ' ▁ ▁ ' + ch + ' ▁ ' NEW_LINE DEDENT elif len ( ch ) == 0 : NEW_LINE INDENT return ' ▁ ▁ ▁ ▁ ▁ ' NEW_LINE DEDENT DEDENT def change ( self , to ) : NEW_LINE INDENT fro = self . position NEW_LINE for a , b in self . items . items ( ) : NEW_LINE INDENT if b == self . format ( str ( to ) ) : NEW_LINE INDENT to = a NEW_LINE break NEW_LINE DEDENT DEDENT self . items [ fro ] , self . items [ to ] = self . items [ to ] , self . items [ fro ] NEW_LINE self . position = to NEW_LINE DEDENT def build_board ( self , difficulty ) : NEW_LINE INDENT for i in range ( 1 , 17 ) : NEW_LINE INDENT self . items [ i ] = self . format ( str ( i ) ) NEW_LINE DEDENT tmp = 0 NEW_LINE for a , b in self . items . items ( ) : NEW_LINE INDENT if b == ' ▁ ▁ 16 ▁ ' : NEW_LINE INDENT self . items [ a ] = ' ▁ ▁ ▁ ▁ ▁ ' NEW_LINE tmp = a NEW_LINE break NEW_LINE DEDENT DEDENT self . position = tmp NEW_LINE if difficulty == 0 : NEW_LINE INDENT diff = 10 NEW_LINE DEDENT elif difficulty == 1 : NEW_LINE INDENT diff = 50 NEW_LINE DEDENT else : NEW_LINE INDENT diff = 100 NEW_LINE DEDENT for _ in range ( diff ) : NEW_LINE INDENT lst = self . valid_moves ( ) NEW_LINE lst1 = [ ] NEW_LINE for j in lst : NEW_LINE INDENT lst1 . append ( int ( j . strip ( ) ) ) NEW_LINE DEDENT self . change ( lst1 [ randint ( 0 , len ( lst1 ) - 1 ) ] ) NEW_LINE DEDENT DEDENT def valid_moves ( self ) : NEW_LINE INDENT pos = self . position NEW_LINE if pos in [ 6 , 7 , 10 , 11 ] : NEW_LINE INDENT return self . items [ pos - 4 ] , self . items [ pos - 1 ] , self . items [ pos + 1 ] , self . items [ pos + 4 ] NEW_LINE DEDENT elif pos in [ 5 , 9 ] : NEW_LINE INDENT return self . items [ pos - 4 ] , self . items [ pos + 4 ] , self . items [ pos + 1 ] NEW_LINE DEDENT elif pos in [ 8 , 12 ] : NEW_LINE INDENT return self . items [ pos - 4 ] , self . items [ pos + 4 ] , self . items [ pos - 1 ] NEW_LINE DEDENT elif pos in [ 2 , 3 ] : NEW_LINE INDENT return self . items [ pos - 1 ] , self . items [ pos + 1 ] , self . items [ pos + 4 ] NEW_LINE DEDENT elif pos in [ 14 , 15 ] : NEW_LINE INDENT return self . items [ pos - 1 ] , self . items [ pos + 1 ] , self . items [ pos - 4 ] NEW_LINE DEDENT elif pos == 1 : NEW_LINE INDENT return self . items [ pos + 1 ] , self . items [ pos + 4 ] NEW_LINE DEDENT elif pos == 4 : NEW_LINE INDENT return self . items [ pos - 1 ] , self . items [ pos + 4 ] NEW_LINE DEDENT elif pos == 13 : NEW_LINE INDENT return self . items [ pos + 1 ] , self . items [ pos - 4 ] NEW_LINE DEDENT elif pos == 16 : NEW_LINE INDENT return self . items [ pos - 1 ] , self . items [ pos - 4 ] NEW_LINE DEDENT DEDENT def game_over ( self ) : NEW_LINE INDENT flag = False NEW_LINE for a , b in self . items . items ( ) : NEW_LINE INDENT if b == ' ▁ ▁ ▁ ▁ ▁ ' : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT if a == int ( b . strip ( ) ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT DEDENT return flag NEW_LINE DEDENT DEDENT g = Puzzle ( ) NEW_LINE g . build_board ( int ( input ( ' Enter ▁ the ▁ difficulty  : ▁ 0 ▁ 1 ▁ 2 \n 2 ▁ ' ' = > ▁ highest ▁ 0 = > ▁ lowest \n ' ) ) ) NEW_LINE g . main_frame ( ) NEW_LINE print ( ' Enter ▁ 0 ▁ to ▁ exit ' ) NEW_LINE while True : NEW_LINE INDENT print ( ' Hello ▁ user : \n To ▁ change ▁ the ▁ position ▁ just ▁ enter ▁ the ▁ no . ▁ near ▁ it ' ) NEW_LINE lst = g . valid_moves ( ) NEW_LINE lst1 = [ ] NEW_LINE for i in lst : NEW_LINE INDENT lst1 . append ( int ( i . strip ( ) ) ) NEW_LINE print ( i . strip ( ) , ' \t ' , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE x = int ( input ( ) ) NEW_LINE if x == 0 : NEW_LINE INDENT break NEW_LINE DEDENT elif x not in lst1 : NEW_LINE INDENT print ( ' Wrong ▁ move ' ) NEW_LINE DEDENT else : NEW_LINE INDENT g . change ( x ) NEW_LINE DEDENT g . main_frame ( ) NEW_LINE if g . game_over ( ) : NEW_LINE INDENT print ( ' You ▁ WON ' ) NEW_LINE break NEW_LINE DEDENT DEDENT
def main ( stdscr ) : NEW_LINE INDENT curses . use_default_colors ( ) NEW_LINE game_field = GameField ( win = 32 ) NEW_LINE state_actions = { } NEW_LINE def init ( ) : NEW_LINE INDENT game_field . reset ( ) NEW_LINE return ' Game ' NEW_LINE DEDENT state_actions [ ' Init ' ] = init NEW_LINE def not_game ( state ) : NEW_LINE INDENT game_field . draw ( stdscr ) NEW_LINE action = get_user_action ( stdscr ) NEW_LINE responses = defaultdict ( lambda : state ) NEW_LINE responses [ ' Restart ' ] , responses [ ' Exit ' ] = ' Init ' , ' Exit ' NEW_LINE return responses [ action ] NEW_LINE DEDENT state_actions [ ' Win ' ] = lambda : not_game ( ' Win ' ) NEW_LINE state_actions [ ' Gameover ' ] = lambda : not_game ( ' Gameover ' ) NEW_LINE def game ( ) : NEW_LINE INDENT game_field . draw ( stdscr ) NEW_LINE action = get_user_action ( stdscr ) NEW_LINE if action == ' Restart ' : NEW_LINE INDENT return ' Init ' NEW_LINE DEDENT if action == ' Exit ' : NEW_LINE INDENT return ' Exit ' NEW_LINE DEDENT if game_field . move ( action ) : NEW_LINE INDENT if game_field . is_win ( ) : NEW_LINE INDENT return ' Win ' NEW_LINE DEDENT if game_field . is_gameover ( ) : NEW_LINE INDENT return ' Gameover ' NEW_LINE DEDENT DEDENT return ' Game ' NEW_LINE DEDENT state_actions [ ' Game ' ] = game NEW_LINE state = ' Init ' NEW_LINE while state != ' Exit ' : NEW_LINE INDENT state = state_actions [ state ] ( ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT digits = choose4 ( ) NEW_LINE welcome ( digits ) NEW_LINE trial = 0 NEW_LINE answer = ' ' NEW_LINE chk = ans = False NEW_LINE while not ( chk and ans == 24 ) : NEW_LINE INDENT trial += 1 NEW_LINE answer = input ( " Expression ▁ % i : ▁ " % trial ) NEW_LINE chk = check ( answer , digits ) NEW_LINE if answer . lower ( ) == ' q ' : NEW_LINE INDENT break NEW_LINE DEDENT if answer == ' ! ' : NEW_LINE INDENT digits = choose4 ( ) NEW_LINE print ( " New ▁ digits : " , ' ▁ ' . join ( digits ) ) NEW_LINE continue NEW_LINE DEDENT if not chk : NEW_LINE INDENT print ( " The ▁ input ▁ ' % s ' ▁ was ▁ wonky ! " % answer ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = eval ( answer ) NEW_LINE print ( " ▁ = ▁ " , ans ) NEW_LINE if ans == 24 : NEW_LINE INDENT print ( " Thats ▁ right ! " ) NEW_LINE DEDENT DEDENT DEDENT print ( " Thank ▁ you ▁ and ▁ goodbye " ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT digits = choose4 ( ) NEW_LINE welcome ( digits ) NEW_LINE trial = 0 NEW_LINE answer = ' ' NEW_LINE chk = ans = False NEW_LINE while not ( chk and ans == 24 ) : NEW_LINE INDENT trial += 1 NEW_LINE answer = input ( " Expression ▁ % i : ▁ " % trial ) NEW_LINE chk = check ( answer , digits ) NEW_LINE if answer == ' ? ' : NEW_LINE INDENT solve ( digits ) NEW_LINE answer = ' ! ' NEW_LINE DEDENT if answer . lower ( ) == ' q ' : NEW_LINE INDENT break NEW_LINE DEDENT if answer == ' ! ' : NEW_LINE INDENT digits = choose4 ( ) NEW_LINE trial = 0 NEW_LINE print ( " \n New ▁ digits : " , ' ▁ ' . join ( digits ) ) NEW_LINE continue NEW_LINE DEDENT if answer == ' ! ! ' : NEW_LINE INDENT digits = ask4 ( ) NEW_LINE trial = 0 NEW_LINE print ( " \n New ▁ digits : " , ' ▁ ' . join ( digits ) ) NEW_LINE continue NEW_LINE DEDENT if not chk : NEW_LINE INDENT print ( " The ▁ input ▁ ' % s ' ▁ was ▁ wonky ! " % answer ) NEW_LINE DEDENT else : NEW_LINE INDENT if ' / ' in answer : NEW_LINE INDENT answer = ' ' . join ( ( ( ' F ( % s ) ' % char ) if char in '123456789' else char ) for char in answer ) NEW_LINE DEDENT ans = eval ( answer ) NEW_LINE print ( " ▁ = ▁ " , ans ) NEW_LINE if ans == 24 : NEW_LINE INDENT print ( " Thats ▁ right ! " ) NEW_LINE DEDENT DEDENT DEDENT print ( " Thank ▁ you ▁ and ▁ goodbye " ) NEW_LINE DEDENT
def cumu ( n ) : NEW_LINE INDENT for l in range ( len ( cache ) , n + 1 ) : NEW_LINE INDENT r = [ 0 ] NEW_LINE for x in range ( 1 , l + 1 ) : NEW_LINE INDENT r . append ( r [ - 1 ] + cache [ l - x ] [ min ( x , l - x ) ] ) NEW_LINE DEDENT cache . append ( r ) NEW_LINE DEDENT return cache [ n ] NEW_LINE DEDENT
def row ( n ) : NEW_LINE INDENT r = cumu ( n ) NEW_LINE return [ r [ i + 1 ] - r [ i ] for i in range ( n ) ] NEW_LINE DEDENT
for i in range ( 99 , 0 , - 1 ) : b = ' bottles ▁ of ▁ beer ' ; w = b + ' ▁ on ▁ the ▁ wall ' ; print ( f ' { i } ▁ { w } , ▁ { i } ▁ { b } \n Take ▁ one ▁ down ▁ and ▁ pass ▁ it ▁ around , ▁ { i ▁ - ▁ 1 } ▁ { w } . \n ' ) NEW_LINE
try : raw_input NEW_LINE except : raw_input = input NEW_LINE print ( sum ( map ( int , raw_input ( ) . split ( ) ) ) ) NEW_LINE
def can_make_word ( word , block_collection = blocks ) : NEW_LINE INDENT if not word : NEW_LINE INDENT return False NEW_LINE DEDENT blocks_remaining = block_collection [ : ] NEW_LINE for char in word . upper ( ) : NEW_LINE INDENT for block in blocks_remaining : NEW_LINE INDENT if char in block : NEW_LINE INDENT blocks_remaining . remove ( block ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
class BaseQueue ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . contents = list ( ) NEW_LINE raise NotImplementedError NEW_LINE DEDENT def Enqueue ( self , item ) : NEW_LINE INDENT raise NotImplementedError NEW_LINE DEDENT def Dequeue ( self ) : NEW_LINE INDENT raise NotImplementedError NEW_LINE DEDENT def Print_Contents ( self ) : NEW_LINE INDENT for i in self . contents : NEW_LINE INDENT print i , NEW_LINE DEDENT DEDENT DEDENT
import ldap NEW_LINE l = ldap . initialize ( " ldap : / / ldap . example . com " ) NEW_LINE try : NEW_LINE INDENT l . protocol_version = ldap . VERSION3 NEW_LINE l . set_option ( ldap . OPT_REFERRALS , 0 ) NEW_LINE bind = l . simple_bind_s ( " me @ example . com " , " password " ) NEW_LINE DEDENT finally : NEW_LINE INDENT l . unbind ( ) NEW_LINE DEDENT
import ldap NEW_LINE l = ldap . initialize ( " ldap : / / ldap . example . com " ) NEW_LINE try : NEW_LINE INDENT l . protocol_version = ldap . VERSION3 NEW_LINE l . set_option ( ldap . OPT_REFERRALS , 0 ) NEW_LINE bind = l . simple_bind_s ( " me @ example . com " , " password " ) NEW_LINE base = " dc = example , ▁ dc = com " NEW_LINE criteria = " ( & ( objectClass = user ) ( sAMAccountName = username ) ) " NEW_LINE attributes = [ ' displayName ' , ' company ' ] NEW_LINE result = l . search_s ( base , ldap . SCOPE_SUBTREE , criteria , attributes ) NEW_LINE results = [ entry for dn , entry in result if isinstance ( entry , dict ) ] NEW_LINE print results NEW_LINE DEDENT finally : NEW_LINE INDENT l . unbind ( ) NEW_LINE DEDENT
from time import time , sleep NEW_LINE from threading import Thread NEW_LINE class Integrator ( Thread ) : NEW_LINE INDENT def __init__ ( self , K = lambda t : 0 , interval = 1e-4 ) : NEW_LINE INDENT Thread . __init__ ( self ) NEW_LINE self . interval = interval NEW_LINE self . K = K NEW_LINE self . S = 0.0 NEW_LINE self . __run = True NEW_LINE self . start ( ) NEW_LINE DEDENT def run ( self ) : NEW_LINE INDENT interval = self . interval NEW_LINE start = time ( ) NEW_LINE t0 , k0 = 0 , self . K ( 0 ) NEW_LINE while self . __run : NEW_LINE INDENT sleep ( interval ) NEW_LINE t1 = time ( ) - start NEW_LINE k1 = self . K ( t1 ) NEW_LINE self . S += ( k1 + k0 ) * ( t1 - t0 ) / 2.0 NEW_LINE t0 , k0 = t1 , k1 NEW_LINE DEDENT DEDENT def join ( self ) : NEW_LINE INDENT self . __run = False NEW_LINE Thread . join ( self ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT from math import sin , pi NEW_LINE ai = Integrator ( lambda t : sin ( pi * t ) ) NEW_LINE sleep ( 2 ) NEW_LINE print ( ai . S ) NEW_LINE ai . K = lambda t : 0 NEW_LINE sleep ( 0.5 ) NEW_LINE print ( ai . S ) NEW_LINE DEDENT
def prepend ( n , seq ) : NEW_LINE INDENT return [ n ] + seq NEW_LINE DEDENT
def is_prime ( n : int ) -> bool : NEW_LINE INDENT if n <= 3 : NEW_LINE INDENT return n > 1 NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i ** 2 <= n : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT
def digit_sum ( n : int ) -> int : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def main ( ) -> None : NEW_LINE INDENT additive_primes = 0 NEW_LINE for i in range ( 2 , 500 ) : NEW_LINE INDENT if is_prime ( i ) and is_prime ( digit_sum ( i ) ) : NEW_LINE INDENT additive_primes += 1 NEW_LINE print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( f " \n Found ▁ { additive _ primes } ▁ additive ▁ primes ▁ less ▁ than ▁ 500" ) NEW_LINE DEDENT
foo = object ( ) NEW_LINE address = id ( foo ) NEW_LINE
def rho ( a ) : NEW_LINE INDENT return exp ( - a / 8500.0 ) NEW_LINE DEDENT
def height ( a , z , d ) : NEW_LINE INDENT return sqrt ( ( RE + a ) ** 2 + d ** 2 - 2 * d * ( RE + a ) * cos ( ( 180 - z ) * DEG ) ) - RE NEW_LINE DEDENT
def column_density ( a , z ) : NEW_LINE INDENT dsum , d = 0.0 , 0.0 NEW_LINE while d < FIN : NEW_LINE INDENT delta = max ( dd , ( dd ) * d ) NEW_LINE dsum += rho ( height ( a , z , d + 0.5 * delta ) ) * delta NEW_LINE d += delta NEW_LINE DEDENT return dsum NEW_LINE DEDENT
def airmass ( a , z ) : NEW_LINE INDENT return column_density ( a , z ) / column_density ( a , 0 ) NEW_LINE DEDENT
def aliquot ( n , maxlen = 16 , maxterm = 2 ** 47 ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return ' terminating ' , [ 0 ] NEW_LINE DEDENT s , slen , new = [ n ] , 1 , n NEW_LINE while slen <= maxlen and new < maxterm : NEW_LINE INDENT new = pdsum ( s [ - 1 ] ) NEW_LINE if new in s : NEW_LINE INDENT if s [ 0 ] == new : NEW_LINE INDENT if slen == 1 : NEW_LINE INDENT return ' perfect ' , s NEW_LINE DEDENT elif slen == 2 : NEW_LINE INDENT return ' amicable ' , s NEW_LINE DEDENT else : NEW_LINE INDENT return ' sociable ▁ of ▁ length ▁ % i ' % slen , s NEW_LINE DEDENT DEDENT elif s [ - 1 ] == new : NEW_LINE INDENT return ' aspiring ' , s NEW_LINE DEDENT else : NEW_LINE INDENT return ' cyclic ▁ back ▁ to ▁ % i ' % new , s NEW_LINE DEDENT DEDENT elif new == 0 : NEW_LINE INDENT return ' terminating ' , s + [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( new ) NEW_LINE slen += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return ' non - terminating ' , s NEW_LINE DEDENT DEDENT
WORDFILE = ' unixdict . txt ' NEW_LINE MINLEN = 6 NEW_LINE class Trie ( object ) : NEW_LINE INDENT class Node ( object ) : NEW_LINE INDENT def __init__ ( self , char = ' \0' , parent = None ) : NEW_LINE INDENT self . children = { } NEW_LINE self . char = char NEW_LINE self . final = False NEW_LINE self . parent = parent NEW_LINE DEDENT def descend ( self , char , extend = False ) : NEW_LINE INDENT if not char in self . children : NEW_LINE INDENT if not extend : return None NEW_LINE self . children [ char ] = Trie . Node ( char , self ) NEW_LINE DEDENT return self . children [ char ] NEW_LINE DEDENT DEDENT def __init__ ( self ) : NEW_LINE INDENT self . root = Trie . Node ( ) NEW_LINE DEDENT def insert ( self , word ) : NEW_LINE INDENT node = self . root NEW_LINE for char in word : node = node . descend ( char , extend = True ) NEW_LINE node . final = True NEW_LINE return node NEW_LINE DEDENT def __contains__ ( self , word ) : NEW_LINE INDENT node = self . root NEW_LINE for char in word : NEW_LINE INDENT node = node . descend ( char ) NEW_LINE if not node : return False NEW_LINE DEDENT return node . final NEW_LINE DEDENT def words ( self ) : NEW_LINE INDENT nodes = [ self . root ] NEW_LINE while nodes : NEW_LINE INDENT node = nodes . pop ( ) NEW_LINE nodes += node . children . values ( ) NEW_LINE if node . final : NEW_LINE INDENT word = [ ] NEW_LINE while node : NEW_LINE INDENT if node . char != ' \0' : word . append ( node . char ) NEW_LINE node = node . parent NEW_LINE DEDENT yield " " . join ( reversed ( word ) ) NEW_LINE DEDENT DEDENT DEDENT def __iter__ ( self ) : NEW_LINE INDENT return self . words ( ) NEW_LINE DEDENT DEDENT words = Trie ( ) NEW_LINE with open ( WORDFILE , " rt " ) as f : NEW_LINE INDENT for word in f . readlines ( ) : NEW_LINE INDENT words . insert ( word . strip ( ) ) NEW_LINE DEDENT DEDENT for word in words : NEW_LINE INDENT if len ( word ) < MINLEN : continue NEW_LINE even = word [ : : 2 ] NEW_LINE odd = word [ 1 : : 2 ] NEW_LINE if even in words and odd in words : NEW_LINE INDENT print ( word , even , odd ) NEW_LINE DEDENT DEDENT
def is_deranged ( words ) : NEW_LINE INDENT return [ ( word1 , word2 ) for word1 , word2 in combinations ( words , 2 ) if all ( ch1 != ch2 for ch1 , ch2 in zip ( word1 , word2 ) ) ] NEW_LINE DEDENT
import sys NEW_LINE from PyQt5 . QtCore import QBasicTimer , Qt NEW_LINE from PyQt5 . QtGui import QFont NEW_LINE from PyQt5 . QtWidgets import QApplication , QLabel NEW_LINE class Marquee ( QLabel ) : NEW_LINE INDENT def __init__ ( self , ** kwargs ) : NEW_LINE INDENT super ( ) . __init__ ( ** kwargs ) NEW_LINE self . right_to_left_direction = True NEW_LINE self . initUI ( ) NEW_LINE self . timer = QBasicTimer ( ) NEW_LINE self . timer . start ( 80 , self ) NEW_LINE DEDENT def initUI ( self ) : NEW_LINE INDENT self . setWindowFlags ( Qt . FramelessWindowHint ) NEW_LINE self . setAttribute ( Qt . WA_TranslucentBackground ) NEW_LINE self . setText ( " Hello ▁ World ! ▁ " ) NEW_LINE self . setFont ( QFont ( None , 50 , QFont . Bold ) ) NEW_LINE self . setStyleSheet ( " QLabel ▁ { color : ▁ cyan ; ▁ } " ) NEW_LINE DEDENT def timerEvent ( self , event ) : NEW_LINE INDENT i = 1 if self . right_to_left_direction else - 1 NEW_LINE self . setText ( self . text ( ) [ i : ] + self . text ( ) [ : i ] ) NEW_LINE DEDENT def mouseReleaseEvent ( self , event ) : NEW_LINE INDENT self . right_to_left_direction = not self . right_to_left_direction NEW_LINE DEDENT def keyPressEvent ( self , event ) : NEW_LINE INDENT if event . key ( ) == Qt . Key_Escape : NEW_LINE INDENT self . close ( ) NEW_LINE DEDENT DEDENT DEDENT app = QApplication ( sys . argv ) NEW_LINE w = Marquee ( ) NEW_LINE w . adjustSize ( ) NEW_LINE w . move ( QApplication . instance ( ) . desktop ( ) . screen ( ) . rect ( ) . center ( ) - w . rect ( ) . center ( ) ) NEW_LINE w . show ( ) NEW_LINE sys . exit ( app . exec ( ) ) NEW_LINE
from __future__ import print_function NEW_LINE from scipy import signal NEW_LINE import matplotlib . pyplot as plt NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sig = [ - 0.917843918645 , 0.141984778794 , 1.20536903482 , 0.190286794412 , - 0.662370894973 , - 1.00700480494 , - 0.404707073677 , 0.800482325044 , 0.743500089861 , 1.01090520172 , 0.741527555207 , 0.277841675195 , 0.400833448236 , - 0.2085993586 , - 0.172842103641 , - 0.134316096293 , 0.0259303398477 , 0.490105989562 , 0.549391221511 , 0.9047198589 ] NEW_LINE a = [ 1.00000000 , - 2.77555756e-16 , 3.33333333e-01 , - 1.85037171e-17 ] NEW_LINE b = [ 0.16666667 , 0.5 , 0.5 , 0.16666667 ] NEW_LINE filt = signal . lfilter ( b , a , sig ) NEW_LINE print ( filt ) NEW_LINE plt . plot ( sig , ' b ' ) NEW_LINE plt . plot ( filt , ' r - - ' ) NEW_LINE plt . show ( ) NEW_LINE DEDENT
from numpy import sqrt NEW_LINE from math import isclose NEW_LINE testvalues = [ [ 100000000000000.01 , 100000000000000.011 ] , [ 100.01 , 100.011 ] , [ 10000000000000.001 / 10000.0 , 1000000000.0000001000 ] , [ 0.001 , 0.0010000001 ] , [ 0.000000000000000000000101 , 0.0 ] , [ sqrt ( 2 ) * sqrt ( 2 ) , 2.0 ] , [ - sqrt ( 2 ) * sqrt ( 2 ) , - 2.0 ] , [ 3.14159265358979323846 , 3.14159265358979324 ] ] NEW_LINE for ( x , y ) in testvalues : NEW_LINE INDENT maybenot = " is " if isclose ( x , y ) else " is ▁ NOT " NEW_LINE print ( x , maybenot , " approximately ▁ equal ▁ to ▁ " , y ) NEW_LINE DEDENT
from turtle import * NEW_LINE from math import * NEW_LINE color ( " blue " ) NEW_LINE down ( ) NEW_LINE for i in range ( 200 ) : NEW_LINE INDENT t = i / 20 * pi NEW_LINE x = ( 1 + 5 * t ) * cos ( t ) NEW_LINE y = ( 1 + 5 * t ) * sin ( t ) NEW_LINE goto ( x , y ) NEW_LINE DEDENT up ( ) NEW_LINE done ( ) NEW_LINE
def cumulative_freq ( freq ) : NEW_LINE INDENT cf = { } NEW_LINE total = 0 NEW_LINE for b in range ( 256 ) : NEW_LINE INDENT if b in freq : NEW_LINE INDENT cf [ b ] = total NEW_LINE total += freq [ b ] NEW_LINE DEDENT DEDENT return cf NEW_LINE DEDENT
import operator NEW_LINE class AstNode ( object ) : NEW_LINE INDENT def __init__ ( self , opr , left , right ) : NEW_LINE INDENT self . opr = opr NEW_LINE self . l = left NEW_LINE self . r = right NEW_LINE DEDENT def eval ( self ) : NEW_LINE INDENT return self . opr ( self . l . eval ( ) , self . r . eval ( ) ) NEW_LINE DEDENT DEDENT class LeafNode ( object ) : NEW_LINE INDENT def __init__ ( self , valStrg ) : NEW_LINE INDENT self . v = int ( valStrg ) NEW_LINE DEDENT def eval ( self ) : NEW_LINE INDENT return self . v NEW_LINE DEDENT DEDENT class Yaccer ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . operstak = [ ] NEW_LINE self . nodestak = [ ] NEW_LINE self . __dict__ . update ( self . state1 ) NEW_LINE DEDENT def v1 ( self , valStrg ) : NEW_LINE INDENT self . nodestak . append ( LeafNode ( valStrg ) ) NEW_LINE self . __dict__ . update ( self . state2 ) NEW_LINE DEDENT def o2 ( self , operchar ) : NEW_LINE INDENT def openParen ( a , b ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT opDict = { ' + ' : ( operator . add , 2 , 2 ) , ' - ' : ( operator . sub , 2 , 2 ) , ' * ' : ( operator . mul , 3 , 3 ) , ' / ' : ( operator . div , 3 , 3 ) , ' ^ ' : ( pow , 4 , 5 ) , ' ( ' : ( openParen , 0 , 8 ) } NEW_LINE operPrecidence = opDict [ operchar ] [ 2 ] NEW_LINE self . redeuce ( operPrecidence ) NEW_LINE self . operstak . append ( opDict [ operchar ] ) NEW_LINE self . __dict__ . update ( self . state1 ) NEW_LINE DEDENT def syntaxErr ( self , char ) : NEW_LINE INDENT print ' parse ▁ error ▁ - ▁ near ▁ operator ▁ " % s " ' % char NEW_LINE DEDENT def pc2 ( self , operchar ) : NEW_LINE INDENT self . redeuce ( 1 ) NEW_LINE if len ( self . operstak ) > 0 : NEW_LINE INDENT self . operstak . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ' Error ▁ - ▁ no ▁ open ▁ parenthesis ▁ matches ▁ close ▁ parens . ' NEW_LINE DEDENT self . __dict__ . update ( self . state2 ) NEW_LINE DEDENT def end ( self ) : NEW_LINE INDENT self . redeuce ( 0 ) NEW_LINE return self . nodestak . pop ( ) NEW_LINE DEDENT def redeuce ( self , precidence ) : NEW_LINE INDENT while len ( self . operstak ) > 0 : NEW_LINE INDENT tailOper = self . operstak [ - 1 ] NEW_LINE if tailOper [ 1 ] < precidence : break NEW_LINE tailOper = self . operstak . pop ( ) NEW_LINE vrgt = self . nodestak . pop ( ) NEW_LINE vlft = self . nodestak . pop ( ) NEW_LINE self . nodestak . append ( AstNode ( tailOper [ 0 ] , vlft , vrgt ) ) NEW_LINE DEDENT DEDENT state1 = { ' v ' : v1 , ' o ' : syntaxErr , ' po ' : o2 , ' pc ' : syntaxErr } NEW_LINE state2 = { ' v ' : syntaxErr , ' o ' : o2 , ' po ' : syntaxErr , ' pc ' : pc2 } NEW_LINE DEDENT def Lex ( exprssn , p ) : NEW_LINE INDENT bgn = None NEW_LINE cp = - 1 NEW_LINE for c in exprssn : NEW_LINE INDENT cp += 1 NEW_LINE if c in ' + - / * ^ ( ) ' : NEW_LINE INDENT if bgn is not None : NEW_LINE INDENT p . v ( p , exprssn [ bgn : cp ] ) NEW_LINE bgn = None NEW_LINE DEDENT if c == ' ( ' : p . po ( p , c ) NEW_LINE elif c == ' ) ' : p . pc ( p , c ) NEW_LINE else : p . o ( p , c ) NEW_LINE DEDENT elif c in ' ▁ \t ' : NEW_LINE INDENT if bgn is not None : NEW_LINE INDENT p . v ( p , exprssn [ bgn : cp ] ) NEW_LINE bgn = None NEW_LINE DEDENT DEDENT elif c in '0123456789' : NEW_LINE INDENT if bgn is None : NEW_LINE INDENT bgn = cp NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ' Invalid ▁ character ▁ in ▁ expression ' NEW_LINE if bgn is not None : NEW_LINE INDENT p . v ( p , exprssn [ bgn : cp ] ) NEW_LINE bgn = None NEW_LINE DEDENT DEDENT DEDENT if bgn is not None : NEW_LINE INDENT p . v ( p , exprssn [ bgn : cp + 1 ] ) NEW_LINE bgn = None NEW_LINE DEDENT return p . end ( ) NEW_LINE DEDENT expr = raw_input ( " Expression : " ) NEW_LINE astTree = Lex ( expr , Yaccer ( ) ) NEW_LINE print expr , ' = ' , astTree . eval ( ) NEW_LINE
def agm ( a0 , g0 , tolerance = 1e-10 ) : NEW_LINE INDENT an , gn = ( a0 + g0 ) / 2.0 , sqrt ( a0 * g0 ) NEW_LINE while abs ( an - gn ) > tolerance : NEW_LINE INDENT an , gn = ( an + gn ) / 2.0 , sqrt ( an * gn ) NEW_LINE DEDENT return an NEW_LINE DEDENT
from decimal import * NEW_LINE D = Decimal NEW_LINE getcontext ( ) . prec = 100 NEW_LINE a = n = D ( 1 ) NEW_LINE g , z , half = 1 / D ( 2 ) . sqrt ( ) , D ( 0.25 ) , D ( 0.5 ) NEW_LINE for i in range ( 18 ) : NEW_LINE INDENT x = [ ( a + g ) * half , ( a * g ) . sqrt ( ) ] NEW_LINE var = x [ 0 ] - a NEW_LINE z -= var * var * n NEW_LINE n += n NEW_LINE a , g = x NEW_LINE DEDENT print ( a * a / z ) NEW_LINE
x = int ( raw_input ( " Number ▁ 1 : ▁ " ) ) NEW_LINE y = int ( raw_input ( " Number ▁ 2 : ▁ " ) ) NEW_LINE print " Sum : ▁ % d " % ( x + y ) NEW_LINE print " Difference : ▁ % d " % ( x - y ) NEW_LINE print " Product : ▁ % d " % ( x * y ) NEW_LINE print " Quotient : ▁ % d " % ( x / y ) NEW_LINE print " Remainder : ▁ % d " % ( x % y ) NEW_LINE print " Quotient : ▁ % d ▁ with ▁ Remainder : ▁ % d " % divmod ( x , y ) NEW_LINE print " Power : ▁ % d " % x ** y NEW_LINE raw_input ( ) NEW_LINE
from fractions import Fraction NEW_LINE for candidate in range ( 2 , 2 ** 19 ) : NEW_LINE INDENT sum = Fraction ( 1 , candidate ) NEW_LINE for factor in range ( 2 , int ( candidate ** 0.5 ) + 1 ) : NEW_LINE INDENT if candidate % factor == 0 : NEW_LINE INDENT sum += Fraction ( 1 , factor ) + Fraction ( 1 , candidate // factor ) NEW_LINE DEDENT DEDENT if sum . denominator == 1 : NEW_LINE INDENT print ( " Sum ▁ of ▁ recipr . ▁ factors ▁ of ▁ % d ▁ = ▁ % d ▁ exactly ▁ % s " % ( candidate , int ( sum ) , " perfect ! " if sum == 1 else " " ) ) NEW_LINE DEDENT DEDENT
arr1 = [ 1 , 2 , 3 ] NEW_LINE arr2 = [ 4 , 5 , 6 ] NEW_LINE arr3 = [ 7 , 8 , 9 ] NEW_LINE arr4 = arr1 + arr2 NEW_LINE assert arr4 == [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE arr4 . extend ( arr3 ) NEW_LINE assert arr4 == [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE
array = [ ] NEW_LINE array . append ( 1 ) NEW_LINE array . append ( 3 ) NEW_LINE array [ 0 ] = 2 NEW_LINE print array [ 0 ] NEW_LINE
oo : : class create InterceptAspect { filter < methodCalled > method < methodCalled > args { puts " [ self ] ▁ - ▁ called ▁ ' [ self ▁ target ] ' ▁ with ▁ ' $ args ' " set result [ next { * } $ args ] puts " [ self ] ▁ - ▁ result ▁ was ▁ ' $ result ' " return   $ result } } NEW_LINE oo : : class create Example { method calculate { a b c } { return [ expr { $ a ** 3 +   $ b ** 2 +   $ c } ] } } NEW_LINE Example create xmpl NEW_LINE puts " > > [ xmpl ▁ calculate ▁ 2 ▁ 3 ▁ 5 ] < < " NEW_LINE oo : : objdefine xmpl mixin InterceptAspect NEW_LINE puts " > > [ xmpl ▁ calculate ▁ 2 ▁ 3 ▁ 5 ] < < " NEW_LINE
a = 5 NEW_LINE assert a == 42 NEW_LINE assert a == 42 , " Error ▁ message " NEW_LINE
hash = dict ( ) NEW_LINE hash = dict ( red = " FF0000" , green = "00FF00" , blue = "0000FF " ) NEW_LINE hash = { ' key1' : 1 , ' key2' : 2 , } NEW_LINE value = hash [ key ] NEW_LINE
myDict = { " hello " : 13 , " world " : 31 , " ! " : 71 } NEW_LINE for key , value in myDict . items ( ) : NEW_LINE INDENT print ( " key ▁ = ▁ % s , ▁ value ▁ = ▁ % s " % ( key , value ) ) NEW_LINE DEDENT for key in myDict : NEW_LINE INDENT print ( " key ▁ = ▁ % s " % key ) NEW_LINE DEDENT for key in myDict . keys ( ) : NEW_LINE INDENT print ( " key ▁ = ▁ % s " % key ) NEW_LINE DEDENT for value in myDict . values ( ) : NEW_LINE INDENT print ( " value ▁ = ▁ % s " % value ) NEW_LINE DEDENT
base = { " name " : " Rocket ▁ Skates " , " price " : 12.75 , " color " : " yellow " } NEW_LINE update = { " price " : 15.25 , " color " : " red " , " year " : 1974 } NEW_LINE result = { ** base , ** update } NEW_LINE print ( result ) NEW_LINE
def equalize ( buckets ) : NEW_LINE INDENT nbuckets = buckets . nbuckets NEW_LINE while not terminate . isSet ( ) : NEW_LINE INDENT src = random . randrange ( nbuckets ) NEW_LINE dst = random . randrange ( nbuckets ) NEW_LINE if dst != src : NEW_LINE INDENT amount = ( buckets [ src ] - buckets [ dst ] ) // 2 NEW_LINE if amount >= 0 : buckets . transfer ( src , dst , amount ) NEW_LINE else : buckets . transfer ( dst , src , - amount ) NEW_LINE DEDENT DEDENT DEDENT
import time NEW_LINE import os NEW_LINE seconds = input ( " Enter ▁ a ▁ number ▁ of ▁ seconds : ▁ " ) NEW_LINE sound = input ( " Enter ▁ an ▁ mp3 ▁ filename : ▁ " ) NEW_LINE time . sleep ( float ( seconds ) ) NEW_LINE os . startfile ( sound + " . mp3" ) NEW_LINE
def analytical ( n ) : NEW_LINE INDENT return sum ( factorial ( n ) / pow ( n , i ) / factorial ( n - i ) for i in range ( 1 , n + 1 ) ) NEW_LINE DEDENT
def mean_angle ( deg ) : NEW_LINE INDENT return degrees ( phase ( sum ( rect ( 1 , radians ( d ) ) for d in deg ) / len ( deg ) ) ) NEW_LINE DEDENT
import random NEW_LINE from PIL import Image NEW_LINE class BarnsleyFern ( object ) : NEW_LINE INDENT def __init__ ( self , img_width , img_height , paint_color = ( 0 , 150 , 0 ) , bg_color = ( 255 , 255 , 255 ) ) : NEW_LINE INDENT self . img_width , self . img_height = img_width , img_height NEW_LINE self . paint_color = paint_color NEW_LINE self . x , self . y = 0 , 0 NEW_LINE self . age = 0 NEW_LINE self . fern = Image . new ( ' RGB ' , ( img_width , img_height ) , bg_color ) NEW_LINE self . pix = self . fern . load ( ) NEW_LINE self . pix [ self . scale ( 0 , 0 ) ] = paint_color NEW_LINE DEDENT def scale ( self , x , y ) : NEW_LINE INDENT h = ( x + 2.182 ) * ( self . img_width - 1 ) / 4.8378 NEW_LINE k = ( 9.9983 - y ) * ( self . img_height - 1 ) / 9.9983 NEW_LINE return h , k NEW_LINE DEDENT def transform ( self , x , y ) : NEW_LINE INDENT rand = random . uniform ( 0 , 100 ) NEW_LINE if rand < 1 : NEW_LINE INDENT return 0 , 0.16 * y NEW_LINE DEDENT elif 1 <= rand < 86 : NEW_LINE INDENT return 0.85 * x + 0.04 * y , - 0.04 * x + 0.85 * y + 1.6 NEW_LINE DEDENT elif 86 <= rand < 93 : NEW_LINE INDENT return 0.2 * x - 0.26 * y , 0.23 * x + 0.22 * y + 1.6 NEW_LINE DEDENT else : NEW_LINE INDENT return - 0.15 * x + 0.28 * y , 0.26 * x + 0.24 * y + 0.44 NEW_LINE DEDENT DEDENT def iterate ( self , iterations ) : NEW_LINE INDENT for _ in range ( iterations ) : NEW_LINE INDENT self . x , self . y = self . transform ( self . x , self . y ) NEW_LINE self . pix [ self . scale ( self . x , self . y ) ] = self . paint_color NEW_LINE DEDENT self . age += iterations NEW_LINE DEDENT DEDENT fern = BarnsleyFern ( 500 , 500 ) NEW_LINE fern . iterate ( 1000000 ) NEW_LINE fern . fern . show ( ) NEW_LINE
import base64 NEW_LINE data = ' VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g = ' NEW_LINE print ( base64 . b64decode ( data ) . decode ( ' utf - 8' ) ) NEW_LINE
import urllib NEW_LINE import base64 NEW_LINE data = urllib . urlopen ( ' http : / / rosettacode . org / favicon . ico ' ) . read ( ) NEW_LINE print base64 . b64encode ( data ) NEW_LINE
def bellTriangle ( n ) : NEW_LINE INDENT tri = [ None ] * n NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT tri [ i ] = [ 0 ] * i NEW_LINE DEDENT tri [ 1 ] [ 0 ] = 1 NEW_LINE for i in xrange ( 2 , n ) : NEW_LINE INDENT tri [ i ] [ 0 ] = tri [ i - 1 ] [ i - 2 ] NEW_LINE for j in xrange ( 1 , i ) : NEW_LINE INDENT tri [ i ] [ j ] = tri [ i ] [ j - 1 ] + tri [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT return tri NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT bt = bellTriangle ( 51 ) NEW_LINE print " First ▁ fifteen ▁ and ▁ fiftieth ▁ Bell ▁ numbers : " NEW_LINE for i in xrange ( 1 , 16 ) : NEW_LINE INDENT print " % 2d : ▁ % d " % ( i , bt [ i ] [ 0 ] ) NEW_LINE DEDENT print "50 : " , bt [ 50 ] [ 0 ] NEW_LINE print NEW_LINE print " The ▁ first ▁ ten ▁ rows ▁ of ▁ Bell ' s ▁ triangle : " NEW_LINE for i in xrange ( 1 , 11 ) : NEW_LINE INDENT print bt [ i ] NEW_LINE DEDENT DEDENT main ( ) NEW_LINE
def count ( w1 , wnew ) : NEW_LINE INDENT return sum ( c1 == c2 for c1 , c2 in zip ( w1 , wnew ) ) NEW_LINE DEDENT
def best_shuffle ( w ) : NEW_LINE INDENT wnew = list ( w ) NEW_LINE n = len ( w ) NEW_LINE rangelists = ( list ( range ( n ) ) , list ( range ( n ) ) ) NEW_LINE for r in rangelists : NEW_LINE INDENT random . shuffle ( r ) NEW_LINE DEDENT rangei , rangej = rangelists NEW_LINE for i in rangei : NEW_LINE INDENT for j in rangej : NEW_LINE INDENT if i != j and wnew [ j ] != wnew [ i ] and w [ i ] != wnew [ j ] and w [ j ] != wnew [ i ] : NEW_LINE INDENT wnew [ j ] , wnew [ i ] = wnew [ i ] , wnew [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT wnew = ' ' . join ( wnew ) NEW_LINE return wnew , count ( w , wnew ) NEW_LINE DEDENT
def binary_search ( l , value ) : NEW_LINE INDENT low = 0 NEW_LINE high = len ( l ) - 1 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if l [ mid ] > value : high = mid - 1 NEW_LINE elif l [ mid ] < value : low = mid + 1 NEW_LINE else : return mid NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def equal_birthdays ( sharers = 2 , groupsize = 23 , rep = 100000 ) : NEW_LINE INDENT g = range ( groupsize ) NEW_LINE sh = sharers - 1 NEW_LINE eq = 0 NEW_LINE for j in range ( rep ) : NEW_LINE INDENT group = [ randint ( 1 , 365 ) for i in g ] NEW_LINE if ( groupsize - len ( set ( group ) ) >= sh and any ( group . count ( member ) >= sharers for member in set ( group ) ) ) : NEW_LINE INDENT eq += 1 NEW_LINE DEDENT DEDENT return ( eq * 100. ) / rep NEW_LINE DEDENT
getClass ( " pixmapIndexed " , package = pixmap ) NEW_LINE pixmapIndexed NEW_LINE plot ( p1 < - pixmapIndexed ( matrix ( 0 , nrow = 3 , ncol = 4 ) , col = " red " ) ) NEW_LINE cols < - rep ( " blue " , 12 ) ; cols [ 7 ] < - " red " NEW_LINE plot ( p2 < - pixmapIndexed ( matrix ( 1 : 12 , nrow = 3 , ncol = 4 ) , col = cols ) ) NEW_LINE getcol < - function ( pm , i , j ) NEW_LINE { pmcol < - pm @ col dim ( pmcol ) < - dim ( pm @ index ) pmcol [ i , j ] } NEW_LINE getcol ( p2 , 3 , 4 ) NEW_LINE
def line ( self , x0 , y0 , x1 , y1 ) : NEW_LINE INDENT dx = abs ( x1 - x0 ) NEW_LINE dy = abs ( y1 - y0 ) NEW_LINE x , y = x0 , y0 NEW_LINE sx = - 1 if x0 > x1 else 1 NEW_LINE sy = - 1 if y0 > y1 else 1 NEW_LINE if dx > dy : NEW_LINE INDENT err = dx / 2.0 NEW_LINE while x != x1 : NEW_LINE INDENT self . set ( x , y ) NEW_LINE err -= dy NEW_LINE if err < 0 : NEW_LINE INDENT y += sy NEW_LINE err += dx NEW_LINE DEDENT x += sx NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT err = dy / 2.0 NEW_LINE while y != y1 : NEW_LINE INDENT self . set ( x , y ) NEW_LINE err -= dx NEW_LINE if err < 0 : NEW_LINE INDENT x += sx NEW_LINE err += dy NEW_LINE DEDENT y += sy NEW_LINE DEDENT DEDENT self . set ( x , y ) NEW_LINE DEDENT Bitmap . line = line NEW_LINE bitmap = Bitmap ( 17 , 17 ) NEW_LINE for points in ( ( 1 , 8 , 8 , 16 ) , ( 8 , 16 , 16 , 8 ) , ( 16 , 8 , 8 , 1 ) , ( 8 , 1 , 1 , 8 ) ) : NEW_LINE INDENT bitmap . line ( * points ) NEW_LINE DEDENT bitmap . chardisplay ( ) NEW_LINE
from PIL import Image NEW_LINE image = Image . open ( " lena . jpg " ) NEW_LINE width , height = image . size NEW_LINE amount = width * height NEW_LINE total = 0 NEW_LINE bw_image = Image . new ( ' L ' , ( width , height ) , 0 ) NEW_LINE bm_image = Image . new ( '1' , ( width , height ) , 0 ) NEW_LINE for h in range ( 0 , height ) : NEW_LINE INDENT for w in range ( 0 , width ) : NEW_LINE INDENT r , g , b = image . getpixel ( ( w , h ) ) NEW_LINE greyscale = int ( ( r + g + b ) / 3 ) NEW_LINE total += greyscale NEW_LINE bw_image . putpixel ( ( w , h ) , gray_scale ) NEW_LINE DEDENT DEDENT avg = total / amount NEW_LINE black = 0 NEW_LINE white = 1 NEW_LINE for h in range ( 0 , height ) : NEW_LINE INDENT for w in range ( 0 , width ) : NEW_LINE INDENT v = bw_image . getpixel ( ( w , h ) ) NEW_LINE if v >= avg : NEW_LINE INDENT bm_image . putpixel ( ( w , h ) , white ) NEW_LINE DEDENT else : NEW_LINE INDENT bm_image . putpixel ( ( w , h ) , black ) NEW_LINE DEDENT DEDENT DEDENT bw_image . show ( ) NEW_LINE bm_image . show ( ) NEW_LINE
def circle ( self , x0 , y0 , radius , colour = black ) : NEW_LINE INDENT f = 1 - radius NEW_LINE ddf_x = 1 NEW_LINE ddf_y = - 2 * radius NEW_LINE x = 0 NEW_LINE y = radius NEW_LINE self . set ( x0 , y0 + radius , colour ) NEW_LINE self . set ( x0 , y0 - radius , colour ) NEW_LINE self . set ( x0 + radius , y0 , colour ) NEW_LINE self . set ( x0 - radius , y0 , colour ) NEW_LINE while x < y : NEW_LINE INDENT if f >= 0 : NEW_LINE INDENT y -= 1 NEW_LINE ddf_y += 2 NEW_LINE f += ddf_y NEW_LINE DEDENT x += 1 NEW_LINE ddf_x += 2 NEW_LINE f += ddf_x NEW_LINE self . set ( x0 + x , y0 + y , colour ) NEW_LINE self . set ( x0 - x , y0 + y , colour ) NEW_LINE self . set ( x0 + x , y0 - y , colour ) NEW_LINE self . set ( x0 - x , y0 - y , colour ) NEW_LINE self . set ( x0 + y , y0 + x , colour ) NEW_LINE self . set ( x0 - y , y0 + x , colour ) NEW_LINE self . set ( x0 + y , y0 - x , colour ) NEW_LINE self . set ( x0 - y , y0 - x , colour ) NEW_LINE DEDENT DEDENT Bitmap . circle = circle NEW_LINE bitmap = Bitmap ( 25 , 25 ) NEW_LINE bitmap . circle ( x0 = 12 , y0 = 12 , radius = 12 ) NEW_LINE bitmap . chardisplay ( ) NEW_LINE
import io NEW_LINE ppmfileout = io . StringIO ( ' ' ) NEW_LINE def writeppmp3 ( self , f ) : NEW_LINE INDENT self . writeppm ( f , ppmformat = ' P3' ) NEW_LINE DEDENT def writeppm ( self , f , ppmformat = ' P6' ) : NEW_LINE INDENT assert ppmformat in [ ' P3' , ' P6' ] , ' Format ▁ wrong ' NEW_LINE magic = ppmformat + ' \n ' NEW_LINE comment = ' # ▁ generated ▁ from ▁ Bitmap . writeppm \n ' NEW_LINE maxval = max ( max ( max ( bit ) for bit in row ) for row in self . map ) NEW_LINE assert ppmformat == ' P3' or 0 <= maxval < 256 , ' R , G , B ▁ must ▁ fit ▁ in ▁ a ▁ byte ' NEW_LINE if ppmformat == ' P6' : NEW_LINE INDENT fwrite = lambda s : f . write ( bytes ( s , ' UTF - 8' ) ) NEW_LINE maxval = 255 NEW_LINE DEDENT else : NEW_LINE INDENT fwrite = f . write NEW_LINE numsize = len ( str ( maxval ) ) NEW_LINE DEDENT fwrite ( magic ) NEW_LINE fwrite ( comment ) NEW_LINE fwrite ( ' % i ▁ % i \n % i \n ' % ( self . width , self . height , maxval ) ) NEW_LINE for h in range ( self . height - 1 , - 1 , - 1 ) : NEW_LINE INDENT for w in range ( self . width ) : NEW_LINE INDENT r , g , b = self . get ( w , h ) NEW_LINE if ppmformat == ' P3' : NEW_LINE INDENT fwrite ( ' ▁ ▁ ▁ % * i ▁ % * i ▁ % * i ' % ( numsize , r , numsize , g , numsize , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT fwrite ( ' % c % c % c ' % ( r , g , b ) ) NEW_LINE DEDENT DEDENT if ppmformat == ' P3' : NEW_LINE INDENT fwrite ( ' \n ' ) NEW_LINE DEDENT DEDENT DEDENT Bitmap . writeppmp3 = writeppmp3 NEW_LINE Bitmap . writeppm = writeppm NEW_LINE bitmap = Bitmap ( 4 , 4 , black ) NEW_LINE bitmap . fillrect ( 1 , 0 , 1 , 2 , white ) NEW_LINE bitmap . set ( 3 , 3 , Colour ( 127 , 0 , 63 ) ) NEW_LINE bitmap . writeppmp3 ( ppmfileout ) NEW_LINE print ( ppmfileout . getvalue ( ) ) NEW_LINE ppmfileout = open ( ' tmp . ppm ' , ' wb ' ) NEW_LINE bitmap . writeppm ( ppmfileout ) NEW_LINE ppmfileout . close ( ) NEW_LINE
def main ( ) : NEW_LINE INDENT for kxs in ( [ ( ' ▁ ' , count ( 1 ) ) , ( ' ▁ odd ▁ ' , count ( 1 , 2 ) ) , ( ' ▁ prime ▁ ' , primes ( ) ) ] ) : NEW_LINE INDENT print ( ' First ▁ 20' + kxs [ 0 ] + ' Brazilians : \n ' + showList ( take ( 20 ) ( filter ( isBrazil , kxs [ 1 ] ) ) ) + ' \n ' ) NEW_LINE DEDENT DEDENT
import random NEW_LINE digits = '123456789' NEW_LINE size = 4 NEW_LINE chosen = ' ' . join ( random . sample ( digits , size ) ) NEW_LINE print ''' I ▁ have ▁ chosen ▁ a ▁ number ▁ from ▁ % s ▁ unique ▁ digits ▁ from ▁ 1 ▁ to ▁ 9 ▁ arranged ▁ in ▁ a ▁ random ▁ order . STRNEWLINE You ▁ need ▁ to ▁ input ▁ a ▁ % i ▁ digit , ▁ unique ▁ digit ▁ number ▁ as ▁ a ▁ guess ▁ at ▁ what ▁ I ▁ have ▁ chosen ''' % ( size , size ) NEW_LINE guesses = 0 NEW_LINE while True : NEW_LINE INDENT guesses += 1 NEW_LINE while True : NEW_LINE INDENT guess = raw_input ( ' \n Next ▁ guess ▁ [ % i ] : ▁ ' % guesses ) . strip ( ) NEW_LINE if len ( guess ) == size and all ( char in digits for char in guess ) and len ( set ( guess ) ) == size : NEW_LINE INDENT break NEW_LINE DEDENT print " Problem , ▁ try ▁ again . ▁ You ▁ need ▁ to ▁ enter ▁ % i ▁ unique ▁ digits ▁ from ▁ 1 ▁ to ▁ 9" % size NEW_LINE DEDENT if guess == chosen : NEW_LINE INDENT print ' \n Congratulations ▁ you ▁ guessed ▁ correctly ▁ in ' , guesses , ' attempts ' NEW_LINE break NEW_LINE DEDENT bulls = cows = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if guess [ i ] == chosen [ i ] : NEW_LINE INDENT bulls += 1 NEW_LINE DEDENT elif guess [ i ] in chosen : NEW_LINE INDENT cows += 1 NEW_LINE DEDENT DEDENT print ' ▁ ▁ % i ▁ Bulls \n ▁ ▁ % i ▁ Cows ' % ( bulls , cows ) NEW_LINE DEDENT
def bwt ( s ) : NEW_LINE INDENT assert " \002" not in s and " \003" not in s , " Input ▁ string ▁ cannot ▁ contain ▁ STX ▁ and ▁ ETX ▁ characters " NEW_LINE s = " \002" + s + " \003" NEW_LINE table = sorted ( s [ i : ] + s [ : i ] for i in range ( len ( s ) ) ) NEW_LINE last_column = [ row [ - 1 : ] for row in table ] NEW_LINE return " " . join ( last_column ) NEW_LINE DEDENT
def ibwt ( r ) : NEW_LINE INDENT table = [ " " ] * len ( r ) NEW_LINE for i in range ( len ( r ) ) : NEW_LINE INDENT table = sorted ( r [ i ] + table [ i ] for i in range ( len ( r ) ) ) NEW_LINE DEDENT s = [ row for row in table if row . endswith ( " \003" ) ] [ 0 ] NEW_LINE return s . rstrip ( " \003" ) . strip ( " \002" ) NEW_LINE DEDENT
import math NEW_LINE e0 = 0 NEW_LINE e = 2 NEW_LINE n = 0 NEW_LINE fact = 1 NEW_LINE while ( e - e0 > 1e-15 ) : NEW_LINE INDENT e0 = e NEW_LINE n += 1 NEW_LINE fact *= 2 * n * ( 2 * n + 1 ) NEW_LINE e += ( 2. * n + 2 ) / fact NEW_LINE DEDENT print " Computed ▁ e ▁ = ▁ " + str ( e ) NEW_LINE print " Real ▁ e ▁ = ▁ " + str ( math . e ) NEW_LINE print " Error ▁ = ▁ " + str ( math . e - e ) NEW_LINE print " Number ▁ of ▁ iterations ▁ = ▁ " + str ( n ) NEW_LINE
int main ( ) NEW_LINE { Py_Initialize ( ) ; PyRun_SimpleString ( " a ▁ = ▁ [ 3 * x ▁ for ▁ x ▁ in ▁ range ( 1,11 ) ] " ) ; PyRun_SimpleString ( " print ▁ ' First ▁ 10 ▁ multiples ▁ of ▁ 3 ▁   : ▁ ' ▁ + ▁ str ( a ) " ) ; PyRun_SimpleString ( " print ▁ ' Last ▁ 5 ▁ multiples ▁ of ▁ 3  : ▁ ' ▁ + ▁ str ( a [ 5 : ] ) " ) ; PyRun_SimpleString ( " print ▁ ' First ▁ 10 ▁ multiples ▁ of ▁ 3 ▁ in ▁ reverse ▁ order  : ▁ ' ▁ + ▁ str ( a [ : : -1 ] ) " ) ; Py_Finalize ( ) ; return 0 ; } NEW_LINE
import ctypes NEW_LINE user32_dll = ctypes . cdll . LoadLibrary ( ' User32 . dll ' ) NEW_LINE print user32_dll . GetDoubleClickTime ( ) NEW_LINE
import sys NEW_LINE from socket import inet_aton , inet_ntoa NEW_LINE from struct import pack , unpack NEW_LINE args = sys . argv [ 1 : ] NEW_LINE if len ( args ) == 0 : NEW_LINE INDENT args = sys . stdin . readlines ( ) NEW_LINE DEDENT for cidr in args : NEW_LINE INDENT dotted , size_str = cidr . split ( ' / ' ) NEW_LINE size = int ( size_str ) NEW_LINE numeric = unpack ( ' ! I ' , inet_aton ( dotted ) ) [ 0 ] NEW_LINE binary = f ' { numeric : # 034b } ' NEW_LINE prefix = binary [ : size + 2 ] NEW_LINE canon_binary = prefix + '0' * ( 32 - size ) NEW_LINE canon_numeric = int ( canon_binary , 2 ) NEW_LINE canon_dotted = inet_ntoa ( pack ( ' ! I ' , ( canon_numeric ) ) ) NEW_LINE print ( f ' { canon _ dotted } / { size } ' ) NEW_LINE DEDENT
WIDTH = 81 NEW_LINE HEIGHT = 5 NEW_LINE lines = [ ] NEW_LINE def cantor ( start , len , index ) : NEW_LINE INDENT seg = len / 3 NEW_LINE if seg == 0 : NEW_LINE INDENT return None NEW_LINE DEDENT for it in xrange ( HEIGHT - index ) : NEW_LINE INDENT i = index + it NEW_LINE for jt in xrange ( seg ) : NEW_LINE INDENT j = start + seg + jt NEW_LINE pos = i * WIDTH + j NEW_LINE lines [ pos ] = ' ▁ ' NEW_LINE DEDENT DEDENT cantor ( start , seg , index + 1 ) NEW_LINE cantor ( start + seg * 2 , seg , index + 1 ) NEW_LINE return None NEW_LINE DEDENT lines = [ ' * ' ] * ( WIDTH * HEIGHT ) NEW_LINE cantor ( 0 , WIDTH , 1 ) NEW_LINE for i in xrange ( HEIGHT ) : NEW_LINE INDENT beg = WIDTH * i NEW_LINE print ' ' . join ( lines [ beg : beg + WIDTH ] ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT lalpha = " HXUCZVAMDSLKPEFJRIGTWOBNYQ " NEW_LINE ralpha = " PTLNBQDEOYSFAVZKGJRIHWXUMC " NEW_LINE msg = " WELLDONEISBETTERTHANWELLSAID " NEW_LINE print ( " L : " , lalpha ) NEW_LINE print ( " R : " , ralpha ) NEW_LINE print ( " I : " , msg ) NEW_LINE print ( " O : " , do_chao ( msg , lalpha , ralpha , 1 , 0 ) , " \n " ) NEW_LINE do_chao ( msg , lalpha , ralpha , 1 , 1 ) NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT plt . style . use ( " ggplot " ) NEW_LINE fig = plt . figure ( ) NEW_LINE line , = plt . plot ( [ ] , [ ] , " . " ) NEW_LINE plt . xlim ( 0 , 1 ) NEW_LINE plt . ylim ( 0 , 1 ) NEW_LINE title = " Chaos ▁ Game " NEW_LINE plt . title ( title ) NEW_LINE fig . canvas . set_window_title ( title ) NEW_LINE data = get_data ( args . frames ) NEW_LINE line_ani = animation . FuncAnimation ( fig = fig , func = update_line , frames = args . frames , fargs = ( data , line ) , interval = args . interval , repeat = False ) NEW_LINE plt . show ( ) NEW_LINE DEDENT
print ord ( ' a ' ) NEW_LINE print chr ( 97 ) NEW_LINE
import os NEW_LINE os . path . isfile ( " input . txt " ) NEW_LINE os . path . isfile ( " / input . txt " ) NEW_LINE os . path . isdir ( " docs " ) NEW_LINE os . path . isdir ( " / docs " ) NEW_LINE
def main ( ) : NEW_LINE INDENT month , day = 0 , 1 NEW_LINE print ( uniquePairing ( month ) ( uniquePairing ( day ) ( monthsWithUniqueDays ( False ) ( [ tuple ( x . split ( ) ) for x in split ( ' , ▁ ' , ' May ▁ 15 , ▁ May ▁ 16 , ▁ May ▁ 19 , ▁ ' + ' June ▁ 17 , ▁ June ▁ 18 , ▁ ' + ' July ▁ 14 , ▁ July ▁ 16 , ▁ ' + ) ] ) ) ) ) DEDENT
def chinese_remainder ( n , a ) : NEW_LINE INDENT sum = 0 NEW_LINE prod = reduce ( lambda a , b : a * b , n ) NEW_LINE for n_i , a_i in zip ( n , a ) : NEW_LINE INDENT p = prod / n_i NEW_LINE sum += a_i * mul_inv ( p , n_i ) * p NEW_LINE DEDENT return sum % prod NEW_LINE DEDENT
def mul_inv ( a , b ) : NEW_LINE INDENT b0 = b NEW_LINE x0 , x1 = 0 , 1 NEW_LINE if b == 1 : return 1 NEW_LINE while a > 1 : NEW_LINE INDENT q = a / b NEW_LINE a , b = b , a % b NEW_LINE x0 , x1 = x1 - q * x0 , x0 NEW_LINE DEDENT if x1 < 0 : x1 += b0 NEW_LINE return x1 NEW_LINE DEDENT
from __future__ import print_function NEW_LINE from pprint import pprint NEW_LINE from math import sqrt NEW_LINE def cholesky ( A ) : NEW_LINE INDENT L = [ [ 0.0 ] * len ( A ) for _ in xrange ( len ( A ) ) ] NEW_LINE for i in xrange ( len ( A ) ) : NEW_LINE INDENT for j in xrange ( i + 1 ) : NEW_LINE INDENT s = sum ( L [ i ] [ k ] * L [ j ] [ k ] for k in xrange ( j ) ) NEW_LINE L [ i ] [ j ] = sqrt ( A [ i ] [ i ] - s ) if ( i == j ) else ( 1.0 / L [ j ] [ j ] * ( A [ i ] [ j ] - s ) ) NEW_LINE DEDENT DEDENT return L NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m1 = [ [ 25 , 15 , - 5 ] , [ 15 , 18 , 0 ] , [ - 5 , 0 , 11 ] ] NEW_LINE pprint ( cholesky ( m1 ) ) NEW_LINE print ( ) NEW_LINE m2 = [ [ 18 , 22 , 54 , 42 ] , [ 22 , 70 , 86 , 62 ] , [ 54 , 86 , 174 , 134 ] , [ 42 , 62 , 134 , 106 ] ] NEW_LINE pprint ( cholesky ( m2 ) , width = 120 ) NEW_LINE DEDENT
def chowla ( n ) : NEW_LINE INDENT return 0 if n < 2 else sum ( divisors ( n , generator = True ) ) - 1 - n NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT cThree = churchFromInt ( 3 ) NEW_LINE cFour = churchFromInt ( 4 ) NEW_LINE print ( list ( map ( intFromChurch , [ churchAdd ( cThree ) ( cFour ) , churchMult ( cThree ) ( cFour ) , churchExp ( cFour ) ( cThree ) , churchExp ( cThree ) ( cFour ) , ] ) ) ) NEW_LINE DEDENT
def is_Prime ( n ) : NEW_LINE INDENT if n != int ( n ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( n ) NEW_LINE if n == 0 or n == 1 or n == 4 or n == 6 or n == 8 or n == 9 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 2 or n == 3 or n == 5 or n == 7 : NEW_LINE INDENT return True NEW_LINE DEDENT s = 0 NEW_LINE d = n - 1 NEW_LINE while d % 2 == 0 : NEW_LINE INDENT d >>= 1 NEW_LINE s += 1 NEW_LINE DEDENT assert ( 2 ** s * d == n - 1 ) NEW_LINE def trial_composite ( a ) : NEW_LINE INDENT if pow ( a , d , n ) == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( s ) : NEW_LINE INDENT if pow ( a , 2 ** i * d , n ) == n - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT for i in range ( 8 ) : NEW_LINE INDENT a = random . randrange ( 2 , n ) NEW_LINE if trial_composite ( a ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT result = [ 2 , 3 , 5 , 7 ] NEW_LINE first = '137' NEW_LINE latter = '1379' NEW_LINE for i in range ( 1 , 6 ) : NEW_LINE INDENT s = set ( int ( ' ' . join ( a ) ) for a in product ( first , * ( ( latter , ) * i ) ) ) NEW_LINE while s : NEW_LINE INDENT a = s . pop ( ) NEW_LINE b = rotations ( a ) NEW_LINE if isCircular ( a ) : NEW_LINE INDENT result . append ( min ( b ) ) NEW_LINE DEDENT s -= b NEW_LINE DEDENT DEDENT result . sort ( ) NEW_LINE return result NEW_LINE DEDENT
class MyClass : NEW_LINE INDENT name2 = 2 NEW_LINE def __init__ ( self ) : NEW_LINE INDENT self . name1 = 0 NEW_LINE DEDENT def someMethod ( self ) : NEW_LINE INDENT self . name1 = 1 NEW_LINE MyClass . name2 = 3 NEW_LINE DEDENT DEDENT myclass = MyClass ( ) NEW_LINE class MyOtherClass : NEW_LINE INDENT count = 0 NEW_LINE def __init__ ( self , name , gender = " Male " , age = None ) : NEW_LINE INDENT MyOtherClass . count += 1 NEW_LINE self . name = name NEW_LINE self . gender = gender NEW_LINE if age is not None : NEW_LINE INDENT self . age = age NEW_LINE DEDENT DEDENT def __del__ ( self ) : NEW_LINE INDENT MyOtherClass . count -= 1 NEW_LINE DEDENT DEDENT person1 = MyOtherClass ( " John " ) NEW_LINE print person1 . name , person1 . gender NEW_LINE print person1 . age NEW_LINE person2 = MyOtherClass ( " Jane " , " Female " , 23 ) NEW_LINE print person2 . name , person2 . gender , person2 . age NEW_LINE
funcs = [ ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT funcs . append ( lambda : i * i ) NEW_LINE DEDENT print funcs [ 3 ] ( ) NEW_LINE
collection = [ 0 , '1' ] NEW_LINE x = collection [ 0 ] NEW_LINE collection . append ( 2 ) NEW_LINE collection . insert ( 0 , ' - 1' ) NEW_LINE y = collection [ 0 ] NEW_LINE collection . extend ( [ 2 , '3' ] ) NEW_LINE collection += [ 2 , '3' ] NEW_LINE collection [ 2 : 6 ] NEW_LINE len ( collection ) NEW_LINE collection = ( 0 , 1 ) NEW_LINE collection [ : ] NEW_LINE collection [ - 4 : - 1 ] NEW_LINE collection [ : : 2 ] NEW_LINE collection = " some ▁ string " NEW_LINE x = collection [ : : - 1 ] NEW_LINE collection [ : : 2 ] == " some ▁ string " [ : : 2 ] NEW_LINE collection . __getitem__ ( slice ( 0 , len ( collection ) , 2 ) ) NEW_LINE collection = { 0 : " zero " , 1 : " one " } NEW_LINE collection [ ' zero ' ] = 2 NEW_LINE collection = set ( [ 0 , '1' ] ) NEW_LINE
from PIL import Image NEW_LINE import colorsys NEW_LINE import math NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT im = Image . new ( " RGB " , ( 300 , 300 ) ) NEW_LINE radius = min ( im . size ) / 2.0 NEW_LINE cx , cy = im . size [ 0 ] / 2 , im . size [ 1 ] / 2 NEW_LINE pix = im . load ( ) NEW_LINE for x in range ( im . width ) : NEW_LINE INDENT for y in range ( im . height ) : NEW_LINE INDENT rx = x - cx NEW_LINE ry = y - cy NEW_LINE s = ( rx ** 2.0 + ry ** 2.0 ) ** 0.5 / radius NEW_LINE if s <= 1.0 : NEW_LINE INDENT h = ( ( math . atan2 ( ry , rx ) / math . pi ) + 1.0 ) / 2.0 NEW_LINE rgb = colorsys . hsv_to_rgb ( h , s , 1.0 ) NEW_LINE pix [ x , y ] = tuple ( [ int ( round ( c * 255.0 ) ) for c in rgb ] ) NEW_LINE DEDENT DEDENT DEDENT im . show ( ) NEW_LINE DEDENT
from livewires import * NEW_LINE horiz = 640 ; vert = 480 NEW_LINE begin_graphics ( width = horiz , height = vert , title = " v _ stripes " , background = Colour . black ) NEW_LINE NameColors = [ " black " , " red " , " green " , " dark _ blue " , " purple " , " blue " , " yellow " , " white " ] NEW_LINE stepik = horiz / len ( NameColors ) NEW_LINE for index , each in enumerate ( NameColors ) : NEW_LINE INDENT ExcStrng = " set _ colour ( Colour . " + each + " ) " NEW_LINE exec ExcStrng NEW_LINE box ( index * stepik , 0 , ( index + 1 ) * stepik , vert , filled = 1 ) NEW_LINE DEDENT while keys_pressed ( ) != [ ' x ' ] : NEW_LINE INDENT pass NEW_LINE DEDENT end_graphics ( ) NEW_LINE
from turtle import * NEW_LINE colors = [ " black " , " red " , " green " , " blue " , " magenta " , " cyan " , " yellow " , " white " ] NEW_LINE screen = getscreen ( ) NEW_LINE left_edge = - screen . window_width ( ) // 2 NEW_LINE right_edge = screen . window_width ( ) // 2 NEW_LINE quarter_height = screen . window_height ( ) // 4 NEW_LINE half_height = quarter_height * 2 NEW_LINE speed ( " fastest " ) NEW_LINE for quarter in range ( 4 ) : NEW_LINE INDENT pensize ( quarter + 1 ) NEW_LINE colornum = 0 NEW_LINE min_y = half_height - ( ( quarter + 1 ) * quarter_height ) NEW_LINE max_y = half_height - ( ( quarter ) * quarter_height ) NEW_LINE for x in range ( left_edge , right_edge , quarter + 1 ) : NEW_LINE INDENT penup ( ) NEW_LINE pencolor ( colors [ colornum ] ) NEW_LINE colornum = ( colornum + 1 ) % len ( colors ) NEW_LINE setposition ( x , min_y ) NEW_LINE pendown ( ) NEW_LINE setposition ( x , max_y ) NEW_LINE DEDENT DEDENT notused = input ( " Hit ▁ enter ▁ to ▁ continue : ▁ " ) NEW_LINE
import sys NEW_LINE program_name = sys . argv [ 0 ] NEW_LINE arguments = sys . argv [ 1 : ] NEW_LINE count = len ( arguments ) NEW_LINE
def Commatize ( _string , _startPos = 0 , _periodLen = 3 , _separator = " , " ) : NEW_LINE INDENT outString = " " NEW_LINE strPos = 0 NEW_LINE matches = RegEx . findall ( " [ 0-9 ] * " , _string ) NEW_LINE for match in matches [ : - 1 ] : NEW_LINE INDENT if not match : NEW_LINE INDENT outString += _string [ strPos ] NEW_LINE strPos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if len ( match ) > _periodLen : NEW_LINE INDENT leadIn = match [ : _startPos ] NEW_LINE periods = [ match [ i : i + _periodLen ] for i in range ( _startPos , len ( match ) , _periodLen ) ] NEW_LINE outString += leadIn + _separator . join ( periods ) NEW_LINE DEDENT else : NEW_LINE INDENT outString += match NEW_LINE DEDENT strPos += len ( match ) NEW_LINE DEDENT DEDENT return outString NEW_LINE DEDENT
foo = 5 NEW_LINE
all ( a == nexta for a , nexta in zip ( strings , strings [ 1 : ] ) ) NEW_LINE all ( a < nexta for a , nexta in zip ( strings , strings [ 1 : ] ) ) NEW_LINE len ( set ( strings ) ) == 1 NEW_LINE sorted ( strings , reverse = True ) == strings NEW_LINE
A = ' I ▁ am ▁ string ' NEW_LINE B = ' I ▁ am ▁ string ▁ too ' NEW_LINE if len ( A ) > len ( B ) : NEW_LINE INDENT print ( ' " ' + A + ' " ' , ' has ▁ length ' , len ( A ) , ' and ▁ is ▁ the ▁ longest ▁ of ▁ the ▁ two ▁ strings ' ) NEW_LINE print ( ' " ' + B + ' " ' , ' has ▁ length ' , len ( B ) , ' and ▁ is ▁ the ▁ shortest ▁ of ▁ the ▁ two ▁ strings ' ) NEW_LINE DEDENT elif len ( A ) < len ( B ) : NEW_LINE INDENT print ( ' " ' + B + ' " ' , ' has ▁ length ' , len ( B ) , ' and ▁ is ▁ the ▁ longest ▁ of ▁ the ▁ two ▁ strings ' ) NEW_LINE print ( ' " ' + A + ' " ' , ' has ▁ length ' , len ( A ) , ' and ▁ is ▁ the ▁ shortest ▁ of ▁ the ▁ two ▁ strings ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' " ' + A + ' " ' , ' has ▁ length ' , len ( A ) , ' and ▁ it ▁ is ▁ as ▁ long ▁ as ▁ the ▁ second ▁ string ' ) NEW_LINE print ( ' " ' + B + ' " ' , ' has ▁ length ' , len ( B ) , ' and ▁ it ▁ is ▁ as ▁ long ▁ as ▁ the ▁ second ▁ string ' ) NEW_LINE DEDENT
def hole ( ) : NEW_LINE INDENT t = len ( code ) NEW_LINE emit_word ( 0 ) NEW_LINE return t NEW_LINE DEDENT
def error ( line , col , msg ) : NEW_LINE INDENT print ( line , col , msg ) NEW_LINE exit ( 1 ) NEW_LINE DEDENT
def error ( msg ) : NEW_LINE INDENT print ( " ( % d , ▁ % d ) ▁ % s " % ( int ( err_line ) , int ( err_col ) , msg ) ) NEW_LINE exit ( 1 ) NEW_LINE DEDENT
X , Y = 0 , 1 NEW_LINE p = ( 3 , 4 ) NEW_LINE p = [ 3 , 4 ] NEW_LINE print p [ X ] NEW_LINE
def main ( ) : NEW_LINE INDENT strings = [ ' Enjoy ' , ' Rosetta ' , ' Code ' ] NEW_LINE coroutines = map ( print_ , strings ) NEW_LINE await asyncio . gather ( * coroutines ) NEW_LINE DEDENT
if x == 0 : NEW_LINE INDENT foo ( ) NEW_LINE DEDENT elif x == 1 : NEW_LINE INDENT bar ( ) NEW_LINE DEDENT elif x == 2 : NEW_LINE INDENT baz ( ) NEW_LINE DEDENT else : NEW_LINE INDENT boz ( ) NEW_LINE DEDENT
from __future__ import print_function NEW_LINE from shapely . geometry import MultiPoint NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT pts = MultiPoint ( [ ( 16 , 3 ) , ( 12 , 17 ) , ( 0 , 6 ) , ( - 4 , - 6 ) , ( 16 , 6 ) , ( 16 , - 7 ) , ( 16 , - 3 ) , ( 17 , - 4 ) , ( 5 , 19 ) , ( 19 , - 8 ) , ( 3 , 16 ) , ( 12 , 13 ) , ( 3 , - 4 ) , ( 17 , 5 ) , ( - 3 , 15 ) , ( - 3 , - 9 ) , ( 0 , 11 ) , ( - 9 , - 3 ) , ( - 4 , - 2 ) , ( 12 , 10 ) ] ) NEW_LINE print ( pts . convex_hull ) NEW_LINE DEDENT
import random NEW_LINE from collections import defaultdict NEW_LINE printdead , printlive = ' - # ' NEW_LINE maxgenerations = 3 NEW_LINE cellcount = 3 , 3 NEW_LINE celltable = defaultdict ( int , { ( 1 , 2 ) : 1 , ( 1 , 3 ) : 1 , ( 0 , 3 ) : 1 , } ) NEW_LINE u = universe = defaultdict ( int ) NEW_LINE u [ ( 1 , 0 ) ] , u [ ( 1 , 1 ) ] , u [ ( 1 , 2 ) ] = 1 , 1 , 1 NEW_LINE for i in range ( maxgenerations ) : NEW_LINE INDENT print ( " \n Generation ▁ % 3i : " % ( i , ) ) NEW_LINE for row in range ( cellcount [ 1 ] ) : NEW_LINE INDENT print ( " ▁ ▁ " , ' ' . join ( str ( universe [ ( row , col ) ] ) for col in range ( cellcount [ 0 ] ) ) . replace ( '0' , printdead ) . replace ( '1' , printlive ) ) NEW_LINE DEDENT nextgeneration = defaultdict ( int ) NEW_LINE for row in range ( cellcount [ 1 ] ) : NEW_LINE INDENT for col in range ( cellcount [ 0 ] ) : NEW_LINE INDENT nextgeneration [ ( row , col ) ] = celltable [ ( universe [ ( row , col ) ] , - universe [ ( row , col ) ] + sum ( universe [ ( r , c ) ] for r in range ( row - 1 , row + 2 ) for c in range ( col - 1 , col + 2 ) ) ) ] NEW_LINE DEDENT DEDENT universe = nextgeneration NEW_LINE DEDENT
( let loop ( ) ( match ( read - char ) [ ( ? eof - object ? ) ( void ) ] [ c ( display c ) ( loop ) ] ) ) NEW_LINE
import sys NEW_LINE for n in xrange ( sys . maxint ) : NEW_LINE INDENT print oct ( n ) NEW_LINE DEDENT
def changes ( amount , coins ) : NEW_LINE INDENT ways = [ 0 ] * ( amount + 1 ) NEW_LINE ways [ 0 ] = 1 NEW_LINE for coin in coins : NEW_LINE INDENT for j in xrange ( coin , amount + 1 ) : NEW_LINE INDENT ways [ j ] += ways [ j - coin ] NEW_LINE DEDENT DEDENT return ways [ amount ] NEW_LINE DEDENT print changes ( 100 , [ 1 , 5 , 10 , 25 ] ) NEW_LINE print changes ( 100000 , [ 1 , 5 , 10 , 25 , 50 , 100 ] ) NEW_LINE
import os NEW_LINE for directory in [ ' / ' , ' . / ' ] : NEW_LINE INDENT open ( directory + ' output . txt ' , ' w ' ) . close ( ) NEW_LINE os . mkdir ( directory + ' docs ' ) NEW_LINE DEDENT
width = int ( raw_input ( " Width ▁ of ▁ myarray : ▁ " ) ) NEW_LINE height = int ( raw_input ( " Height ▁ of ▁ Array : ▁ " ) ) NEW_LINE myarray = [ [ 0 ] * width for i in range ( height ) ] NEW_LINE myarray [ 0 ] [ 0 ] = 3.5 NEW_LINE print ( myarray [ 0 ] [ 0 ] ) NEW_LINE
import fileinput NEW_LINE changerow , changecolumn , changevalue = 2 , 4 , ' " Spam " ' NEW_LINE with fileinput . input ( ' csv _ data _ manipulation . csv ' , inplace = True ) as f : NEW_LINE INDENT for line in f : NEW_LINE INDENT if fileinput . filelineno ( ) == changerow : NEW_LINE INDENT fields = line . rstrip ( ) . split ( ' , ' ) NEW_LINE fields [ changecolumn - 1 ] = changevalue NEW_LINE line = ' , ' . join ( fields ) + ' \n ' NEW_LINE DEDENT print ( line , end = ' ' ) NEW_LINE DEDENT DEDENT
import datetime NEW_LINE import math NEW_LINE primes = [ 3 , 5 ] NEW_LINE cutOff = 200 NEW_LINE bigUn = 100_000 NEW_LINE chunks = 50 NEW_LINE little = bigUn / chunks NEW_LINE tn = " ▁ cuban ▁ prime " NEW_LINE print ( " The ▁ first ▁ { : , } { } s : " . format ( cutOff , tn ) ) NEW_LINE c = 0 NEW_LINE showEach = True NEW_LINE u = 0 NEW_LINE v = 1 NEW_LINE st = datetime . datetime . now ( ) NEW_LINE for i in range ( 1 , int ( math . pow ( 2 , 20 ) ) ) : NEW_LINE INDENT found = False NEW_LINE u += 6 NEW_LINE v += u NEW_LINE mx = int ( math . sqrt ( v ) ) NEW_LINE for item in primes : NEW_LINE INDENT if ( item > mx ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( v % item == 0 ) : NEW_LINE INDENT found = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( found == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE if ( showEach ) : NEW_LINE INDENT z = primes [ - 1 ] NEW_LINE while ( z <= v - 2 ) : NEW_LINE INDENT z += 2 NEW_LINE fnd = False NEW_LINE for item in primes : NEW_LINE INDENT if ( item > mx ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( z % item == 0 ) : NEW_LINE INDENT fnd = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not fnd ) : NEW_LINE INDENT primes . append ( z ) NEW_LINE DEDENT DEDENT primes . append ( v ) NEW_LINE print ( " { : > 11 , } " . format ( v ) , end = ' ' ) NEW_LINE if ( c % 10 == 0 ) : NEW_LINE INDENT print ( " " ) ; NEW_LINE DEDENT if ( c == cutOff ) : NEW_LINE INDENT showEach = False NEW_LINE print ( " Progress ▁ to ▁ the ▁ { : , } th ▁ { } : " . format ( bigUn , tn ) , end = ' ' ) NEW_LINE DEDENT DEDENT if ( c % little == 0 ) : NEW_LINE INDENT print ( ' . ' , end = ' ' ) NEW_LINE DEDENT if ( c == bigUn ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( " " ) ; NEW_LINE print ( " The ▁ { : , } th { } ▁ is ▁ { : , } " . format ( c , tn , v ) ) NEW_LINE print ( " Computation ▁ time ▁ was ▁ { } ▁ seconds " . format ( ( datetime . datetime . now ( ) - st ) . seconds ) ) NEW_LINE
from decimal import Decimal as D NEW_LINE from collections import namedtuple NEW_LINE Item = namedtuple ( ' Item ' , ' price , ▁ quant ' ) NEW_LINE items = dict ( hamburger = Item ( D ( '5.50' ) , D ( '4000000000000000' ) ) , milkshake = Item ( D ( '2.86' ) , D ( '2' ) ) ) NEW_LINE tax_rate = D ( '0.0765' ) NEW_LINE fmt = " % -10s ▁ % 8s ▁ % 18s ▁ % 22s " NEW_LINE print ( fmt % tuple ( ' Item ▁ Price ▁ Quantity ▁ Extension ' . upper ( ) . split ( ) ) ) NEW_LINE total_before_tax = 0 NEW_LINE for item , ( price , quant ) in sorted ( items . items ( ) ) : NEW_LINE INDENT ext = price * quant NEW_LINE print ( fmt % ( item , price , quant , ext ) ) NEW_LINE total_before_tax += ext NEW_LINE DEDENT print ( fmt % ( ' ' , ' ' , ' ' , ' - - - - - - - - - - - - - - - - - - - - ' ) ) NEW_LINE print ( fmt % ( ' ' , ' ' , ' subtotal ' , total_before_tax ) ) NEW_LINE tax = ( tax_rate * total_before_tax ) . quantize ( D ( '0.00' ) ) NEW_LINE print ( fmt % ( ' ' , ' ' , ' Tax ' , tax ) ) NEW_LINE total = total_before_tax + tax NEW_LINE print ( fmt % ( ' ' , ' ' , ' ' , ' - - - - - - - - - - - - - - - - - - - - ' ) ) NEW_LINE print ( fmt % ( ' ' , ' ' , ' Total ' , total ) ) NEW_LINE
def brent ( f , x0 ) : NEW_LINE INDENT power = lam = 1 NEW_LINE tortoise = x0 NEW_LINE hare = f ( x0 ) NEW_LINE while tortoise != hare : NEW_LINE INDENT if power == lam : NEW_LINE INDENT tortoise = hare NEW_LINE power *= 2 NEW_LINE lam = 0 NEW_LINE DEDENT hare = f ( hare ) NEW_LINE lam += 1 NEW_LINE DEDENT mu = 0 NEW_LINE tortoise = hare = x0 NEW_LINE for i in range ( lam ) : NEW_LINE INDENT hare = f ( hare ) NEW_LINE DEDENT while tortoise != hare : NEW_LINE INDENT tortoise = f ( tortoise ) NEW_LINE hare = f ( hare ) NEW_LINE mu += 1 NEW_LINE DEDENT return lam , mu NEW_LINE DEDENT
def damm ( num : int ) -> bool : NEW_LINE INDENT row = 0 NEW_LINE for digit in str ( num ) : NEW_LINE INDENT row = _matrix [ row ] [ int ( digit ) ] NEW_LINE DEDENT return row == 0 NEW_LINE DEDENT
import datetime NEW_LINE today = datetime . date . today ( ) NEW_LINE today . isoformat ( ) NEW_LINE today . strftime ( " % A , ▁ % B ▁ % d , ▁ % Y " ) NEW_LINE " The ▁ date ▁ is ▁ { 0 : % A , ▁ % B ▁ % d , ▁ % Y } " . format ( d ) NEW_LINE " The ▁ date ▁ is ▁ { date : % A , ▁ % B ▁ % d , ▁ % Y } " . format ( date = d ) NEW_LINE
import datetime NEW_LINE def mt ( ) : NEW_LINE INDENT datime1 = " March ▁ 7 ▁ 2009 ▁ 7:30pm ▁ EST " NEW_LINE formatting = " % B ▁ % d ▁ % Y ▁ % I : % M % p ▁ " NEW_LINE datime2 = datime1 [ : - 3 ] NEW_LINE tdelta = datetime . timedelta ( hours = 12 ) NEW_LINE s3 = datetime . datetime . strptime ( datime2 , formatting ) NEW_LINE datime2 = s3 + tdelta NEW_LINE print datime2 . strftime ( " % B ▁ % d ▁ % Y ▁ % I : % M % p ▁ % Z " ) + datime1 [ - 3 : ] NEW_LINE DEDENT mt ( ) NEW_LINE
from calendar import weekday , SUNDAY NEW_LINE [ year for year in range ( 2008 , 2122 ) if weekday ( year , 12 , 25 ) == SUNDAY ] NEW_LINE
def de_bruijn ( k , n ) : NEW_LINE INDENT try : NEW_LINE INDENT _ = int ( k ) NEW_LINE alphabet = list ( map ( str , range ( k ) ) ) NEW_LINE DEDENT except ( ValueError , TypeError ) : NEW_LINE INDENT alphabet = k NEW_LINE k = len ( k ) NEW_LINE DEDENT a = [ 0 ] * k * n NEW_LINE sequence = [ ] NEW_LINE def db ( t , p ) : NEW_LINE INDENT if t > n : NEW_LINE INDENT if n % p == 0 : NEW_LINE INDENT sequence . extend ( a [ 1 : p + 1 ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT a [ t ] = a [ t - p ] NEW_LINE db ( t + 1 , p ) NEW_LINE for j in range ( a [ t - p ] + 1 , k ) : NEW_LINE INDENT a [ t ] = j NEW_LINE db ( t + 1 , t ) NEW_LINE DEDENT DEDENT DEDENT db ( 1 , 1 ) NEW_LINE return " " . join ( alphabet [ i ] for i in sequence ) NEW_LINE DEDENT
def validate ( db ) : NEW_LINE INDENT dbwithwrap = db + db [ 0 : 3 ] NEW_LINE digits = '0123456789' NEW_LINE errorstrings = [ ] NEW_LINE for d1 in digits : NEW_LINE INDENT for d2 in digits : NEW_LINE INDENT for d3 in digits : NEW_LINE INDENT for d4 in digits : NEW_LINE INDENT teststring = d1 + d2 + d3 + d4 NEW_LINE if teststring not in dbwithwrap : NEW_LINE INDENT errorstrings . append ( teststring ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if len ( errorstrings ) > 0 : NEW_LINE INDENT print ( " ▁ ▁ " + str ( len ( errorstrings ) ) + " ▁ errors ▁ found : " ) NEW_LINE for e in errorstrings : NEW_LINE INDENT print ( " ▁ ▁ PIN ▁ number ▁ " + e + " ▁ ▁ missing " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " ▁ ▁ No ▁ errors ▁ found " ) NEW_LINE DEDENT DEDENT
import copy NEW_LINE deepcopy_of_obj = copy . deepcopy ( obj ) NEW_LINE
class Delegator : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . delegate = None NEW_LINE DEDENT def operation ( self ) : NEW_LINE INDENT if hasattr ( self . delegate , ' thing ' ) and callable ( self . delegate . thing ) : NEW_LINE INDENT return self . delegate . thing ( ) NEW_LINE DEDENT return ' default ▁ implementation ' NEW_LINE DEDENT DEDENT class Delegate : NEW_LINE INDENT def thing ( self ) : NEW_LINE INDENT return ' delegate ▁ implementation ' NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = Delegator ( ) NEW_LINE assert a . operation ( ) == ' default ▁ implementation ' NEW_LINE a . delegate = ' A ▁ delegate ▁ may ▁ be ▁ any ▁ object ' NEW_LINE assert a . operation ( ) == ' default ▁ implementation ' NEW_LINE a . delegate = Delegate ( ) NEW_LINE assert a . operation ( ) == ' delegate ▁ implementation ' NEW_LINE DEDENT
import os NEW_LINE os . remove ( " output . txt " ) NEW_LINE os . rmdir ( " docs " ) NEW_LINE os . remove ( " / output . txt " ) NEW_LINE os . rmdir ( " / docs " ) NEW_LINE
def funnel ( dxs , rule ) : NEW_LINE INDENT x , rxs = 0 , [ ] NEW_LINE for dx in dxs : NEW_LINE INDENT rxs . append ( x + dx ) NEW_LINE x = rule ( x , dx ) NEW_LINE DEDENT return rxs NEW_LINE DEDENT
def mean ( xs ) : return sum ( xs ) / len ( xs ) NEW_LINE def stddev ( xs ) : NEW_LINE INDENT m = mean ( xs ) NEW_LINE return math . sqrt ( sum ( ( x - m ) ** 2 for x in xs ) / len ( xs ) ) NEW_LINE DEDENT
def perm ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE r = range ( n ) NEW_LINE s = permutations ( r ) NEW_LINE return fsum ( prod ( a [ i ] [ sigma [ i ] ] for i in r ) for sigma in s ) NEW_LINE DEDENT
def det ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE r = range ( n ) NEW_LINE s = spermutations ( n ) NEW_LINE return fsum ( sign * prod ( a [ i ] [ sigma [ i ] ] for i in r ) for sigma , sign in s ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT print ( fTable ( ' First , ▁ if ▁ any , ▁ points ▁ of ▁ difference : \n ' ) ( repr ) ( either ( identity ) ( lambda dct : dct [ ' char ' ] + ' ▁ ( ' + dct [ ' hex ' ] + ' ) ▁ at ▁ character ▁ ' + str ( 1 + dct [ ' index ' ] ) + ' ▁ of ▁ ' + str ( dct [ ' total ' ] ) + ' . ' ) ) ( firstDifferingCharLR ) ( [ ' ' , ' ▁ ▁ ▁ ' , '2' , '333' , ' . 55' , ' tttTTT ' , ] ) ) DEDENT
def main ( ) : NEW_LINE INDENT def showSample ( s ) : NEW_LINE INDENT return repr ( s ) + ' ▁ ( ' + str ( len ( s ) ) + ' ) ' NEW_LINE DEDENT def showDuplicate ( cix ) : NEW_LINE INDENT c , ix = cix NEW_LINE return repr ( c ) + ( ' ▁ ( ' + hex ( ord ( c ) ) + ' ) ▁ at ▁ ' + repr ( ix ) ) NEW_LINE DEDENT print ( fTable ( ' First ▁ duplicated ▁ character , ▁ if ▁ any : ' ) ( showSample ) ( maybe ( ' None ' ) ( showDuplicate ) ) ( duplicatedCharIndices ) ( [ ' ' , ' . ' , ' abcABC ' , ' XYZ ▁ ZYX ' , ] ) ) DEDENT
from collections import namedtuple , deque NEW_LINE from pprint import pprint as pp NEW_LINE inf = float ( ' inf ' ) NEW_LINE Edge = namedtuple ( ' Edge ' , [ ' start ' , ' end ' , ' cost ' ] ) NEW_LINE class Graph ( ) : NEW_LINE INDENT def __init__ ( self , edges ) : NEW_LINE INDENT self . edges = [ Edge ( * edge ) for edge in edges ] NEW_LINE self . vertices = { e . start for e in self . edges } | { e . end for e in self . edges } NEW_LINE DEDENT def dijkstra ( self , source , dest ) : NEW_LINE INDENT assert source in self . vertices NEW_LINE dist = { vertex : inf for vertex in self . vertices } NEW_LINE previous = { vertex : None for vertex in self . vertices } NEW_LINE dist [ source ] = 0 NEW_LINE q = self . vertices . copy ( ) NEW_LINE neighbours = { vertex : set ( ) for vertex in self . vertices } NEW_LINE for start , end , cost in self . edges : NEW_LINE INDENT neighbours [ start ] . add ( ( end , cost ) ) NEW_LINE neighbours [ end ] . add ( ( start , cost ) ) NEW_LINE DEDENT while q : NEW_LINE INDENT u = min ( q , key = lambda vertex : dist [ vertex ] ) NEW_LINE q . remove ( u ) NEW_LINE if dist [ u ] == inf or u == dest : NEW_LINE INDENT break NEW_LINE DEDENT for v , cost in neighbours [ u ] : NEW_LINE INDENT alt = dist [ u ] + cost NEW_LINE if alt < dist [ v ] : NEW_LINE INDENT dist [ v ] = alt NEW_LINE previous [ v ] = u NEW_LINE DEDENT DEDENT DEDENT s , u = deque ( ) , dest NEW_LINE while previous [ u ] : NEW_LINE INDENT s . appendleft ( u ) NEW_LINE u = previous [ u ] NEW_LINE DEDENT s . appendleft ( u ) NEW_LINE return s NEW_LINE DEDENT DEDENT graph = Graph ( [ ( " a " , " b " , 7 ) , ( " a " , " c " , 9 ) , ( " a " , " f " , 14 ) , ( " b " , " c " , 10 ) , ( " b " , " d " , 15 ) , ( " c " , " d " , 11 ) , ( " c " , " f " , 2 ) , ( " d " , " e " , 6 ) , ( " e " , " f " , 9 ) ] ) NEW_LINE pp ( graph . dijkstra ( " a " , " e " ) ) NEW_LINE
def main ( ) : NEW_LINE INDENT print ( unlines ( map ( showDiversityValues ( 49 ) , [ [ 48 , 47 , 51 ] , [ 48 , 47 , 51 , 42 ] , [ 50 , ' ? ' , 50 , { } , 50 ] , [ ] ] ) ) ) NEW_LINE print ( unlines ( map ( showDiversityValues ( '49' ) , [ [ 50 , 50 , 50 ] , [ 40 , 35 , 40 ] , ] ) ) ) NEW_LINE DEDENT
class Doc ( object ) : NEW_LINE INDENT def method ( self , num ) : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT
from collections import deque NEW_LINE some_list = deque ( [ " a " , " b " , " c " ] ) NEW_LINE print ( some_list ) NEW_LINE some_list . appendleft ( " Z " ) NEW_LINE print ( some_list ) NEW_LINE for value in reversed ( some_list ) : NEW_LINE INDENT print ( value ) NEW_LINE DEDENT
class Node ( object ) : NEW_LINE INDENT def __init__ ( self , data = None , prev = None , next = None ) : NEW_LINE INDENT self . prev = prev NEW_LINE self . next = next NEW_LINE self . data = data NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return str ( self . data ) NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return repr ( self . data ) NEW_LINE DEDENT def iter_forward ( self ) : NEW_LINE INDENT c = self NEW_LINE while c != None : NEW_LINE INDENT yield c NEW_LINE c = c . next NEW_LINE DEDENT DEDENT def iter_backward ( self ) : NEW_LINE INDENT c = self NEW_LINE while c != None : NEW_LINE INDENT yield c NEW_LINE c = c . prev NEW_LINE DEDENT DEDENT DEDENT
class List : NEW_LINE INDENT def __init__ ( self , data , next = None , prev = None ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = next NEW_LINE self . prev = prev NEW_LINE DEDENT def append ( self , data ) : NEW_LINE INDENT if self . next == None : NEW_LINE INDENT self . next = List ( data , None , self ) NEW_LINE return self . next NEW_LINE DEDENT else : NEW_LINE INDENT return self . next . append ( data ) NEW_LINE DEDENT DEDENT DEDENT tail = head = List ( 10 ) NEW_LINE for i in [ 20 , 30 , 40 ] : NEW_LINE INDENT tail = tail . append ( i ) NEW_LINE DEDENT node = head NEW_LINE while node != None : NEW_LINE INDENT print ( node . data ) NEW_LINE node = node . next NEW_LINE DEDENT node = tail NEW_LINE while node != None : NEW_LINE INDENT print ( node . data ) NEW_LINE node = node . prev NEW_LINE DEDENT
from PIL import Image NEW_LINE img = Image . new ( ' RGB ' , ( 320 , 240 ) ) NEW_LINE pixels = img . load ( ) NEW_LINE pixels [ 100 , 100 ] = ( 255 , 0 , 0 ) NEW_LINE img . show ( ) NEW_LINE
from visual import * NEW_LINE scene . title = " VPython : ▁ Draw ▁ a ▁ rotating ▁ cube " NEW_LINE scene . range = 2 NEW_LINE scene . autocenter = True NEW_LINE print " Drag ▁ with ▁ right ▁ mousebutton ▁ to ▁ rotate ▁ view . " NEW_LINE print " Drag ▁ up + down ▁ with ▁ middle ▁ mousebutton ▁ to ▁ zoom . " NEW_LINE deg45 = math . radians ( 45.0 ) NEW_LINE cube = box ( ) NEW_LINE cube . rotate ( angle = deg45 , axis = ( 1 , 0 , 0 ) ) NEW_LINE cube . rotate ( angle = deg45 , axis = ( 0 , 0 , 1 ) ) NEW_LINE while True : NEW_LINE INDENT rate ( 50 ) NEW_LINE cube . rotate ( angle = 0.005 , axis = ( 0 , 1 , 0 ) ) NEW_LINE DEDENT
def normalize ( v ) : NEW_LINE INDENT len = math . sqrt ( v [ 0 ] ** 2 + v [ 1 ] ** 2 + v [ 2 ] ** 2 ) NEW_LINE return ( v [ 0 ] / len , v [ 1 ] / len , v [ 2 ] / len ) NEW_LINE DEDENT
def dot ( x , y ) : NEW_LINE INDENT d = x [ 0 ] * y [ 0 ] + x [ 1 ] * y [ 1 ] + x [ 2 ] * y [ 2 ] NEW_LINE return - d if d < 0 else 0 NEW_LINE DEDENT
def draw_sphere ( r , k , ambient , light ) : NEW_LINE INDENT for i in range ( int ( math . floor ( - r ) ) , int ( math . ceil ( r ) + 1 ) ) : NEW_LINE INDENT x = i + 0.5 NEW_LINE line = ' ' NEW_LINE for j in range ( int ( math . floor ( - 2 * r ) ) , int ( math . ceil ( 2 * r ) + 1 ) ) : NEW_LINE INDENT y = j / 2 + 0.5 NEW_LINE if x * x + y * y <= r * r : NEW_LINE INDENT vec = normalize ( ( x , y , math . sqrt ( r * r - x * x - y * y ) ) ) NEW_LINE b = dot ( light , vec ) ** k + ambient NEW_LINE intensity = int ( ( 1 - b ) * ( len ( shades ) - 1 ) ) NEW_LINE line += shades [ intensity ] if 0 <= intensity < len ( shades ) else shades [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT line += ' ▁ ' NEW_LINE DEDENT DEDENT print ( line ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT balls = random_balls ( ) NEW_LINE if not dutch_flag_check ( balls ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " Original ▁ Ball ▁ order : " , balls ) NEW_LINE sorted_balls = dutch_flag_sort ( balls ) NEW_LINE print ( " Sorted ▁ Ball ▁ Order : " , sorted_balls ) NEW_LINE assert dutch_flag_check ( sorted_balls ) , ' Whoops . ▁ Not ▁ sorted ! ' NEW_LINE DEDENT
from primesieve import primes NEW_LINE LIMIT = 10 ** 9 NEW_LINE pri = primes ( LIMIT * 5 ) NEW_LINE gapstarts = { } NEW_LINE for i in range ( 1 , len ( pri ) ) : NEW_LINE INDENT if pri [ i ] - pri [ i - 1 ] not in gapstarts : NEW_LINE INDENT gapstarts [ pri [ i ] - pri [ i - 1 ] ] = pri [ i - 1 ] NEW_LINE DEDENT DEDENT PM , GAP1 , = 10 , 2 NEW_LINE while True : NEW_LINE INDENT while GAP1 not in gapstarts : NEW_LINE INDENT GAP1 += 2 NEW_LINE DEDENT start1 = gapstarts [ GAP1 ] NEW_LINE GAP2 = GAP1 + 2 NEW_LINE if GAP2 not in gapstarts : NEW_LINE INDENT GAP1 = GAP2 + 2 NEW_LINE continue NEW_LINE DEDENT start2 = gapstarts [ GAP2 ] NEW_LINE diff = abs ( start2 - start1 ) NEW_LINE if diff > PM : NEW_LINE INDENT print ( f " Earliest ▁ difference ▁ > { PM : ▁ , } ▁ between ▁ adjacent ▁ prime ▁ gap ▁ starting ▁ primes : " ) NEW_LINE print ( f " Gap ▁ { GAP1 } ▁ starts ▁ at { start1 : ▁ , } , ▁ gap ▁ { GAP2 } ▁ starts ▁ at { start2 : ▁ , } , ▁ difference ▁ is { diff : ▁ , } . \n " ) NEW_LINE if PM == LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT PM *= 10 NEW_LINE DEDENT else : NEW_LINE INDENT GAP1 = GAP2 NEW_LINE DEDENT DEDENT
import inflect NEW_LINE import time NEW_LINE before = time . perf_counter ( ) NEW_LINE p = inflect . engine ( ) NEW_LINE print ( ' ▁ ' ) NEW_LINE print ( ' eban ▁ numbers ▁ up ▁ to ▁ and ▁ including ▁ 1000 : ' ) NEW_LINE print ( ' ▁ ' ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE INDENT if not ' e ' in p . number_to_words ( i ) : NEW_LINE INDENT print ( str ( i ) + ' ▁ ' , end = ' ' ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( ' ▁ ' ) NEW_LINE print ( ' ▁ ' ) NEW_LINE print ( ' count ▁ = ▁ ' + str ( count ) ) NEW_LINE print ( ' ▁ ' ) NEW_LINE print ( ' ▁ ' ) NEW_LINE print ( ' eban ▁ numbers ▁ between ▁ 1000 ▁ and ▁ 4000 ▁ ( inclusive ) : ' ) NEW_LINE print ( ' ▁ ' ) NEW_LINE count = 0 NEW_LINE for i in range ( 1000 , 4001 ) : NEW_LINE INDENT if not ' e ' in p . number_to_words ( i ) : NEW_LINE INDENT print ( str ( i ) + ' ▁ ' , end = ' ' ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( ' ▁ ' ) NEW_LINE print ( ' ▁ ' ) NEW_LINE print ( ' count ▁ = ▁ ' + str ( count ) ) NEW_LINE print ( ' ▁ ' ) NEW_LINE print ( ' ▁ ' ) NEW_LINE print ( ' eban ▁ numbers ▁ up ▁ to ▁ and ▁ including ▁ 10000 : ' ) NEW_LINE print ( ' ▁ ' ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , 10001 ) : NEW_LINE INDENT if not ' e ' in p . number_to_words ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( ' ▁ ' ) NEW_LINE print ( ' count ▁ = ▁ ' + str ( count ) ) NEW_LINE print ( ' ▁ ' ) NEW_LINE print ( ' ▁ ' ) NEW_LINE print ( ' eban ▁ numbers ▁ up ▁ to ▁ and ▁ including ▁ 100000 : ' ) NEW_LINE print ( ' ▁ ' ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , 100001 ) : NEW_LINE INDENT if not ' e ' in p . number_to_words ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( ' ▁ ' ) NEW_LINE print ( ' count ▁ = ▁ ' + str ( count ) ) NEW_LINE print ( ' ▁ ' ) NEW_LINE print ( ' ▁ ' ) NEW_LINE print ( ' eban ▁ numbers ▁ up ▁ to ▁ and ▁ including ▁ 1000000 : ' ) NEW_LINE print ( ' ▁ ' ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , 1000001 ) : NEW_LINE INDENT if not ' e ' in p . number_to_words ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( ' ▁ ' ) NEW_LINE print ( ' count ▁ = ▁ ' + str ( count ) ) NEW_LINE print ( ' ▁ ' ) NEW_LINE print ( ' ▁ ' ) NEW_LINE print ( ' eban ▁ numbers ▁ up ▁ to ▁ and ▁ including ▁ 10000000 : ' ) NEW_LINE print ( ' ▁ ' ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , 10000001 ) : NEW_LINE INDENT if not ' e ' in p . number_to_words ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( ' ▁ ' ) NEW_LINE print ( ' count ▁ = ▁ ' + str ( count ) ) NEW_LINE print ( ' ▁ ' ) NEW_LINE after = time . perf_counter ( ) NEW_LINE print ( " ▁ " ) NEW_LINE print ( " Run ▁ time ▁ in ▁ seconds : ▁ " + str ( after - before ) ) NEW_LINE
import SocketServer NEW_LINE HOST = " localhost " NEW_LINE PORT = 12321 NEW_LINE class EchoServer ( SocketServer . ThreadingMixIn , SocketServer . TCPServer ) : NEW_LINE INDENT pass NEW_LINE DEDENT class EchoRequestHandler ( SocketServer . StreamRequestHandler ) : NEW_LINE INDENT def handle ( self ) : NEW_LINE INDENT print " connection ▁ from ▁ % s " % self . client_address [ 0 ] NEW_LINE while True : NEW_LINE INDENT line = self . rfile . readline ( ) NEW_LINE if not line : break NEW_LINE print " % s ▁ wrote : ▁ % s " % ( self . client_address [ 0 ] , line . rstrip ( ) ) NEW_LINE self . wfile . write ( line ) NEW_LINE DEDENT print " % s ▁ disconnected " % self . client_address [ 0 ] NEW_LINE DEDENT DEDENT server = EchoServer ( ( HOST , PORT ) , EchoRequestHandler ) NEW_LINE print " server ▁ listening ▁ on ▁ % s : % s " % server . server_address NEW_LINE server . serve_forever ( ) NEW_LINE
from __future__ import print_function NEW_LINE class Node ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . edges = { } NEW_LINE self . link = None NEW_LINE self . len = 0 NEW_LINE DEDENT DEDENT class Eertree ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . nodes = [ ] NEW_LINE self . rto = Node ( ) NEW_LINE self . rte = Node ( ) NEW_LINE self . rto . link = self . rte . link = self . rto ; NEW_LINE self . rto . len = - 1 NEW_LINE self . rte . len = 0 NEW_LINE self . S = [ 0 ] NEW_LINE self . maxSufT = self . rte NEW_LINE DEDENT def get_max_suffix_pal ( self , startNode , a ) : NEW_LINE INDENT u = startNode NEW_LINE i = len ( self . S ) NEW_LINE k = u . len NEW_LINE while id ( u ) != id ( self . rto ) and self . S [ i - k - 1 ] != a : NEW_LINE INDENT assert id ( u ) != id ( u . link ) NEW_LINE u = u . link NEW_LINE k = u . len NEW_LINE DEDENT return u NEW_LINE DEDENT def add ( self , a ) : NEW_LINE INDENT Q = self . get_max_suffix_pal ( self . maxSufT , a ) NEW_LINE createANewNode = not a in Q . edges NEW_LINE if createANewNode : NEW_LINE INDENT P = Node ( ) NEW_LINE self . nodes . append ( P ) NEW_LINE P . len = Q . len + 2 NEW_LINE if P . len == 1 : NEW_LINE INDENT P . link = self . rte NEW_LINE DEDENT else : NEW_LINE INDENT P . link = self . get_max_suffix_pal ( Q . link , a ) . edges [ a ] NEW_LINE DEDENT Q . edges [ a ] = P NEW_LINE DEDENT self . maxSufT = Q . edges [ a ] NEW_LINE self . S . append ( a ) NEW_LINE return createANewNode NEW_LINE DEDENT def get_sub_palindromes ( self , nd , nodesToHere , charsToHere , result ) : NEW_LINE INDENT for lnkName in nd . edges : NEW_LINE INDENT nd2 = nd . edges [ lnkName ] NEW_LINE self . get_sub_palindromes ( nd2 , nodesToHere + [ nd2 ] , charsToHere + [ lnkName ] , result ) NEW_LINE DEDENT if id ( nd ) != id ( self . rto ) and id ( nd ) != id ( self . rte ) : NEW_LINE INDENT tmp = " " . join ( charsToHere ) NEW_LINE if id ( nodesToHere [ 0 ] ) == id ( self . rte ) : NEW_LINE INDENT assembled = tmp [ : : - 1 ] + tmp NEW_LINE DEDENT else : NEW_LINE INDENT assembled = tmp [ : : - 1 ] + tmp [ 1 : ] NEW_LINE DEDENT result . append ( assembled ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT st = " eertree " NEW_LINE print ( " Processing ▁ string " , st ) NEW_LINE eertree = Eertree ( ) NEW_LINE for ch in st : NEW_LINE INDENT eertree . add ( ch ) NEW_LINE DEDENT print ( " Number ▁ of ▁ sub - palindromes : " , len ( eertree . nodes ) ) NEW_LINE result = [ ] NEW_LINE eertree . get_sub_palindromes ( eertree . rto , [ eertree . rto ] , [ ] , result ) NEW_LINE eertree . get_sub_palindromes ( eertree . rte , [ eertree . rte ] , [ ] , result ) NEW_LINE print ( " Sub - palindromes : " , result ) NEW_LINE DEDENT
def from_y ( y ) : NEW_LINE INDENT n = y * y - Point . b NEW_LINE x = n ** ( 1. / 3 ) if n >= 0 else - ( ( - n ) ** ( 1. / 3 ) ) NEW_LINE return Point ( x , y ) NEW_LINE DEDENT
import os ; NEW_LINE if os . listdir ( raw_input ( " directory " ) ) : NEW_LINE INDENT print " not ▁ empty " NEW_LINE DEDENT else : NEW_LINE INDENT print " empty " NEW_LINE DEDENT
1 NEW_LINE QUIT NEW_LINE
import os NEW_LINE os . environ [ ' HOME ' ] NEW_LINE
def fitness ( trial ) : NEW_LINE INDENT return sum ( t == h for t , h in zip ( trial , target ) ) NEW_LINE DEDENT
def mutate ( parent , rate ) : NEW_LINE INDENT return [ ( ch if random ( ) <= rate else choice ( charset ) ) for ch in parent ] NEW_LINE DEDENT
import exceptions NEW_LINE class SillyError ( exceptions . Exception ) : NEW_LINE INDENT def __init__ ( self , args = None ) : NEW_LINE INDENT self . args = args NEW_LINE DEDENT DEDENT
def foo ( ) : NEW_LINE INDENT for i in range ( 2 ) : NEW_LINE INDENT try : NEW_LINE INDENT bar ( i ) NEW_LINE DEDENT except U0 : NEW_LINE INDENT print ( " Function ▁ foo ▁ caught ▁ exception ▁ U0" ) NEW_LINE DEDENT DEDENT DEDENT
import os NEW_LINE exit_code = os . system ( ' ls ' ) NEW_LINE output = os . popen ( ' ls ' ) . read ( ) NEW_LINE
MULTIPLY = lambda x , y : x * y NEW_LINE class num ( float ) : NEW_LINE INDENT def __pow__ ( self , b ) : NEW_LINE INDENT return reduce ( MULTIPLY , [ self ] * b , 1 ) NEW_LINE DEDENT DEDENT print num ( 2 ) . __pow__ ( 3 ) NEW_LINE print num ( 2 ) ** 3 NEW_LINE print num ( 2.3 ) . __pow__ ( 8 ) NEW_LINE print num ( 2.3 ) ** 8 NEW_LINE
a , b = 1 , 0 NEW_LINE if ( c1 := a == 1 ) and ( c2 := b == 3 ) : NEW_LINE INDENT print ( ' a ▁ = ▁ 1 ▁ and ▁ b ▁ = ▁ 3' ) NEW_LINE DEDENT elif c1 : NEW_LINE INDENT print ( ' a ▁ = ▁ 1 ▁ and ▁ b ▁ < > ▁ 3' ) NEW_LINE DEDENT elif c2 : NEW_LINE INDENT print ( ' a ▁ < > ▁ 1 ▁ and ▁ b ▁ = ▁ 3' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' a ▁ < > ▁ 1 ▁ and ▁ b ▁ < > ▁ 3' ) NEW_LINE DEDENT
islice ( count ( 7 ) , 0 , None , 2 ) NEW_LINE
import math NEW_LINE math . factorial ( n ) NEW_LINE
fact = [ 1 ] NEW_LINE for n in range ( 1 , 12 ) : NEW_LINE INDENT fact . append ( fact [ n - 1 ] * n ) NEW_LINE DEDENT for b in range ( 9 , 12 + 1 ) : NEW_LINE INDENT print ( f " The ▁ factorions ▁ for ▁ base ▁ { b } ▁ are : " ) NEW_LINE for i in range ( 1 , 1500000 ) : NEW_LINE INDENT fact_sum = 0 NEW_LINE j = i NEW_LINE while j > 0 : NEW_LINE INDENT d = j % b NEW_LINE fact_sum += fact [ d ] NEW_LINE j = j // b NEW_LINE DEDENT if fact_sum == i : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " \n " ) NEW_LINE DEDENT
def is_prime ( number ) : NEW_LINE INDENT return True NEW_LINE DEDENT
def fft ( x ) : NEW_LINE INDENT N = len ( x ) NEW_LINE if N <= 1 : return x NEW_LINE even = fft ( x [ 0 : : 2 ] ) NEW_LINE odd = fft ( x [ 1 : : 2 ] ) NEW_LINE T = [ exp ( - 2j * pi * k / N ) * odd [ k ] for k in range ( N // 2 ) ] NEW_LINE return [ even [ k ] + T [ k ] for k in range ( N // 2 ) ] + [ even [ k ] - T [ k ] for k in range ( N // 2 ) ] NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT fs = faulhaberTriangle ( 9 ) NEW_LINE print ( fTable ( __doc__ + ' : \n ' ) ( str ) ( compose ( concat ) ( fmap ( showRatio ( 3 ) ( 3 ) ) ) ) ( index ( fs ) ) ( range ( 0 , len ( fs ) ) ) ) NEW_LINE print ( ' ' ) NEW_LINE print ( faulhaberSum ( 17 , 1000 ) ) NEW_LINE DEDENT
max_it = 13 NEW_LINE max_it_j = 10 NEW_LINE a1 = 1.0 NEW_LINE a2 = 0.0 NEW_LINE d1 = 3.2 NEW_LINE a = 0.0 NEW_LINE print " ▁ i ▁ ▁ ▁ ▁ ▁ ▁ ▁ d " NEW_LINE for i in range ( 2 , max_it + 1 ) : NEW_LINE INDENT a = a1 + ( a1 - a2 ) / d1 NEW_LINE for j in range ( 1 , max_it_j + 1 ) : NEW_LINE INDENT x = 0.0 NEW_LINE y = 0.0 NEW_LINE for k in range ( 1 , ( 1 << i ) + 1 ) : NEW_LINE INDENT y = 1.0 - 2.0 * y * x NEW_LINE x = a - x * x NEW_LINE DEDENT a = a - x / y NEW_LINE DEDENT d = ( a1 - a2 ) / ( a - a1 ) NEW_LINE print ( " { 0:2d } ▁ ▁ ▁ ▁ { 1 : . 8f } " . format ( i , d ) ) NEW_LINE d1 = d NEW_LINE a2 = a1 NEW_LINE a1 = a NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT n = 25 NEW_LINE step = 1 NEW_LINE width = 1050 NEW_LINE height = 1050 NEW_LINE w = fibonacci_word ( n ) NEW_LINE setup ( width = width , height = height ) NEW_LINE speed ( 0 ) NEW_LINE setheading ( 90 ) NEW_LINE left ( 90 ) NEW_LINE penup ( ) NEW_LINE forward ( 500 ) NEW_LINE right ( 90 ) NEW_LINE backward ( 500 ) NEW_LINE pendown ( ) NEW_LINE tracer ( 10000 ) NEW_LINE hideturtle ( ) NEW_LINE draw_fractal ( w , step ) NEW_LINE getscreen ( ) . getcanvas ( ) . postscript ( file = " fibonacci _ word _ fractal . eps " ) NEW_LINE exitonclick ( ) NEW_LINE DEDENT
import shutil NEW_LINE shutil . copyfile ( ' input . txt ' , ' output . txt ' ) NEW_LINE
import os NEW_LINE modtime = os . path . getmtime ( ' filename ' ) NEW_LINE os . utime ( ' path ' , ( actime , mtime ) ) NEW_LINE os . utime ( ' path ' , ( os . path . getatime ( ' path ' ) , mtime ) ) NEW_LINE os . utime ( ' path ' , None ) NEW_LINE
import os NEW_LINE size = os . path . getsize ( ' input . txt ' ) NEW_LINE size = os . path . getsize ( ' / input . txt ' ) NEW_LINE
values = range ( 10 ) NEW_LINE evens = [ x for x in values if not x & 1 ] NEW_LINE ievens = ( x for x in values if not x & 1 ) NEW_LINE evens = filter ( lambda x : not x & 1 , values ) NEW_LINE
import sys NEW_LINE print ( sys . getrecursionlimit ( ) ) NEW_LINE
import sys NEW_LINE import calendar NEW_LINE year = 2013 NEW_LINE if len ( sys . argv ) > 1 : NEW_LINE INDENT try : NEW_LINE INDENT year = int ( sys . argv [ - 1 ] ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT for month in range ( 1 , 13 ) : NEW_LINE INDENT last_sunday = max ( week [ - 1 ] for week in calendar . monthcalendar ( year , month ) ) NEW_LINE print ( ' { } - { } - { :2 } ' . format ( year , calendar . month_abbr [ month ] , last_sunday ) ) NEW_LINE DEDENT
from itertools import permutations NEW_LINE given = ''' ABCD ▁ CABD ▁ ACDB ▁ DACB ▁ BCDA ▁ ACBD ▁ ADCB ▁ CDAB ▁ DABC ▁ BCAD ▁ CADB ▁ CDBA STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ CBAD ▁ ABDC ▁ ADBC ▁ BDCA ▁ DCBA ▁ BACD ▁ BADC ▁ BDAC ▁ CBDA ▁ DBCA ▁ DCAB ''' . split ( ) NEW_LINE allPerms = [ ' ' . join ( x ) for x in permutations ( given [ 0 ] ) ] NEW_LINE missing = list ( set ( allPerms ) - set ( given ) ) NEW_LINE
def main ( ) : NEW_LINE INDENT start = time ( ) NEW_LINE print ( main . __doc__ + ' : \n \n Base ▁ ▁ ▁ ▁ ▁ ▁ Root ▁ ▁ ▁ ▁ Square ' ) NEW_LINE q = 0 NEW_LINE for b in enumFromTo ( 2 ) ( 16 ) : NEW_LINE INDENT q = allDigitSquare ( b , q ) NEW_LINE print ( str ( b ) . rjust ( 2 , ' ▁ ' ) + ' ▁ - > ▁ ' + showIntAtBase ( b ) ( digit ) ( q ) ( ' ' ) . rjust ( 8 , ' ▁ ' ) + ' ▁ - > ▁ ' + showIntAtBase ( b ) ( digit ) ( q * q ) ( ' ' ) ) NEW_LINE DEDENT print ( ' \n c . ▁ ' + str ( ceil ( time ( ) - start ) ) + ' ▁ seconds . ' ) NEW_LINE DEDENT
def p ( l , n , pwr = 2 ) : NEW_LINE INDENT l = int ( abs ( l ) ) NEW_LINE digitcount = floor ( log ( l , 10 ) ) NEW_LINE log10pwr = log ( pwr , 10 ) NEW_LINE raised , found = - 1 , 0 NEW_LINE while found < n : NEW_LINE INDENT raised += 1 NEW_LINE firstdigits = floor ( 10 ** ( modf ( log10pwr * raised ) [ 0 ] + digitcount ) ) NEW_LINE if firstdigits == l : NEW_LINE INDENT found += 1 NEW_LINE DEDENT DEDENT return raised NEW_LINE DEDENT
def fivenum ( array ) : NEW_LINE INDENT n = len ( array ) NEW_LINE if n == 0 : NEW_LINE INDENT print ( " you ▁ entered ▁ an ▁ empty ▁ array . " ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT x = sorted ( array ) NEW_LINE n4 = math . floor ( ( n + 3.0 ) / 2.0 ) / 2.0 NEW_LINE d = [ 1 , n4 , ( n + 1 ) / 2 , n + 1 - n4 , n ] NEW_LINE sum_array = [ ] NEW_LINE for e in range ( 5 ) : NEW_LINE INDENT floor = int ( math . floor ( d [ e ] - 1 ) ) NEW_LINE ceil = int ( math . ceil ( d [ e ] - 1 ) ) NEW_LINE sum_array . append ( 0.5 * ( x [ floor ] + x [ ceil ] ) ) NEW_LINE DEDENT return sum_array NEW_LINE DEDENT
for i in xrange ( 1 , 101 ) : NEW_LINE INDENT if i % 15 == 0 : NEW_LINE INDENT print " FizzBuzz " NEW_LINE DEDENT elif i % 3 == 0 : NEW_LINE INDENT print " Fizz " NEW_LINE DEDENT elif i % 5 == 0 : NEW_LINE INDENT print " Buzz " NEW_LINE DEDENT else : NEW_LINE INDENT print i NEW_LINE DEDENT DEDENT
for i in range ( n ) : NEW_LINE INDENT if ( n % 2 ) == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if ( n % i ) == 0 : NEW_LINE INDENT result = i NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT result = None NEW_LINE print " No ▁ odd ▁ factors ▁ found " NEW_LINE DEDENT
def floyd_warshall ( n , edge ) : NEW_LINE INDENT rn = range ( n ) NEW_LINE dist = [ [ inf ] * n for i in rn ] NEW_LINE nxt = [ [ 0 ] * n for i in rn ] NEW_LINE for i in rn : NEW_LINE INDENT dist [ i ] [ i ] = 0 NEW_LINE DEDENT for u , v , w in edge : NEW_LINE INDENT dist [ u - 1 ] [ v - 1 ] = w NEW_LINE nxt [ u - 1 ] [ v - 1 ] = v - 1 NEW_LINE DEDENT for k , i , j in product ( rn , repeat = 3 ) : NEW_LINE INDENT sum_ik_kj = dist [ i ] [ k ] + dist [ k ] [ j ] NEW_LINE if dist [ i ] [ j ] > sum_ik_kj : NEW_LINE INDENT dist [ i ] [ j ] = sum_ik_kj NEW_LINE nxt [ i ] [ j ] = nxt [ i ] [ k ] NEW_LINE DEDENT DEDENT print ( " pair ▁ ▁ ▁ ▁ ▁ dist ▁ ▁ ▁ ▁ path " ) NEW_LINE for i , j in product ( rn , repeat = 2 ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT path = [ i ] NEW_LINE while path [ - 1 ] != j : NEW_LINE INDENT path . append ( nxt [ path [ - 1 ] ] [ j ] ) NEW_LINE DEDENT print ( " % d ▁ → ▁ % d ▁ ▁ % 4d ▁ ▁ ▁ ▁ ▁ ▁ ▁ % s " % ( i + 1 , j + 1 , dist [ i ] [ j ] , ' ▁ → ▁ ' . join ( str ( p + 1 ) for p in path ) ) ) NEW_LINE DEDENT DEDENT DEDENT
import os NEW_LINE pid = os . fork ( ) NEW_LINE if pid > 0 : NEW_LINE else : NEW_LINE
from math import pi , exp NEW_LINE r = exp ( pi ) - pi NEW_LINE print r NEW_LINE print " e = % e ▁ f = % f ▁ g = % g ▁ G = % G ▁ s = % s ▁ r = % r ! " % ( r , r , r , r , r , r ) NEW_LINE print " e = % 9.4e ▁ f = % 9.4f ▁ g = % 9.4g ! " % ( - r , - r , - r ) NEW_LINE print " e = % 9.4e ▁ f = % 9.4f ▁ g = % 9.4g ! " % ( r , r , r ) NEW_LINE print " e = % -9.4e ▁ f = % -9.4f ▁ g = % -9.4g ! " % ( r , r , r ) NEW_LINE print " e = % 09.4e ▁ f = % 09.4f ▁ g = % 09.4g ! " % ( - r , - r , - r ) NEW_LINE print " e = % 09.4e ▁ f = % 09.4f ▁ g = % 09.4g ! " % ( r , r , r ) NEW_LINE print " e = % -09.4e ▁ f = % -09.4f ▁ g = % -09.4g ! " % ( r , r , r ) NEW_LINE
def translate_to_origin ( poly ) : NEW_LINE INDENT ( minx , miny ) = minima ( poly ) NEW_LINE return [ ( x - minx , y - miny ) for ( x , y ) in poly ] NEW_LINE DEDENT
def rotations_and_reflections ( poly ) : NEW_LINE INDENT return ( poly , map ( rotate90 , poly ) , map ( rotate180 , poly ) , map ( rotate270 , poly ) , map ( reflect , poly ) , [ reflect ( rotate90 ( pt ) ) for pt in poly ] , [ reflect ( rotate180 ( pt ) ) for pt in poly ] , [ reflect ( rotate270 ( pt ) ) for pt in poly ] ) NEW_LINE DEDENT
def new_points ( poly ) : NEW_LINE INDENT return unique ( [ pt for pt in concat_map ( contiguous , poly ) if pt not in poly ] ) NEW_LINE DEDENT
def rank ( n ) : NEW_LINE INDENT assert n >= 0 NEW_LINE if n == 0 : return [ ] NEW_LINE if n == 1 : return monominoes NEW_LINE return unique ( concat_map ( new_polys , rank ( n - 1 ) ) ) NEW_LINE DEDENT
from ftplib import FTP NEW_LINE ftp = FTP ( ' kernel . org ' ) NEW_LINE ftp . login ( ) NEW_LINE ftp . cwd ( ' / pub / linux / kernel ' ) NEW_LINE ftp . set_pasv ( True ) NEW_LINE print ftp . retrlines ( ' LIST ' ) NEW_LINE print ftp . retrbinary ( ' RETR ▁ README ' , open ( ' README ' , ' wb ' ) . write ) NEW_LINE ftp . quit ( ) NEW_LINE
compose = lambda f , g : lambda x : f ( g ( x ) ) NEW_LINE
def multiply ( a , b ) : NEW_LINE INDENT return a * b NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT board = Board ( width = 15 , well_depth = 5 , N = 10 ) NEW_LINE board . add_ball ( ) NEW_LINE while ( board . balls_on_board ( ) > 0 ) : NEW_LINE INDENT board . print_all ( ) NEW_LINE time . sleep ( 0.25 ) NEW_LINE board . update ( ) NEW_LINE board . print_all ( ) NEW_LINE time . sleep ( 0.25 ) NEW_LINE board . update ( ) NEW_LINE board . add_ball ( ) NEW_LINE DEDENT DEDENT
from itertools import islice , count NEW_LINE for start , n in [ ( 100 , 30 ) , ( 1_000_000 , 15 ) , ( 1_000_000_000 , 10 ) ] : NEW_LINE INDENT print ( f " \n First ▁ { n } ▁ gapful ▁ numbers ▁ from ▁ { start : _ } " ) NEW_LINE print ( list ( islice ( ( x for x in count ( start ) if ( x % ( int ( str ( x ) [ 0 ] ) * 10 + ( x % 10 ) ) == 0 ) ) , n ) ) ) NEW_LINE DEDENT
import numpy as np NEW_LINE from numpy . linalg import inv NEW_LINE a = np . array ( [ [ 1. , 2. , 3. ] , [ 4. , 1. , 6. ] , [ 7. , 8. , 9. ] ] ) NEW_LINE ainv = inv ( a ) NEW_LINE print ( a ) NEW_LINE print ( ainv ) NEW_LINE
from string import ascii_lowercase NEW_LINE lower = [ chr ( i ) for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) ] NEW_LINE
def place_kings ( brd ) : NEW_LINE INDENT while True : NEW_LINE INDENT rank_white , file_white , rank_black , file_black = random . randint ( 0 , 7 ) , random . randint ( 0 , 7 ) , random . randint ( 0 , 7 ) , random . randint ( 0 , 7 ) NEW_LINE diff_list = [ abs ( rank_white - rank_black ) , abs ( file_white - file_black ) ] NEW_LINE if sum ( diff_list ) > 2 or set ( diff_list ) == set ( [ 0 , 2 ] ) : NEW_LINE INDENT brd [ rank_white ] [ file_white ] , brd [ rank_black ] [ file_black ] = " K " , " k " NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
import random NEW_LINE print ( random . sample ( range ( 1 , 21 ) , 20 ) ) NEW_LINE
a , b = b , a NEW_LINE
def e ( n ) : NEW_LINE INDENT assert n <= 4 , " n ▁ must ▁ be ▁ less ▁ than ▁ 5" NEW_LINE result = Vector ( [ 0.0 ] * 32 ) NEW_LINE result [ 1 << n ] = 1.0 NEW_LINE return result NEW_LINE DEDENT
import fileinput NEW_LINE for line in fileinput . input ( inplace = True ) : NEW_LINE INDENT print ( line . replace ( ' Goodbye ▁ London ! ' , ' Hello ▁ New ▁ York ! ' ) , end = ' ' ) NEW_LINE DEDENT
Red [ Title : " Go ▁ Fish " Author : " gltewalt " ] NEW_LINE chand : [ ] ; - - c and p = computer and player NEW_LINE cguesses : [ ] NEW_LINE phand : [ ] NEW_LINE cbooks : 0 NEW_LINE pbooks : 0 NEW_LINE gf : { ** ** ** ** ** ** ** * * GO FISH * ** ** ** ** ** ** ** * } NEW_LINE pip : [ " a " "2" "3" "4" "5" "6" "7" "8" "9" "10" " j " " q " " k " ] ; - - suits are not relevant NEW_LINE pile : [ ] ; - - where discarded cards go NEW_LINE ; - - - - - - - - - - - - - - - - - - - - - NEW_LINE ; Helper functions - NEW_LINE ; - - - - - - - - - - - - - - - - - - - - - NEW_LINE clear - screen : does [ call / console either system / platform =   ' Linux [ " clear " ] [ " cls " ] ] clear - and - show : func [ duration str ] [ { Poor persons animation . Blips message to screen after a pause of duration length . } clear - screen print str wait duration clear - screen ] NEW_LINE deal - cards : func [ num hand ] [ loop num [ append hand rejoin [ trim / all form take deck ] ] ] NEW_LINE find - in : func [ blk str ] [ foreach i blk [ if find i str [ return i ] ] ] go - fish : func [ num hand ] [ either not empty ? deck [ deal - cards num hand ] [ append hand rejoin [ trim / all form take pile ] ; - - take from pile if deck is empty ] ] NEW_LINE guess - from : func [ hand guessed ] [ { Randomly picks from hand minus guessed . Simulates a person asking for different cards on their next turn if their previous guess resulted in a Go Fish . } random / seed now / time either any [ empty ? guessed empty ? exclude hand guessed ] [ random / only hand ] [ random / only exclude hand guessed ] ] NEW_LINE make - deck : function [ ] [ new - deck : make block ! 52 foreach p pip [ loop 4 [ append / only new - deck p ] ] return new - deck ] show - cards : does [ clear - and - show 0 " " print [ newline " Player ▁ cards : " newline sort phand newline ] print [ " Computer ▁ books : " cbooks ] print [ " Player ▁ books : " pbooks newline ] ] NEW_LINE shuffle : function [ deck [ block ! ] ] [ deck : random deck ] NEW_LINE ; - - - - - - - - - - - - - end of helper functions - - - - - - - - - - - - - - - - - NEW_LINE check - for - books : func [ { Checks for a book in a players hand . Increments the players book score , and discards the book from the players hand } hand " from ▁ or ▁ to ▁ hand " kind " rank ▁ of ▁ cards " / local c " collected " ] [ c : collect [ forall hand [ keep find hand / 1 kind ] ] remove - each i c [ none = i ] if 4 = length ? c [ either hand = phand [ pbooks : pbooks + 1 ] [ cbooks : cbooks + 1 ] remove - each i hand [ if find / only c i [ i ] ] ; - - remove book from hand forall c [ append pile c / 1 ] ; - - append discarded book to the pile ] ] NEW_LINE transfer - cards : func [ fhand " from ▁ hand " thand " to ▁ hand " kind " rank ▁ of ▁ cards " / local c " collected " ] [ c : collect [ forall fhand [ keep find fhand / 1 kind ] ] remove - each i c [ none = i ] ; - - remove none values from collected forall c [ append thand c / 1 ] ; - - append remaining values to " to ▁ hand " remove - each i fhand [ if find / only c i [ i ] ] ; - - remove those values from " from ▁ hand " ] computer - turn : func [ fhand " from ▁ hand " thand " to ▁ hand " kind " rank ▁ of ▁ cards " / local a ] [ a : ask rejoin [ " Do ▁ you ▁ have ▁ any ▁ " kind " ▁ s ? ▁ " ] if a = " x " [ halt ] either any [ a = " y " a = " yes " ] [ check - for - books thand kind transfer - cards fhand thand kind show - cards computer - turn fhand thand guess - from thand cguesses ] [ clear - and - show 0.4 gf go - fish 1 thand append cguesses kind ] ] NEW_LINE player - turn : func [ fhand " from ▁ hand " thand " to ▁ hand " kind " rank ▁ of ▁ cards " / local p ] [ if empty ? fhand [ go - fish 3 fhand ] if none ? find - in thand kind [ ; - - player has to hold rank asked for clear - and - show 1.0 exit ] either find - in fhand kind [ check - for - books thand kind transfer - cards fhand thand kind show - cards if find - in thand kind [ p : ask " Your ▁ guess : ▁ " either p = " x " [ halt ] [ player - turn fhand thand p ] check - for - books thand p ] ] [ clear - and - show 0.4 gf go - fish 1 thand ] ] game - round : has [ c p ] [ print { - - - - - - - - - - - - - - - - - - - - COMPUTER TURN - - - - - - - - - - - - - - - - - - - - } if empty ? chand [ ; computer has no more cards ? fish 3 cards . go - fish 3 chand show - cards ] computer - turn phand chand c : guess - from chand cguesses check - for - books chand c show - cards print { - - - - - - - - - - - - - - - - - - - - PLAYER TURN - - - - - - - - - - - - - - - - - - - - } if empty ? phand [ ; - - player has no more cards ? fish 3 cards . go - fish 3 phand show - cards ] p : ask " Your ▁ guess : ▁ " either p = " x " [ halt ] [ player - turn chand phand find - in phand p ] check - for - books phand p show - cards ] NEW_LINE main : does [ deck : shuffle make - deck deal - cards 9 chand deal - cards 9 phand show - cards while [ cbooks + pbooks < 13 ] [ game - round ] clear - and - show 0 " " print " GAME ▁ OVER " print [ newline " Computer ▁ books : " cbooks newline " Player ▁ books : " pbooks ] ] NEW_LINE main NEW_LINE
def gray_encode ( n ) : NEW_LINE INDENT return n ^ n >> 1 NEW_LINE DEDENT
def gray_decode ( n ) : NEW_LINE INDENT m = n >> 1 NEW_LINE while m : NEW_LINE INDENT n ^= m NEW_LINE m >>= 1 NEW_LINE DEDENT return n NEW_LINE DEDENT
import io NEW_LINE ppmfileout = io . StringIO ( ' ' ) NEW_LINE def togreyscale ( self ) : NEW_LINE INDENT for h in range ( self . height ) : NEW_LINE INDENT for w in range ( self . width ) : NEW_LINE INDENT r , g , b = self . get ( w , h ) NEW_LINE l = int ( 0.2126 * r + 0.7152 * g + 0.0722 * b ) NEW_LINE self . set ( w , h , Colour ( l , l , l ) ) NEW_LINE DEDENT DEDENT DEDENT Bitmap . togreyscale = togreyscale NEW_LINE bitmap = Bitmap ( 4 , 4 , white ) NEW_LINE bitmap . fillrect ( 1 , 0 , 1 , 2 , Colour ( 127 , 0 , 63 ) ) NEW_LINE bitmap . set ( 3 , 3 , Colour ( 0 , 127 , 31 ) ) NEW_LINE print ( ' Colour : ' ) NEW_LINE bitmap . writeppmp3 ( ppmfileout ) NEW_LINE print ( ppmfileout . getvalue ( ) ) NEW_LINE print ( ' Grey : ' ) NEW_LINE bitmap . togreyscale ( ) NEW_LINE ppmfileout = io . StringIO ( ' ' ) NEW_LINE bitmap . writeppmp3 ( ppmfileout ) NEW_LINE print ( ppmfileout . getvalue ( ) ) NEW_LINE
from fractions import gcd NEW_LINE
max ( values ) NEW_LINE
def maxsubseq ( seq ) : NEW_LINE INDENT return max ( ( seq [ begin : end ] for begin in xrange ( len ( seq ) + 1 ) for end in xrange ( begin , len ( seq ) + 1 ) ) , key = sum ) NEW_LINE DEDENT
from livewires import * NEW_LINE horiz = 640 ; vert = 480 ; pruh = vert / 4 ; dpp = 255.0 NEW_LINE begin_graphics ( width = horiz , height = vert , title = " Gray ▁ stripes " , background = Colour . black ) NEW_LINE def ty_pruhy ( each ) : NEW_LINE INDENT hiy = each [ 0 ] * pruh ; loy = hiy - pruh NEW_LINE krok = horiz / each [ 1 ] ; piecol = 255.0 / ( each [ 1 ] - 1 ) NEW_LINE for x in xrange ( 0 , each [ 1 ] ) : NEW_LINE INDENT barva = Colour ( piecol * x / dpp , piecol * x / dpp , piecol * x / dpp ) ; set_colour ( barva ) NEW_LINE if each [ 2 ] : NEW_LINE INDENT box ( x * krok , hiy , x * krok + krok , loy , filled = 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT box ( horiz - x * krok , hiy , horiz - ( ( x + 1 ) * krok ) , loy , filled = 1 ) NEW_LINE DEDENT DEDENT DEDENT source = [ [ 4 , 8 , True ] , [ 3 , 16 , False ] , [ 2 , 32 , True ] , [ 1 , 64 , False ] ] NEW_LINE for each in source : NEW_LINE INDENT ty_pruhy ( each ) NEW_LINE DEDENT while keys_pressed ( ) != [ ' ▁ ' ] : NEW_LINE INDENT pass NEW_LINE DEDENT
import random NEW_LINE t , g = random . randint ( 1 , 10 ) , 0 NEW_LINE g = int ( input ( " Guess ▁ a ▁ number ▁ that ' s ▁ between ▁ 1 ▁ and ▁ 10 : ▁ " ) ) NEW_LINE while t != g : g = int ( input ( " Guess ▁ again ! ▁ " ) ) NEW_LINE print ( " That ' s ▁ right ! " ) NEW_LINE
inclusive_range = mn , mx = ( 1 , 10 ) NEW_LINE print ( ''' \ STRNEWLINE Think ▁ of ▁ a ▁ number ▁ between ▁ % i ▁ and ▁ % i ▁ and ▁ wait ▁ for ▁ me ▁ to ▁ guess ▁ it . STRNEWLINE On ▁ every ▁ guess ▁ of ▁ mine ▁ you ▁ should ▁ state ▁ whether ▁ the ▁ guess ▁ was STRNEWLINE too ▁ high , ▁ too ▁ low , ▁ or ▁ equal ▁ to ▁ your ▁ number ▁ by ▁ typing ▁ h , ▁ l , ▁ or ▁ = STRNEWLINE ''' % inclusive_range ) NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT i += 1 NEW_LINE guess = ( mn + mx ) // 2 NEW_LINE txt = input ( " Guess ▁ % 2i ▁ is : ▁ % 2i . ▁ The ▁ score ▁ for ▁ which ▁ is ▁ ( h , l , = ) : ▁ " % ( i , guess ) ) . strip ( ) . lower ( ) [ 0 ] NEW_LINE if txt not in ' hl = ' : NEW_LINE INDENT print ( " ▁ ▁ I ▁ don ' t ▁ understand ▁ your ▁ input ▁ of ▁ ' % s '   ? " % txt ) NEW_LINE continue NEW_LINE DEDENT if txt == ' h ' : NEW_LINE INDENT mx = guess - 1 NEW_LINE DEDENT if txt == ' l ' : NEW_LINE INDENT mn = guess + 1 NEW_LINE DEDENT if txt == ' = ' : NEW_LINE INDENT print ( " ▁ ▁ Ye - Haw ! ! " ) NEW_LINE break NEW_LINE DEDENT if ( mn > mx ) or ( mn < inclusive_range [ 0 ] ) or ( mx > inclusive_range [ 1 ] ) : NEW_LINE INDENT print ( " Please ▁ check ▁ your ▁ scoring ▁ as ▁ I ▁ cannot ▁ find ▁ the ▁ value " ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( " \n Thanks ▁ for ▁ keeping ▁ score . " ) NEW_LINE
import random NEW_LINE inclusive_range = ( 1 , 100 ) NEW_LINE print ( " Guess ▁ my ▁ target ▁ number ▁ that ▁ is ▁ between ▁ % i ▁ and ▁ % i ▁ ( inclusive ) . \n " % inclusive_range ) NEW_LINE target = random . randint ( * inclusive_range ) NEW_LINE answer , i = None , 0 NEW_LINE while answer != target : NEW_LINE INDENT i += 1 NEW_LINE txt = input ( " Your ▁ guess ( % i ) : ▁ " % i ) NEW_LINE try : NEW_LINE INDENT answer = int ( txt ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT print ( " ▁ ▁ I ▁ don ' t ▁ understand ▁ your ▁ input ▁ of ▁ ' % s '   ? " % txt ) NEW_LINE continue NEW_LINE DEDENT if answer < inclusive_range [ 0 ] or answer > inclusive_range [ 1 ] : NEW_LINE INDENT print ( " ▁ ▁ Out ▁ of ▁ range ! " ) NEW_LINE continue NEW_LINE DEDENT if answer == target : NEW_LINE INDENT print ( " ▁ ▁ Ye - Haw ! ! " ) NEW_LINE break NEW_LINE DEDENT if answer < target : print ( " ▁ ▁ Too ▁ low . " ) NEW_LINE if answer > target : print ( " ▁ ▁ Too ▁ high . " ) NEW_LINE DEDENT print ( " \n Thanks ▁ for ▁ playing . " ) NEW_LINE
def main ( ) : NEW_LINE INDENT app = MyForm ( ) NEW_LINE app . mainloop ( ) NEW_LINE DEDENT
import tkinter as tk NEW_LINE root = tk . Tk ( ) NEW_LINE root . state ( ' zoomed ' ) NEW_LINE root . update_idletasks ( ) NEW_LINE tk . Label ( root , text = ( str ( root . winfo_width ( ) ) + " ▁ x ▁ " + str ( root . winfo_height ( ) ) ) , font = ( " Helvetica " , 25 ) ) . pack ( ) NEW_LINE root . mainloop ( ) NEW_LINE
import time NEW_LINE def counter ( ) : NEW_LINE INDENT n = 0 NEW_LINE t1 = time . time ( ) NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT time . sleep ( 0.5 ) NEW_LINE n += 1 NEW_LINE print n NEW_LINE DEDENT except KeyboardInterrupt , e : NEW_LINE INDENT print ' Program ▁ has ▁ run ▁ for ▁ % 5.3f ▁ seconds . ' % ( time . time ( ) - t1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT counter ( ) NEW_LINE
keys = [ ' a ' , ' b ' , ' c ' ] NEW_LINE values = [ 1 , 2 , 3 ] NEW_LINE hash = { key : value for key , value in zip ( keys , values ) } NEW_LINE
import bpy NEW_LINE bpy . data . objects [ ' Cube ' ] . select_set ( True ) NEW_LINE bpy . ops . object . delete ( True ) NEW_LINE bpy . data . curves . new ( type = " FONT " , name = " Font ▁ Curve " ) . body = " Hello ▁ World " NEW_LINE font_obj = bpy . data . objects . new ( name = " Font ▁ Object " , object_data = bpy . data . curves [ " Font ▁ Curve " ] ) NEW_LINE bpy . context . scene . collection . objects . link ( font_obj ) NEW_LINE bpy . context . scene . camera . location = ( 2.5 , 0.3 , 10 ) NEW_LINE bpy . context . scene . camera . rotation_euler = ( 0 , 0 , 0 ) NEW_LINE area = next ( area for area in bpy . context . screen . areas if area . type == ' VIEW _ 3D ' ) NEW_LINE area . spaces [ 0 ] . region_3d . view_perspective = ' CAMERA ' NEW_LINE
lp = open ( " / dev / lp0" ) NEW_LINE lp . write ( " Hello ▁ World ! \n " ) NEW_LINE lp . close ( ) NEW_LINE
print " Goodbye , ▁ World ! " NEW_LINE
import sys NEW_LINE sys . stdout . write ( " Goodbye , ▁ World ! " ) NEW_LINE
import sys NEW_LINE print >> sys . stderr , " Goodbye , ▁ World ! " NEW_LINE
print " Hello ▁ world ! " NEW_LINE
def main ( ) : NEW_LINE INDENT print ( hilbertCurve ( 6 ) ) NEW_LINE DEDENT
def ffr ( n ) : NEW_LINE INDENT if n < 1 or type ( n ) != int : raise ValueError ( " n ▁ must ▁ be ▁ an ▁ int ▁ > = ▁ 1" ) NEW_LINE try : NEW_LINE INDENT return ffr . r [ n ] NEW_LINE DEDENT except IndexError : NEW_LINE INDENT r , s = ffr . r , ffs . s NEW_LINE ffr_n_1 = ffr ( n - 1 ) NEW_LINE lastr = r [ - 1 ] NEW_LINE s += list ( range ( s [ - 1 ] + 1 , lastr ) ) NEW_LINE if s [ - 1 ] < lastr : s += [ lastr + 1 ] NEW_LINE len_s = len ( s ) NEW_LINE ffs_n_1 = s [ n - 1 ] if len_s > n else ( n - len_s ) + s [ - 1 ] NEW_LINE ans = ffr_n_1 + ffs_n_1 NEW_LINE r . append ( ans ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
def ffs ( n ) : NEW_LINE INDENT if n < 1 or type ( n ) != int : raise ValueError ( " n ▁ must ▁ be ▁ an ▁ int ▁ > = ▁ 1" ) NEW_LINE try : NEW_LINE INDENT return ffs . s [ n ] NEW_LINE DEDENT except IndexError : NEW_LINE INDENT r , s = ffr . r , ffs . s NEW_LINE for i in range ( len ( r ) , n + 2 ) : NEW_LINE INDENT ffr ( i ) NEW_LINE if len ( s ) > n : NEW_LINE INDENT return s [ n ] NEW_LINE DEDENT DEDENT raise Exception ( " Whoops ! " ) NEW_LINE DEDENT DEDENT
def q ( n ) : NEW_LINE INDENT if n < 1 or type ( n ) != int : raise ValueError ( " n ▁ must ▁ be ▁ an ▁ int ▁ > = ▁ 1" ) NEW_LINE try : NEW_LINE INDENT return q . seq [ n ] NEW_LINE DEDENT except IndexError : NEW_LINE INDENT ans = q ( n - q ( n - 1 ) ) + q ( n - q ( n - 2 ) ) NEW_LINE q . seq . append ( ans ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
from __future__ import print_function NEW_LINE import math NEW_LINE try : raw_input NEW_LINE except : raw_input = input NEW_LINE lat = float ( raw_input ( " Enter ▁ latitude ▁ ▁ ▁ ▁ ▁ ▁ ▁ = > ▁ " ) ) NEW_LINE lng = float ( raw_input ( " Enter ▁ longitude ▁ ▁ ▁ ▁ ▁ ▁ = > ▁ " ) ) NEW_LINE ref = float ( raw_input ( " Enter ▁ legal ▁ meridian ▁ = > ▁ " ) ) NEW_LINE print ( ) NEW_LINE slat = math . sin ( math . radians ( lat ) ) NEW_LINE print ( " ▁ ▁ ▁ ▁ sine ▁ of ▁ latitude : ▁ ▁ ▁ % .3f " % slat ) NEW_LINE print ( " ▁ ▁ ▁ ▁ diff ▁ longitude : ▁ ▁ ▁ ▁ ▁ % .3f " % ( lng - ref ) ) NEW_LINE print ( ) NEW_LINE print ( " Hour , ▁ sun ▁ hour ▁ angle , ▁ dial ▁ hour ▁ line ▁ angle ▁ from ▁ 6am ▁ to ▁ 6pm " ) NEW_LINE for h in range ( - 6 , 7 ) : NEW_LINE INDENT hra = 15 * h NEW_LINE hra -= lng - ref NEW_LINE hla = math . degrees ( math . atan ( slat * math . tan ( math . radians ( hra ) ) ) ) NEW_LINE print ( " HR = % 3d ; ▁ HRA = % 7.3f ; ▁ HLA = % 7.3f " % ( h , hra , hla ) ) NEW_LINE DEDENT
import socket NEW_LINE host = socket . gethostname ( ) NEW_LINE
import urllib . request NEW_LINE print ( urllib . request . urlopen ( " http : / / rosettacode . org " ) . read ( ) ) NEW_LINE
import urllib . request NEW_LINE print ( urllib . request . urlopen ( " https : / / sourceforge . net / " ) . read ( ) ) NEW_LINE
def main ( ) : NEW_LINE INDENT print ( ' First ▁ 50 ▁ Humble ▁ numbers : \n ' ) NEW_LINE for row in chunksOf ( 10 ) ( take ( 50 ) ( humbles ( ) ) ) : NEW_LINE INDENT print ( ' ▁ ' . join ( map ( lambda x : str ( x ) . rjust ( 3 ) , row ) ) ) NEW_LINE DEDENT print ( ' \n Counts ▁ of ▁ Humble ▁ numbers ▁ with ▁ n ▁ digits : \n ' ) NEW_LINE for tpl in take ( 10 ) ( ( k , len ( list ( g ) ) ) for k , g in groupby ( len ( str ( x ) ) for x in humbles ( ) ) ) : NEW_LINE INDENT print ( tpl ) NEW_LINE DEDENT DEDENT
def identity ( size ) : NEW_LINE INDENT matrix = [ [ 0 ] * size for i in range ( size ) ] NEW_LINE for i in range ( size ) : NEW_LINE INDENT matrix [ i ] [ i ] = 1 NEW_LINE DEDENT for rows in matrix : NEW_LINE INDENT for elements in rows : NEW_LINE INDENT print elements , NEW_LINE DEDENT print " " NEW_LINE DEDENT DEDENT
[   $ "0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrS "     $ QsTtUuVvWwXxYyZz ( ) [ ] { } < > ~ = + - * / ^ \ | _ . , : ; ? ! ' " ` % @ & join ] constant is tokenchars ( - ->   $ ) NEW_LINE ( The first non - whitespace character after the word   $ ( pronounced " string " ) is deemed to be the delimiter for the string that follows it . In the first string the conventional character   " is used , so cannot appear as a character in that string . In the second string all the reasonable delimiters are used , so Q is used as the delimiter . As it is not possible to make a string that uses all the characters , two strings are concatenated ( join ) to make the string during compilation . ( Which is why     $ "0 . . . S "   $ Qs ... $ Q join is nested ( inside [ ... ] ) and followed by the word constant , which causes the nest to be evaluated during compilation . ) Regardless of operating system , Quackery only knows the characters in the string tokenchars , plus space and carriage return . The characters in tokenchars are in QACSFOT order ( the Quackery Arbitrary Character Sequence For Ordered Text ) which it uses for string comparison , but the valid tokens ( which is all of them ) will be printed by alltokens in the order native to the operating system . ( In this instance , Unicode . ) ) NEW_LINE [ tokenchars find tokenchars found ] is validtoken ( c - -> b ) NEW_LINE [ 256 times [ i ^ validtoken if [ i ^ emit ] ] ] is alltokens ( - -> ) NEW_LINE alltokens NEW_LINE
classes = ( str . isupper , str . islower , str . isalnum , str . isalpha , str . isdecimal , str . isdigit , str . isidentifier , str . isnumeric , str . isprintable , str . isspace , str . istitle ) NEW_LINE for stringclass in classes : NEW_LINE INDENT chars = ' ' . join ( chr ( i ) for i in range ( 0x10FFFF + 1 ) if stringclass ( chr ( i ) ) ) NEW_LINE print ( ' \n String ▁ class ▁ % s ▁ has ▁ % i ▁ characters ▁ the ▁ first ▁ of ▁ which ▁ are : \n ▁ ▁ % r ' % ( stringclass . __name__ , len ( chars ) , chars [ : 100 ] ) ) NEW_LINE DEDENT
from PIL import Image , ImageFilter NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT im = Image . open ( " test . jpg " ) NEW_LINE kernelValues = [ - 2 , - 1 , 0 , - 1 , 1 , 1 , 0 , 1 , 2 ] NEW_LINE kernel = ImageFilter . Kernel ( ( 3 , 3 ) , kernelValues ) NEW_LINE im2 = im . filter ( kernel ) NEW_LINE im2 . show ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT root = Tkinter . Tk ( ) NEW_LINE app = App ( ( 320 , 240 ) , root ) NEW_LINE root . mainloop ( ) NEW_LINE DEDENT
from fractions import Fraction NEW_LINE from decimal import Decimal , getcontext NEW_LINE getcontext ( ) . prec = 60 NEW_LINE from itertools import product NEW_LINE casting_functions = [ int , float , complex , Fraction , Decimal , hex , oct , bin , bool , iter , list , tuple , range , str , bytes , bytearray , set , frozenset , dict , ] NEW_LINE examples_of_types = [ 0 , 42 , 0.0 - 0.0 , 12.34 , 56.0 , ( 0 + 0j ) , ( 1 + 2j ) , ( 1 + 0j ) , ( 78.9 + 0j ) , ( 0 + 1.2j ) , Fraction ( 0 , 1 ) , Fraction ( 22 , 7 ) , Fraction ( 4 , 2 ) , Decimal ( '0' ) , Decimal ( '3.14159265358979323846264338327950288419716939937510' ) , Decimal ( '1' ) , Decimal ( '1.5' ) , True , False , iter ( ( ) ) , iter ( [ 1 , 2 , 3 ] ) , iter ( { ' A ' , ' B ' , ' C ' } ) , iter ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) , iter ( ( ( ' a ' , 1 ) , ( 2 , ' b ' ) ) ) , [ ] , [ 1 , 2 ] , [ [ 1 , 2 ] , [ 3 , 4 ] ] , ( ) , ( 1 , ' two ' , ( 3 + 0j ) ) , ( ( ' a ' , 1 ) , ( 2 , ' b ' ) ) , range ( 0 ) , range ( 3 ) , " " , " A " , " ABBA " , " Milü " , b " " , b " A " , b " ABBA " , bytearray ( b " " ) , bytearray ( b " A " ) , bytearray ( b " ABBA " ) , set ( ) , { 1 , ' two ' , ( 3 + 0j ) , ( 4 , 5 , 6 ) } , frozenset ( ) , frozenset ( { 1 , ' two ' , ( 3 + 0j ) , ( 4 , 5 , 6 ) } ) , { } , { 1 : ' one ' , ' two ' : ( 2 + 3j ) , ( ' RC ' , 3 ) : None } ] NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( ' Common ▁ Python ▁ types / type ▁ casting ▁ functions : ' ) NEW_LINE print ( ' ▁ ▁ ' + ' \n ▁ ▁ ' . join ( f . __name__ for f in casting_functions ) ) NEW_LINE print ( ' \n Examples ▁ of ▁ those ▁ types : ' ) NEW_LINE print ( ' ▁ ▁ ' + ' \n ▁ ▁ ' . join ( ' % -26s ▁ % r ' % ( type ( e ) , e ) for e in examples_of_types ) ) NEW_LINE print ( ' \n Casts ▁ of ▁ the ▁ examples : ' ) NEW_LINE for f , e in product ( casting_functions , examples_of_types ) : NEW_LINE INDENT try : NEW_LINE INDENT ans = f ( e ) NEW_LINE DEDENT except BaseException : NEW_LINE INDENT ans = ' EXCEPTION ▁ RAISED ! ' NEW_LINE DEDENT print ( ' % -60s ▁ - > ▁ % r ' % ( ' % s ( % r ) ' % ( f . __name__ , e ) , ans ) ) NEW_LINE DEDENT DEDENT
import mymodule NEW_LINE
next = str ( int ( '123' ) + 1 ) NEW_LINE
def rank ( x ) : return int ( ' a ' . join ( map ( str , [ 1 ] + x ) ) , 11 ) NEW_LINE def unrank ( n ) : NEW_LINE INDENT s = ' ' NEW_LINE while n : s , n = "0123456789a " [ n % 11 ] + s , n // 11 NEW_LINE return map ( int , s . split ( ' a ' ) ) [ 1 : ] NEW_LINE DEDENT
class Camera : NEW_LINE INDENT pass NEW_LINE DEDENT
class Animal : NEW_LINE INDENT pass NEW_LINE DEDENT class Dog ( Animal ) : NEW_LINE INDENT pass NEW_LINE DEDENT class Cat ( Animal ) : NEW_LINE INDENT pass NEW_LINE DEDENT class Lab ( Dog ) : NEW_LINE INDENT pass NEW_LINE DEDENT class Collie ( Dog ) : NEW_LINE INDENT pass NEW_LINE DEDENT
while ( True ) : NEW_LINE INDENT x = input ( " What ▁ is ▁ your ▁ age ? ▁ " ) NEW_LINE print ( x ) NEW_LINE DEDENT
def do_stuff ( words ) : NEW_LINE INDENT print ( words ) NEW_LINE DEDENT
def do_stuff ( a , b ) : NEW_LINE INDENT return a + b NEW_LINE DEDENT
a = input ( ' Enter ▁ value ▁ of ▁ a : ▁ ' ) NEW_LINE b = input ( ' Enter ▁ value ▁ of ▁ b : ▁ ' ) NEW_LINE if a < b : NEW_LINE INDENT print ' a ▁ is ▁ less ▁ than ▁ b ' NEW_LINE DEDENT elif a > b : NEW_LINE INDENT print ' a ▁ is ▁ greater ▁ than ▁ b ' NEW_LINE DEDENT elif a == b : NEW_LINE INDENT print ' a ▁ is ▁ equal ▁ to ▁ b ' NEW_LINE DEDENT
i = 1 NEW_LINE while i : NEW_LINE INDENT print ( i ) NEW_LINE i += 1 NEW_LINE DEDENT
x = truevalue if condition else falsevalue NEW_LINE
def isqrt ( x ) : NEW_LINE INDENT q = 1 NEW_LINE while q <= x : NEW_LINE INDENT q *= 4 NEW_LINE DEDENT z , r = x , 0 NEW_LINE while q > 1 : NEW_LINE INDENT q /= 4 NEW_LINE t , r = z - r - q , r / 2 NEW_LINE if t >= 0 : NEW_LINE INDENT z , r = t , r + q NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT
def jaro ( s , t ) : NEW_LINE INDENT s_len = len ( s ) NEW_LINE t_len = len ( t ) NEW_LINE if s_len == 0 and t_len == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT match_distance = ( max ( s_len , t_len ) // 2 ) - 1 NEW_LINE s_matches = [ False ] * s_len NEW_LINE t_matches = [ False ] * t_len NEW_LINE matches = 0 NEW_LINE transpositions = 0 NEW_LINE for i in range ( s_len ) : NEW_LINE INDENT start = max ( 0 , i - match_distance ) NEW_LINE end = min ( i + match_distance + 1 , t_len ) NEW_LINE for j in range ( start , end ) : NEW_LINE INDENT if t_matches [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT if s [ i ] != t [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT s_matches [ i ] = True NEW_LINE t_matches [ j ] = True NEW_LINE matches += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if matches == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = 0 NEW_LINE for i in range ( s_len ) : NEW_LINE INDENT if not s_matches [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT while not t_matches [ k ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT if s [ i ] != t [ k ] : NEW_LINE INDENT transpositions += 1 NEW_LINE DEDENT k += 1 NEW_LINE DEDENT return ( ( matches / s_len ) + ( matches / t_len ) + ( ( matches - transpositions / 2 ) / matches ) ) / 3 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT for s , t in [ ( ' MARTHA ' , ' MARHTA ' ) , ( ' DIXON ' , ' DICKSONX ' ) , ( ' JELLYFISH ' , ' SMELLYFISH ' ) ] : NEW_LINE INDENT print ( " jaro ( % r , ▁ % r ) ▁ = ▁ % .10f " % ( s , t , jaro ( s , t ) ) ) NEW_LINE DEDENT DEDENT
def jaro_winkler_distance ( st1 , st2 ) : NEW_LINE INDENT if len ( st1 ) < len ( st2 ) : NEW_LINE INDENT st1 , st2 = st2 , st1 NEW_LINE DEDENT len1 , len2 = len ( st1 ) , len ( st2 ) NEW_LINE if len2 == 0 : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT delta = max ( 0 , len2 // 2 - 1 ) NEW_LINE flag = [ False for _ in range ( len2 ) ] NEW_LINE ch1_match = [ ] NEW_LINE for idx1 , ch1 in enumerate ( st1 ) : NEW_LINE INDENT for idx2 , ch2 in enumerate ( st2 ) : NEW_LINE INDENT if idx2 <= idx1 + delta and idx2 >= idx1 - delta and ch1 == ch2 and not flag [ idx2 ] : NEW_LINE INDENT flag [ idx2 ] = True NEW_LINE ch1_match . append ( ch1 ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT matches = len ( ch1_match ) NEW_LINE if matches == 0 : NEW_LINE INDENT return 1.0 NEW_LINE DEDENT transpositions , idx1 = 0 , 0 NEW_LINE for idx2 , ch2 in enumerate ( st2 ) : NEW_LINE INDENT if flag [ idx2 ] : NEW_LINE INDENT transpositions += ( ch2 != ch1_match [ idx1 ] ) NEW_LINE idx1 += 1 NEW_LINE DEDENT DEDENT jaro = ( matches / len1 + matches / len2 + ( matches - transpositions / 2 ) / matches ) / 3.0 NEW_LINE commonprefix = 0 NEW_LINE for i in range ( min ( 4 , len2 ) ) : NEW_LINE INDENT commonprefix += ( st1 [ i ] == st2 [ i ] ) NEW_LINE DEDENT return 1.0 - ( jaro + commonprefix * 0.1 * ( 1 - jaro ) ) NEW_LINE DEDENT
def within_distance ( maxdistance , stri , maxtoreturn ) : NEW_LINE INDENT arr = [ w for w in WORDS if jaro_winkler_distance ( stri , w ) <= maxdistance ] NEW_LINE arr . sort ( key = lambda x : jaro_winkler_distance ( stri , x ) ) NEW_LINE return arr if len ( arr ) <= maxtoreturn else arr [ : maxtoreturn ] NEW_LINE DEDENT
from PIL import Image NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT w , h , zoom = 800 , 600 , 1 NEW_LINE bitmap = Image . new ( " RGB " , ( w , h ) , " white " ) NEW_LINE pix = bitmap . load ( ) NEW_LINE cX , cY = - 0.7 , 0.27015 NEW_LINE moveX , moveY = 0.0 , 0.0 NEW_LINE maxIter = 255 NEW_LINE for x in range ( w ) : NEW_LINE INDENT for y in range ( h ) : NEW_LINE INDENT zx = 1.5 * ( x - w / 2 ) / ( 0.5 * zoom * w ) + moveX NEW_LINE zy = 1.0 * ( y - h / 2 ) / ( 0.5 * zoom * h ) + moveY NEW_LINE i = maxIter NEW_LINE while zx * zx + zy * zy < 4 and i > 1 : NEW_LINE INDENT tmp = zx * zx - zy * zy + cX NEW_LINE zy , zx = 2.0 * zx * zy + cY , tmp NEW_LINE i -= 1 NEW_LINE DEDENT pix [ x ] [ y ] = ( i << 21 ) + ( i << 10 ) + i * 8 NEW_LINE DEDENT DEDENT bitmap . show ( ) NEW_LINE DEDENT
from goto import goto , label NEW_LINE label . start NEW_LINE for i in range ( 1 , 4 ) : NEW_LINE INDENT print i NEW_LINE if i == 2 : NEW_LINE INDENT try : NEW_LINE INDENT output = message NEW_LINE DEDENT except NameError : NEW_LINE INDENT print " Oops ▁ - ▁ forgot ▁ to ▁ define ▁ ' message ' ! ▁ ▁ Start ▁ again . " NEW_LINE message = " Hello ▁ world " NEW_LINE goto . start NEW_LINE DEDENT DEDENT DEDENT print output , " \n " NEW_LINE
def main ( ) : NEW_LINE INDENT global char NEW_LINE char = None NEW_LINE _thread . start_new_thread ( keypress , ( ) ) NEW_LINE while True : NEW_LINE INDENT if char is not None : NEW_LINE INDENT try : NEW_LINE INDENT print ( " Key ▁ pressed ▁ is ▁ " + char . decode ( ' utf - 8' ) ) NEW_LINE DEDENT except UnicodeDecodeError : NEW_LINE INDENT print ( " character ▁ can ▁ not ▁ be ▁ decoded , ▁ sorry ! " ) NEW_LINE char = None NEW_LINE DEDENT _thread . start_new_thread ( keypress , ( ) ) NEW_LINE if char == ' q ' or char == ' \x1b ' : NEW_LINE INDENT exit ( ) NEW_LINE DEDENT char = None NEW_LINE DEDENT print ( " Program ▁ is ▁ running " ) NEW_LINE time . sleep ( 1 ) NEW_LINE DEDENT DEDENT
items = [ ( " beef " , 3.8 , 36.0 ) , ( " pork " , 5.4 , 43.0 ) , ( " ham " , 3.6 , 90.0 ) , ( " greaves " , 2.4 , 45.0 ) , ( " flitch " , 4.0 , 30.0 ) , ( " brawn " , 2.5 , 56.0 ) , ( " welt " , 3.7 , 67.0 ) , ( " salami " , 3.0 , 95.0 ) , ( " sausage " , 5.9 , 98.0 ) ] NEW_LINE MAXWT = 15.0 NEW_LINE sorted_items = sorted ( ( ( value / amount , amount , name ) for name , amount , value in items ) , reverse = True ) NEW_LINE wt = val = 0 NEW_LINE bagged = [ ] NEW_LINE for unit_value , amount , name in sorted_items : NEW_LINE INDENT portion = min ( MAXWT - wt , amount ) NEW_LINE wt += portion NEW_LINE addval = portion * unit_value NEW_LINE val += addval NEW_LINE bagged += [ ( name , portion , addval ) ] NEW_LINE if wt >= MAXWT : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " ▁ ▁ ▁ ▁ ITEM ▁ ▁ ▁ PORTION ▁ VALUE " ) NEW_LINE print ( " \n " . join ( " % 10s ▁ % 6.2f ▁ % 6.2f " % item for item in bagged ) ) NEW_LINE print ( " \n TOTAL ▁ WEIGHT : ▁ % 5.2f \n TOTAL ▁ VALUE : ▁ % 5.2f " % ( wt , val ) ) NEW_LINE
weights < - c ( panacea = 0.3 , ichor = 0.2 , gold = 2.0 ) NEW_LINE volumes < - c ( panacea = 0.025 , ichor = 0.015 , gold = 0.002 ) NEW_LINE values < - c ( panacea = 3000 , ichor = 1800 , gold = 2500 ) NEW_LINE sack . weight < - 25 NEW_LINE sack . volume < - 0.25 NEW_LINE max . items < - floor ( pmin ( sack . weight / weights , sack . volume / volumes ) ) NEW_LINE getTotalValue < - function ( n ) sum ( n * values ) NEW_LINE getTotalWeight < - function ( n ) sum ( n * weights ) NEW_LINE getTotalVolume < - function ( n ) sum ( n * volumes ) NEW_LINE willFitInSack < - function ( n ) getTotalWeight ( n ) <= sack . weight & & getTotalVolume ( n ) <= sack . volume NEW_LINE knapsack < - expand . grid ( lapply ( max . items , function ( n ) seq . int ( 0 , n ) ) ) NEW_LINE ok < - apply ( knapsack , 1 , willFitInSack ) NEW_LINE knapok < - knapsack [ ok , ] NEW_LINE vals < - apply ( knapok , 1 , getTotalValue ) NEW_LINE knapok [ vals == max ( vals ) , ] NEW_LINE
def path ( n , p = { 1 : 0 } , lvl = [ [ 1 ] ] ) : NEW_LINE INDENT if not n : return [ ] NEW_LINE while n not in p : NEW_LINE INDENT q = [ ] NEW_LINE for x , y in ( ( x , x + y ) for x in lvl [ 0 ] for y in path ( x ) if not x + y in p ) : NEW_LINE INDENT p [ y ] = x NEW_LINE q . append ( y ) NEW_LINE DEDENT lvl [ 0 ] = q NEW_LINE DEDENT return path ( p [ n ] ) + [ n ] NEW_LINE DEDENT
def tree_pow ( x , n ) : NEW_LINE INDENT r , p = { 0 : 1 , 1 : x } , 0 NEW_LINE for i in path ( n ) : NEW_LINE INDENT r [ i ] = r [ i - p ] * r [ p ] NEW_LINE p = i NEW_LINE DEDENT return r [ n ] NEW_LINE DEDENT
def show_pow ( x , n ) : NEW_LINE INDENT fmt = " % d : ▁ % s \n " + [ " % g ^ % d ▁ = ▁ % f " , " % d ^ % d ▁ = ▁ % d " ] [ x == int ( x ) ] + " \n " NEW_LINE print ( fmt % ( n , repr ( path ( n ) ) , x , n , tree_pow ( x , n ) ) ) NEW_LINE DEDENT
def kolakoski ( start_items = ( 1 , 2 ) , length = 20 ) : NEW_LINE INDENT return list ( itertools . islice ( _kolakoski_gen ( start_items ) , length ) ) NEW_LINE DEDENT
def kosaraju ( g ) : NEW_LINE INDENT class nonlocal : pass NEW_LINE size = len ( g ) NEW_LINE vis = [ False ] * size NEW_LINE l = [ 0 ] * size NEW_LINE nonlocal . x = size NEW_LINE t = [ [ ] ] * size NEW_LINE def visit ( u ) : NEW_LINE INDENT if not vis [ u ] : NEW_LINE INDENT vis [ u ] = True NEW_LINE for v in g [ u ] : NEW_LINE INDENT visit ( v ) NEW_LINE t [ v ] = t [ v ] + [ u ] NEW_LINE DEDENT nonlocal . x = nonlocal . x - 1 NEW_LINE l [ nonlocal . x ] = u NEW_LINE DEDENT DEDENT for u in range ( len ( g ) ) : NEW_LINE INDENT visit ( u ) NEW_LINE DEDENT c = [ 0 ] * size NEW_LINE def assign ( u , root ) : NEW_LINE INDENT if vis [ u ] : NEW_LINE INDENT vis [ u ] = False NEW_LINE c [ u ] = root NEW_LINE for v in t [ u ] : NEW_LINE INDENT assign ( v , root ) NEW_LINE DEDENT DEDENT DEDENT for u in l : NEW_LINE INDENT assign ( u , u ) NEW_LINE DEDENT return c NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT digits = [ 1 , 2 , 3 , 4 , 6 , 7 , 8 , 9 ] NEW_LINE lcmDigits = reduce ( lcm , digits ) NEW_LINE sevenDigits = ( ( delete ) ( digits ) ( x ) for x in [ 1 , 4 , 7 ] ) NEW_LINE print ( max ( ( intFromDigits ( x ) for x in concatMap ( permutations ) ( sevenDigits ) ) , key = lambda n : n if 0 == n % lcmDigits else 0 ) ) NEW_LINE DEDENT
import calendar NEW_LINE calendar . isleap ( year ) NEW_LINE
def Leonardo ( L_Zero , L_One , Add , Amount ) : NEW_LINE INDENT terms = [ L_Zero , L_One ] NEW_LINE while len ( terms ) < Amount : NEW_LINE INDENT new = terms [ - 1 ] + terms [ - 2 ] NEW_LINE new += Add NEW_LINE terms . append ( new ) NEW_LINE DEDENT return terms NEW_LINE DEDENT
from __future__ import print_function NEW_LINE from time import sleep NEW_LINE last_idle = last_total = 0 NEW_LINE while True : NEW_LINE INDENT with open ( ' / proc / stat ' ) as f : NEW_LINE INDENT fields = [ float ( column ) for column in f . readline ( ) . strip ( ) . split ( ) [ 1 : ] ] NEW_LINE DEDENT idle , total = fields [ 3 ] , sum ( fields ) NEW_LINE idle_delta , total_delta = idle - last_idle , total - last_total NEW_LINE last_idle , last_total = idle , total NEW_LINE utilisation = 100.0 * ( 1.0 - idle_delta / total_delta ) NEW_LINE print ( ' % 5.1f % % ' % utilisation , end = ' ' ) NEW_LINE sleep ( 5 ) NEW_LINE DEDENT
[ ( x , y , z ) for x in xrange ( 1 , n + 1 ) for y in xrange ( x , n + 1 ) for z in xrange ( y , n + 1 ) if x ** 2 + y ** 2 == z ** 2 ] NEW_LINE
FLOAT NEW_LINE INDENT : ' . ' DIGITS ( Exponent ) ? NEW_LINE | DIGITS ' . ' Exponent NEW_LINE | DIGITS ( ' . ' ( DIGITS ( Exponent ) ? ) ? | Exponent ) NEW_LINE ; NEW_LINE DEDENT DIGITS : ( '0' . . '9' ) + ; NEW_LINE Exponent NEW_LINE INDENT : ( ' e ' | ' E ' ) ( ' + ' | ' - ' ) ? DIGITS NEW_LINE ; NEW_LINE DEDENT
' c ' == " c " NEW_LINE ' text ' == " text " NEW_LINE ' \x20' == ' ▁ ' NEW_LINE u ' \u05d0' NEW_LINE
def f ( t , r ) : NEW_LINE INDENT return ( n0 * np . exp ( r * t ) ) / ( ( 1 + n0 * ( np . exp ( r * t ) - 1 ) / K ) ) NEW_LINE DEDENT
print 2 ** 64 * 2 ** 64 NEW_LINE
def sieve ( limit ) : NEW_LINE INDENT primes = [ ] NEW_LINE c = [ False ] * ( limit + 1 ) NEW_LINE p = 3 NEW_LINE while True : NEW_LINE INDENT p2 = p * p NEW_LINE if p2 > limit : break NEW_LINE for i in range ( p2 , limit , 2 * p ) : c [ i ] = True NEW_LINE while True : NEW_LINE INDENT p += 2 NEW_LINE if not c [ p ] : break NEW_LINE DEDENT DEDENT for i in range ( 3 , limit , 2 ) : NEW_LINE INDENT if not c [ i ] : primes . append ( i ) NEW_LINE DEDENT return primes NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT for year in [ x for x in range ( 2000 , 1 + 2100 ) if longYear ( x ) ] : NEW_LINE INDENT print ( year ) NEW_LINE DEDENT DEDENT
def lcp ( * s ) : NEW_LINE INDENT return os . path . commonprefix ( s ) NEW_LINE DEDENT
s1 = " thisisatest " NEW_LINE s2 = " testing123testing " NEW_LINE len1 , len2 = len ( s1 ) , len ( s2 ) NEW_LINE ir , jr = 0 , - 1 NEW_LINE for i1 in range ( len1 ) : NEW_LINE INDENT i2 = s2 . find ( s1 [ i1 ] ) NEW_LINE while i2 >= 0 : NEW_LINE INDENT j1 , j2 = i1 , i2 NEW_LINE while j1 < len1 and j2 < len2 and s2 [ j2 ] == s1 [ j1 ] : NEW_LINE INDENT if j1 - i1 >= jr - ir : NEW_LINE INDENT ir , jr = i1 , j1 NEW_LINE DEDENT j1 += 1 ; j2 += 1 NEW_LINE DEDENT i2 = s2 . find ( s1 [ i1 ] , i2 + 1 ) NEW_LINE DEDENT DEDENT print ( s1 [ ir : jr + 1 ] ) NEW_LINE
def main ( ) : NEW_LINE INDENT samples = [ [ " Sunday " , " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " ] , [ " Sondag " , " Maandag " , " Dinsdag " , " Woensdag " , " Donderdag " , " Vrydag " , " Saterdag " ] ] NEW_LINE for xs in samples : NEW_LINE INDENT print ( longestCommonSuffix ( xs ) ) NEW_LINE DEDENT DEDENT
def longer ( a , b ) : NEW_LINE INDENT try : NEW_LINE INDENT b [ len ( a ) - 1 ] NEW_LINE return False NEW_LINE DEDENT except : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
from random import randrange NEW_LINE while True : NEW_LINE INDENT a = randrange ( 20 ) NEW_LINE print ( a ) NEW_LINE if a == 10 : NEW_LINE INDENT break NEW_LINE DEDENT b = randrange ( 20 ) NEW_LINE print ( b ) NEW_LINE DEDENT
for i in xrange ( 1 , 11 ) : NEW_LINE INDENT if i % 5 == 0 : NEW_LINE INDENT print i NEW_LINE continue NEW_LINE DEDENT print i , " , " , NEW_LINE DEDENT
val = 0 NEW_LINE while True : NEW_LINE INDENT val += 1 NEW_LINE print val NEW_LINE if val % 6 == 0 : break NEW_LINE DEDENT
for i in xrange ( 10 , - 1 , - 1 ) : NEW_LINE INDENT print i NEW_LINE DEDENT
for i in xrange ( 2 , 9 , 2 ) : NEW_LINE INDENT print " % d , " % i , NEW_LINE DEDENT print " who ▁ do ▁ we ▁ appreciate ? " NEW_LINE
import sys NEW_LINE for i in xrange ( 5 ) : NEW_LINE INDENT for j in xrange ( i + 1 ) : NEW_LINE INDENT sys . stdout . write ( " * " ) NEW_LINE DEDENT print NEW_LINE DEDENT
for i in collection : NEW_LINE INDENT print i NEW_LINE DEDENT
while 1 : NEW_LINE INDENT print " SPAM " NEW_LINE DEDENT
print ( ' , ▁ ' . join ( str ( i + 1 ) for i in range ( 10 ) ) ) NEW_LINE
from random import randint NEW_LINE def do_scan ( mat ) : NEW_LINE INDENT for row in mat : NEW_LINE INDENT for item in row : NEW_LINE INDENT print item , NEW_LINE if item == 20 : NEW_LINE INDENT print NEW_LINE return NEW_LINE DEDENT DEDENT print NEW_LINE DEDENT print NEW_LINE DEDENT mat = [ [ randint ( 1 , 20 ) for x in xrange ( 10 ) ] for y in xrange ( 10 ) ] NEW_LINE do_scan ( mat ) NEW_LINE
n = 1024 NEW_LINE while n > 0 : NEW_LINE INDENT print n NEW_LINE n //= 2 NEW_LINE DEDENT
import re NEW_LINE from itertools import islice NEW_LINE data = ''' STRNEWLINE start ▁ TABSYMBOL stop ▁ TABSYMBOL increment ▁ TABSYMBOL Comment STRNEWLINE - 2 ▁ TABSYMBOL 2 ▁ TABSYMBOL 1 ▁ TABSYMBOL Normal STRNEWLINE - 2 ▁ TABSYMBOL 2 ▁ TABSYMBOL 0 ▁ TABSYMBOL Zero ▁ increment STRNEWLINE - 2 ▁ TABSYMBOL 2 ▁ TABSYMBOL - 1 ▁ TABSYMBOL Increments ▁ away ▁ from ▁ stop ▁ value STRNEWLINE - 2 ▁ TABSYMBOL 2 ▁ TABSYMBOL 10 ▁ TABSYMBOL First ▁ increment ▁ is ▁ beyond ▁ stop ▁ value STRNEWLINE 2 ▁ TABSYMBOL - 2 ▁ TABSYMBOL 1 ▁ TABSYMBOL Start ▁ more ▁ than ▁ stop : ▁ positive ▁ increment STRNEWLINE 2 ▁ TABSYMBOL 2 ▁ TABSYMBOL 1 ▁ TABSYMBOL Start ▁ equal ▁ stop : ▁ positive ▁ increment STRNEWLINE 2 ▁ TABSYMBOL 2 ▁ TABSYMBOL - 1 ▁ TABSYMBOL Start ▁ equal ▁ stop : ▁ negative ▁ increment STRNEWLINE 2 ▁ TABSYMBOL 2 ▁ TABSYMBOL 0 ▁ TABSYMBOL Start ▁ equal ▁ stop : ▁ zero ▁ increment STRNEWLINE 0 ▁ TABSYMBOL 0 ▁ TABSYMBOL 0 ▁ TABSYMBOL Start ▁ equal ▁ stop ▁ equal ▁ zero : ▁ zero ▁ increment ▁ STRNEWLINE ''' NEW_LINE table = [ re . split ( r ' \s\s + ' , line . strip ( ) ) for line in data . strip ( ) . split ( ' \n ' ) ] NEW_LINE for _start , _stop , _increment , comment in table [ 1 : ] : NEW_LINE INDENT start , stop , increment = [ int ( x ) for x in ( _start , _stop , _increment ) ] NEW_LINE print ( f ' { comment . upper ( ) } : \n ▁ ▁ range ( { start } , ▁ { stop } , ▁ { increment } ) ' ) NEW_LINE values = None NEW_LINE try : NEW_LINE INDENT values = list ( islice ( range ( start , stop , increment ) , 999 ) ) NEW_LINE DEDENT except ValueError as e : NEW_LINE INDENT print ( ' ▁   ! ! ERROR ! ! ' , e ) NEW_LINE DEDENT if values is not None : NEW_LINE INDENT if len ( values ) < 22 : NEW_LINE INDENT print ( ' ▁ ▁ ▁ ▁ = ' , values ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' ▁ ▁ ▁ ▁ = ' , str ( values [ : 22 ] ) [ : - 1 ] , ' . . . ' ) NEW_LINE DEDENT DEDENT DEDENT
def is_prime ( p ) : NEW_LINE INDENT if p == 2 : return True NEW_LINE elif p <= 1 or p % 2 == 0 : return False NEW_LINE else : NEW_LINE INDENT for i in range ( 3 , int ( sqrt ( p ) ) + 1 , 2 ) : NEW_LINE INDENT if p % i == 0 : return False NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
def is_mersenne_prime ( p ) : NEW_LINE INDENT if p == 2 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT m_p = ( 1 << p ) - 1 NEW_LINE s = 4 NEW_LINE for i in range ( 3 , p + 1 ) : NEW_LINE INDENT s = ( s ** 2 - 2 ) % m_p NEW_LINE DEDENT return s == 0 NEW_LINE DEDENT DEDENT
def compress ( uncompressed ) : NEW_LINE INDENT dict_size = 256 NEW_LINE dictionary = dict ( ( chr ( i ) , i ) for i in range ( dict_size ) ) NEW_LINE w = " " NEW_LINE result = [ ] NEW_LINE for c in uncompressed : NEW_LINE INDENT wc = w + c NEW_LINE if wc in dictionary : NEW_LINE INDENT w = wc NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( dictionary [ w ] ) NEW_LINE dictionary [ wc ] = dict_size NEW_LINE dict_size += 1 NEW_LINE w = c NEW_LINE DEDENT DEDENT if w : NEW_LINE INDENT result . append ( dictionary [ w ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def decompress ( compressed ) : NEW_LINE INDENT from io import StringIO NEW_LINE dict_size = 256 NEW_LINE dictionary = dict ( ( i , chr ( i ) ) for i in range ( dict_size ) ) NEW_LINE result = StringIO ( ) NEW_LINE w = chr ( compressed . pop ( 0 ) ) NEW_LINE result . write ( w ) NEW_LINE for k in compressed : NEW_LINE INDENT if k in dictionary : NEW_LINE INDENT entry = dictionary [ k ] NEW_LINE DEDENT elif k == dict_size : NEW_LINE INDENT entry = w + w [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( ' Bad ▁ compressed ▁ k : ▁ % s ' % k ) NEW_LINE DEDENT result . write ( entry ) NEW_LINE dictionary [ dict_size ] = w + entry [ 0 ] NEW_LINE dict_size += 1 NEW_LINE w = entry NEW_LINE DEDENT return result . getvalue ( ) NEW_LINE DEDENT
import requests NEW_LINE for addr in [ '88:53:2E : 67:07 : BE ' , ' FC : FB : FB : 01 : FA : 21' , ' D4 : F4:6F : C9 : EF : 8D ' , '23:45:67' ] : NEW_LINE INDENT vendor = requests . get ( ' http : / / api . macvendors . com / ' + addr ) . text NEW_LINE print ( addr , vendor ) NEW_LINE DEDENT
import random NEW_LINE s = ( ' It ▁ is ▁ certain ' , ' It ▁ is ▁ decidedly ▁ so ' , ' Without ▁ a ▁ doubt ' , ' Yes , ▁ definitely ' , ' You ▁ may ▁ rely ▁ on ▁ it ' , ' As ▁ I ▁ see ▁ it , ▁ yes ' , ' Most ▁ likely ' , ' Outlook ▁ good ' , ' Signs ▁ point ▁ to ▁ yes ' , ' Yes ' , ' Reply ▁ hazy , ▁ try ▁ again ' , ' Ask ▁ again ▁ later ' , ' Better ▁ not ▁ tell ▁ you ▁ now ' , ' Cannot ▁ predict ▁ now ' , ' Concentrate ▁ and ▁ ask ▁ again ' , " Don ' t ▁ bet ▁ on ▁ it " , ' My ▁ reply ▁ is ▁ no ' , ' My ▁ sources ▁ say ▁ no ' , ' Outlook ▁ not ▁ so ▁ good ' , ' Very ▁ doubtful ' ) NEW_LINE q_and_a = { } NEW_LINE while True : NEW_LINE INDENT question = input ( ' Ask ▁ your ▁ question : ' ) NEW_LINE if len ( question ) == 0 : break NEW_LINE if question in q_and_a : NEW_LINE INDENT print ( ' Your ▁ question ▁ has ▁ already ▁ been ▁ answered ' ) NEW_LINE DEDENT else : NEW_LINE INDENT answer = random . choice ( s ) NEW_LINE q_and_a [ question ] = answer NEW_LINE print ( answer ) NEW_LINE DEDENT DEDENT
import os NEW_LINE targetfile = " pycon - china " NEW_LINE os . rename ( os . path . realpath ( targetfile ) , os . path . realpath ( targetfile ) + " . bak " ) NEW_LINE f = open ( os . path . realpath ( targetfile ) , " w " ) NEW_LINE f . write ( " this ▁ task ▁ was ▁ solved ▁ during ▁ a ▁ talk ▁ about ▁ rosettacode ▁ at ▁ the ▁ PyCon ▁ China ▁ in ▁ 2011" ) NEW_LINE f . close ( ) NEW_LINE
def a ( in_k , x1 , x2 , x3 , x4 , x5 ) : NEW_LINE INDENT k = [ in_k ] NEW_LINE def b ( ) : NEW_LINE INDENT k [ 0 ] -= 1 NEW_LINE return a ( k [ 0 ] , b , x1 , x2 , x3 , x4 ) NEW_LINE DEDENT return x4 ( ) + x5 ( ) if k [ 0 ] <= 0 else b ( ) NEW_LINE DEDENT
m = ( ( 1 , 1 , 1 , 1 ) , ( 2 , 4 , 8 , 16 ) , ( 3 , 9 , 27 , 81 ) , ( 4 , 16 , 64 , 256 ) , ( 5 , 25 , 125 , 625 ) ) NEW_LINE print ( zip ( * m ) ) NEW_LINE
def main ( ) : NEW_LINE INDENT for n in [ 7 , 8 ] : NEW_LINE INDENT print ( showMatrix ( twoDiagonalMatrix ( n ) ) + ' \n ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT print ( main . __doc__ + ' : \n \n ' + ' \n ' . join ( mayanFramed ( n ) for n in [ 4005 , 8017 , 326205 , 886205 , 1081439556 , 1000000 , 1000000000 ] ) ) NEW_LINE DEDENT
import hashlib NEW_LINE print hashlib . new ( " md4" , raw_input ( ) . encode ( ' utf - 16le ' ) ) . hexdigest ( ) . upper ( ) NEW_LINE
import time NEW_LINE import threading NEW_LINE sem = threading . Semaphore ( 4 ) NEW_LINE workers = [ ] NEW_LINE running = 1 NEW_LINE def worker ( ) : NEW_LINE INDENT me = threading . currentThread ( ) NEW_LINE while 1 : NEW_LINE INDENT sem . acquire ( ) NEW_LINE try : NEW_LINE INDENT if not running : NEW_LINE INDENT break NEW_LINE DEDENT print ' % s ▁ acquired ▁ semaphore ' % me . getName ( ) NEW_LINE time . sleep ( 2.0 ) NEW_LINE DEDENT finally : NEW_LINE INDENT sem . release ( ) NEW_LINE DEDENT time . sleep ( 0.01 ) NEW_LINE DEDENT DEDENT for i in range ( 10 ) : NEW_LINE INDENT t = threading . Thread ( name = str ( i ) , target = worker ) NEW_LINE workers . append ( t ) NEW_LINE t . start ( ) NEW_LINE DEDENT try : NEW_LINE INDENT while 1 : NEW_LINE INDENT time . sleep ( 0.1 ) NEW_LINE DEDENT DEDENT except KeyboardInterrupt : NEW_LINE INDENT running = 0 NEW_LINE for t in workers : NEW_LINE INDENT t . join ( ) NEW_LINE DEDENT DEDENT
import time NEW_LINE def main ( bpm = 72 , bpb = 4 ) : NEW_LINE INDENT sleep = 60.0 / bpm NEW_LINE counter = 0 NEW_LINE while True : NEW_LINE INDENT counter += 1 NEW_LINE if counter % bpb : NEW_LINE INDENT print ' tick ' NEW_LINE DEDENT else : NEW_LINE INDENT print ' TICK ' NEW_LINE DEDENT time . sleep ( sleep ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE
def mian_chowla ( ) : NEW_LINE INDENT mc = [ 1 ] NEW_LINE yield mc [ - 1 ] NEW_LINE psums = set ( [ 2 ] ) NEW_LINE newsums = set ( [ ] ) NEW_LINE for trial in count ( 2 ) : NEW_LINE INDENT for n in chain ( mc , [ trial ] ) : NEW_LINE INDENT sum = n + trial NEW_LINE if sum in psums : NEW_LINE INDENT newsums . clear ( ) NEW_LINE break NEW_LINE DEDENT newsums . add ( sum ) NEW_LINE DEDENT else : NEW_LINE INDENT psums |= newsums NEW_LINE newsums . clear ( ) NEW_LINE mc . append ( trial ) NEW_LINE yield trial NEW_LINE DEDENT DEDENT DEDENT
from functools import lru_cache NEW_LINE DIVS = { 2 , 3 } NEW_LINE SUBS = { 1 } NEW_LINE class Minrec ( ) : NEW_LINE INDENT def __init__ ( self , divs = DIVS , subs = SUBS ) : NEW_LINE INDENT self . divs , self . subs = divs , subs NEW_LINE DEDENT @ lru_cache ( maxsize = None ) NEW_LINE def _minrec ( self , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 0 , [ ' = 1' ] NEW_LINE DEDENT possibles = { } NEW_LINE for d in self . divs : NEW_LINE INDENT if n % d == 0 : NEW_LINE INDENT possibles [ f ' / { d } = > { n ▁ / / ▁ d : 2 } ' ] = self . _minrec ( n // d ) NEW_LINE DEDENT DEDENT for s in self . subs : NEW_LINE INDENT if n > s : NEW_LINE INDENT possibles [ f ' - { s } = > { n ▁ - ▁ s : 2 } ' ] = self . _minrec ( n - s ) NEW_LINE DEDENT DEDENT thiskind , ( count , otherkinds ) = min ( possibles . items ( ) , key = lambda x : x [ 1 ] ) NEW_LINE ret = 1 + count , [ thiskind ] + otherkinds NEW_LINE return ret NEW_LINE DEDENT def __call__ ( self , n ) : NEW_LINE INDENT ans = self . _minrec ( n ) [ 1 ] [ : - 1 ] NEW_LINE return len ( ans ) , ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT for DIVS , SUBS in [ ( { 2 , 3 } , { 1 } ) , ( { 2 , 3 } , { 2 } ) ] : NEW_LINE INDENT minrec = Minrec ( DIVS , SUBS ) NEW_LINE print ( ' \n MINIMUM ▁ STEPS ▁ TO ▁ 1 : ▁ Recursive ▁ algorithm ' ) NEW_LINE print ( ' ▁ ▁ Possible ▁ divisors : ▁ ▁ ' , DIVS ) NEW_LINE print ( ' ▁ ▁ Possible ▁ decrements : ' , SUBS ) NEW_LINE for n in range ( 1 , 11 ) : NEW_LINE INDENT steps , how = minrec ( n ) NEW_LINE print ( f ' ▁ ▁ ▁ ▁ minrec ( { n : 2 } ) ▁ in ▁ { steps : 2 } ▁ by : ▁ ' , ' , ▁ ' . join ( how ) ) NEW_LINE DEDENT upto = 2000 NEW_LINE print ( f ' \n ▁ ▁ ▁ ▁ Those ▁ numbers ▁ up ▁ to ▁ { upto } ▁ that ▁ take ▁ the ▁ maximum , ▁ " minimal ▁ steps ▁ down ▁ to ▁ 1 " : ' ) NEW_LINE stepn = sorted ( ( minrec ( n ) [ 0 ] , n ) for n in range ( upto , 0 , - 1 ) ) NEW_LINE mx = stepn [ - 1 ] [ 0 ] NEW_LINE ans = [ x [ 1 ] for x in stepn if x [ 0 ] == mx ] NEW_LINE print ( ' ▁ ▁ ▁ ▁ ▁ ▁ Taking ' , mx , f ' steps ▁ is / are ▁ the ▁ { len ( ans ) } ▁ numbers : ' , ' , ▁ ' . join ( str ( n ) for n in sorted ( ans ) ) ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT
def f ( x ) : NEW_LINE INDENT return x ** 100 + x + 1 NEW_LINE DEDENT
a = 2988348162058574136915891421498819466320163312926952423791023078876139 NEW_LINE b = 2351399303373464486466122544523690094744975233415544072992656881240319 NEW_LINE m = 10 ** 40 NEW_LINE print ( pow ( a , b , m ) ) NEW_LINE
def meaning_of_life ( ) : NEW_LINE INDENT return 42 NEW_LINE DEDENT
class Montgomery : NEW_LINE INDENT BASE = 2 NEW_LINE def __init__ ( self , m ) : NEW_LINE INDENT self . m = m NEW_LINE self . n = m . bit_length ( ) NEW_LINE self . rrm = ( 1 << ( self . n * 2 ) ) % m NEW_LINE DEDENT def reduce ( self , t ) : NEW_LINE INDENT a = t NEW_LINE for i in xrange ( self . n ) : NEW_LINE INDENT if ( a & 1 ) == 1 : NEW_LINE INDENT a = a + self . m NEW_LINE DEDENT a = a >> 1 NEW_LINE DEDENT if a >= self . m : NEW_LINE INDENT a = a - self . m NEW_LINE DEDENT return a NEW_LINE DEDENT DEDENT m = 750791094644726559640638407699 NEW_LINE x1 = 540019781128412936473322405310 NEW_LINE x2 = 515692107665463680305819378593 NEW_LINE mont = Montgomery ( m ) NEW_LINE t1 = x1 * mont . rrm NEW_LINE t2 = x2 * mont . rrm NEW_LINE r1 = mont . reduce ( t1 ) NEW_LINE r2 = mont . reduce ( t2 ) NEW_LINE r = 1 << mont . n NEW_LINE print " b  : ▁ " , Montgomery . BASE NEW_LINE print " n  : ▁ " , mont . n NEW_LINE print " r  : ▁ " , r NEW_LINE print " m  : ▁ " , mont . m NEW_LINE print " t1 : ▁ " , t1 NEW_LINE print " t2 : ▁ " , t2 NEW_LINE print " r1 : ▁ " , r1 NEW_LINE print " r2 : ▁ " , r2 NEW_LINE print NEW_LINE print " Original ▁ x1 ▁ ▁ ▁ ▁ ▁ ▁   : " , x1 NEW_LINE print " Recovered ▁ from ▁ r1  : " , mont . reduce ( r1 ) NEW_LINE print " Original ▁ x2 ▁ ▁ ▁ ▁ ▁ ▁   : " , x2 NEW_LINE print " Recovered ▁ from ▁ r2  : " , mont . reduce ( r2 ) NEW_LINE print " \n Montgomery ▁ computation ▁ of ▁ x1 ▁ ^ ▁ x2 ▁ mod ▁ m : " NEW_LINE prod = mont . reduce ( mont . rrm ) NEW_LINE base = mont . reduce ( x1 * mont . rrm ) NEW_LINE exp = x2 NEW_LINE while exp . bit_length ( ) > 0 : NEW_LINE INDENT if ( exp & 1 ) == 1 : NEW_LINE INDENT prod = mont . reduce ( prod * base ) NEW_LINE DEDENT exp = exp >> 1 NEW_LINE base = mont . reduce ( base * base ) NEW_LINE DEDENT print mont . reduce ( prod ) NEW_LINE print " \n Alternate ▁ computation ▁ of ▁ x1 ▁ ^ ▁ x2 ▁ mod ▁ m  : " NEW_LINE print pow ( x1 , x2 , m ) NEW_LINE
[ Foo ( ) ] * n NEW_LINE
for i in range ( 5000 ) : NEW_LINE INDENT if i == sum ( int ( x ) ** int ( x ) for x in str ( i ) ) : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT
import Image , ImageDraw NEW_LINE image = Image . new ( " RGB " , ( 256 , 256 ) ) NEW_LINE drawingTool = ImageDraw . Draw ( image ) NEW_LINE for x in range ( 256 ) : NEW_LINE INDENT for y in range ( 256 ) : NEW_LINE INDENT drawingTool . point ( ( x , y ) , ( 0 , x ^ y , 0 ) ) NEW_LINE DEDENT DEDENT del drawingTool NEW_LINE image . save ( " xorpic . png " , " PNG " ) NEW_LINE
import threading NEW_LINE from time import sleep NEW_LINE res = 2 NEW_LINE sema = threading . Semaphore ( res ) NEW_LINE class res_thread ( threading . Thread ) : NEW_LINE INDENT def run ( self ) : NEW_LINE INDENT global res NEW_LINE n = self . getName ( ) NEW_LINE for i in range ( 1 , 4 ) : NEW_LINE INDENT sema . acquire ( ) NEW_LINE res = res - 1 NEW_LINE print n , " + ▁ ▁ res ▁ count " , res NEW_LINE sleep ( 2 ) NEW_LINE res = res + 1 NEW_LINE print n , " - ▁ ▁ res ▁ count " , res NEW_LINE sema . release ( ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , 5 ) : NEW_LINE INDENT t = res_thread ( ) NEW_LINE t . start ( ) NEW_LINE DEDENT
def F ( n ) : return 1 if n == 0 else n - M ( F ( n - 1 ) ) NEW_LINE def M ( n ) : return 0 if n == 0 else n - F ( M ( n - 1 ) ) NEW_LINE print ( [ F ( n ) for n in range ( 20 ) ] ) NEW_LINE print ( [ M ( n ) for n in range ( 20 ) ] ) NEW_LINE
import math NEW_LINE class Vector : NEW_LINE INDENT def __init__ ( self , x , y , z ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE self . z = z NEW_LINE DEDENT def __add__ ( self , other ) : NEW_LINE INDENT return Vector ( self . x + other . x , self . y + other . y , self . z + other . z ) NEW_LINE DEDENT def __sub__ ( self , other ) : NEW_LINE INDENT return Vector ( self . x - other . x , self . y - other . y , self . z - other . z ) NEW_LINE DEDENT def __mul__ ( self , other ) : NEW_LINE INDENT return Vector ( self . x * other , self . y * other , self . z * other ) NEW_LINE DEDENT def __div__ ( self , other ) : NEW_LINE INDENT return Vector ( self . x / other , self . y / other , self . z / other ) NEW_LINE DEDENT def __eq__ ( self , other ) : NEW_LINE INDENT if isinstance ( other , Vector ) : NEW_LINE INDENT return self . x == other . x and self . y == other . y and self . z == other . z NEW_LINE DEDENT return False NEW_LINE DEDENT def __ne__ ( self , other ) : NEW_LINE INDENT return not self . __eq__ ( other ) NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return ' ( { x } , ▁ { y } , ▁ { z } ) ' . format ( x = self . x , y = self . y , z = self . z ) NEW_LINE DEDENT def abs ( self ) : NEW_LINE INDENT return math . sqrt ( self . x * self . x + self . y * self . y + self . z * self . z ) NEW_LINE DEDENT DEDENT origin = Vector ( 0 , 0 , 0 ) NEW_LINE class NBody : NEW_LINE INDENT def __init__ ( self , fileName ) : NEW_LINE INDENT with open ( fileName , " r " ) as fh : NEW_LINE INDENT lines = fh . readlines ( ) NEW_LINE gbt = lines [ 0 ] . split ( ) NEW_LINE self . gc = float ( gbt [ 0 ] ) NEW_LINE self . bodies = int ( gbt [ 1 ] ) NEW_LINE self . timeSteps = int ( gbt [ 2 ] ) NEW_LINE self . masses = [ 0.0 for i in range ( self . bodies ) ] NEW_LINE self . positions = [ origin for i in range ( self . bodies ) ] NEW_LINE self . velocities = [ origin for i in range ( self . bodies ) ] NEW_LINE self . accelerations = [ origin for i in range ( self . bodies ) ] NEW_LINE for i in range ( self . bodies ) : NEW_LINE INDENT self . masses [ i ] = float ( lines [ i * 3 + 1 ] ) NEW_LINE self . positions [ i ] = self . __decompose ( lines [ i * 3 + 2 ] ) NEW_LINE self . velocities [ i ] = self . __decompose ( lines [ i * 3 + 3 ] ) NEW_LINE DEDENT print " Contents ▁ of " , fileName NEW_LINE for line in lines : NEW_LINE INDENT print line . rstrip ( ) NEW_LINE DEDENT print NEW_LINE print " Body ▁ ▁   : ▁ ▁ ▁ ▁ ▁ ▁ x ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ y ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ z ▁ ▁ ▁ ▁ | " , NEW_LINE print " ▁ ▁ ▁ ▁ ▁ vx ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ vy ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ vz " NEW_LINE DEDENT DEDENT def __decompose ( self , line ) : NEW_LINE INDENT xyz = line . split ( ) NEW_LINE x = float ( xyz [ 0 ] ) NEW_LINE y = float ( xyz [ 1 ] ) NEW_LINE z = float ( xyz [ 2 ] ) NEW_LINE return Vector ( x , y , z ) NEW_LINE DEDENT def __computeAccelerations ( self ) : NEW_LINE INDENT for i in xrange ( self . bodies ) : NEW_LINE INDENT self . accelerations [ i ] = origin NEW_LINE for j in xrange ( self . bodies ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT temp = self . gc * self . masses [ j ] / math . pow ( ( self . positions [ i ] - self . positions [ j ] ) . abs ( ) , 3 ) NEW_LINE self . accelerations [ i ] += ( self . positions [ j ] - self . positions [ i ] ) * temp NEW_LINE DEDENT DEDENT DEDENT return None NEW_LINE DEDENT def __computePositions ( self ) : NEW_LINE INDENT for i in xrange ( self . bodies ) : NEW_LINE INDENT self . positions [ i ] += self . velocities [ i ] + self . accelerations [ i ] * 0.5 NEW_LINE DEDENT return None NEW_LINE DEDENT def __computeVelocities ( self ) : NEW_LINE INDENT for i in xrange ( self . bodies ) : NEW_LINE INDENT self . velocities [ i ] += self . accelerations [ i ] NEW_LINE DEDENT return None NEW_LINE DEDENT def __resolveCollisions ( self ) : NEW_LINE INDENT for i in xrange ( self . bodies ) : NEW_LINE INDENT for j in xrange ( self . bodies ) : NEW_LINE INDENT if self . positions [ i ] == self . positions [ j ] : NEW_LINE INDENT ( self . velocities [ i ] , self . velocities [ j ] ) = ( self . velocities [ j ] , self . velocities [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return None NEW_LINE DEDENT def simulate ( self ) : NEW_LINE INDENT self . __computeAccelerations ( ) NEW_LINE self . __computePositions ( ) NEW_LINE self . __computeVelocities ( ) NEW_LINE self . __resolveCollisions ( ) NEW_LINE return None NEW_LINE DEDENT def printResults ( self ) : NEW_LINE INDENT fmt = " Body ▁ % d  : ▁ % ▁ 8.6f ▁ ▁ % ▁ 8.6f ▁ ▁ % ▁ 8.6f ▁ | ▁ % ▁ 8.6f ▁ ▁ % ▁ 8.6f ▁ ▁ % ▁ 8.6f " NEW_LINE for i in xrange ( self . bodies ) : NEW_LINE INDENT print fmt % ( i + 1 , self . positions [ i ] . x , self . positions [ i ] . y , self . positions [ i ] . z , self . velocities [ i ] . x , self . velocities [ i ] . y , self . velocities [ i ] . z ) NEW_LINE DEDENT return None NEW_LINE DEDENT DEDENT nb = NBody ( " nbody . txt " ) NEW_LINE for i in xrange ( nb . timeSteps ) : NEW_LINE INDENT print " \n Cycle ▁ % d " % ( i + 1 ) NEW_LINE nb . simulate ( ) NEW_LINE nb . printResults ( ) NEW_LINE DEDENT
from itertools import permutations NEW_LINE n = 8 NEW_LINE cols = range ( n ) NEW_LINE for vec in permutations ( cols ) : NEW_LINE INDENT if n == len ( set ( vec [ i ] + i for i in cols ) ) == len ( set ( vec [ i ] - i for i in cols ) ) : NEW_LINE INDENT print ( vec ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE with open ( sys . argv [ 0 ] ) as quine : NEW_LINE INDENT code = raw_input ( " Enter ▁ source ▁ code : ▁ " ) NEW_LINE if code == quine . read ( ) : NEW_LINE INDENT print ( " Accept " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Reject " ) NEW_LINE DEDENT DEDENT
def hpo2 ( n ) : return n & ( - n ) NEW_LINE def lhpo2 ( n ) : NEW_LINE INDENT q = 0 NEW_LINE m = hpo2 ( n ) NEW_LINE while m % 2 == 0 : NEW_LINE INDENT m = m >> 1 NEW_LINE q += 1 NEW_LINE DEDENT return q NEW_LINE DEDENT
i = int ( '1a ' , 16 ) NEW_LINE
from itertools import izip NEW_LINE def gen_row ( w , s ) : NEW_LINE INDENT def gen_seg ( o , sp ) : NEW_LINE INDENT if not o : NEW_LINE INDENT return [ [ 2 ] * sp ] NEW_LINE DEDENT return [ [ 2 ] * x + o [ 0 ] + tail for x in xrange ( 1 , sp - len ( o ) + 2 ) for tail in gen_seg ( o [ 1 : ] , sp - x ) ] NEW_LINE DEDENT return [ x [ 1 : ] for x in gen_seg ( [ [ 1 ] * i for i in s ] , w + 1 - sum ( s ) ) ] NEW_LINE DEDENT def deduce ( hr , vr ) : NEW_LINE INDENT def allowable ( row ) : NEW_LINE INDENT return reduce ( lambda a , b : [ x | y for x , y in izip ( a , b ) ] , row ) NEW_LINE DEDENT def fits ( a , b ) : NEW_LINE INDENT return all ( x & y for x , y in izip ( a , b ) ) NEW_LINE DEDENT def fix_col ( n ) : NEW_LINE INDENT c = [ x [ n ] for x in can_do ] NEW_LINE cols [ n ] = [ x for x in cols [ n ] if fits ( x , c ) ] NEW_LINE for i , x in enumerate ( allowable ( cols [ n ] ) ) : NEW_LINE INDENT if x != can_do [ i ] [ n ] : NEW_LINE INDENT mod_rows . add ( i ) NEW_LINE can_do [ i ] [ n ] &= x NEW_LINE DEDENT DEDENT DEDENT def fix_row ( n ) : NEW_LINE INDENT c = can_do [ n ] NEW_LINE rows [ n ] = [ x for x in rows [ n ] if fits ( x , c ) ] NEW_LINE for i , x in enumerate ( allowable ( rows [ n ] ) ) : NEW_LINE INDENT if x != can_do [ n ] [ i ] : NEW_LINE INDENT mod_cols . add ( i ) NEW_LINE can_do [ n ] [ i ] &= x NEW_LINE DEDENT DEDENT DEDENT def show_gram ( m ) : NEW_LINE INDENT for x in m : NEW_LINE INDENT print " ▁ " . join ( " x # . ? " [ i ] for i in x ) NEW_LINE DEDENT print NEW_LINE DEDENT w , h = len ( vr ) , len ( hr ) NEW_LINE rows = [ gen_row ( w , x ) for x in hr ] NEW_LINE cols = [ gen_row ( h , x ) for x in vr ] NEW_LINE can_do = map ( allowable , rows ) NEW_LINE mod_rows , mod_cols = set ( ) , set ( xrange ( w ) ) NEW_LINE while mod_cols : NEW_LINE INDENT for i in mod_cols : NEW_LINE INDENT fix_col ( i ) NEW_LINE DEDENT mod_cols = set ( ) NEW_LINE for i in mod_rows : NEW_LINE INDENT fix_row ( i ) NEW_LINE DEDENT mod_rows = set ( ) NEW_LINE DEDENT if all ( can_do [ i ] [ j ] in ( 1 , 2 ) for j in xrange ( w ) for i in xrange ( h ) ) : NEW_LINE INDENT print " Solution ▁ would ▁ be ▁ unique " NEW_LINE DEDENT else : NEW_LINE INDENT print " Solution ▁ may ▁ not ▁ be ▁ unique , ▁ doing ▁ exhaustive ▁ search : " NEW_LINE DEDENT out = [ 0 ] * h NEW_LINE def try_all ( n = 0 ) : NEW_LINE INDENT if n >= h : NEW_LINE INDENT for j in xrange ( w ) : NEW_LINE INDENT if [ x [ j ] for x in out ] not in cols [ j ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT show_gram ( out ) NEW_LINE return 1 NEW_LINE DEDENT sol = 0 NEW_LINE for x in rows [ n ] : NEW_LINE INDENT out [ n ] = x NEW_LINE sol += try_all ( n + 1 ) NEW_LINE DEDENT return sol NEW_LINE DEDENT n = try_all ( ) NEW_LINE if not n : NEW_LINE INDENT print " No ▁ solution . " NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT print " Unique ▁ solution . " NEW_LINE DEDENT else : NEW_LINE INDENT print n , " solutions . " NEW_LINE DEDENT print NEW_LINE DEDENT def solve ( p , show_runs = True ) : NEW_LINE INDENT s = [ [ [ ord ( c ) - ord ( ' A ' ) + 1 for c in w ] for w in l . split ( ) ] for l in p . splitlines ( ) ] NEW_LINE if show_runs : NEW_LINE INDENT print " Horizontal ▁ runs : " , s [ 0 ] NEW_LINE print " Vertical ▁ runs : " , s [ 1 ] NEW_LINE DEDENT deduce ( s [ 0 ] , s [ 1 ] ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT fn = " nonogram _ problems . txt " NEW_LINE for p in ( x for x in open ( fn ) . read ( ) . split ( " \n \n " ) if x ) : NEW_LINE INDENT solve ( p ) NEW_LINE DEDENT print " Extra ▁ example ▁ not ▁ solvable ▁ by ▁ deduction ▁ alone : " NEW_LINE solve ( " B ▁ B ▁ A ▁ A \n B ▁ B ▁ A ▁ A " ) NEW_LINE print " Extra ▁ example ▁ where ▁ there ▁ is ▁ no ▁ solution : " NEW_LINE solve ( " B ▁ A ▁ A \n A ▁ A ▁ A " ) NEW_LINE DEDENT main ( ) NEW_LINE
x = None NEW_LINE if x is None : NEW_LINE INDENT print " x ▁ is ▁ None " NEW_LINE DEDENT else : NEW_LINE INDENT print " x ▁ is ▁ not ▁ None " NEW_LINE DEDENT
import random NEW_LINE print ( __doc__ ) NEW_LINE data , trials = list ( '123456789' ) , 0 NEW_LINE while data == sorted ( data ) : NEW_LINE INDENT random . shuffle ( data ) NEW_LINE DEDENT while data != sorted ( data ) : NEW_LINE INDENT trials += 1 NEW_LINE flip = int ( input ( ' # % 2i : ▁ LIST : ▁ % r ▁ Flip ▁ how ▁ many ? : ▁ ' % ( trials , ' ▁ ' . join ( data ) ) ) ) NEW_LINE data [ : flip ] = reversed ( data [ : flip ] ) NEW_LINE DEDENT print ( ' \n You ▁ took ▁ % 2i ▁ attempts ▁ to ▁ put ▁ the ▁ digits ▁ in ▁ order ! ' % trials ) NEW_LINE
def trapezium ( f , x , h ) : NEW_LINE INDENT return ( f ( x ) + f ( x + h ) ) / 2.0 NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT ( a , b , ) = ( 0.0 , 1.0 , ) NEW_LINE sinx = quad_asr ( math . sin , a , b , 1e-09 ) ; NEW_LINE print ( " Simpson ' s ▁ integration ▁ of ▁ sine ▁ from ▁ { } ▁ to ▁ { } ▁ = ▁ { } \n " . format ( a , b , sinx ) ) NEW_LINE DEDENT
import pickle NEW_LINE class Entity : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . name = " Entity " NEW_LINE DEDENT def printName ( self ) : NEW_LINE INDENT print self . name NEW_LINE DEDENT DEDENT class Person ( Entity ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . name = " Cletus " NEW_LINE DEDENT DEDENT instance1 = Person ( ) NEW_LINE instance1 . printName ( ) NEW_LINE instance2 = Entity ( ) NEW_LINE instance2 . printName ( ) NEW_LINE target = file ( " objects . dat " , " w " ) NEW_LINE pickle . dump ( ( instance1 , instance2 ) , target ) NEW_LINE target . close ( ) NEW_LINE print " Serialized . . . " NEW_LINE target = file ( " objects . dat " ) NEW_LINE i1 , i2 = pickle . load ( target ) NEW_LINE print " Unserialized . . . " NEW_LINE i1 . printName ( ) NEW_LINE i2 . printName ( ) NEW_LINE
import urllib . request NEW_LINE urllib . request . urlretrieve ( " http : / / wiki . puzzlers . org / pub / wordlists / unixdict . txt " , " unixdict . txt " ) NEW_LINE dictionary = open ( " unixdict . txt " , " r " ) NEW_LINE wordList = dictionary . read ( ) . split ( ' \n ' ) NEW_LINE dictionary . close ( ) NEW_LINE oddWordSet = set ( { } ) NEW_LINE for word in wordList : NEW_LINE INDENT if len ( word ) >= 9 and word [ : : 2 ] in wordList : NEW_LINE INDENT oddWordSet . add ( word [ : : 2 ] ) NEW_LINE DEDENT DEDENT [ print ( i ) for i in sorted ( oddWordSet ) ] NEW_LINE
import zlib , base64 NEW_LINE b64 = b ''' STRNEWLINE eNrtVE1rwzAMvedXaKdeRn7ENrb21rHCzmrs1m49K9gOJv9 + cko / HBcGg0LHcpOfnq2np0QL STRNEWLINE 2FuKgBbICDAoeoiKwEc0hqIUgLAxfV0tQJCdhQM7qh68kheswKeBt5ROYetTemYMCC3rii / / STRNEWLINE WMS3WkhXVyuFAaLT261JuBWwu4iDbvYp1tYzHVS68VEIObwFgaDB0KizuFs38aSdqKv3TgcJ STRNEWLINE uPYdn2B1opwIpeKE53qPftxRd88Y6uoVbdPzWxznrQ3ZUi3DudQ / bcELbevqM32iCIrj3IIh STRNEWLINE W6plOJf6L6xaajZjzqW / qAsKIvITBGs9Nm3glboZzkVP5l6Y + 0bHLnedD0CttIyrpEU5Kv7N STRNEWLINE Mz3XkPBc / TSN3yxGiqMiipHRekycK0ZwMhM8jerGC9zuZaoTho3kMKSfJjLaF8v8wLzmXMqM STRNEWLINE zJvGew / jnZPzclA08yAkikegDTTUMfzwDXBcwoE = ''' NEW_LINE print ( zlib . decompress ( base64 . b64decode ( b64 ) ) . decode ( " utf - 8" , " strict " ) ) NEW_LINE
from sys import argv NEW_LINE unit2mult = { " arshin " : 0.7112 , " centimeter " : 0.01 , " diuym " : 0.0254 , " fut " : 0.3048 , " kilometer " : 1000.0 , " liniya " : 0.00254 , " meter " : 1.0 , " milia " : 7467.6 , " piad " : 0.1778 , " sazhen " : 2.1336 , " tochka " : 0.000254 , " vershok " : 0.04445 , " versta " : 1066.8 } NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT assert len ( argv ) == 3 , ' ERROR . ▁ Need ▁ two ▁ arguments ▁ - ▁ number ▁ then ▁ units ' NEW_LINE try : NEW_LINE INDENT value = float ( argv [ 1 ] ) NEW_LINE DEDENT except : NEW_LINE INDENT print ( ' ERROR . ▁ First ▁ argument ▁ must ▁ be ▁ a ▁ ( float ) ▁ number ' ) NEW_LINE raise NEW_LINE DEDENT unit = argv [ 2 ] NEW_LINE assert unit in unit2mult , ( ' ERROR . ▁ Only ▁ know ▁ the ▁ following ▁ units : ▁ ' + ' ▁ ' . join ( unit2mult . keys ( ) ) ) NEW_LINE print ( " % g ▁ % s ▁ to : " % ( value , unit ) ) NEW_LINE for unt , mlt in sorted ( unit2mult . items ( ) ) : NEW_LINE INDENT print ( ' ▁ ▁ % 10s : ▁ % g ' % ( unt , value * unit2mult [ unit ] / mlt ) ) NEW_LINE DEDENT DEDENT
def one_of_n ( lines ) : NEW_LINE INDENT choice = None NEW_LINE for i , line in enumerate ( lines ) : NEW_LINE INDENT if randrange ( i + 1 ) == 0 : NEW_LINE INDENT choice = line NEW_LINE DEDENT DEDENT return choice NEW_LINE DEDENT
import random NEW_LINE printdead , printlive = ' _ # ' NEW_LINE maxgenerations = 10 NEW_LINE cellcount = 20 NEW_LINE offendvalue = '0' NEW_LINE universe = ' ' . join ( random . choice ( '01' ) for i in range ( cellcount ) ) NEW_LINE neighbours2newstate = { '000' : '0' , '001' : '0' , '010' : '0' , '011' : '1' , '100' : '0' , '101' : '1' , '110' : '1' , '111' : '0' , } NEW_LINE for i in range ( maxgenerations ) : NEW_LINE INDENT print " Generation ▁ % 3i : ▁ ▁ % s " % ( i , universe . replace ( '0' , printdead ) . replace ( '1' , printlive ) ) NEW_LINE universe = offendvalue + universe + offendvalue NEW_LINE universe = ' ' . join ( neighbours2newstate [ universe [ i : i + 3 ] ] for i in range ( cellcount ) ) NEW_LINE DEDENT
def main ( pad , message , outfile ) : NEW_LINE INDENT if not pad . exists ( ) : NEW_LINE INDENT error ( f " no ▁ such ▁ pad ▁ ' { pad } ' " ) NEW_LINE DEDENT with pad . open ( " r " ) as fd : NEW_LINE INDENT if fd . readline ( ) . strip ( ) != MAGIC : NEW_LINE INDENT error ( f " file ▁ ' { pad } ' ▁ does ▁ not ▁ look ▁ like ▁ a ▁ one - time ▁ pad " ) NEW_LINE DEDENT DEDENT with pad . open ( " r + " ) as fd : NEW_LINE INDENT updated , key = use_key ( fd . read ( ) ) NEW_LINE fd . seek ( 0 ) NEW_LINE fd . write ( updated ) NEW_LINE DEDENT outfile . write ( xor ( message , bytes . fromhex ( key ) ) ) NEW_LINE DEDENT
def rotate ( i , j , alpha ) : NEW_LINE INDENT return [ mulAdd ( i , math . cos ( alpha ) , j , math . sin ( alpha ) ) , mulAdd ( i , - math . sin ( alpha ) , j , math . cos ( alpha ) ) ] NEW_LINE DEDENT
import urllib . request NEW_LINE url = ' http : / / www . puzzlers . org / pub / wordlists / unixdict . txt ' NEW_LINE words = urllib . request . urlopen ( url ) . read ( ) . decode ( " utf - 8" ) . split ( ) NEW_LINE ordered = [ word for word in words if word == ' ' . join ( sorted ( word ) ) ] NEW_LINE maxlen = len ( max ( ordered , key = len ) ) NEW_LINE maxorderedwords = [ word for word in ordered if len ( word ) == maxlen ] NEW_LINE print ( ' ▁ ' . join ( maxorderedwords ) ) NEW_LINE
def main ( ) : NEW_LINE INDENT palinDates = list ( chain . from_iterable ( map ( palinDay , range ( 2021 , 10000 ) ) ) ) NEW_LINE for x in [ ' Count ▁ of ▁ palindromic ▁ dates ▁ [ 2021 . . 9999 ] : ' , len ( palinDates ) , ' \n First ▁ 15 : ' , ' \n ' . join ( palinDates [ 0 : 15 ] ) , ' \n Last ▁ 15 : ' , ' \n ' . join ( palinDates [ - 15 : ] ) ] : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT
def is_gapful ( x ) : NEW_LINE INDENT return ( x % ( int ( str ( x ) [ 0 ] ) * 10 + ( x % 10 ) ) == 0 ) NEW_LINE DEDENT
def pancake ( n : int ) -> Tuple [ Pancakes , int ] : NEW_LINE INDENT init_stack = tuple ( range ( 1 , n + 1 ) ) NEW_LINE stack_flips = { init_stack : 0 } NEW_LINE queue = deque ( [ init_stack ] ) NEW_LINE while queue : NEW_LINE INDENT stack = queue . popleft ( ) NEW_LINE flips = stack_flips [ stack ] + 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT flipped = flip ( stack , i ) NEW_LINE if flipped not in stack_flips : NEW_LINE INDENT stack_flips [ flipped ] = flips NEW_LINE queue . append ( flipped ) NEW_LINE DEDENT DEDENT DEDENT return max ( stack_flips . items ( ) , key = itemgetter ( 1 ) ) NEW_LINE DEDENT
def bicenter ( s ) : NEW_LINE INDENT global ra , unrooted NEW_LINE if not ( s & 1 ) : NEW_LINE INDENT aux = ra [ s / 2 ] NEW_LINE unrooted [ s ] += aux * ( aux + 1 ) / 2 NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT with multiprocessing . Pool ( ) as p : NEW_LINE INDENT p . map ( brute , range ( 97 , 97 + 26 ) ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT print ( ' For ▁ these ▁ numbers : ' ) NEW_LINE print ( ' \n ▁ ▁ ' . join ( str ( p ) for p in NUMBERS ) ) NEW_LINE number , all_factors = prime_factors_of_number_with_lowest_prime_factor ( NUMBERS ) NEW_LINE print ( ' ▁ ▁ ▁ ▁ The ▁ one ▁ with ▁ the ▁ largest ▁ minimum ▁ prime ▁ factor ▁ is ▁ { } : ' . format ( number ) ) NEW_LINE print ( ' ▁ ▁ ▁ ▁ ▁ ▁ All ▁ its ▁ prime ▁ factors ▁ in ▁ order ▁ are : ▁ { } ' . format ( all_factors ) ) NEW_LINE DEDENT
import sqlite3 NEW_LINE db = sqlite3 . connect ( ' : memory : ' ) NEW_LINE db . execute ( ' create ▁ temp ▁ table ▁ players ▁ ( name , ▁ score , ▁ active , ▁ jerseyNum ) ' ) NEW_LINE db . execute ( ' insert ▁ into ▁ players ▁ values ▁ ( " name " ,0 , " false " ,99 ) ' ) NEW_LINE db . execute ( ' insert ▁ into ▁ players ▁ values ▁ ( " name " ,0 , " false " ,100 ) ' ) NEW_LINE db . execute ( ' update ▁ players ▁ set ▁ name = ? , ▁ score = ? , ▁ active = ? ▁ where ▁ jerseyNum = ? ' , ( ' Smith , ▁ Steve ' , 42 , True , 99 ) ) NEW_LINE db . execute ( ' update ▁ players ▁ set ▁ name = : name , ▁ score = : score , ▁ active = : active ▁ where ▁ jerseyNum = : num ' , { ' num ' : 100 , ' name ' : ' John ▁ Doe ' , ' active ' : False , ' score ' : - 1 } ) NEW_LINE for row in db . execute ( ' select ▁ * ▁ from ▁ players ' ) : NEW_LINE INDENT print ( row ) NEW_LINE DEDENT
from functools import partial NEW_LINE def fs ( f , s ) : return [ f ( value ) for value in s ] NEW_LINE def f1 ( value ) : return value * 2 NEW_LINE def f2 ( value ) : return value ** 2 NEW_LINE fsf1 = partial ( fs , f1 ) NEW_LINE fsf2 = partial ( fs , f2 ) NEW_LINE s = [ 0 , 1 , 2 , 3 ] NEW_LINE assert fs ( f1 , s ) == fsf1 ( s ) NEW_LINE assert fs ( f2 , s ) == fsf2 ( s ) NEW_LINE s = [ 2 , 4 , 6 , 8 ] NEW_LINE assert fs ( f1 , s ) == fsf1 ( s ) NEW_LINE assert fs ( f2 , s ) == fsf2 ( s ) NEW_LINE
def mccormick ( x ) : NEW_LINE INDENT ( a , b ) = x NEW_LINE return math . sin ( a + b ) + ( a - b ) * ( a - b ) + 1.0 + 2.5 * b - 1.5 * a NEW_LINE DEDENT
def pascal_upp ( n ) : NEW_LINE INDENT s = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE s [ 0 ] = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT s [ i ] [ j ] = s [ i - 1 ] [ j - 1 ] + s [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def pascal_low ( n ) : NEW_LINE INDENT return [ list ( x ) for x in zip ( * pascal_upp ( n ) ) ] NEW_LINE DEDENT
def pascal_sym ( n ) : NEW_LINE INDENT s = [ [ 1 ] * n for _ in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT s [ i ] [ j ] = s [ i - 1 ] [ j ] + s [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def pascal ( n ) : NEW_LINE INDENT row = [ 1 ] NEW_LINE k = [ 0 ] NEW_LINE for x in range ( max ( n , 0 ) ) : NEW_LINE INDENT print row NEW_LINE row = [ l + r for l , r in zip ( row + k , k + row ) ] NEW_LINE DEDENT return n >= 1 NEW_LINE DEDENT
def place ( m , n ) : NEW_LINE INDENT board = set ( product ( range ( n ) , repeat = 2 ) ) NEW_LINE placements = { frozenset ( c ) for c in combinations ( board , m ) } NEW_LINE for blacks in placements : NEW_LINE INDENT black_attacks = reduce ( _or , ( queen_attacks_from ( pos , n ) for pos in blacks ) , set ( ) ) NEW_LINE for whites in { frozenset ( c ) for c in combinations ( board - black_attacks , m ) } : NEW_LINE INDENT if not black_attacks & whites : NEW_LINE INDENT return blacks , whites NEW_LINE DEDENT DEDENT DEDENT return set ( ) , set ( ) NEW_LINE DEDENT
from __future__ import print_function NEW_LINE import random NEW_LINE from time import sleep NEW_LINE first = random . choice ( [ True , False ] ) NEW_LINE you = ' ' NEW_LINE if first : NEW_LINE INDENT me = ' ' . join ( random . sample ( ' HT ' * 3 , 3 ) ) NEW_LINE print ( ' I ▁ choose ▁ first ▁ and ▁ will ▁ win ▁ on ▁ first ▁ seeing ▁ { } ▁ in ▁ the ▁ list ▁ of ▁ tosses ' . format ( me ) ) NEW_LINE while len ( you ) != 3 or any ( ch not in ' HT ' for ch in you ) or you == me : NEW_LINE INDENT you = input ( ' What ▁ sequence ▁ of ▁ three ▁ Heads / Tails ▁ will ▁ you ▁ win ▁ with : ▁ ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while len ( you ) != 3 or any ( ch not in ' HT ' for ch in you ) : NEW_LINE INDENT you = input ( ' After ▁ you : ▁ What ▁ sequence ▁ of ▁ three ▁ Heads / Tails ▁ will ▁ you ▁ win ▁ with : ▁ ' ) NEW_LINE DEDENT me = ( ' H ' if you [ 1 ] == ' T ' else ' T ' ) + you [ : 2 ] NEW_LINE print ( ' I ▁ win ▁ on ▁ first ▁ seeing ▁ { } ▁ in ▁ the ▁ list ▁ of ▁ tosses ' . format ( me ) ) NEW_LINE DEDENT print ( ' Rolling : \n ▁ ▁ ' , end = ' ' ) NEW_LINE rolled = ' ' NEW_LINE while True : NEW_LINE INDENT rolled += random . choice ( ' HT ' ) NEW_LINE print ( rolled [ - 1 ] , end = ' ' ) NEW_LINE if rolled . endswith ( you ) : NEW_LINE INDENT print ( ' \n ▁ ▁ You ▁ win ! ' ) NEW_LINE break NEW_LINE DEDENT if rolled . endswith ( me ) : NEW_LINE INDENT print ( ' \n ▁ ▁ I ▁ win ! ' ) NEW_LINE break NEW_LINE DEDENT sleep ( 1 ) NEW_LINE DEDENT
import turtle NEW_LINE turtle . bgcolor ( " green " ) NEW_LINE t = turtle . Turtle ( ) NEW_LINE t . color ( " red " , " blue " ) NEW_LINE t . begin_fill ( ) NEW_LINE for i in range ( 0 , 5 ) : NEW_LINE INDENT t . forward ( 200 ) NEW_LINE t . right ( 144 ) NEW_LINE DEDENT t . end_fill ( ) NEW_LINE
from PIL import Image NEW_LINE i1 = Image . open ( " image1 . jpg " ) NEW_LINE i2 = Image . open ( " image2 . jpg " ) NEW_LINE assert i1 . mode == i2 . mode , " Different ▁ kinds ▁ of ▁ images . " NEW_LINE assert i1 . size == i2 . size , " Different ▁ sizes . " NEW_LINE pairs = zip ( i1 . getdata ( ) , i2 . getdata ( ) ) NEW_LINE if len ( i1 . getbands ( ) ) == 1 : NEW_LINE INDENT dif = sum ( abs ( p1 - p2 ) for p1 , p2 in pairs ) NEW_LINE DEDENT else : NEW_LINE INDENT dif = sum ( abs ( c1 - c2 ) for p1 , p2 in pairs for c1 , c2 in zip ( p1 , p2 ) ) NEW_LINE DEDENT ncomponents = i1 . size [ 0 ] * i1 . size [ 1 ] * 3 NEW_LINE print ( " Difference ▁ ( percentage ) : " , ( dif / 255.0 * 100 ) / ncomponents ) NEW_LINE
def main ( ) : NEW_LINE INDENT doctest . testmod ( ) NEW_LINE print ( " Length ▁ of ▁ the ▁ deck ▁ of ▁ cards ▁ | ▁ Perfect ▁ shuffles ▁ needed ▁ to ▁ obtain ▁ the ▁ same ▁ deck ▁ back " ) NEW_LINE for length in ( 8 , 24 , 52 , 100 , 1020 , 1024 , 10000 ) : NEW_LINE INDENT deck = list ( range ( length ) ) NEW_LINE shuffles_needed = after_how_many_is_equal ( magic_shuffle , deck , deck ) NEW_LINE print ( " { } ▁ | ▁ { } " . format ( length , shuffles_needed ) ) NEW_LINE DEDENT DEDENT
def perfect_totient ( ) : NEW_LINE INDENT for n0 in count ( 1 ) : NEW_LINE INDENT parts , n = 0 , n0 NEW_LINE while n != 1 : NEW_LINE INDENT n = φ ( n ) NEW_LINE parts += n NEW_LINE DEDENT if parts == n0 : NEW_LINE INDENT yield n0 NEW_LINE DEDENT DEDENT DEDENT
def fade ( t ) : NEW_LINE INDENT return t ** 3 * ( t * ( t * 6 - 15 ) + 10 ) NEW_LINE DEDENT
def lerp ( t , a , b ) : NEW_LINE INDENT return a + t * ( b - a ) NEW_LINE DEDENT
def grad ( hash , x , y , z ) : NEW_LINE INDENT h = hash & 15 NEW_LINE u = x if h < 8 else y NEW_LINE v = y if h < 4 else ( x if h in ( 12 , 14 ) else z ) NEW_LINE return ( u if ( h & 1 ) == 0 else - u ) + ( v if ( h & 2 ) == 0 else - v ) NEW_LINE DEDENT
from operator import itemgetter NEW_LINE DEBUG = False NEW_LINE def spermutations ( n ) : NEW_LINE INDENT sign = 1 NEW_LINE p = [ [ i , 0 if i == 0 else - 1 ] for i in range ( n ) ] NEW_LINE if DEBUG : print ' ▁ # ' , p NEW_LINE yield tuple ( pp [ 0 ] for pp in p ) , sign NEW_LINE while any ( pp [ 1 ] for pp in p ) : NEW_LINE INDENT i1 , ( n1 , d1 ) = max ( ( ( i , pp ) for i , pp in enumerate ( p ) if pp [ 1 ] ) , key = itemgetter ( 1 ) ) NEW_LINE sign *= - 1 NEW_LINE if d1 == - 1 : NEW_LINE INDENT i2 = i1 - 1 NEW_LINE p [ i1 ] , p [ i2 ] = p [ i2 ] , p [ i1 ] NEW_LINE if i2 == 0 or p [ i2 - 1 ] [ 0 ] > n1 : NEW_LINE INDENT p [ i2 ] [ 1 ] = 0 NEW_LINE DEDENT DEDENT elif d1 == 1 : NEW_LINE INDENT i2 = i1 + 1 NEW_LINE p [ i1 ] , p [ i2 ] = p [ i2 ] , p [ i1 ] NEW_LINE if i2 == n - 1 or p [ i2 + 1 ] [ 0 ] > n1 : NEW_LINE INDENT p [ i2 ] [ 1 ] = 0 NEW_LINE DEDENT DEDENT if DEBUG : print ' ▁ # ' , p NEW_LINE yield tuple ( pp [ 0 ] for pp in p ) , sign NEW_LINE for i3 , pp in enumerate ( p ) : NEW_LINE INDENT n3 , d3 = pp NEW_LINE if n3 > n1 : NEW_LINE INDENT pp [ 1 ] = 1 if i3 < i2 else - 1 NEW_LINE if DEBUG : print ' ▁ # ▁ Set ▁ Moving ' NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT from itertools import permutations NEW_LINE for n in ( 3 , 4 ) : NEW_LINE INDENT print ' \n Permutations ▁ and ▁ sign ▁ of ▁ % i ▁ items ' % n NEW_LINE sp = set ( ) NEW_LINE for i in spermutations ( n ) : NEW_LINE INDENT sp . add ( i [ 0 ] ) NEW_LINE print ( ' Perm : ▁ % r ▁ Sign : ▁ % 2i ' % i ) NEW_LINE DEDENT p = set ( permutations ( range ( n ) ) ) NEW_LINE assert sp == p , ' Two ▁ methods ▁ of ▁ generating ▁ permutations ▁ do ▁ not ▁ agree ' NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT print ( fTable ( main . __doc__ + ' : \n ' ) ( repr ) ( showList ) ( replicateM ( 2 ) ) ( [ [ 1 , 2 , 3 ] , ' abc ' ] ) ) NEW_LINE DEDENT
import itertools NEW_LINE for values in itertools . permutations ( [ 1 , 2 , 3 ] ) : NEW_LINE INDENT print ( values ) NEW_LINE DEDENT
def derangements ( n ) : NEW_LINE INDENT return ( perm for perm in permutations ( range ( n ) ) if all ( indx != p for indx , p in enumerate ( perm ) ) ) NEW_LINE DEDENT
def subfact ( n ) : NEW_LINE INDENT if n == 2 or n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif 1 <= n <= 18 : NEW_LINE INDENT return round ( math . factorial ( n ) / math . e ) NEW_LINE DEDENT elif n . imag == 0 and n . real == int ( n . real ) and n > 0 : NEW_LINE INDENT return ( n - 1 ) * ( subfact ( n - 1 ) + subfact ( n - 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT DEDENT
from random import randint NEW_LINE playercount = 2 NEW_LINE maxscore = 100 NEW_LINE safescore = [ 0 ] * playercount NEW_LINE player = 0 NEW_LINE score = 0 NEW_LINE while max ( safescore ) < maxscore : NEW_LINE INDENT rolling = input ( " Player ▁ % i : ▁ ( % i , ▁ % i ) ▁ Rolling ? ▁ ( Y ) ▁ " % ( player , safescore [ player ] , score ) ) . strip ( ) . lower ( ) in { ' yes ' , ' y ' , ' ' } NEW_LINE if rolling : NEW_LINE INDENT rolled = randint ( 1 , 6 ) NEW_LINE print ( ' ▁ ▁ Rolled ▁ % i ' % rolled ) NEW_LINE if rolled == 1 : NEW_LINE INDENT print ( ' ▁ ▁ Bust ! ▁ you ▁ lose ▁ % i ▁ but ▁ still ▁ keep ▁ your ▁ previous ▁ % i ' % ( score , safescore [ player ] ) ) NEW_LINE score , player = 0 , ( player + 1 ) % playercount NEW_LINE DEDENT else : NEW_LINE INDENT score += rolled NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT safescore [ player ] += score NEW_LINE if safescore [ player ] >= maxscore : NEW_LINE INDENT break NEW_LINE DEDENT print ( ' ▁ ▁ Sticking ▁ with ▁ % i ' % safescore [ player ] ) NEW_LINE score , player = 0 , ( player + 1 ) % playercount NEW_LINE DEDENT DEDENT print ( ' \n Player ▁ % i ▁ wins ▁ with ▁ a ▁ score ▁ of ▁ % i ' % ( player , safescore [ player ] ) ) NEW_LINE
from PIL import Image NEW_LINE from PIL import ImageColor NEW_LINE from PIL import ImageDraw NEW_LINE x_size = 1650 NEW_LINE y_size = 1000 NEW_LINE im = Image . new ( ' RGB ' , ( x_size , y_size ) ) NEW_LINE draw = ImageDraw . Draw ( im ) NEW_LINE White = ( 255 , 255 , 255 ) NEW_LINE y_delimiter_list = [ ] NEW_LINE for y_delimiter in range ( 1 , y_size , y_size / 4 ) : NEW_LINE INDENT y_delimiter_list . append ( y_delimiter ) NEW_LINE DEDENT for x in range ( 1 , x_size , 2 ) : NEW_LINE INDENT for y in range ( 1 , y_delimiter_list [ 1 ] , 1 ) : NEW_LINE INDENT draw . point ( ( x , y ) , White ) NEW_LINE DEDENT DEDENT for x in range ( 1 , x_size - 1 , 4 ) : NEW_LINE INDENT for y in range ( y_delimiter_list [ 1 ] , y_delimiter_list [ 2 ] , 1 ) : NEW_LINE INDENT draw . point ( ( x , y ) , White ) NEW_LINE draw . point ( ( x + 1 , y ) , White ) NEW_LINE DEDENT DEDENT for x in range ( 1 , x_size - 2 , 6 ) : NEW_LINE INDENT for y in range ( y_delimiter_list [ 2 ] , y_delimiter_list [ 3 ] , 1 ) : NEW_LINE INDENT draw . point ( ( x , y ) , White ) NEW_LINE draw . point ( ( x + 1 , y ) , White ) NEW_LINE draw . point ( ( x + 2 , y ) , White ) NEW_LINE DEDENT DEDENT for x in range ( 1 , x_size - 3 , 8 ) : NEW_LINE INDENT for y in range ( y_delimiter_list [ 3 ] , y_size , 1 ) : NEW_LINE INDENT draw . point ( ( x , y ) , White ) NEW_LINE draw . point ( ( x + 1 , y ) , White ) NEW_LINE draw . point ( ( x + 2 , y ) , White ) NEW_LINE draw . point ( ( x + 3 , y ) , White ) NEW_LINE DEDENT DEDENT print " Your ▁ picture ▁ is ▁ saved " NEW_LINE im . save ( ' PictureResult . jpg ' ) NEW_LINE
import random NEW_LINE class Card ( object ) : NEW_LINE INDENT suits = ( " Clubs " , " Hearts " , " Spades " , " Diamonds " ) NEW_LINE pips = ( "2" , "3" , "4" , "5" , "6" , "7" , "8" , "9" , "10" , " Jack " , " Queen " , " King " , " Ace " ) NEW_LINE def __init__ ( self , pip , suit ) : NEW_LINE INDENT self . pip = pip NEW_LINE self . suit = suit NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return " % s ▁ % s " % ( self . pip , self . suit ) NEW_LINE DEDENT DEDENT class Deck ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . deck = [ Card ( pip , suit ) for suit in Card . suits for pip in Card . pips ] NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return " [ % s ] " % " , ▁ " . join ( ( str ( card ) for card in self . deck ) ) NEW_LINE DEDENT def shuffle ( self ) : NEW_LINE INDENT random . shuffle ( self . deck ) NEW_LINE DEDENT def deal ( self ) : NEW_LINE INDENT self . shuffle ( ) NEW_LINE return self . deck . pop ( 0 ) NEW_LINE DEDENT DEDENT
import copy NEW_LINE class T : NEW_LINE INDENT def classname ( self ) : NEW_LINE INDENT return self . __class__ . __name__ NEW_LINE DEDENT def __init__ ( self ) : NEW_LINE INDENT self . myValue = " I ' m ▁ a ▁ T . " NEW_LINE DEDENT def speak ( self ) : NEW_LINE INDENT print self . classname ( ) , ' Hello ' , self . myValue NEW_LINE DEDENT def clone ( self ) : NEW_LINE INDENT return copy . copy ( self ) NEW_LINE DEDENT DEDENT class S1 ( T ) : NEW_LINE INDENT def speak ( self ) : NEW_LINE INDENT print self . classname ( ) , " Meow " , self . myValue NEW_LINE DEDENT DEDENT class S2 ( T ) : NEW_LINE INDENT def speak ( self ) : NEW_LINE INDENT print self . classname ( ) , " Woof " , self . myValue NEW_LINE DEDENT DEDENT print " creating ▁ initial ▁ objects ▁ of ▁ types ▁ S1 , ▁ S2 , ▁ and ▁ T " NEW_LINE a = S1 ( ) NEW_LINE a . myValue = ' Green ' NEW_LINE a . speak ( ) NEW_LINE b = S2 ( ) NEW_LINE b . myValue = ' Blue ' NEW_LINE b . speak ( ) NEW_LINE u = T ( ) NEW_LINE u . myValue = ' Purple ' NEW_LINE u . speak ( ) NEW_LINE print " Making ▁ copy ▁ of ▁ a ▁ as ▁ u , ▁ colors ▁ and ▁ types ▁ should ▁ match " NEW_LINE u = a . clone ( ) NEW_LINE u . speak ( ) NEW_LINE a . speak ( ) NEW_LINE print " Assigning ▁ new ▁ color ▁ to ▁ u , ▁ A ' s ▁ color ▁ should ▁ be ▁ unchanged . " NEW_LINE u . myValue = " Orange " NEW_LINE u . speak ( ) NEW_LINE a . speak ( ) NEW_LINE print " Assigning ▁ u ▁ to ▁ reference ▁ same ▁ object ▁ as ▁ b , ▁ colors ▁ and ▁ types ▁ should ▁ match " NEW_LINE u = b NEW_LINE u . speak ( ) NEW_LINE b . speak ( ) NEW_LINE print " Assigning ▁ new ▁ color ▁ to ▁ u . ▁ Since ▁ u , b ▁ references ▁ same ▁ object ▁ b ' s ▁ color ▁ changes ▁ as ▁ well " NEW_LINE u . myValue = " Yellow " NEW_LINE u . speak ( ) NEW_LINE b . speak ( ) NEW_LINE
class Point ( object ) : NEW_LINE INDENT def __init__ ( self , x = 0.0 , y = 0.0 ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' < Point ▁ 0x % x ▁ x : ▁ % f ▁ y : ▁ % f > ' % ( id ( self ) , self . x , self . y ) NEW_LINE DEDENT DEDENT class Circle ( object ) : NEW_LINE INDENT def __init__ ( self , center = None , radius = 1.0 ) : NEW_LINE INDENT self . center = center or Point ( ) NEW_LINE self . radius = radius NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' < Circle ▁ 0x % x ▁ x : ▁ % f ▁ y : ▁ % f ▁ radius : ▁ % f > ' % ( id ( self ) , self . center . x , self . center . y , self . radius ) NEW_LINE DEDENT DEDENT
from __future__ import print_function NEW_LINE from __future__ import division NEW_LINE def extended_synthetic_division ( dividend , divisor ) : NEW_LINE INDENT out = list ( dividend ) NEW_LINE normalizer = divisor [ 0 ] NEW_LINE for i in xrange ( len ( dividend ) - ( len ( divisor ) - 1 ) ) : NEW_LINE INDENT out [ i ] /= normalizer NEW_LINE coef = out [ i ] NEW_LINE if coef != 0 : NEW_LINE INDENT for j in xrange ( 1 , len ( divisor ) ) : NEW_LINE INDENT out [ i + j ] += - divisor [ j ] * coef NEW_LINE DEDENT DEDENT DEDENT separator = - ( len ( divisor ) - 1 ) NEW_LINE return out [ : separator ] , out [ separator : ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( " POLYNOMIAL ▁ SYNTHETIC ▁ DIVISION " ) NEW_LINE N = [ 1 , - 12 , 0 , - 42 ] NEW_LINE D = [ 1 , - 3 ] NEW_LINE print ( " ▁ ▁ % s ▁ / ▁ % s ▁ ▁ = " % ( N , D ) , " ▁ % s ▁ remainder ▁ % s " % extended_synthetic_division ( N , D ) ) NEW_LINE DEDENT
import math NEW_LINE import pygame NEW_LINE from pygame . locals import * NEW_LINE pygame . init ( ) NEW_LINE screen = pygame . display . set_mode ( ( 1024 , 600 ) ) NEW_LINE pygame . display . set_caption ( " Polyspiral " ) NEW_LINE incr = 0 NEW_LINE running = True NEW_LINE while running : NEW_LINE INDENT pygame . time . Clock ( ) . tick ( 60 ) NEW_LINE for event in pygame . event . get ( ) : NEW_LINE INDENT if event . type == QUIT : NEW_LINE INDENT running = False NEW_LINE break NEW_LINE DEDENT DEDENT incr = ( incr + 0.05 ) % 360 NEW_LINE x1 = pygame . display . Info ( ) . current_w / 2 NEW_LINE y1 = pygame . display . Info ( ) . current_h / 2 NEW_LINE length = 5 NEW_LINE angle = incr NEW_LINE screen . fill ( ( 255 , 255 , 255 ) ) NEW_LINE for i in range ( 1 , 151 ) : NEW_LINE INDENT x2 = x1 + math . cos ( angle ) * length NEW_LINE y2 = y1 + math . sin ( angle ) * length NEW_LINE pygame . draw . line ( screen , ( 255 , 0 , 0 ) , ( x1 , y1 ) , ( x2 , y2 ) , 1 ) NEW_LINE x1 , y1 = x2 , y2 NEW_LINE length += 3 NEW_LINE angle = ( angle + incr ) % 360 NEW_LINE DEDENT pygame . display . flip ( ) NEW_LINE DEDENT
def is_practical ( x : int ) -> bool : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if x % 2 : NEW_LINE INDENT return False NEW_LINE DEDENT f = factors5 ( x ) NEW_LINE ps = powerset ( f ) NEW_LINE found = { y for y in { sum ( i ) for i in ps } if 1 <= y < x } NEW_LINE return len ( found ) == x - 1 NEW_LINE DEDENT
def prime ( a ) : NEW_LINE INDENT return not ( a < 2 or any ( a % x == 0 for x in xrange ( 2 , int ( a ** 0.5 ) + 1 ) ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT matches = primesWithGivenDigitSum ( 5000 , 25 ) NEW_LINE print ( str ( len ( matches ) ) + ( ) ) print ( ' \n ' . join ( [ ' ▁ ' . join ( [ str ( x ) . rjust ( 4 , ' ▁ ' ) for x in xs ] ) for xs in chunksOf ( 4 ) ( matches ) ] ) ) NEW_LINE DEDENT
def primorial ( n ) : NEW_LINE INDENT return reduce ( int . __mul__ , primelist [ : n ] , 1 ) NEW_LINE DEDENT
import logging , logging . handlers NEW_LINE LOG_FILENAME = " logdemo . log " NEW_LINE FORMAT_STRING = " % ( levelname ) s : % ( asctime ) s : % ( name ) s : % ( funcName ) s : line - % ( lineno ) d : ▁ % ( message ) s " NEW_LINE LOGLEVEL = logging . DEBUG NEW_LINE def print_squares ( number ) : NEW_LINE INDENT logger . info ( " In ▁ print _ squares " ) NEW_LINE for i in range ( number ) : NEW_LINE INDENT print ( " square ▁ of ▁ { 0 } ▁ is ▁ { 1 } " . format ( i , i * i ) ) NEW_LINE logger . debug ( f ' square ▁ of ▁ { i } ▁ is ▁ { i * i } ' ) NEW_LINE DEDENT DEDENT def print_cubes ( number ) : NEW_LINE INDENT logger . info ( " In ▁ print _ cubes " ) NEW_LINE for j in range ( number ) : NEW_LINE INDENT print ( " cube ▁ of ▁ { 0 } ▁ is ▁ { 1 } " . format ( j , j * j * j ) ) NEW_LINE logger . debug ( f ' cube ▁ of ▁ { j } ▁ is ▁ { j * j * j } ' ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT logger = logging . getLogger ( " logdemo " ) NEW_LINE logger . setLevel ( LOGLEVEL ) NEW_LINE handler = logging . FileHandler ( LOG_FILENAME ) NEW_LINE handler . setFormatter ( logging . Formatter ( FORMAT_STRING ) ) NEW_LINE logger . addHandler ( handler ) NEW_LINE print_squares ( 10 ) NEW_LINE print_cubes ( 10 ) NEW_LINE logger . info ( " All ▁ done " ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT program = sys . argv [ 0 ] NEW_LINE print ( " Program : ▁ % s " % program ) NEW_LINE DEDENT
import sys NEW_LINE if problem : NEW_LINE INDENT sys . exit ( 1 ) NEW_LINE DEDENT
a1 = [ 0 , 1403580 , - 810728 ] NEW_LINE m1 = 2 ** 32 - 209 NEW_LINE a2 = [ 527612 , 0 , - 1370589 ] NEW_LINE m2 = 2 ** 32 - 22853 NEW_LINE d = m1 + 1 NEW_LINE class MRG32k3a ( ) : NEW_LINE INDENT def __init__ ( self , seed_state = 123 ) : NEW_LINE INDENT self . seed ( seed_state ) NEW_LINE DEDENT def seed ( self , seed_state ) : NEW_LINE INDENT assert 0 < seed_state < d , f " Out ▁ of ▁ Range ▁ 0 ▁ x ▁ < ▁ { d } " NEW_LINE self . x1 = [ seed_state , 0 , 0 ] NEW_LINE self . x2 = [ seed_state , 0 , 0 ] NEW_LINE DEDENT def next_int ( self ) : NEW_LINE INDENT x1i = sum ( aa * xx for aa , xx in zip ( a1 , self . x1 ) ) % m1 NEW_LINE x2i = sum ( aa * xx for aa , xx in zip ( a2 , self . x2 ) ) % m2 NEW_LINE self . x1 = [ x1i ] + self . x1 [ : 2 ] NEW_LINE self . x2 = [ x2i ] + self . x2 [ : 2 ] NEW_LINE z = ( x1i - x2i ) % m1 NEW_LINE answer = ( z + 1 ) NEW_LINE return answer NEW_LINE DEDENT def next_float ( self ) : NEW_LINE INDENT return self . next_int ( ) / d NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT random_gen = MRG32k3a ( ) NEW_LINE random_gen . seed ( 1234567 ) NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT print ( random_gen . next_int ( ) ) NEW_LINE DEDENT random_gen . seed ( 987654321 ) NEW_LINE hist = { i : 0 for i in range ( 5 ) } NEW_LINE for i in range ( 100_000 ) : NEW_LINE INDENT hist [ int ( random_gen . next_float ( ) * 5 ) ] += 1 NEW_LINE DEDENT print ( hist ) NEW_LINE DEDENT
mask64 = ( 1 << 64 ) - 1 NEW_LINE mask32 = ( 1 << 32 ) - 1 NEW_LINE CONST = 6364136223846793005 NEW_LINE class PCG32 ( ) : NEW_LINE INDENT def __init__ ( self , seed_state = None , seed_sequence = None ) : NEW_LINE INDENT if all ( type ( x ) == int for x in ( seed_state , seed_sequence ) ) : NEW_LINE INDENT self . seed ( seed_state , seed_sequence ) NEW_LINE DEDENT else : NEW_LINE INDENT self . state = self . inc = 0 NEW_LINE DEDENT DEDENT def seed ( self , seed_state , seed_sequence ) : NEW_LINE INDENT self . state = 0 NEW_LINE self . inc = ( ( seed_sequence << 1 ) | 1 ) & mask64 NEW_LINE self . next_int ( ) NEW_LINE self . state = ( self . state + seed_state ) NEW_LINE self . next_int ( ) NEW_LINE DEDENT def next_int ( self ) : NEW_LINE INDENT old = self . state NEW_LINE self . state = ( ( old * CONST ) + self . inc ) & mask64 NEW_LINE xorshifted = ( ( ( old >> 18 ) ^ old ) >> 27 ) & mask32 NEW_LINE rot = ( old >> 59 ) & mask32 NEW_LINE answer = ( xorshifted >> rot ) | ( xorshifted << ( ( - rot ) & 31 ) ) NEW_LINE answer = answer & mask32 NEW_LINE return answer NEW_LINE DEDENT def next_float ( self ) : NEW_LINE INDENT return self . next_int ( ) / ( 1 << 32 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT random_gen = PCG32 ( ) NEW_LINE random_gen . seed ( 42 , 54 ) NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT print ( random_gen . next_int ( ) ) NEW_LINE DEDENT random_gen . seed ( 987654321 , 1 ) NEW_LINE hist = { i : 0 for i in range ( 5 ) } NEW_LINE for i in range ( 100_000 ) : NEW_LINE INDENT hist [ int ( random_gen . next_float ( ) * 5 ) ] += 1 NEW_LINE DEDENT print ( hist ) NEW_LINE DEDENT
mask64 = ( 1 << 64 ) - 1 NEW_LINE mask32 = ( 1 << 32 ) - 1 NEW_LINE const = 0x2545F4914F6CDD1D NEW_LINE class Xorshift_star ( ) : NEW_LINE INDENT def __init__ ( self , seed = 0 ) : NEW_LINE INDENT self . state = seed & mask64 NEW_LINE DEDENT def seed ( self , num ) : NEW_LINE INDENT self . state = num & mask64 NEW_LINE DEDENT def next_int ( self ) : NEW_LINE INDENT x = self . state NEW_LINE x = ( x ^ ( x >> 12 ) ) & mask64 NEW_LINE x = ( x ^ ( x << 25 ) ) & mask64 NEW_LINE x = ( x ^ ( x >> 27 ) ) & mask64 NEW_LINE self . state = x NEW_LINE answer = ( ( ( x * const ) & mask64 ) >> 32 ) & mask32 NEW_LINE return answer NEW_LINE DEDENT def next_float ( self ) : NEW_LINE INDENT return self . next_int ( ) / ( 1 << 32 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT random_gen = Xorshift_star ( ) NEW_LINE random_gen . seed ( 1234567 ) NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT print ( random_gen . next_int ( ) ) NEW_LINE DEDENT random_gen . seed ( 987654321 ) NEW_LINE hist = { i : 0 for i in range ( 5 ) } NEW_LINE for i in range ( 100_000 ) : NEW_LINE INDENT hist [ int ( random_gen . next_float ( ) * 5 ) ] += 1 NEW_LINE DEDENT print ( hist ) NEW_LINE DEDENT
INDENT class FIFO ( object ) : NEW_LINE INDENT def __init__ ( self , * args ) : NEW_LINE INDENT self . contents = list ( args ) NEW_LINE DEDENT def __call__ ( self ) : NEW_LINE INDENT return self . pop ( ) NEW_LINE DEDENT def __len__ ( self ) : NEW_LINE INDENT return len ( self . contents ) NEW_LINE DEDENT def pop ( self ) : NEW_LINE INDENT return self . contents . pop ( 0 ) NEW_LINE DEDENT def push ( self , item ) : NEW_LINE INDENT self . contents . append ( item ) NEW_LINE DEDENT def extend ( self , * itemlist ) : NEW_LINE INDENT self . contents += itemlist NEW_LINE DEDENT def empty ( self ) : NEW_LINE INDENT return bool ( self . contents ) NEW_LINE DEDENT def __iter__ ( self ) : NEW_LINE INDENT return self NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT if self . empty ( ) : NEW_LINE INDENT raise StopIteration NEW_LINE DEDENT return self . pop ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT f = FIFO ( ) NEW_LINE f . push ( 3 ) NEW_LINE f . push ( 2 ) NEW_LINE f . push ( 1 ) NEW_LINE while not f . empty ( ) : NEW_LINE INDENT print f . pop ( ) , NEW_LINE DEDENT f = FIFO ( 3 , 2 , 1 ) NEW_LINE while not f . empty ( ) : NEW_LINE INDENT print f ( ) , NEW_LINE DEDENT f = FIFO ( 3 , 2 , 1 ) NEW_LINE while f : NEW_LINE INDENT print f ( ) , NEW_LINE DEDENT f = FIFO ( 3 , 2 , 1 ) NEW_LINE for i in f : NEW_LINE INDENT print i , NEW_LINE DEDENT DEDENT
import Queue NEW_LINE my_queue = Queue . Queue ( ) NEW_LINE my_queue . put ( " foo " ) NEW_LINE my_queue . put ( " bar " ) NEW_LINE my_queue . put ( " baz " ) NEW_LINE print my_queue . get ( ) NEW_LINE print my_queue . get ( ) NEW_LINE print my_queue . get ( ) NEW_LINE
def partition ( vector , left , right , pivotIndex ) : NEW_LINE INDENT pivotValue = vector [ pivotIndex ] NEW_LINE vector [ pivotIndex ] , vector [ right ] = vector [ right ] , vector [ pivotIndex ] NEW_LINE storeIndex = left NEW_LINE for i in range ( left , right ) : NEW_LINE INDENT if vector [ i ] < pivotValue : NEW_LINE INDENT vector [ storeIndex ] , vector [ i ] = vector [ i ] , vector [ storeIndex ] NEW_LINE storeIndex += 1 NEW_LINE DEDENT DEDENT vector [ right ] , vector [ storeIndex ] = vector [ storeIndex ] , vector [ right ] NEW_LINE return storeIndex NEW_LINE DEDENT
def _select ( vector , left , right , k ) : NEW_LINE INDENT while True : NEW_LINE INDENT pivotIndex = random . randint ( left , right ) NEW_LINE pivotNewIndex = partition ( vector , left , right , pivotIndex ) NEW_LINE pivotDist = pivotNewIndex - left NEW_LINE if pivotDist == k : NEW_LINE INDENT return vector [ pivotNewIndex ] NEW_LINE DEDENT elif k < pivotDist : NEW_LINE INDENT right = pivotNewIndex - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= pivotDist + 1 NEW_LINE left = pivotNewIndex + 1 NEW_LINE DEDENT DEDENT DEDENT
def select ( vector , k , left = None , right = None ) : NEW_LINE INDENT if left is None : NEW_LINE INDENT left = 0 NEW_LINE DEDENT lv1 = len ( vector ) - 1 NEW_LINE if right is None : NEW_LINE INDENT right = lv1 NEW_LINE DEDENT assert vector and k >= 0 , " Either ▁ null ▁ vector ▁ or ▁ k ▁ < ▁ 0 ▁ " NEW_LINE assert 0 <= left <= lv1 , " left ▁ is ▁ out ▁ of ▁ range " NEW_LINE assert left <= right <= lv1 , " right ▁ is ▁ out ▁ of ▁ range " NEW_LINE return _select ( vector , left , right , k ) NEW_LINE DEDENT
w = " print ( ' w ▁ = ▁ ' ▁ + ▁ chr ( 34 ) ▁ + ▁ w ▁ + ▁ chr ( 34 ) ▁ + ▁ chr ( 10 ) ▁ + ▁ w ) " NEW_LINE print ( ' w ▁ = ▁ ' + chr ( 34 ) + w + chr ( 34 ) + chr ( 10 ) + w ) NEW_LINE
from mpmath import mp NEW_LINE heegner = [ 19 , 43 , 67 , 163 ] NEW_LINE mp . dps = 50 NEW_LINE x = mp . exp ( mp . pi * mp . sqrt ( 163 ) ) NEW_LINE print ( " calculated ▁ Ramanujan ' s ▁ constant : ▁ { } " . format ( x ) ) NEW_LINE print ( " Heegner ▁ numbers ▁ yielding ▁ ' almost ' ▁ integers : " ) NEW_LINE for i in heegner : NEW_LINE INDENT print ( " ▁ for ▁ { } : ▁ { } ▁ ~ ▁ { } ▁ error : ▁ { } " . format ( str ( i ) , mp . exp ( mp . pi * mp . sqrt ( i ) ) , round ( mp . exp ( mp . pi * mp . sqrt ( i ) ) ) , ( mp . pi * mp . sqrt ( i ) ) - round ( mp . pi * mp . sqrt ( i ) ) ) ) NEW_LINE DEDENT
from __future__ import print_function NEW_LINE from shapely . geometry import LineString NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT line = LineString ( [ ( 0 , 0 ) , ( 1 , 0.1 ) , ( 2 , - 0.1 ) , ( 3 , 5 ) , ( 4 , 6 ) , ( 5 , 7 ) , ( 6 , 8.1 ) , ( 7 , 9 ) , ( 8 , 9 ) , ( 9 , 9 ) ] ) NEW_LINE print ( line . simplify ( 1.0 , preserve_topology = False ) ) NEW_LINE DEDENT
import random NEW_LINE rand = random . SystemRandom ( ) NEW_LINE rand . randint ( 1 , 10 ) NEW_LINE
typedef unsigned long long u8 ; NEW_LINE typedef struct ranctx { u8 a ; u8 b ; u8 c ; u8 d ; } ranctx ; NEW_LINE u8 ranval ( ranctx * x ) { u8 e = x -> a - rot ( x -> b , 7 ) ; x -> a = x -> b ^ rot ( x -> c , 13 ) ; x -> b = x -> c + rot ( x -> d , 37 ) ; x -> c = x -> d + e ; x -> d = e + x -> a ; return x -> d ; } NEW_LINE void raninit ( ranctx * x , u8 seed ) { u8 i ; x -> a = 0xf1ea5eed , x -> b = x -> c = x -> d = seed ; for ( i = 0 ; i < 20 ; + + i ) { ( void ) ranval ( x ) ; } } NEW_LINE
def consolidate ( ranges ) : NEW_LINE INDENT norm = normalize ( ranges ) NEW_LINE for i , r1 in enumerate ( norm ) : NEW_LINE INDENT if r1 : NEW_LINE INDENT for r2 in norm [ i + 1 : ] : NEW_LINE INDENT if r2 and r1 [ - 1 ] >= r2 [ 0 ] : NEW_LINE INDENT r1 [ : ] = [ r1 [ 0 ] , max ( r1 [ - 1 ] , r2 [ - 1 ] ) ] NEW_LINE r2 . clear ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return [ rnge for rnge in norm if rnge ] NEW_LINE DEDENT

with open ( " foobar . txt " ) as f : NEW_LINE INDENT for line in f : NEW_LINE INDENT process ( line ) NEW_LINE DEDENT DEDENT
with open ( ' xxx . txt ' ) as f : NEW_LINE INDENT for i , line in enumerate ( f ) : NEW_LINE INDENT if i == 6 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' Not ▁ 7 ▁ lines ▁ in ▁ file ' ) NEW_LINE line = None NEW_LINE DEDENT DEDENT
open ( filename ) . read ( ) NEW_LINE
import readline NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT print ( input ( ' > ▁ ' ) ) NEW_LINE DEDENT except : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT
import math NEW_LINE math . e NEW_LINE math . pi NEW_LINE math . sqrt ( x ) NEW_LINE math . log ( x ) NEW_LINE math . log10 ( x ) NEW_LINE math . exp ( x ) NEW_LINE abs ( x ) NEW_LINE math . floor ( x ) NEW_LINE math . ceil ( x ) NEW_LINE x ** y NEW_LINE pow ( x , y [ , n ] ) NEW_LINE
from itertools import islice NEW_LINE class Recamans ( ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . a = None NEW_LINE self . n = None NEW_LINE DEDENT def __call__ ( self ) : NEW_LINE INDENT nxt = 0 NEW_LINE a , n = { nxt } , 0 NEW_LINE self . a = a NEW_LINE self . n = n NEW_LINE yield nxt NEW_LINE while True : NEW_LINE INDENT an1 , n = nxt , n + 1 NEW_LINE nxt = an1 - n NEW_LINE if nxt < 0 or nxt in a : NEW_LINE INDENT nxt = an1 + n NEW_LINE DEDENT a . add ( nxt ) NEW_LINE self . n = n NEW_LINE yield nxt NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT recamans = Recamans ( ) NEW_LINE print ( " First ▁ fifteen ▁ members ▁ of ▁ Recamans ▁ sequence : " , list ( islice ( recamans ( ) , 15 ) ) ) NEW_LINE so_far = set ( ) NEW_LINE for term in recamans ( ) : NEW_LINE INDENT if term in so_far : NEW_LINE INDENT print ( f " First ▁ duplicate ▁ number ▁ in ▁ series ▁ is : ▁ a ( { recamans . n } ) ▁ = ▁ { term } " ) NEW_LINE break NEW_LINE DEDENT so_far . add ( term ) NEW_LINE DEDENT n = 1_000 NEW_LINE setn = set ( range ( n + 1 ) ) NEW_LINE for _ in recamans ( ) : NEW_LINE INDENT if setn . issubset ( recamans . a ) : NEW_LINE INDENT print ( f " Range ▁ 0 ▁ . . { n } ▁ is ▁ covered ▁ by ▁ terms ▁ up ▁ to ▁ a ( { recamans . n } ) " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
import os NEW_LINE os . __file__ NEW_LINE
class Parent ( object ) : NEW_LINE INDENT __priv = ' private ' NEW_LINE def __init__ ( self , name ) : NEW_LINE INDENT self . name = name NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' % s ( % s ) ' % ( type ( self ) . __name__ , self . name ) NEW_LINE DEDENT def doNothing ( self ) : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT import re NEW_LINE class Child ( Parent ) : NEW_LINE INDENT __rePrivate = re . compile ( ' ^ _ ( Child | Parent ) _ _ ' ) NEW_LINE __reBleh = re . compile ( ' \Wbleh $ ' ) NEW_LINE @ property NEW_LINE def reBleh ( self ) : NEW_LINE INDENT return self . __reBleh NEW_LINE DEDENT def __init__ ( self , name , * args ) : NEW_LINE INDENT super ( Child , self ) . __init__ ( name ) NEW_LINE self . args = args NEW_LINE DEDENT def __dir__ ( self ) : NEW_LINE INDENT myDir = filter ( lambda p : not self . __rePrivate . match ( p ) , list ( set ( sum ( [ dir ( base ) for base in type ( self ) . __bases__ ] , [ ] ) + type ( self ) . __dict__ . keys ( ) + self . __dict__ . keys ( ) ) ) ) NEW_LINE return myDir + map ( lambda p : p + ' _ bleh ' , filter ( lambda p : ( p [ : 2 ] != ' _ _ ' or p [ - 2 : ] != ' _ _ ' ) and not callable ( getattr ( self , p ) ) , myDir ) ) NEW_LINE DEDENT def __getattr__ ( self , name ) : NEW_LINE INDENT if name [ - 5 : ] == ' _ bleh ' : NEW_LINE INDENT return str ( getattr ( self , name [ : - 5 ] ) ) + ' ▁ bleh ' NEW_LINE DEDENT if hasattr ( super ( Child , chld ) , ' _ _ getattr _ _ ' ) : NEW_LINE INDENT return super ( Child , self ) . __getattr__ ( name ) NEW_LINE DEDENT raise AttributeError ( " ' % s ' ▁ object ▁ has ▁ no ▁ attribute ▁ ' % s ' " % ( type ( self ) . __name__ , name ) ) NEW_LINE DEDENT def __setattr__ ( self , name , value ) : NEW_LINE INDENT if name [ - 5 : ] == ' _ bleh ' : NEW_LINE INDENT if not ( hasattr ( self , name [ : - 5 ] ) and callable ( getattr ( self , name [ : - 5 ] ) ) ) : NEW_LINE INDENT setattr ( self , name [ : - 5 ] , self . reBleh . sub ( ' ' , value ) ) NEW_LINE DEDENT DEDENT elif hasattr ( super ( Child , self ) , ' _ _ setattr _ _ ' ) : NEW_LINE INDENT super ( Child , self ) . __setattr__ ( name , value ) NEW_LINE DEDENT elif hasattr ( self , ' _ _ dict _ _ ' ) : NEW_LINE INDENT self . __dict__ [ name ] = value NEW_LINE DEDENT DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' % s ( % s , ▁ % s ) ' % ( type ( self ) . __name__ , self . name , str ( self . args ) . strip ( ' [ ] ( ) ' ) ) NEW_LINE DEDENT def doStuff ( self ) : NEW_LINE INDENT return ( 1 + 1.0 / 1e6 ) ** 1e6 NEW_LINE DEDENT DEDENT par = Parent ( ' par ' ) NEW_LINE par . parent = True NEW_LINE dir ( par ) NEW_LINE inspect . getmembers ( par ) NEW_LINE chld = Child ( ' chld ' , 0 , ' I ' , ' two ' ) NEW_LINE chld . own = " chld ' s ▁ own " NEW_LINE dir ( chld ) NEW_LINE inspect . getmembers ( chld ) NEW_LINE
import re NEW_LINE string = " This ▁ is ▁ a ▁ string " NEW_LINE if re . search ( ' string $ ' , string ) : NEW_LINE INDENT print ( " Ends ▁ with ▁ string . " ) NEW_LINE DEDENT string = re . sub ( " ▁ a ▁ " , " ▁ another ▁ " , string ) NEW_LINE print ( string ) NEW_LINE
items = [ 1 , 2 , 3 , ' a ' , ' b ' , ' c ' , 2 , 3 , 4 , ' b ' , ' c ' , ' d ' ] NEW_LINE unique = list ( set ( items ) ) NEW_LINE
import fileinput , sys NEW_LINE fname , start , count = sys . argv [ 1 : 4 ] NEW_LINE start , count = int ( start ) , int ( count ) NEW_LINE for line in fileinput . input ( fname , inplace = 1 , backup = ' . orig ' ) : NEW_LINE INDENT if start <= fileinput . lineno ( ) < start + count : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT print line . rstrip ( " \n " ) NEW_LINE DEDENT DEDENT fileinput . close ( ) NEW_LINE
import os NEW_LINE os . rename ( " input . txt " , " output . txt " ) NEW_LINE os . rename ( " docs " , " mydocs " ) NEW_LINE os . rename ( os . sep + " input . txt " , os . sep + " output . txt " ) NEW_LINE os . rename ( os . sep + " docs " , os . sep + " mydocs " ) NEW_LINE
" ha " * 5 NEW_LINE
def repeat ( f , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT f ( ) ; NEW_LINE DEDENT DEDENT
def set_boundary ( m ) : NEW_LINE INDENT m [ 1 ] [ 1 ] = Node ( 1.0 , Fixed . A ) NEW_LINE m [ 6 ] [ 7 ] = Node ( - 1.0 , Fixed . B ) NEW_LINE DEDENT
input ( ) [ : : - 1 ] NEW_LINE
INDENT text = ''' \ STRNEWLINE - - - - - - - - - - ▁ Ice ▁ and ▁ Fire ▁ - - - - - - - - - - - - STRNEWLINE STRNEWLINE fire , ▁ in ▁ end ▁ will ▁ world ▁ the ▁ say ▁ Some STRNEWLINE ice . ▁ in ▁ say ▁ Some STRNEWLINE desire ▁ of ▁ tasted ▁ I ' ve ▁ what ▁ From STRNEWLINE fire . ▁ favor ▁ who ▁ those ▁ with ▁ hold ▁ I STRNEWLINE STRNEWLINE . . . ▁ elided ▁ paragraph ▁ last ▁ . . . STRNEWLINE STRNEWLINE Frost ▁ Robert ▁ - - - - - - - - - - - - - - - - - - - - - - - ''' NEW_LINE DEDENT for line in text . split ( ' \n ' ) : print ( ' ▁ ' . join ( line . split ( ) [ : : - 1 ] ) ) NEW_LINE
from random import choice NEW_LINE rules = { ' rock ' : ' paper ' , ' scissors ' : ' rock ' , ' paper ' : ' scissors ' } NEW_LINE previous = [ ' rock ' , ' paper ' , ' scissors ' ] NEW_LINE while True : NEW_LINE INDENT human = input ( ' \n choose ▁ your ▁ weapon : ▁ ' ) NEW_LINE computer = rules [ choice ( previous ) ] NEW_LINE if human in ( ' quit ' , ' exit ' ) : break NEW_LINE elif human in rules : NEW_LINE INDENT previous . append ( human ) NEW_LINE print ( ' the ▁ computer ▁ played ' , computer , end = ' ; ▁ ' ) NEW_LINE if rules [ computer ] == human : NEW_LINE INDENT print ( ' yay ▁ you ▁ win ! ' ) NEW_LINE DEDENT elif rules [ human ] == computer : NEW_LINE INDENT print ( ' the ▁ computer ▁ beat ▁ you . . .   : ( ' ) NEW_LINE DEDENT else : print ( " it ' s ▁ a ▁ tie ! " ) NEW_LINE DEDENT else : print ( " that ' s ▁ not ▁ a ▁ valid ▁ choice " ) NEW_LINE DEDENT
import roman NEW_LINE print ( roman . toRoman ( 2022 ) ) NEW_LINE
f = lambda x : x * x * x - 3 * x * x + 2 * x NEW_LINE step = 0.001 NEW_LINE start = - 1 NEW_LINE stop = 3 NEW_LINE sign = f ( start ) > 0 NEW_LINE x = start NEW_LINE while x <= stop : NEW_LINE INDENT value = f ( x ) NEW_LINE if value == 0 : NEW_LINE INDENT print " Root ▁ found ▁ at " , x NEW_LINE DEDENT elif ( value > 0 ) != sign : NEW_LINE INDENT print " Root ▁ found ▁ near " , x NEW_LINE DEDENT sign = value > 0 NEW_LINE x += step NEW_LINE DEDENT
f = lambda x : x * x * x - 3 * x * x + 2 * x NEW_LINE step = 0.001 NEW_LINE start = - 1 NEW_LINE stop = 3 NEW_LINE sign = f ( start ) > 0 NEW_LINE x = start NEW_LINE while x <= stop : NEW_LINE INDENT value = f ( x ) NEW_LINE if value == 0 : NEW_LINE INDENT print " Root ▁ found ▁ at " , x NEW_LINE DEDENT elif ( value > 0 ) != sign : NEW_LINE INDENT print " Root ▁ found ▁ near " , x NEW_LINE DEDENT sign = value > 0 NEW_LINE x += step NEW_LINE DEDENT
from urllib . request import urlopen , Request NEW_LINE import xml . dom . minidom NEW_LINE r = Request ( ' https : / / www . rosettacode . org / mw / api . php ? action = query & list = categorymembers & cmtitle = Category : Programming _ Tasks & cmlimit = 500 & format = xml ' , headers = { ' User - Agent ' : ' Mozilla / 5.0' } ) NEW_LINE x = urlopen ( r ) NEW_LINE tasks = [ ] NEW_LINE for i in xml . dom . minidom . parseString ( x . read ( ) ) . getElementsByTagName ( ' cm ' ) : NEW_LINE INDENT t = i . getAttribute ( ' title ' ) . replace ( ' ▁ ' , ' _ ' ) NEW_LINE r = Request ( f ' https : / / www . rosettacode . org / mw / index . php ? title = { t } & action = raw ' , headers = { ' User - Agent ' : ' Mozilla / 5.0' } ) NEW_LINE y = urlopen ( r ) NEW_LINE tasks . append ( y . read ( ) . lower ( ) . count ( b ' { { header | ' ) ) NEW_LINE print ( t . replace ( ' _ ' , ' ▁ ' ) + f ' : ▁ { tasks [ -1 ] } ▁ examples . ' ) NEW_LINE DEDENT print ( f ' \n Total : ▁ { sum ( tasks ) } ▁ examples . ' ) NEW_LINE
import requests NEW_LINE import re NEW_LINE response = requests . get ( " http : / / rosettacode . org / wiki / Category : Programming _ Languages " ) . text NEW_LINE languages = re . findall ( ' title = " Category : ( . * ? ) " > ' , response ) [ : - 3 ] NEW_LINE response = requests . get ( " http : / / rosettacode . org / mw / index . php ? title = Special : Categories & limit = 5000" ) . text NEW_LINE response = re . sub ( ' ( \d + ) , ( \d + ) ' , r ' \1' + r ' \2' , response ) NEW_LINE members = re . findall ( ' < li > < a [ ^ > ] + > ( [ ^ < ] + ) < / a > [ ^ ( ] * [ ( ] ( \\d + ) ▁ member [ s ] * [ ) ] < / li > ' , response ) NEW_LINE for cnt , ( language , members ) in enumerate ( sorted ( members , key = lambda x : - int ( x [ 1 ] ) ) [ : 15 ] ) : NEW_LINE INDENT if language in languages : NEW_LINE INDENT print ( " { :4d } ▁ { :4d } ▁ - ▁ { } " . format ( cnt + 1 , int ( members ) , language ) ) NEW_LINE DEDENT DEDENT
import random NEW_LINE random . seed ( ) NEW_LINE attributes_total = 0 NEW_LINE count = 0 NEW_LINE while attributes_total < 75 or count < 2 : NEW_LINE INDENT attributes = [ ] NEW_LINE for attribute in range ( 0 , 6 ) : NEW_LINE INDENT rolls = [ ] NEW_LINE for roll in range ( 0 , 4 ) : NEW_LINE INDENT result = random . randint ( 1 , 6 ) NEW_LINE rolls . append ( result ) NEW_LINE DEDENT sorted_rolls = sorted ( rolls ) NEW_LINE largest_3 = sorted_rolls [ 1 : ] NEW_LINE rolls_total = sum ( largest_3 ) NEW_LINE if rolls_total >= 15 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT attributes . append ( rolls_total ) NEW_LINE DEDENT attributes_total = sum ( attributes ) NEW_LINE DEDENT print ( attributes_total , attributes ) NEW_LINE
import binascii NEW_LINE n = 9516311845790656153499716760847001433441357 NEW_LINE e = 65537 NEW_LINE d = 5617843187844953170308463622230283376298685 NEW_LINE message = ' Rosetta ▁ Code ! ' NEW_LINE print ( ' message ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ' , message ) NEW_LINE hex_data = binascii . hexlify ( message . encode ( ) ) NEW_LINE print ( ' hex ▁ data ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ' , hex_data ) NEW_LINE plain_text = int ( hex_data , 16 ) NEW_LINE print ( ' plain ▁ text ▁ integer ▁ ▁ ▁ ▁ ▁ ▁ ' , plain_text ) NEW_LINE if plain_text > n : NEW_LINE INDENT raise Exception ( ' plain ▁ text ▁ too ▁ large ▁ for ▁ key ' ) NEW_LINE DEDENT encrypted_text = pow ( plain_text , e , n ) NEW_LINE print ( ' encrypted ▁ text ▁ integer ▁ ▁ ' , encrypted_text ) NEW_LINE decrypted_text = pow ( encrypted_text , d , n ) NEW_LINE print ( ' decrypted ▁ text ▁ integer ▁ ▁ ' , decrypted_text ) NEW_LINE print ( ' message ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ' , binascii . unhexlify ( hex ( decrypted_text ) [ 2 : ] ) . decode ( ) ) NEW_LINE
def encode ( input_string ) : NEW_LINE INDENT count = 1 NEW_LINE prev = None NEW_LINE lst = [ ] NEW_LINE for character in input_string : NEW_LINE INDENT if character != prev : NEW_LINE INDENT if prev : NEW_LINE INDENT entry = ( prev , count ) NEW_LINE lst . append ( entry ) NEW_LINE DEDENT count = 1 NEW_LINE prev = character NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT try : NEW_LINE INDENT entry = ( character , count ) NEW_LINE lst . append ( entry ) NEW_LINE return ( lst , 0 ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT print ( " Exception ▁ encountered ▁ { e } " . format ( e = e ) ) NEW_LINE return ( e , 1 ) NEW_LINE DEDENT DEDENT DEDENT
def decode ( lst ) : NEW_LINE INDENT q = [ ] NEW_LINE for character , count in lst : NEW_LINE INDENT q . append ( character * count ) NEW_LINE DEDENT return ' ' . join ( q ) NEW_LINE DEDENT
primes = [ ] NEW_LINE sp = [ ] NEW_LINE usp = [ ] NEW_LINE n = 10000000 NEW_LINE if 2 < n : NEW_LINE INDENT primes . append ( 2 ) NEW_LINE DEDENT for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT for j in primes : NEW_LINE INDENT if ( j > i / 2 ) or ( j == primes [ - 1 ] ) : NEW_LINE INDENT primes . append ( i ) NEW_LINE if ( ( i - 1 ) / 2 ) in primes : NEW_LINE INDENT sp . append ( i ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT usp . append ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( i % j == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( ' First ▁ 35 ▁ safe ▁ primes ▁ are : \n ' , sp [ : 35 ] ) NEW_LINE print ( ' There ▁ are ▁ ' + str ( len ( sp [ : 1000000 ] ) ) + ' ▁ safe ▁ primes ▁ below ▁ 1,000,000' ) NEW_LINE print ( ' There ▁ are ▁ ' + str ( len ( sp ) ) + ' ▁ safe ▁ primes ▁ below ▁ 10,000,000' ) NEW_LINE print ( ' First ▁ 40 ▁ unsafe ▁ primes : \n ' , usp [ : 40 ] ) NEW_LINE print ( ' There ▁ are ▁ ' + str ( len ( usp [ : 1000000 ] ) ) + ' ▁ unsafe ▁ primes ▁ below ▁ 1,000,000' ) NEW_LINE print ( ' There ▁ are ▁ ' + str ( len ( usp ) ) + ' ▁ safe ▁ primes ▁ below ▁ 10,000,000' ) NEW_LINE
haystack = [ " Zig " , " Zag " , " Wally " , " Ronald " , " Bush " , " Krusty " , " Charlie " , " Bush " , " Bozo " ] NEW_LINE for needle in ( " Washington " , " Bush " ) : NEW_LINE INDENT try : NEW_LINE INDENT print haystack . index ( needle ) , needle NEW_LINE DEDENT except ValueError , value_error : NEW_LINE INDENT print needle , " is ▁ not ▁ in ▁ haystack " NEW_LINE DEDENT DEDENT
class Example ( object ) : NEW_LINE INDENT def foo ( self , x ) : NEW_LINE INDENT return 42 + x NEW_LINE DEDENT DEDENT name = " foo " NEW_LINE getattr ( Example ( ) , name ) ( 5 ) NEW_LINE
def is_prime ( n ) : NEW_LINE INDENT return len ( divisors ( n ) ) == 2 NEW_LINE DEDENT
def consolidate ( sets ) : NEW_LINE INDENT setlist = [ s for s in sets if s ] NEW_LINE for i , s1 in enumerate ( setlist ) : NEW_LINE INDENT if s1 : NEW_LINE INDENT for s2 in setlist [ i + 1 : ] : NEW_LINE INDENT intersection = s1 . intersection ( s2 ) NEW_LINE if intersection : NEW_LINE INDENT s2 . update ( s1 ) NEW_LINE s1 . clear ( ) NEW_LINE s1 = s2 NEW_LINE DEDENT DEDENT DEDENT DEDENT return [ s for s in setlist if s ] NEW_LINE DEDENT
class Setr ( ) : NEW_LINE INDENT def __init__ ( self , lo , hi , includelo = True , includehi = False ) : NEW_LINE INDENT self . eqn = " ( % i < % sX < % s % i ) " % ( lo , ' = ' if includelo else ' ' , ' = ' if includehi else ' ' , hi ) NEW_LINE DEDENT def __contains__ ( self , X ) : NEW_LINE INDENT return eval ( self . eqn , locals ( ) ) NEW_LINE DEDENT def __or__ ( self , b ) : NEW_LINE INDENT ans = Setr ( 0 , 0 ) NEW_LINE ans . eqn = " ( % sor % s ) " % ( self . eqn , b . eqn ) NEW_LINE return ans NEW_LINE DEDENT def __and__ ( self , b ) : NEW_LINE INDENT ans = Setr ( 0 , 0 ) NEW_LINE ans . eqn = " ( % sand % s ) " % ( self . eqn , b . eqn ) NEW_LINE return ans NEW_LINE DEDENT def __sub__ ( self , b ) : NEW_LINE INDENT ans = Setr ( 0 , 0 ) NEW_LINE ans . eqn = " ( % sand ▁ not % s ) " % ( self . eqn , b . eqn ) NEW_LINE return ans NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return " Setr % s " % self . eqn NEW_LINE DEDENT DEDENT sets = [ Setr ( 0 , 1 , 0 , 1 ) | Setr ( 0 , 2 , 1 , 0 ) , Setr ( 0 , 2 , 1 , 0 ) & Setr ( 1 , 2 , 0 , 1 ) , Setr ( 0 , 3 , 1 , 0 ) - Setr ( 0 , 1 , 0 , 0 ) , Setr ( 0 , 3 , 1 , 0 ) - Setr ( 0 , 1 , 1 , 1 ) , ] NEW_LINE settexts = ' ( 0 , ▁ 1 ] ▁ ∪ ▁ [ 0 , ▁ 2 ) ; [0 , ▁ 2 ) ▁ ∩ ▁ ( 1 , ▁ 2 ] ; [0 , ▁ 3 ) ▁ − ▁ ( 0 , ▁ 1 ) ; [0 , ▁ 3 ) ▁ − ▁ [ 0 , ▁ 1 ] ' . split ( ' ; ' ) NEW_LINE for s , t in zip ( sets , settexts ) : NEW_LINE INDENT print ( " Set ▁ % s ▁ % s . ▁ % s " % ( t , ' , ▁ ' . join ( " % scludes ▁ % i " % ( ' in ' if v in s else ' ex ' , v ) for v in range ( 3 ) ) , s . eqn ) ) NEW_LINE DEDENT
import hashlib NEW_LINE h = hashlib . sha1 ( ) NEW_LINE h . update ( bytes ( " Ars ▁ longa , ▁ vita ▁ brevis " , encoding = " ASCII " ) ) NEW_LINE h . hexdigest ( ) NEW_LINE
def main ( filename , block_size = 1024 * 1024 ) : NEW_LINE INDENT if filename : NEW_LINE INDENT fin = open ( filename , ' rb ' ) NEW_LINE DEDENT else : NEW_LINE INDENT fin = sys . stdin NEW_LINE DEDENT stack = [ ] NEW_LINE block = fin . read ( block_size ) NEW_LINE while block : NEW_LINE INDENT node = ( 0 , hashlib . sha256 ( block ) . digest ( ) ) NEW_LINE stack . append ( node ) NEW_LINE while len ( stack ) >= 2 and stack [ - 2 ] [ 0 ] == stack [ - 1 ] [ 0 ] : NEW_LINE INDENT a = stack [ - 2 ] NEW_LINE b = stack [ - 1 ] NEW_LINE l = a [ 0 ] NEW_LINE stack [ - 2 : ] = [ ( l + 1 , hashlib . sha256 ( a [ 1 ] + b [ 1 ] ) . digest ( ) ) ] NEW_LINE DEDENT block = fin . read ( block_size ) NEW_LINE DEDENT while len ( stack ) > 1 : NEW_LINE INDENT a = stack [ - 2 ] NEW_LINE b = stack [ - 1 ] NEW_LINE al = a [ 0 ] NEW_LINE bl = b [ 0 ] NEW_LINE stack [ - 2 : ] = [ ( max ( al , bl ) + 1 , hashlib . sha256 ( a [ 1 ] + b [ 1 ] ) . digest ( ) ) ] NEW_LINE DEDENT print ( stack [ 0 ] [ 1 ] . hex ( ) ) NEW_LINE DEDENT
for i in range ( 16 ) : NEW_LINE INDENT for j in range ( 32 + i , 127 + 1 , 16 ) : NEW_LINE INDENT if j == 32 : NEW_LINE INDENT k = ' Spc ' NEW_LINE DEDENT elif j == 127 : NEW_LINE INDENT k = ' Del ' NEW_LINE DEDENT else : NEW_LINE INDENT k = chr ( j ) NEW_LINE DEDENT print ( " % 3d  : ▁ % -3s " % ( j , k ) , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT t = Turtle ( ) NEW_LINE t . hideturtle ( ) NEW_LINE t . penup ( ) NEW_LINE screen = t . getscreen ( ) NEW_LINE y = screen . window_height ( ) NEW_LINE t . goto ( 0 , y / 2 - 20 ) NEW_LINE i = 5 NEW_LINE size = 300 NEW_LINE size *= part_ratio NEW_LINE sierpinski ( i , t , size ) NEW_LINE DEDENT
def sierpinski ( n ) : NEW_LINE INDENT d = [ " * " ] NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT sp = " ▁ " * ( 2 ** i ) NEW_LINE d = [ sp + x + sp for x in d ] + [ x + " ▁ " + x for x in d ] NEW_LINE DEDENT return d NEW_LINE DEDENT print " \n " . join ( sierpinski ( 4 ) ) NEW_LINE
def main ( ) : NEW_LINE INDENT window = tk . Tk ( ) NEW_LINE window . geometry ( "200x50 + 100 + 100" ) NEW_LINE label = tk . Label ( master = window , text = " There ▁ have ▁ been ▁ no ▁ clicks ▁ yet " ) NEW_LINE label . pack ( ) NEW_LINE counter = tk . IntVar ( ) NEW_LINE update_counter = partial ( on_click , label = label , counter = counter ) NEW_LINE button = tk . Button ( master = window , text = " click ▁ me " , command = update_counter ) NEW_LINE button . pack ( ) NEW_LINE window . mainloop ( ) NEW_LINE DEDENT
import autopy NEW_LINE autopy . key . type_string ( " Hello , ▁ world ! " ) NEW_LINE autopy . key . type_string ( " Hello , ▁ world ! " , wpm = 60 ) NEW_LINE autopy . key . tap ( autopy . key . Code . RETURN ) NEW_LINE autopy . key . tap ( autopy . key . Code . F1 ) NEW_LINE autopy . key . tap ( autopy . key . Code . LEFT_ARROW ) NEW_LINE
class LinkedList ( object ) : NEW_LINE INDENT INDENT class Node ( object ) : NEW_LINE INDENT def __init__ ( self , item ) : NEW_LINE INDENT self . value = item NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def __init__ ( self , item = None ) : NEW_LINE INDENT if item is not None : NEW_LINE INDENT self . head = Node ( item ) ; self . tail = self . head NEW_LINE DEDENT else : NEW_LINE INDENT self . head = None ; self . tail = None NEW_LINE DEDENT DEDENT def append ( self , item ) : NEW_LINE INDENT if not self . head : NEW_LINE INDENT self . head = Node ( item ) NEW_LINE self . tail = self . head NEW_LINE DEDENT elif self . tail : NEW_LINE INDENT self . tail . next = Node ( item ) NEW_LINE self . tail = self . tail . next NEW_LINE DEDENT else : NEW_LINE INDENT self . tail = Node ( item ) NEW_LINE DEDENT DEDENT def __iter__ ( self ) : NEW_LINE INDENT cursor = self . head NEW_LINE while cursor : NEW_LINE INDENT yield cursor . value NEW_LINE cursor = cursor . next NEW_LINE DEDENT DEDENT DEDENT DEDENT
for node in lst : NEW_LINE INDENT print node . value NEW_LINE DEDENT
import time NEW_LINE seconds = float ( raw_input ( ) ) NEW_LINE print " Sleeping . . . " NEW_LINE time . sleep ( seconds ) NEW_LINE print " Awake ! " NEW_LINE
def is_prime ( n ) : NEW_LINE INDENT return len ( divisors ( n ) ) == 2 NEW_LINE DEDENT
def sum_digits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while n > 0 : NEW_LINE INDENT m = n % 10 NEW_LINE sum += m NEW_LINE n -= m NEW_LINE n //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
import random NEW_LINE import sys NEW_LINE snl = { 4 : 14 , 9 : 31 , 17 : 7 , 20 : 38 , 28 : 84 , 40 : 59 , 51 : 67 , 54 : 34 , 62 : 19 , 63 : 81 , 64 : 60 , 71 : 91 , 87 : 24 , 93 : 73 , 95 : 75 , 99 : 78 } NEW_LINE sixesRollAgain = True NEW_LINE def turn ( player , square ) : NEW_LINE INDENT while True : NEW_LINE INDENT roll = random . randint ( 1 , 6 ) NEW_LINE sys . stdout . write ( " Player ▁ { 0 } ▁ on ▁ square ▁ { 1 } , ▁ rolls ▁ a ▁ { 2 } " . format ( player , square , roll ) ) NEW_LINE if square + roll > 100 : NEW_LINE INDENT print " ▁ but ▁ cannot ▁ move . " NEW_LINE DEDENT else : NEW_LINE INDENT square += roll NEW_LINE print " ▁ and ▁ moves ▁ to ▁ square ▁ { 0 } " . format ( square ) NEW_LINE if square == 100 : NEW_LINE INDENT return 100 NEW_LINE DEDENT next = snl . get ( square , square ) NEW_LINE if square < next : NEW_LINE INDENT print " Yay ! ▁ landed ▁ on ▁ a ▁ ladder . ▁ Climb ▁ up ▁ to ▁ { 0 } . " . format ( next ) NEW_LINE if square == 100 : NEW_LINE INDENT return 100 NEW_LINE DEDENT square = next NEW_LINE DEDENT elif square > next : NEW_LINE INDENT print " Oops ! ▁ Landed ▁ on ▁ a ▁ snake . ▁ Slither ▁ down ▁ to ▁ { 0 } . " . format ( next ) NEW_LINE square = next NEW_LINE DEDENT DEDENT if roll < 6 or not sixesRollAgain : NEW_LINE INDENT return square NEW_LINE DEDENT print " Rolled ▁ a ▁ 6 ▁ so ▁ roll ▁ again . " NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT players = [ 1 , 1 , 1 ] NEW_LINE while True : NEW_LINE INDENT for i in range ( 0 , 3 ) : NEW_LINE INDENT ns = turn ( i + 1 , players [ i ] ) NEW_LINE if ns == 100 : NEW_LINE INDENT print " Player ▁ { 0 } ▁ wins ! " . format ( i + 1 ) NEW_LINE return NEW_LINE DEDENT players [ i ] = ns ; NEW_LINE print NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE
from __future__ import annotations NEW_LINE import itertools NEW_LINE import random NEW_LINE from enum import Enum NEW_LINE from typing import Any NEW_LINE from typing import Tuple NEW_LINE import pygame as pg NEW_LINE from pygame import Color NEW_LINE from pygame import Rect NEW_LINE from pygame . surface import Surface NEW_LINE from pygame . sprite import AbstractGroup NEW_LINE from pygame . sprite import Group NEW_LINE from pygame . sprite import RenderUpdates NEW_LINE from pygame . sprite import Sprite NEW_LINE class Direction ( Enum ) : NEW_LINE INDENT UP = ( 0 , - 1 ) NEW_LINE DOWN = ( 0 , 1 ) NEW_LINE LEFT = ( - 1 , 0 ) NEW_LINE RIGHT = ( 1 , 0 ) NEW_LINE def opposite ( self , other : Direction ) : NEW_LINE INDENT return ( self [ 0 ] + other [ 0 ] , self [ 1 ] + other [ 1 ] ) == ( 0 , 0 ) NEW_LINE DEDENT def __getitem__ ( self , i : int ) : NEW_LINE INDENT return self . value [ i ] NEW_LINE DEDENT DEDENT class SnakeHead ( Sprite ) : NEW_LINE INDENT def __init__ ( self , size : int , position : Tuple [ int , int ] , facing : Direction , bounds : Rect , ) -> None : NEW_LINE INDENT super ( ) . __init__ ( ) NEW_LINE self . image = Surface ( ( size , size ) ) NEW_LINE self . image . fill ( Color ( " aquamarine4" ) ) NEW_LINE self . rect = self . image . get_rect ( ) NEW_LINE self . rect . center = position NEW_LINE self . facing = facing NEW_LINE self . size = size NEW_LINE self . speed = size NEW_LINE self . bounds = bounds NEW_LINE DEDENT def update ( self , * args : Any , ** kwargs : Any ) -> None : NEW_LINE INDENT self . rect . move_ip ( ( self . facing [ 0 ] * self . speed , self . facing [ 1 ] * self . speed , ) ) NEW_LINE if self . rect . right > self . bounds . right : NEW_LINE INDENT self . rect . left = 0 NEW_LINE DEDENT elif self . rect . left < 0 : NEW_LINE INDENT self . rect . right = self . bounds . right NEW_LINE DEDENT if self . rect . bottom > self . bounds . bottom : NEW_LINE INDENT self . rect . top = 0 NEW_LINE DEDENT elif self . rect . top < 0 : NEW_LINE INDENT self . rect . bottom = self . bounds . bottom NEW_LINE DEDENT DEDENT def change_direction ( self , direction : Direction ) : NEW_LINE INDENT if not self . facing == direction and not direction . opposite ( self . facing ) : NEW_LINE INDENT self . facing = direction NEW_LINE DEDENT DEDENT DEDENT class SnakeBody ( Sprite ) : NEW_LINE INDENT def __init__ ( self , size : int , position : Tuple [ int , int ] , colour : str = " white " , ) -> None : NEW_LINE INDENT super ( ) . __init__ ( ) NEW_LINE self . image = Surface ( ( size , size ) ) NEW_LINE self . image . fill ( Color ( colour ) ) NEW_LINE self . rect = self . image . get_rect ( ) NEW_LINE self . rect . center = position NEW_LINE DEDENT DEDENT class Snake ( RenderUpdates ) : NEW_LINE INDENT def __init__ ( self , game : Game ) -> None : NEW_LINE INDENT self . segment_size = game . segment_size NEW_LINE self . colours = itertools . cycle ( [ " aquamarine1" , " aquamarine3" ] ) NEW_LINE self . head = SnakeHead ( size = self . segment_size , position = game . rect . center , facing = Direction . RIGHT , bounds = game . rect , ) NEW_LINE neck = [ SnakeBody ( size = self . segment_size , position = game . rect . center , colour = next ( self . colours ) , ) for _ in range ( 2 ) ] NEW_LINE super ( ) . __init__ ( * [ self . head , * neck ] ) NEW_LINE self . body = Group ( ) NEW_LINE self . tail = neck [ - 1 ] NEW_LINE DEDENT def update ( self , * args : Any , ** kwargs : Any ) -> None : NEW_LINE INDENT self . head . update ( ) NEW_LINE segments = self . sprites ( ) NEW_LINE for i in range ( len ( segments ) - 1 , 0 , - 1 ) : NEW_LINE INDENT segments [ i ] . rect . center = segments [ i - 1 ] . rect . center NEW_LINE DEDENT DEDENT def change_direction ( self , direction : Direction ) : NEW_LINE INDENT self . head . change_direction ( direction ) NEW_LINE DEDENT def grow ( self ) : NEW_LINE INDENT tail = SnakeBody ( size = self . segment_size , position = self . tail . rect . center , colour = next ( self . colours ) , ) NEW_LINE self . tail = tail NEW_LINE self . add ( self . tail ) NEW_LINE self . body . add ( self . tail ) NEW_LINE DEDENT DEDENT class SnakeFood ( Sprite ) : NEW_LINE INDENT def __init__ ( self , game : Game , size : int , * groups : AbstractGroup ) -> None : NEW_LINE INDENT super ( ) . __init__ ( * groups ) NEW_LINE self . image = Surface ( ( size , size ) ) NEW_LINE self . image . fill ( Color ( " red " ) ) NEW_LINE self . rect = self . image . get_rect ( ) NEW_LINE self . rect . topleft = ( random . randint ( 0 , game . rect . width ) , random . randint ( 0 , game . rect . height ) , ) NEW_LINE self . rect . clamp_ip ( game . rect ) NEW_LINE while pg . sprite . spritecollideany ( self , game . snake ) : NEW_LINE INDENT self . rect . topleft = ( random . randint ( 0 , game . rect . width ) , random . randint ( 0 , game . rect . height ) , ) NEW_LINE self . rect . clamp_ip ( game . rect ) NEW_LINE DEDENT DEDENT DEDENT class Game : NEW_LINE INDENT def __init__ ( self ) -> None : NEW_LINE INDENT self . rect = Rect ( 0 , 0 , 640 , 480 ) NEW_LINE self . background = Surface ( self . rect . size ) NEW_LINE self . background . fill ( Color ( " black " ) ) NEW_LINE self . score = 0 NEW_LINE self . framerate = 16 NEW_LINE self . segment_size = 10 NEW_LINE self . snake = Snake ( self ) NEW_LINE self . food_group = RenderUpdates ( SnakeFood ( game = self , size = self . segment_size ) ) NEW_LINE pg . init ( ) NEW_LINE DEDENT def _init_display ( self ) -> Surface : NEW_LINE INDENT bestdepth = pg . display . mode_ok ( self . rect . size , 0 , 32 ) NEW_LINE screen = pg . display . set_mode ( self . rect . size , 0 , bestdepth ) NEW_LINE pg . display . set_caption ( " Snake " ) NEW_LINE pg . mouse . set_visible ( False ) NEW_LINE screen . blit ( self . background , ( 0 , 0 ) ) NEW_LINE pg . display . flip ( ) NEW_LINE return screen NEW_LINE DEDENT def draw ( self , screen : Surface ) : NEW_LINE INDENT dirty = self . snake . draw ( screen ) NEW_LINE pg . display . update ( dirty ) NEW_LINE dirty = self . food_group . draw ( screen ) NEW_LINE pg . display . update ( dirty ) NEW_LINE DEDENT def update ( self , screen ) : NEW_LINE INDENT self . food_group . clear ( screen , self . background ) NEW_LINE self . food_group . update ( ) NEW_LINE self . snake . clear ( screen , self . background ) NEW_LINE self . snake . update ( ) NEW_LINE DEDENT def main ( self ) -> int : NEW_LINE INDENT screen = self . _init_display ( ) NEW_LINE clock = pg . time . Clock ( ) NEW_LINE while self . snake . head . alive ( ) : NEW_LINE INDENT for event in pg . event . get ( ) : NEW_LINE INDENT if event . type == pg . QUIT or ( event . type == pg . KEYDOWN and event . key in ( pg . K_ESCAPE , pg . K_q ) ) : NEW_LINE INDENT return self . score NEW_LINE DEDENT DEDENT keystate = pg . key . get_pressed ( ) NEW_LINE if keystate [ pg . K_RIGHT ] : NEW_LINE INDENT self . snake . change_direction ( Direction . RIGHT ) NEW_LINE DEDENT elif keystate [ pg . K_LEFT ] : NEW_LINE INDENT self . snake . change_direction ( Direction . LEFT ) NEW_LINE DEDENT elif keystate [ pg . K_UP ] : NEW_LINE INDENT self . snake . change_direction ( Direction . UP ) NEW_LINE DEDENT elif keystate [ pg . K_DOWN ] : NEW_LINE INDENT self . snake . change_direction ( Direction . DOWN ) NEW_LINE DEDENT self . update ( screen ) NEW_LINE for food in pg . sprite . spritecollide ( self . snake . head , self . food_group , dokill = False ) : NEW_LINE INDENT food . kill ( ) NEW_LINE self . snake . grow ( ) NEW_LINE self . score += 1 NEW_LINE if self . score % 5 == 0 : NEW_LINE INDENT self . framerate += 1 NEW_LINE DEDENT self . food_group . add ( SnakeFood ( self , self . segment_size ) ) NEW_LINE DEDENT if pg . sprite . spritecollideany ( self . snake . head , self . snake . body ) : NEW_LINE INDENT self . snake . head . kill ( ) NEW_LINE DEDENT self . draw ( screen ) NEW_LINE clock . tick ( self . framerate ) NEW_LINE DEDENT return self . score NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT game = Game ( ) NEW_LINE score = game . main ( ) NEW_LINE print ( score ) NEW_LINE DEDENT
import socket NEW_LINE sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) NEW_LINE sock . connect ( ( " localhost " , 256 ) ) NEW_LINE sock . sendall ( " hello ▁ socket ▁ world " ) NEW_LINE sock . close ( ) NEW_LINE
def solve ( pz , sz , sx , sy , idx , cnt ) : NEW_LINE INDENT if idx > cnt : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( len ( moves ) ) : NEW_LINE INDENT x = sx + moves [ i ] [ 0 ] NEW_LINE y = sy + moves [ i ] [ 1 ] NEW_LINE if sz > x > - 1 and sz > y > - 1 and pz [ x ] [ y ] == 0 : NEW_LINE INDENT pz [ x ] [ y ] = idx NEW_LINE if 1 == solve ( pz , sz , x , y , idx + 1 , cnt ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT pz [ x ] [ y ] = 0 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def solve ( pz , w , h ) : NEW_LINE INDENT global cnt , pWid , pHei NEW_LINE pa = [ [ - 1 for j in range ( h ) ] for i in range ( w ) ] NEW_LINE f = 0 NEW_LINE pWid = w NEW_LINE pHei = h NEW_LINE for j in range ( h ) : NEW_LINE INDENT for i in range ( w ) : NEW_LINE INDENT if pz [ f ] == "1" : NEW_LINE INDENT pa [ i ] [ j ] = 0 NEW_LINE cnt += 1 NEW_LINE DEDENT f += 1 NEW_LINE DEDENT DEDENT for y in range ( h ) : NEW_LINE INDENT for x in range ( w ) : NEW_LINE INDENT if pa [ x ] [ y ] == 0 : NEW_LINE INDENT pa [ x ] [ y ] = 1 NEW_LINE if 1 == iterate ( pa , x , y , 2 ) : NEW_LINE INDENT return 1 , pa NEW_LINE DEDENT pa [ x ] [ y ] = 0 NEW_LINE DEDENT DEDENT DEDENT return 0 , pa NEW_LINE DEDENT
def solve ( pz , w , h ) : NEW_LINE INDENT global lastNumber , wid , hei , exists NEW_LINE lastNumber = w * h NEW_LINE wid = w NEW_LINE hei = h NEW_LINE exists = [ 0 for j in range ( lastNumber + 1 ) ] NEW_LINE pa = [ [ 0 for j in range ( h ) ] for i in range ( w ) ] NEW_LINE st = pz . split ( ) NEW_LINE idx = 0 NEW_LINE for j in range ( h ) : NEW_LINE INDENT for i in range ( w ) : NEW_LINE INDENT if st [ idx ] == " . " : NEW_LINE INDENT idx += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pa [ i ] [ j ] = int ( st [ idx ] ) NEW_LINE exists [ pa [ i ] [ j ] ] = 1 NEW_LINE idx += 1 NEW_LINE DEDENT DEDENT DEDENT x = 0 NEW_LINE y = 0 NEW_LINE t = w * h + 1 NEW_LINE for j in range ( h ) : NEW_LINE INDENT for i in range ( w ) : NEW_LINE INDENT if pa [ i ] [ j ] != 0 and pa [ i ] [ j ] < t : NEW_LINE INDENT t = pa [ i ] [ j ] NEW_LINE x = i NEW_LINE y = j NEW_LINE DEDENT DEDENT DEDENT return find_solution ( pa , x , y , t + 1 ) , pa NEW_LINE DEDENT
data = [ '1.3.6.1.4.1.11.2.17.19.3.4.0.10' , '1.3.6.1.4.1.11.2.17.5.2.0.79' , '1.3.6.1.4.1.11.2.17.19.3.4.0.4' , '1.3.6.1.4.1.11150.3.4.0.1' , '1.3.6.1.4.1.11.2.17.19.3.4.0.1' , ] for s in sorted ( data , key = lambda x : list ( map ( int , x . split ( ' . ' ) ) ) ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT
people = [ ( ' joe ' , 120 ) , ( ' foo ' , 31 ) , ( ' bar ' , 51 ) ] NEW_LINE sorted ( people ) NEW_LINE
nums = [ 2 , 4 , 3 , 1 , 2 ] NEW_LINE nums . sort ( ) NEW_LINE
n = 13 NEW_LINE print ( sorted ( range ( 1 , n + 1 ) , key = str ) ) NEW_LINE
x < - sample ( c ( 0 , 1 ) , 26 , replace = T ) NEW_LINE x NEW_LINE names ( x ) < - letters NEW_LINE x NEW_LINE sort ( x , method = " quick " ) NEW_LINE sort ( x , method = " shell " ) NEW_LINE
a = raw_input ( " Enter ▁ values ▁ one ▁ by ▁ one ▁ . . \n 1 . " ) . strip ( ) NEW_LINE b = raw_input ( "2 . " ) . strip ( ) NEW_LINE c = raw_input ( "3 . " ) . strip ( ) NEW_LINE if a > b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT if a > c : NEW_LINE INDENT a , c = c , a NEW_LINE DEDENT if b > c : NEW_LINE INDENT b , c = c , b NEW_LINE DEDENT print ( str ( a ) + " ▁ " + str ( b ) + " ▁ " + str ( c ) ) NEW_LINE
def circle_sort ( L : list ) -> ' sort ▁ A ▁ in ▁ place , ▁ returning ▁ the ▁ number ▁ of ▁ swaps ' : NEW_LINE INDENT swaps = 0 NEW_LINE s = 1 NEW_LINE while s : NEW_LINE INDENT s = circle_sort_backend ( L , 0 , len ( L ) ) NEW_LINE swaps += s NEW_LINE DEDENT return swaps NEW_LINE DEDENT
def insertion_sort ( L ) : NEW_LINE INDENT for i in xrange ( 1 , len ( L ) ) : NEW_LINE INDENT j = i - 1 NEW_LINE key = L [ i ] NEW_LINE while j >= 0 and L [ j ] > key : NEW_LINE INDENT L [ j + 1 ] = L [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT L [ j + 1 ] = key NEW_LINE DEDENT DEDENT
def merge_sort ( m ) : NEW_LINE INDENT if len ( m ) <= 1 : NEW_LINE INDENT return m NEW_LINE DEDENT middle = len ( m ) // 2 NEW_LINE left = m [ : middle ] NEW_LINE right = m [ middle : ] NEW_LINE left = merge_sort ( left ) NEW_LINE right = merge_sort ( right ) NEW_LINE return list ( merge ( left , right ) ) NEW_LINE DEDENT
from functools import total_ordering NEW_LINE from bisect import bisect_left NEW_LINE from heapq import merge NEW_LINE @ total_ordering NEW_LINE class Pile ( list ) : NEW_LINE INDENT def __lt__ ( self , other ) : return self [ - 1 ] < other [ - 1 ] NEW_LINE def __eq__ ( self , other ) : return self [ - 1 ] == other [ - 1 ] NEW_LINE DEDENT def patience_sort ( n ) : NEW_LINE INDENT piles = [ ] NEW_LINE for x in n : NEW_LINE INDENT new_pile = Pile ( [ x ] ) NEW_LINE i = bisect_left ( piles , new_pile ) NEW_LINE if i != len ( piles ) : NEW_LINE INDENT piles [ i ] . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT piles . append ( new_pile ) NEW_LINE DEDENT DEDENT n [ : ] = merge ( * [ reversed ( pile ) for pile in piles ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 4 , 65 , 2 , - 31 , 0 , 99 , 83 , 782 , 1 ] NEW_LINE patience_sort ( a ) NEW_LINE print a NEW_LINE DEDENT
from itertools import permutations NEW_LINE in_order = lambda s : all ( x <= s [ i + 1 ] for i , x in enumerate ( s [ : - 1 ] ) ) NEW_LINE perm_sort = lambda s : ( p for p in permutations ( s ) if in_order ( p ) ) . next ( ) NEW_LINE
def strand_sort ( a ) : NEW_LINE INDENT out = strand ( a ) NEW_LINE while len ( a ) : NEW_LINE INDENT out = merge_list ( out , strand ( a ) ) NEW_LINE DEDENT return out NEW_LINE DEDENT
names = sorted ( ( set ( globals ( ) . keys ( ) ) | set ( __builtins__ . __dict__ . keys ( ) ) ) - set ( ' _ ▁ names ▁ i ' . split ( ) ) ) NEW_LINE print ( ' \n ' . join ( ' ▁ ' . join ( names [ i : i + 8 ] ) for i in range ( 0 , len ( names ) , 8 ) ) ) NEW_LINE
from time import sleep NEW_LINE while True : NEW_LINE INDENT for rod in r ' \ | / - ' : NEW_LINE INDENT print ( rod , end = ' ' ) NEW_LINE sleep ( 0.25 ) NEW_LINE DEDENT DEDENT
def spiral ( n ) : NEW_LINE INDENT dx , dy = 1 , 0 NEW_LINE x , y = 0 , 0 NEW_LINE myarray = [ [ None ] * n for j in range ( n ) ] NEW_LINE for i in xrange ( n ** 2 ) : NEW_LINE INDENT myarray [ x ] [ y ] = i NEW_LINE nx , ny = x + dx , y + dy NEW_LINE if 0 <= nx < n and 0 <= ny < n and myarray [ nx ] [ ny ] == None : NEW_LINE INDENT x , y = nx , ny NEW_LINE DEDENT else : NEW_LINE INDENT dx , dy = - dy , dx NEW_LINE x , y = x + dx , y + dy NEW_LINE DEDENT DEDENT return myarray NEW_LINE DEDENT def printspiral ( myarray ) : NEW_LINE INDENT n = range ( len ( myarray ) ) NEW_LINE for y in n : NEW_LINE INDENT for x in n : NEW_LINE INDENT print " % 2i " % myarray [ x ] [ y ] , NEW_LINE DEDENT print NEW_LINE DEDENT DEDENT printspiral ( spiral ( 5 ) ) NEW_LINE
def main ( ) : NEW_LINE INDENT print ( unlines ( squareListing ( nonCubeSquares ( 30 ) ) ) ) NEW_LINE DEDENT
import traceback NEW_LINE def f ( ) : return g ( ) NEW_LINE def g ( ) : traceback . print_stack ( ) NEW_LINE f ( ) NEW_LINE
from collections import deque NEW_LINE stack = deque ( ) NEW_LINE stack . append ( value ) NEW_LINE value = stack . pop ( ) NEW_LINE not stack NEW_LINE
from collections import defaultdict NEW_LINE states = [ " Alabama " , " Alaska " , " Arizona " , " Arkansas " , " California " , " Colorado " , " Connecticut " , " Delaware " , " Florida " , " Georgia " , " Hawaii " , " Idaho " , " Illinois " , " Indiana " , " Iowa " , " Kansas " , " Kentucky " , " Louisiana " , " Maine " , " Maryland " , " Massachusetts " , " Michigan " , " Minnesota " , " Mississippi " , " Missouri " , " Montana " , " Nebraska " , " Nevada " , " New ▁ Hampshire " , " New ▁ Jersey " , " New ▁ Mexico " , " New ▁ York " , " North ▁ Carolina " , " North ▁ Dakota " , " Ohio " , " Oklahoma " , " Oregon " , " Pennsylvania " , " Rhode ▁ Island " , " South ▁ Carolina " , " South ▁ Dakota " , " Tennessee " , " Texas " , " Utah " , " Vermont " , " Virginia " , " Washington " , " West ▁ Virginia " , " Wisconsin " , " Wyoming " , ] NEW_LINE states = sorted ( set ( states ) ) NEW_LINE smap = defaultdict ( list ) NEW_LINE for i , s1 in enumerate ( states [ : - 1 ] ) : NEW_LINE INDENT for s2 in states [ i + 1 : ] : NEW_LINE INDENT smap [ " " . join ( sorted ( s1 + s2 ) ) ] . append ( s1 + " ▁ + ▁ " + s2 ) NEW_LINE DEDENT DEDENT for pairs in sorted ( smap . itervalues ( ) ) : NEW_LINE INDENT if len ( pairs ) > 1 : NEW_LINE INDENT print " ▁ = ▁ " . join ( pairs ) NEW_LINE DEDENT DEDENT
from __future__ import division NEW_LINE import matplotlib . pyplot as plt NEW_LINE import random NEW_LINE mean , stddev , size = 50 , 4 , 100000 NEW_LINE data = [ random . gauss ( mean , stddev ) for c in range ( size ) ] NEW_LINE mn = sum ( data ) / size NEW_LINE sd = ( sum ( x * x for x in data ) / size - ( sum ( data ) / size ) ** 2 ) ** 0.5 NEW_LINE print ( " Sample ▁ mean ▁ = ▁ % g ; ▁ Stddev ▁ = ▁ % g ; ▁ max ▁ = ▁ % g ; ▁ min ▁ = ▁ % g ▁ for ▁ % i ▁ values " % ( mn , sd , max ( data ) , min ( data ) , size ) ) NEW_LINE plt . hist ( data , bins = 50 ) NEW_LINE
def sterling1 ( n , k ) : NEW_LINE INDENT key = str ( n ) + " , " + str ( k ) NEW_LINE if key in computed . keys ( ) : NEW_LINE INDENT return computed [ key ] NEW_LINE DEDENT if n == k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n > 0 and k == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if k > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = sterling1 ( n - 1 , k - 1 ) + ( n - 1 ) * sterling1 ( n - 1 , k ) NEW_LINE computed [ key ] = result NEW_LINE return result NEW_LINE DEDENT
def sterling2 ( n , k ) : NEW_LINE INDENT key = str ( n ) + " , " + str ( k ) NEW_LINE if key in computed . keys ( ) : NEW_LINE INDENT return computed [ key ] NEW_LINE DEDENT if n == k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n > 0 and k == 0 ) or ( n == 0 and k > 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == k : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = k * sterling2 ( n - 1 , k ) + sterling2 ( n - 1 , k - 1 ) NEW_LINE computed [ key ] = result NEW_LINE return result NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT xs = [ n for n in range ( 100 , 1 + 500 ) if isStrange ( n ) ] NEW_LINE print ( ' \n Strange ▁ numbers ▁ in ▁ range ▁ [ 100 . . 500 ] \n ' ) NEW_LINE print ( ' ( Total : ▁ ' + str ( len ( xs ) ) + ' ) \n ' ) NEW_LINE print ( ' \n ' . join ( ' ▁ ' . join ( str ( x ) for x in row ) for row in chunksOf ( 10 ) ( xs ) ) ) NEW_LINE DEDENT
def digits ( n ) : NEW_LINE INDENT return [ int ( c ) for c in str ( n ) ] NEW_LINE DEDENT
str = "12345678" ; NEW_LINE str += "9 ! " ; NEW_LINE print ( str ) NEW_LINE
s = " alphaBETA " NEW_LINE print s . upper ( ) NEW_LINE print s . lower ( ) NEW_LINE print s . swapcase ( ) NEW_LINE print " fOo ▁ bAR " . capitalize ( ) NEW_LINE print " fOo ▁ bAR " . title ( ) NEW_LINE import string NEW_LINE print string . capwords ( " fOo ▁ bAR " ) NEW_LINE
def compare ( a , b ) : NEW_LINE INDENT print ( " \n % r ▁ is ▁ of ▁ type ▁ % r ▁ and ▁ % r ▁ is ▁ of ▁ type ▁ % r " % ( a , type ( a ) , b , type ( b ) ) ) NEW_LINE if a < b : print ( ' % r ▁ is ▁ strictly ▁ less ▁ than ▁ ▁ % r ' % ( a , b ) ) NEW_LINE if a <= b : print ( ' % r ▁ is ▁ less ▁ than ▁ or ▁ equal ▁ to ▁ % r ' % ( a , b ) ) NEW_LINE if a > b : print ( ' % r ▁ is ▁ strictly ▁ greater ▁ than ▁ ▁ % r ' % ( a , b ) ) NEW_LINE if a >= b : print ( ' % r ▁ is ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ % r ' % ( a , b ) ) NEW_LINE if a == b : print ( ' % r ▁ is ▁ equal ▁ to ▁ % r ' % ( a , b ) ) NEW_LINE if a != b : print ( ' % r ▁ is ▁ not ▁ equal ▁ to ▁ % r ' % ( a , b ) ) NEW_LINE if a is b : print ( ' % r ▁ has ▁ object ▁ identity ▁ with ▁ % r ' % ( a , b ) ) NEW_LINE if a is not b : print ( ' % r ▁ has ▁ negated ▁ object ▁ identity ▁ with ▁ % r ' % ( a , b ) ) NEW_LINE DEDENT
s1 = " hello " NEW_LINE print s1 + " ▁ world " NEW_LINE s2 = s1 + " ▁ world " NEW_LINE print s2 NEW_LINE
print len ( ' ascii ' ) NEW_LINE
" abcd " . startswith ( " ab " ) NEW_LINE " abcd " . endswith ( " zn " ) NEW_LINE " bb " in " abab " NEW_LINE " ab " in " abab " NEW_LINE loc = " abab " . find ( " bb " ) NEW_LINE loc = " abab " . find ( " ab " ) NEW_LINE loc = " abab " . find ( " ab " , loc + 1 ) NEW_LINE
s = "12345678" NEW_LINE s = "0" + s NEW_LINE print ( s ) NEW_LINE
stripped = lambda s : " " . join ( i for i in s if 31 < ord ( i ) < 127 ) NEW_LINE print ( stripped ( " \ba\x00b \n c\fd\xc3" ) ) NEW_LINE
words = { " alliance " : - 624 , " archbishop " : - 925 , " balm " : 397 , " bonnet " : 452 , " brute " : 870 , " centipede " : - 658 , " cobol " : 362 , " covariate " : 590 , " departure " : 952 , " deploy " : 44 , " diophantine " : 645 , " efferent " : 54 , " elysee " : - 326 , " eradicate " : 376 , " escritoire " : 856 , " exorcism " : - 983 , " fiat " : 170 , " filmy " : - 874 , " flatworm " : 503 , " gestapo " : 915 , " infra " : - 847 , " isis " : - 982 , " lindholm " : 999 , " markham " : 475 , " mincemeat " : - 880 , " moresby " : 756 , " mycenae " : 183 , " plugging " : - 266 , " smokescreen " : 423 , " speakeasy " : - 745 , " vein " : 813 } NEW_LINE neg = 0 NEW_LINE pos = 0 NEW_LINE for ( w , v ) in words . iteritems ( ) : NEW_LINE INDENT if v > 0 : pos += v NEW_LINE else : neg += v NEW_LINE DEDENT sums = [ 0 ] * ( pos - neg + 1 ) NEW_LINE for ( w , v ) in words . iteritems ( ) : NEW_LINE INDENT s = sums [ : ] NEW_LINE if not s [ v - neg ] : s [ v - neg ] = ( w , ) NEW_LINE for ( i , w2 ) in enumerate ( sums ) : NEW_LINE INDENT if w2 and not s [ i + v ] : NEW_LINE INDENT s [ i + v ] = w2 + ( w , ) NEW_LINE DEDENT DEDENT sums = s NEW_LINE if s [ - neg ] : NEW_LINE INDENT for x in s [ - neg ] : NEW_LINE INDENT print ( x , words [ x ] ) NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT
print " knight " [ 1 : ] NEW_LINE print " socks " [ : - 1 ] NEW_LINE print " brooms " [ 1 : - 1 ] NEW_LINE
def successive_primes ( offsets = ( 2 , ) , primes_max = 1_000_000 ) : NEW_LINE INDENT return ( sp for sp in nsuccprimes ( len ( offsets ) + 1 , primes_max ) if check_value_diffs ( offsets , sp ) ) NEW_LINE DEDENT
def F ( n , x , y ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return x + y NEW_LINE DEDENT elif y == 0 : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return F ( n - 1 , F ( n , x , y - 1 ) , F ( n , x , y - 1 ) + y ) NEW_LINE DEDENT DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , sub = " " , children = None ) : NEW_LINE INDENT self . sub = sub NEW_LINE self . ch = children or [ ] NEW_LINE DEDENT DEDENT class SuffixTree : NEW_LINE INDENT def __init__ ( self , str ) : NEW_LINE INDENT self . nodes = [ Node ( ) ] NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT self . addSuffix ( str [ i : ] ) NEW_LINE DEDENT DEDENT def addSuffix ( self , suf ) : NEW_LINE INDENT n = 0 NEW_LINE i = 0 NEW_LINE while i < len ( suf ) : NEW_LINE INDENT b = suf [ i ] NEW_LINE x2 = 0 NEW_LINE while True : NEW_LINE INDENT children = self . nodes [ n ] . ch NEW_LINE if x2 == len ( children ) : NEW_LINE INDENT n2 = len ( self . nodes ) NEW_LINE self . nodes . append ( Node ( suf [ i : ] , [ ] ) ) NEW_LINE self . nodes [ n ] . ch . append ( n2 ) NEW_LINE return NEW_LINE DEDENT n2 = children [ x2 ] NEW_LINE if self . nodes [ n2 ] . sub [ 0 ] == b : NEW_LINE INDENT break NEW_LINE DEDENT x2 = x2 + 1 NEW_LINE DEDENT sub2 = self . nodes [ n2 ] . sub NEW_LINE j = 0 NEW_LINE while j < len ( sub2 ) : NEW_LINE INDENT if suf [ i + j ] != sub2 [ j ] : NEW_LINE INDENT n3 = n2 NEW_LINE n2 = len ( self . nodes ) NEW_LINE self . nodes . append ( Node ( sub2 [ : j ] , [ n3 ] ) ) NEW_LINE self . nodes [ n3 ] . sub = sub2 [ j : ] NEW_LINE self . nodes [ n ] . ch [ x2 ] = n2 NEW_LINE break NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT i = i + j NEW_LINE n = n2 NEW_LINE DEDENT DEDENT def visualize ( self ) : NEW_LINE INDENT if len ( self . nodes ) == 0 : NEW_LINE INDENT print " < empty > " NEW_LINE return NEW_LINE DEDENT def f ( n , pre ) : NEW_LINE INDENT children = self . nodes [ n ] . ch NEW_LINE if len ( children ) == 0 : NEW_LINE INDENT print " - - " , self . nodes [ n ] . sub NEW_LINE return NEW_LINE DEDENT print " + - " , self . nodes [ n ] . sub NEW_LINE for c in children [ : - 1 ] : NEW_LINE INDENT print pre , " + - " , NEW_LINE f ( c , pre + " ▁ | ▁ " ) NEW_LINE DEDENT print pre , " + - " , NEW_LINE f ( children [ - 1 ] , pre + " ▁ ▁ " ) NEW_LINE DEDENT f ( 0 , " " ) NEW_LINE DEDENT DEDENT SuffixTree ( " banana $ " ) . visualize ( ) NEW_LINE
numbers = [ 1 , 2 , 3 ] NEW_LINE total = sum ( numbers ) NEW_LINE product = 1 NEW_LINE for i in numbers : NEW_LINE INDENT product *= i NEW_LINE DEDENT
print ( sum ( 1.0 / ( x * x ) for x in range ( 1 , 1001 ) ) ) NEW_LINE
from numpy import array , tril , sum NEW_LINE A = [ [ 1 , 3 , 7 , 8 , 10 ] , [ 2 , 4 , 16 , 14 , 4 ] , [ 3 , 1 , 9 , 18 , 11 ] , [ 12 , 14 , 17 , 18 , 20 ] , [ 7 , 1 , 3 , 9 , 5 ] ] NEW_LINE print ( sum ( tril ( A , - 1 ) ) ) NEW_LINE
sum ( x * x for x in [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE sum ( x ** 2 for x in [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE sum ( pow ( x , 2 ) for x in [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE
import time NEW_LINE print time . ctime ( ) NEW_LINE
import sys , datetime , shutil NEW_LINE if len ( sys . argv ) == 1 : NEW_LINE INDENT try : NEW_LINE INDENT with open ( ' notes . txt ' , ' r ' ) as f : NEW_LINE INDENT shutil . copyfileobj ( f , sys . stdout ) NEW_LINE DEDENT DEDENT except IOError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT with open ( ' notes . txt ' , ' a ' ) as f : NEW_LINE INDENT f . write ( datetime . datetime . now ( ) . isoformat ( ) + ' \n ' ) NEW_LINE f . write ( " \t % s \n " % ' ▁ ' . join ( sys . argv [ 1 : ] ) ) NEW_LINE DEDENT DEDENT
from collections import defaultdict NEW_LINE from itertools import product NEW_LINE from pprint import pprint as pp NEW_LINE cube2n = { x ** 3 : x for x in range ( 1 , 1201 ) } NEW_LINE sum2cubes = defaultdict ( set ) NEW_LINE for c1 , c2 in product ( cube2n , cube2n ) : NEW_LINE INDENT if c1 >= c2 : sum2cubes [ c1 + c2 ] . add ( ( cube2n [ c1 ] , cube2n [ c2 ] ) ) NEW_LINE DEDENT taxied = sorted ( ( k , v ) for k , v in sum2cubes . items ( ) if len ( v ) >= 2 ) NEW_LINE for t in enumerate ( taxied [ : 25 ] , 1 ) : NEW_LINE INDENT pp ( t ) NEW_LINE DEDENT print ( ' . . . ' ) NEW_LINE for t in enumerate ( taxied [ 2000 - 1 : 2000 + 6 ] , 2000 ) : NEW_LINE INDENT pp ( t ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT print ( ' \n ' . join ( concatMap ( circularGroup ) ( anagrams ( 3 ) ( lines ( readFile ( ' ~ / mitWords . txt ' ) ) ) ) ) ) NEW_LINE DEDENT
import os NEW_LINE os . system ( " clear " ) NEW_LINE
print u ' \u00a3' NEW_LINE
import time NEW_LINE print " \033 [ ? 1049h\033 [ H " NEW_LINE print " Alternate ▁ buffer ! " NEW_LINE for i in xrange ( 5 , 0 , - 1 ) : NEW_LINE INDENT print " Going ▁ back ▁ in : " , i NEW_LINE time . sleep ( 1 ) NEW_LINE DEDENT print " \033 [ ? 1049l " NEW_LINE
print " \a " NEW_LINE

import fileinput NEW_LINE import sys NEW_LINE nodata = 0 ; NEW_LINE nodata_max = - 1 ; NEW_LINE nodata_maxline = [ ] ; NEW_LINE tot_file = 0 NEW_LINE num_file = 0 NEW_LINE infiles = sys . argv [ 1 : ] NEW_LINE for line in fileinput . input ( ) : NEW_LINE INDENT tot_line = 0 ; NEW_LINE num_line = 0 ; NEW_LINE field = line . split ( ) NEW_LINE date = field [ 0 ] NEW_LINE data = [ float ( f ) for f in field [ 1 : : 2 ] ] NEW_LINE flags = [ int ( f ) for f in field [ 2 : : 2 ] ] NEW_LINE for datum , flag in zip ( data , flags ) : NEW_LINE INDENT if flag < 1 : NEW_LINE INDENT nodata += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if nodata_max == nodata and nodata > 0 : NEW_LINE INDENT nodata_maxline . append ( date ) NEW_LINE DEDENT if nodata_max < nodata and nodata > 0 : NEW_LINE INDENT nodata_max = nodata NEW_LINE nodata_maxline = [ date ] NEW_LINE DEDENT nodata = 0 ; NEW_LINE tot_line += datum NEW_LINE num_line += 1 NEW_LINE DEDENT DEDENT tot_file += tot_line NEW_LINE num_file += num_line NEW_LINE print " Line : ▁ % 11s ▁ ▁ Reject : ▁ % 2i ▁ ▁ Accept : ▁ % 2i ▁ ▁ Line _ tot : ▁ % 10.3f ▁ ▁ Line _ avg : ▁ % 10.3f " % ( date , len ( data ) - num_line , num_line , tot_line , tot_line / num_line if ( num_line > 0 ) else 0 ) NEW_LINE DEDENT print " " NEW_LINE print " File ( s ) ▁ ▁ = ▁ % s " % ( " , ▁ " . join ( infiles ) , ) NEW_LINE print " Total ▁ ▁ ▁ ▁ = ▁ % 10.3f " % ( tot_file , ) NEW_LINE print " Readings ▁ = ▁ % 6i " % ( num_file , ) NEW_LINE print " Average ▁ ▁ = ▁ % 10.3f " % ( tot_file / num_file , ) NEW_LINE print " \n Maximum ▁ run ( s ) ▁ of ▁ % i ▁ consecutive ▁ false ▁ readings ▁ ends ▁ at ▁ line ▁ starting ▁ with ▁ date ( s ) : ▁ % s " % ( nodata_max , " , ▁ " . join ( nodata_maxline ) ) NEW_LINE
import re NEW_LINE import zipfile NEW_LINE import StringIO NEW_LINE def munge2 ( readings ) : NEW_LINE INDENT datePat = re . compile ( r ' \d { 4 } - \d { 2 } - \d { 2 } ' ) NEW_LINE valuPat = re . compile ( r ' [ - + ] ? \d + \ . \d + ' ) NEW_LINE statPat = re . compile ( r ' - ? \d + ' ) NEW_LINE allOk , totalLines = 0 , 0 NEW_LINE datestamps = set ( [ ] ) NEW_LINE for line in readings : NEW_LINE INDENT totalLines += 1 NEW_LINE fields = line . split ( ' \t ' ) NEW_LINE date = fields [ 0 ] NEW_LINE pairs = [ ( fields [ i ] , fields [ i + 1 ] ) for i in range ( 1 , len ( fields ) , 2 ) ] NEW_LINE lineFormatOk = datePat . match ( date ) and all ( valuPat . match ( p [ 0 ] ) for p in pairs ) and all ( statPat . match ( p [ 1 ] ) for p in pairs ) NEW_LINE if not lineFormatOk : NEW_LINE INDENT print ' Bad ▁ formatting ' , line NEW_LINE continue NEW_LINE DEDENT if len ( pairs ) != 24 or any ( int ( p [ 1 ] ) < 1 for p in pairs ) : NEW_LINE INDENT print ' Missing ▁ values ' , line NEW_LINE continue NEW_LINE DEDENT if date in datestamps : NEW_LINE INDENT print ' Duplicate ▁ datestamp ' , line NEW_LINE continue NEW_LINE DEDENT datestamps . add ( date ) NEW_LINE allOk += 1 NEW_LINE DEDENT print ' Lines ▁ with ▁ all ▁ readings : ▁ ' , allOk NEW_LINE print ' Total ▁ records : ▁ ' , totalLines NEW_LINE DEDENT readings = open ( ' readings . txt ' , ' r ' ) NEW_LINE munge2 ( readings ) NEW_LINE
out , max_out , max_times = 0 , - 1 , [ ] NEW_LINE for job in open ( ' mlijobs . txt ' ) : NEW_LINE INDENT out += 1 if " OUT " in job else - 1 NEW_LINE if out > max_out : NEW_LINE INDENT max_out , max_times = out , [ ] NEW_LINE DEDENT if out == max_out : NEW_LINE INDENT max_times . append ( job . split ( ) [ 3 ] ) NEW_LINE DEDENT DEDENT print ( " Maximum ▁ simultaneous ▁ license ▁ use ▁ is ▁ % i ▁ at ▁ the ▁ following ▁ times : " % max_out ) NEW_LINE print ( ' ▁ ▁ ' + ' \n ▁ ▁ ' . join ( max_times ) ) NEW_LINE
def print_verse ( n ) : NEW_LINE INDENT l = [ ' b ' , ' f ' , ' m ' ] NEW_LINE s = n [ 1 : ] NEW_LINE if str . lower ( n [ 0 ] ) in l : NEW_LINE INDENT l [ l . index ( str . lower ( n [ 0 ] ) ) ] = ' ' NEW_LINE DEDENT elif n [ 0 ] in [ ' A ' , ' E ' , ' I ' , ' O ' , ' U ' ] : NEW_LINE INDENT s = str . lower ( n ) NEW_LINE DEDENT print ( ' { 0 } , ▁ { 0 } , ▁ bo - {2 } { 1 } \n Banana - fana ▁ fo - {3 } { 1 } \n Fee - fi - mo - {4 } { 1 } \n { 0 } ! \n ' . format ( n , s , * l ) ) NEW_LINE DEDENT
gifts = ''' \ STRNEWLINE A ▁ partridge ▁ in ▁ a ▁ pear ▁ tree . STRNEWLINE Two ▁ turtle ▁ doves STRNEWLINE Three ▁ french ▁ hens STRNEWLINE Four ▁ calling ▁ birds STRNEWLINE Five ▁ golden ▁ rings STRNEWLINE Six ▁ geese ▁ a - laying STRNEWLINE Seven ▁ swans ▁ a - swimming STRNEWLINE Eight ▁ maids ▁ a - milking STRNEWLINE Nine ▁ ladies ▁ dancing STRNEWLINE Ten ▁ lords ▁ a - leaping STRNEWLINE Eleven ▁ pipers ▁ piping STRNEWLINE Twelve ▁ drummers ▁ drumming ''' . split ( ' \n ' ) NEW_LINE days = ''' first ▁ second ▁ third ▁ fourth ▁ fifth STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ sixth ▁ seventh ▁ eighth ▁ ninth ▁ tenth STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ eleventh ▁ twelfth ''' . split ( ) NEW_LINE for n , day in enumerate ( days , 1 ) : NEW_LINE INDENT g = gifts [ : n ] [ : : - 1 ] NEW_LINE print ( ( ' \n On ▁ the ▁ % s ▁ day ▁ of ▁ Christmas \n My ▁ true ▁ love ▁ gave ▁ to ▁ me : \n ' % day ) + ' \n ' . join ( g [ : - 1 ] ) + ( ' ▁ and \n ' + g [ - 1 ] if n > 1 else g [ - 1 ] . capitalize ( ) ) ) NEW_LINE DEDENT
m = '0' NEW_LINE print ( m ) NEW_LINE for i in range ( 0 , 6 ) : NEW_LINE INDENT m0 = m NEW_LINE m = m . replace ( '0' , ' a ' ) NEW_LINE m = m . replace ( '1' , '0' ) NEW_LINE m = m . replace ( ' a ' , '1' ) NEW_LINE m = m0 + m NEW_LINE print ( m ) NEW_LINE DEDENT
text = " Hello , How , Are , You , Today " NEW_LINE tokens = text . split ( ' , ' ) NEW_LINE print ( ' . ' . join ( tokens ) ) NEW_LINE
from collections import defaultdict NEW_LINE from heapq import nlargest NEW_LINE data = [ ( ' Employee ▁ Name ' , ' Employee ▁ ID ' , ' Salary ' , ' Department ' ) , ( ' Tyler ▁ Bennett ' , ' E10297' , 32000 , ' D101' ) , ( ' John ▁ Rappl ' , ' E21437' , 47000 , ' D050' ) , ( ' George ▁ Woltman ' , ' E00127' , 53500 , ' D101' ) , ( ' Adam ▁ Smith ' , ' E63535' , 18000 , ' D202' ) , ( ' Claire ▁ Buckman ' , ' E39876' , 27800 , ' D202' ) , ( ' David ▁ McClellan ' , ' E04242' , 41500 , ' D101' ) , ( ' Rich ▁ Holcomb ' , ' E01234' , 49500 , ' D202' ) , ( ' Nathan ▁ Adams ' , ' E41298' , 21900 , ' D050' ) , ( ' Richard ▁ Potter ' , ' E43128' , 15900 , ' D101' ) , ( ' David ▁ Motsinger ' , ' E27002' , 19250 , ' D202' ) , ( ' Tim ▁ Sampair ' , ' E03033' , 27000 , ' D101' ) , ( ' Kim ▁ Arlich ' , ' E10001' , 57000 , ' D190' ) , ( ' Timothy ▁ Grove ' , ' E16398' , 29900 , ' D190' ) ] NEW_LINE departments = defaultdict ( list ) NEW_LINE for rec in data [ 1 : ] : NEW_LINE INDENT departments [ rec [ - 1 ] ] . append ( rec ) NEW_LINE DEDENT N = 3 NEW_LINE format = " ▁ % -15s ▁ " * len ( data [ 0 ] ) NEW_LINE for department , recs in sorted ( departments . items ( ) ) : NEW_LINE INDENT print ( " Department ▁ % s " % department ) NEW_LINE print ( format % data [ 0 ] ) NEW_LINE for rec in nlargest ( N , recs , key = lambda rec : rec [ - 2 ] ) : NEW_LINE INDENT print ( format % rec ) NEW_LINE DEDENT print ( ' ' ) NEW_LINE DEDENT
from collections import namedtuple NEW_LINE Circle = namedtuple ( " Circle " , " x ▁ y ▁ r " ) NEW_LINE circles = [ Circle ( 1.6417233788 , 1.6121789534 , 0.0848270516 ) , Circle ( - 1.4944608174 , 1.2077959613 , 1.1039549836 ) , Circle ( 0.6110294452 , - 0.6907087527 , 0.9089162485 ) , Circle ( 0.3844862411 , 0.2923344616 , 0.2375743054 ) , Circle ( - 0.2495892950 , - 0.3832854473 , 1.0845181219 ) , Circle ( 1.7813504266 , 1.6178237031 , 0.8162655711 ) , Circle ( - 0.1985249206 , - 0.8343333301 , 0.0538864941 ) , Circle ( - 1.7011985145 , - 0.1263820964 , 0.4776976918 ) , Circle ( - 0.4319462812 , 1.4104420482 , 0.7886291537 ) , Circle ( 0.2178372997 , - 0.9499557344 , 0.0357871187 ) , Circle ( - 0.6294854565 , - 1.3078893852 , 0.7653357688 ) , Circle ( 1.7952608455 , 0.6281269104 , 0.2727652452 ) , Circle ( 1.4168575317 , 1.0683357171 , 1.1016025378 ) , Circle ( 1.4637371396 , 0.9463877418 , 1.1846214562 ) , Circle ( - 0.5263668798 , 1.7315156631 , 1.4428514068 ) , Circle ( - 1.2197352481 , 0.9144146579 , 1.0727263474 ) , Circle ( - 0.1389358881 , 0.1092805780 , 0.7350208828 ) , Circle ( 1.5293954595 , 0.0030278255 , 1.2472867347 ) , Circle ( - 0.5258728625 , 1.3782633069 , 1.3495508831 ) , Circle ( - 0.1403562064 , 0.2437382535 , 1.3804956588 ) , Circle ( 0.8055826339 , - 0.0482092025 , 0.3327165165 ) , Circle ( - 0.6311979224 , 0.7184578971 , 0.2491045282 ) , Circle ( 1.4685857879 , - 0.8347049536 , 1.3670667538 ) , Circle ( - 0.6855727502 , 1.6465021616 , 1.0593087096 ) , Circle ( 0.0152957411 , 0.0638919221 , 0.9771215985 ) ] NEW_LINE def main ( ) : NEW_LINE INDENT x_min = min ( c . x - c . r for c in circles ) NEW_LINE x_max = max ( c . x + c . r for c in circles ) NEW_LINE y_min = min ( c . y - c . r for c in circles ) NEW_LINE y_max = max ( c . y + c . r for c in circles ) NEW_LINE box_side = 500 NEW_LINE dx = ( x_max - x_min ) / box_side NEW_LINE dy = ( y_max - y_min ) / box_side NEW_LINE count = 0 NEW_LINE for r in xrange ( box_side ) : NEW_LINE INDENT y = y_min + r * dy NEW_LINE for c in xrange ( box_side ) : NEW_LINE INDENT x = x_min + c * dx NEW_LINE if any ( ( x - circle . x ) ** 2 + ( y - circle . y ) ** 2 <= ( circle . r ** 2 ) for circle in circles ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print " Approximated ▁ area : " , count * dx * dy NEW_LINE DEDENT main ( ) NEW_LINE
from itertools import product NEW_LINE while True : NEW_LINE INDENT bexp = input ( ' \n Boolean ▁ expression : ▁ ' ) NEW_LINE bexp = bexp . strip ( ) NEW_LINE if not bexp : NEW_LINE INDENT print ( " \n Thank ▁ you " ) NEW_LINE break NEW_LINE DEDENT code = compile ( bexp , ' < string > ' , ' eval ' ) NEW_LINE names = code . co_names NEW_LINE print ( ' \n ' + ' ▁ ' . join ( names ) , ' : ' , bexp ) NEW_LINE for values in product ( range ( 2 ) , repeat = len ( names ) ) : NEW_LINE INDENT env = dict ( zip ( names , values ) ) NEW_LINE print ( ' ▁ ' . join ( str ( v ) for v in values ) , ' : ' , eval ( code , env ) ) NEW_LINE DEDENT DEDENT
def two_sum ( arr , num ) : NEW_LINE INDENT i = 0 NEW_LINE j = len ( arr ) - 1 NEW_LINE while i < j : NEW_LINE INDENT if arr [ i ] + arr [ j ] == num : NEW_LINE INDENT return ( i , j ) NEW_LINE DEDENT if arr [ i ] + arr [ j ] < num : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT
def ulam ( n ) : NEW_LINE INDENT if n <= 2 : NEW_LINE INDENT return n NEW_LINE DEDENT mx = 1352000 NEW_LINE lst = [ 1 , 2 ] + [ 0 ] * mx NEW_LINE sums = [ 0 ] * ( mx * 2 + 1 ) NEW_LINE sums [ 3 ] = 1 NEW_LINE size = 2 NEW_LINE while size < n : NEW_LINE INDENT query = lst [ size - 1 ] + 1 NEW_LINE while True : NEW_LINE INDENT if sums [ query ] == 1 : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT sum = query + lst [ i ] NEW_LINE t = sums [ sum ] + 1 NEW_LINE if t <= 2 : NEW_LINE INDENT sums [ sum ] = t NEW_LINE DEDENT DEDENT lst [ size ] , size = query , size + 1 NEW_LINE break NEW_LINE DEDENT query += 1 NEW_LINE DEDENT DEDENT return query NEW_LINE DEDENT
def unbiased ( biased ) : NEW_LINE INDENT this , that = biased ( ) , biased ( ) NEW_LINE while this == that : NEW_LINE INDENT this , that = biased ( ) , biased ( ) NEW_LINE DEDENT return this NEW_LINE DEDENT
try : name NEW_LINE except NameError : print " name ▁ is ▁ undefined ▁ at ▁ first ▁ check " NEW_LINE name = " Chocolate " NEW_LINE try : name NEW_LINE except NameError : print " name ▁ is ▁ undefined ▁ at ▁ second ▁ check " NEW_LINE del name NEW_LINE try : name NEW_LINE except NameError : print " name ▁ is ▁ undefined ▁ at ▁ third ▁ check " NEW_LINE name = 42 NEW_LINE try : name NEW_LINE except NameError : print " name ▁ is ▁ undefined ▁ at ▁ fourth ▁ check " NEW_LINE print " Done " NEW_LINE
u = ' abcdÃ © ' NEW_LINE print ( ord ( u [ - 1 ] ) ) NEW_LINE
def main ( ) : NEW_LINE INDENT barcodes = [ " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ ▁ ▁ # ▁ # # ▁ ▁ # ▁ ▁ # # ▁ # ▁ ▁ ▁ # # ▁ # # # ▁ # # ▁ # # # ▁ # # ▁ # # # # ▁ # ▁ # ▁ # ▁ # # ▁ # # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ # # ▁ ▁ # # ▁ # # # ▁ ▁ # ▁ # # ▁ ▁ # # ▁ # # # ▁ # ▁ ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ # ▁ ▁ ▁ # # ▁ ▁ ▁ # # ▁ # ▁ # # # # ▁ # ▁ ▁ ▁ # ▁ # # ▁ # ▁ ▁ ▁ # # ▁ # ▁ ▁ ▁ # # ▁ # ▁ # ▁ # ▁ # # # ▁ ▁ # ▁ # # # ▁ ▁ # # ▁ ▁ # # ▁ # # # ▁ ▁ # ▁ # ▁ ▁ # # # ▁ # # # ▁ ▁ # ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ ▁ ▁ ▁ # ▁ # ▁ # ▁ ▁ # # # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ ▁ ▁ # ▁ # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ ▁ ▁ # ▁ # ▁ # ▁ # ▁ # # ▁ # ▁ ▁ ▁ # # ▁ # ▁ ▁ ▁ # # ▁ # ▁ ▁ ▁ # # ▁ ▁ ▁ # ▁ # ▁ # # # # ▁ # # # ▁ # # ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ # # ▁ ▁ # # ▁ # # ▁ ▁ # # ▁ ▁ ▁ # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ # ▁ # # # ▁ ▁ # ▁ # # ▁ ▁ # # ▁ # ▁ # ▁ # ▁ ▁ ▁ # # ▁ # # ▁ ▁ # ▁ ▁ # # # ▁ # # ▁ # # ▁ # ▁ ▁ ▁ # ▁ # # # # ▁ # # ▁ # ▁ ▁ ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ # # # ▁ # # ▁ # ▁ ▁ ▁ # # ▁ # # ▁ # # # ▁ ▁ # # ▁ ▁ # ▁ # # ▁ ▁ ▁ # ▁ ▁ ▁ # ▁ # # ▁ # ▁ # ▁ # # # ▁ # ▁ ▁ # # ▁ # # ▁ ▁ # ▁ ▁ ▁ ▁ # ▁ # # # ▁ # ▁ ▁ # # ▁ # # ▁ ▁ # ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ ▁ # ▁ ▁ ▁ # ▁ # # ▁ ▁ # # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ # ▁ # # ▁ ▁ # # ▁ ▁ # ▁ ▁ ▁ # ▁ # ▁ # ▁ # ▁ # # # # ▁ # ▁ ▁ # # ▁ ▁ # ▁ # # # # ▁ # # # # ▁ # ▁ # ▁ ▁ # # ▁ ▁ # ▁ # # # # ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ ▁ # ▁ ▁ # # ▁ ▁ # # ▁ ▁ # ▁ # ▁ ▁ ▁ # # ▁ # # ▁ ▁ ▁ # ▁ # # # ▁ # # ▁ # # ▁ ▁ ▁ # ▁ # ▁ # ▁ # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ # ▁ ▁ # # # ▁ # ▁ # ▁ ▁ ▁ ▁ # # # ▁ ▁ # ▁ # ▁ ▁ # ▁ ▁ ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ # ▁ ▁ ▁ ▁ # ▁ # # ▁ ▁ # # ▁ ▁ ▁ # ▁ ▁ # ▁ # # ▁ ▁ # # ▁ ▁ # # # ▁ # ▁ ▁ ▁ # ▁ ▁ # ▁ # ▁ # ▁ # # # ▁ # # ▁ # # ▁ # # # ▁ # # ▁ # # # ▁ # # # ▁ # # ▁ # ▁ ▁ # # ▁ ▁ # # # ▁ # # ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ # # # ▁ # # ▁ ▁ ▁ # # ▁ # ▁ # ▁ # # # # ▁ # ▁ ▁ ▁ # # ▁ # ▁ # # # # ▁ # ▁ # # # # ▁ # ▁ # ▁ # ▁ ▁ ▁ # ▁ ▁ # ▁ # # # ▁ ▁ # ▁ ▁ ▁ ▁ # ▁ # # # ▁ ▁ # ▁ # ▁ ▁ ▁ ▁ # ▁ # # # ▁ ▁ # ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ # ▁ # # # # ▁ # # ▁ ▁ ▁ # ▁ # # # # ▁ # ▁ # ▁ ▁ ▁ # # ▁ # # ▁ # # # ▁ # # # # ▁ # ▁ # ▁ # ▁ # ▁ ▁ # # # ▁ # ▁ # # # ▁ ▁ # # # ▁ ▁ # ▁ # ▁ # # # ▁ ▁ # ▁ ▁ ▁ ▁ # ▁ # ▁ ▁ # # # ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ # ▁ # # # # ▁ # # ▁ ▁ ▁ # ▁ # # # # ▁ # ▁ # ▁ ▁ ▁ # # ▁ # # ▁ # # # ▁ # # # # ▁ # ▁ # ▁ # ▁ # ▁ ▁ # # # ▁ # ▁ # # # ▁ ▁ # # # ▁ ▁ # ▁ # ▁ # # # ▁ ▁ # # ▁ # # ▁ ▁ # ▁ ▁ # # # ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , ] NEW_LINE for barcode in barcodes : NEW_LINE INDENT try : NEW_LINE INDENT digits = parse ( barcode ) NEW_LINE DEDENT except ParityError as err : NEW_LINE INDENT print ( f " { err } ▁ parity ▁ error ! " ) NEW_LINE continue NEW_LINE DEDENT try : NEW_LINE INDENT check_digit = checksum ( digits ) NEW_LINE DEDENT except ChecksumError as err : NEW_LINE INDENT print ( f " { ' ▁ ' . join ( str ( d ) ▁ for ▁ d ▁ in ▁ digits ) } ▁ checksum ▁ error ! ▁ ( { err } ) " ) NEW_LINE continue NEW_LINE DEDENT print ( f " { ' ▁ ' . join ( str ( d ) ▁ for ▁ d ▁ in ▁ digits ) } " ) NEW_LINE DEDENT DEDENT
import re NEW_LINE import string NEW_LINE DISABLED_PREFIX = ' ; ' NEW_LINE class Option ( object ) : NEW_LINE INDENT def __init__ ( self , name , value = None , disabled = False , disabled_prefix = DISABLED_PREFIX ) : NEW_LINE INDENT self . name = str ( name ) NEW_LINE self . value = value NEW_LINE self . disabled = bool ( disabled ) NEW_LINE self . disabled_prefix = disabled_prefix NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT disabled = ( ' ' , ' % s ▁ ' % self . disabled_prefix ) [ self . disabled ] NEW_LINE value = ( ' ▁ % s ' % self . value , ' ' ) [ self . value is None ] NEW_LINE return ' ' . join ( ( disabled , self . name , value ) ) NEW_LINE DEDENT def get ( self ) : NEW_LINE INDENT enabled = not bool ( self . disabled ) NEW_LINE if self . value is None : NEW_LINE INDENT value = enabled NEW_LINE DEDENT else : NEW_LINE INDENT value = enabled and self . value NEW_LINE DEDENT return value NEW_LINE DEDENT DEDENT class Config ( object ) : NEW_LINE INDENT reOPTION = r ' ^ \s * ( ? P < disabled > % s * ) \s * ( ? P < name > \w + ) ( ? : \s + ( ? P < value > . + ? ) ) ? \s * $ ' NEW_LINE def __init__ ( self , fname = None , disabled_prefix = DISABLED_PREFIX ) : NEW_LINE INDENT self . disabled_prefix = disabled_prefix NEW_LINE self . contents = [ ] NEW_LINE self . options = { } NEW_LINE self . creOPTION = re . compile ( self . reOPTION % self . disabled_prefix ) NEW_LINE if fname : NEW_LINE INDENT self . parse_file ( fname ) NEW_LINE DEDENT DEDENT def __str__ ( self ) : NEW_LINE INDENT return ' \n ' . join ( map ( str , self . contents ) ) NEW_LINE DEDENT def parse_file ( self , fname ) : NEW_LINE INDENT with open ( fname ) as f : NEW_LINE INDENT self . parse_lines ( f ) NEW_LINE DEDENT return self NEW_LINE DEDENT def parse_lines ( self , lines ) : NEW_LINE INDENT for line in lines : NEW_LINE INDENT self . parse_line ( line ) NEW_LINE DEDENT return self NEW_LINE DEDENT def parse_line ( self , line ) : NEW_LINE INDENT s = ' ' . join ( c for c in line . strip ( ) if c in string . printable ) NEW_LINE moOPTION = self . creOPTION . match ( s ) NEW_LINE if moOPTION : NEW_LINE INDENT name = moOPTION . group ( ' name ' ) . upper ( ) NEW_LINE if not name in self . options : NEW_LINE INDENT self . add_option ( name , moOPTION . group ( ' value ' ) , moOPTION . group ( ' disabled ' ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if not s . startswith ( self . disabled_prefix ) : NEW_LINE INDENT self . contents . append ( line . rstrip ( ) ) NEW_LINE DEDENT DEDENT return self NEW_LINE DEDENT def add_option ( self , name , value = None , disabled = False ) : NEW_LINE INDENT name = name . upper ( ) NEW_LINE opt = Option ( name , value , disabled ) NEW_LINE self . options [ name ] = opt NEW_LINE self . contents . append ( opt ) NEW_LINE return opt NEW_LINE DEDENT def set_option ( self , name , value = None , disabled = False ) : NEW_LINE INDENT name = name . upper ( ) NEW_LINE opt = self . options . get ( name ) NEW_LINE if opt : NEW_LINE INDENT opt . value = value NEW_LINE opt . disabled = disabled NEW_LINE DEDENT else : NEW_LINE INDENT opt = self . add_option ( name , value , disabled ) NEW_LINE DEDENT return opt NEW_LINE DEDENT def enable_option ( self , name , value = None ) : NEW_LINE INDENT return self . set_option ( name , value , False ) NEW_LINE DEDENT def disable_option ( self , name , value = None ) : NEW_LINE INDENT return self . set_option ( name , value , True ) NEW_LINE DEDENT def get_option ( self , name ) : NEW_LINE INDENT opt = self . options . get ( name . upper ( ) ) NEW_LINE value = opt . get ( ) if opt else None NEW_LINE return value NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE cfg = Config ( sys . argv [ 1 ] if len ( sys . argv ) > 1 else None ) NEW_LINE cfg . disable_option ( ' needspeeling ' ) NEW_LINE cfg . enable_option ( ' seedsremoved ' ) NEW_LINE cfg . enable_option ( ' numberofbananas ' , 1024 ) NEW_LINE cfg . enable_option ( ' numberofstrawberries ' , 62000 ) NEW_LINE print cfg NEW_LINE DEDENT
import urllib NEW_LINE print urllib . unquote ( " http % 3A % 2F % 2Ffoo % 20bar % 2F " ) NEW_LINE from urllib . parse import unquote NEW_LINE print ( unquote ( ' http % 3A % 2F % 2Ffoo % 20bar % 2F ' ) ) NEW_LINE
import urllib NEW_LINE s = ' http : / / foo / bar / ' NEW_LINE s = urllib . quote ( s ) NEW_LINE
import urllib . parse as up NEW_LINE url = up . urlparse ( ' http : / / user : pass @ example . com : 8081 / path / file . html ; params ? query1 = 1 # fragment ' ) NEW_LINE print ( ' url . scheme ▁ = ▁ ' , url . scheme ) NEW_LINE print ( ' url . netloc ▁ = ▁ ' , url . netloc ) NEW_LINE print ( ' url . hostname ▁ = ▁ ' , url . hostname ) NEW_LINE print ( ' url . port ▁ = ▁ ' , url . port ) NEW_LINE print ( ' url . path ▁ = ▁ ' , url . path ) NEW_LINE print ( ' url . params ▁ = ▁ ' , url . params ) NEW_LINE print ( ' url . query ▁ = ▁ ' , url . query ) NEW_LINE print ( ' url . fragment ▁ = ▁ ' , url . fragment ) NEW_LINE print ( ' url . username ▁ = ▁ ' , url . username ) NEW_LINE print ( ' url . password ▁ = ▁ ' , url . password ) NEW_LINE
import Tkinter , tkSimpleDialog NEW_LINE root = Tkinter . Tk ( ) NEW_LINE root . withdraw ( ) NEW_LINE number = tkSimpleDialog . askinteger ( " Integer " , " Enter ▁ a ▁ Number " ) NEW_LINE string = tkSimpleDialog . askstring ( " String " , " Enter ▁ a ▁ String " ) NEW_LINE
INDENT string = raw_input ( " Input ▁ a ▁ string : ▁ " ) NEW_LINE DEDENT
def vdc ( n , base = 2 ) : NEW_LINE INDENT vdc , denom = 0 , 1 NEW_LINE while n : NEW_LINE INDENT denom *= base NEW_LINE n , remainder = divmod ( n , base ) NEW_LINE vdc += remainder / denom NEW_LINE DEDENT return vdc NEW_LINE DEDENT
def van_eck ( ) : NEW_LINE INDENT n , seen , val = 0 , { } , 0 NEW_LINE while True : NEW_LINE INDENT yield val NEW_LINE last = { val : n } NEW_LINE val = n - seen . get ( val , n ) NEW_LINE seen . update ( last ) NEW_LINE n += 1 NEW_LINE DEDENT DEDENT
s = [ 1 , 2 , 2 , 3 , 4 , 4 , 5 ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT curr = s [ i ] NEW_LINE if i > 0 and curr == prev : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT prev = curr NEW_LINE DEDENT
example1 = 3 NEW_LINE example2 = 3.0 NEW_LINE example3 = True NEW_LINE example4 = " hello " NEW_LINE example1 = " goodbye " NEW_LINE
def print_all ( * things ) : NEW_LINE INDENT for x in things : NEW_LINE INDENT print x NEW_LINE DEDENT DEDENT
def encrypt ( message , key ) : NEW_LINE INDENT message = filter ( str . isalpha , message . upper ( ) ) NEW_LINE def enc ( c , k ) : NEW_LINE INDENT return chr ( ( ( ord ( k ) + ord ( c ) - 2 * ord ( ' A ' ) ) % 26 ) + ord ( ' A ' ) ) NEW_LINE DEDENT return ' ' . join ( starmap ( enc , zip ( message , cycle ( key ) ) ) ) NEW_LINE DEDENT
def decrypt ( message , key ) : NEW_LINE INDENT def dec ( c , k ) : NEW_LINE INDENT return chr ( ( ( ord ( c ) - ord ( k ) - 2 * ord ( ' A ' ) ) % 26 ) + ord ( ' A ' ) ) NEW_LINE DEDENT return ' ' . join ( starmap ( dec , zip ( message , cycle ( key ) ) ) ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT text = ' Beware ▁ the ▁ Jabberwock , ▁ my ▁ son ! ▁ The ▁ jaws ▁ that ▁ bite , ▁ ' + ( ) key = ' VIGENERECIPHER ' NEW_LINE encr = encrypt ( text , key ) NEW_LINE decr = decrypt ( encr , key ) NEW_LINE print ( text ) NEW_LINE print ( encr ) NEW_LINE print ( decr ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE costs = { ' W ' : { ' A ' : 16 , ' B ' : 16 , ' C ' : 13 , ' D ' : 22 , ' E ' : 17 } , ' X ' : { ' A ' : 14 , ' B ' : 14 , ' C ' : 13 , ' D ' : 19 , ' E ' : 15 } , ' Y ' : { ' A ' : 19 , ' B ' : 19 , ' C ' : 20 , ' D ' : 23 , ' E ' : 50 } , ' Z ' : { ' A ' : 50 , ' B ' : 12 , ' C ' : 50 , ' D ' : 15 , ' E ' : 11 } } NEW_LINE demand = { ' A ' : 30 , ' B ' : 20 , ' C ' : 70 , ' D ' : 30 , ' E ' : 60 } NEW_LINE cols = sorted ( demand . iterkeys ( ) ) NEW_LINE supply = { ' W ' : 50 , ' X ' : 60 , ' Y ' : 50 , ' Z ' : 50 } NEW_LINE res = dict ( ( k , defaultdict ( int ) ) for k in costs ) NEW_LINE g = { } NEW_LINE for x in supply : NEW_LINE INDENT g [ x ] = sorted ( costs [ x ] . iterkeys ( ) , key = lambda g : costs [ x ] [ g ] ) NEW_LINE DEDENT for x in demand : NEW_LINE INDENT g [ x ] = sorted ( costs . iterkeys ( ) , key = lambda g : costs [ g ] [ x ] ) NEW_LINE DEDENT while g : NEW_LINE INDENT d = { } NEW_LINE for x in demand : NEW_LINE INDENT d [ x ] = ( costs [ g [ x ] [ 1 ] ] [ x ] - costs [ g [ x ] [ 0 ] ] [ x ] ) if len ( g [ x ] ) > 1 else costs [ g [ x ] [ 0 ] ] [ x ] NEW_LINE DEDENT s = { } NEW_LINE for x in supply : NEW_LINE INDENT s [ x ] = ( costs [ x ] [ g [ x ] [ 1 ] ] - costs [ x ] [ g [ x ] [ 0 ] ] ) if len ( g [ x ] ) > 1 else costs [ x ] [ g [ x ] [ 0 ] ] NEW_LINE DEDENT f = max ( d , key = lambda n : d [ n ] ) NEW_LINE t = max ( s , key = lambda n : s [ n ] ) NEW_LINE t , f = ( f , g [ f ] [ 0 ] ) if d [ f ] > s [ t ] else ( g [ t ] [ 0 ] , t ) NEW_LINE v = min ( supply [ f ] , demand [ t ] ) NEW_LINE res [ f ] [ t ] += v NEW_LINE demand [ t ] -= v NEW_LINE if demand [ t ] == 0 : NEW_LINE INDENT for k , n in supply . iteritems ( ) : NEW_LINE INDENT if n != 0 : NEW_LINE INDENT g [ k ] . remove ( t ) NEW_LINE DEDENT DEDENT del g [ t ] NEW_LINE del demand [ t ] NEW_LINE DEDENT supply [ f ] -= v NEW_LINE if supply [ f ] == 0 : NEW_LINE INDENT for k , n in demand . iteritems ( ) : NEW_LINE INDENT if n != 0 : NEW_LINE INDENT g [ k ] . remove ( f ) NEW_LINE DEDENT DEDENT del g [ f ] NEW_LINE del supply [ f ] NEW_LINE DEDENT DEDENT for n in cols : NEW_LINE INDENT print " \t " , n , NEW_LINE DEDENT print NEW_LINE cost = 0 NEW_LINE for g in sorted ( costs ) : NEW_LINE INDENT print g , " \t " , NEW_LINE for n in cols : NEW_LINE INDENT y = res [ g ] [ n ] NEW_LINE if y != 0 : NEW_LINE INDENT print y , NEW_LINE DEDENT cost += y * costs [ g ] [ n ] NEW_LINE print " \t " , NEW_LINE DEDENT print NEW_LINE DEDENT print " \n \n Total ▁ Cost ▁ = ▁ " , cost NEW_LINE
import glob NEW_LINE for filename in glob . glob ( ' / foo / bar / * . mp3' ) : NEW_LINE INDENT print ( filename ) NEW_LINE DEDENT
from pathlib import Path NEW_LINE for path in Path ( ' . ' ) . rglob ( ' * . * ' ) : NEW_LINE INDENT print ( path ) NEW_LINE DEDENT
import urllib NEW_LINE page = urllib . urlopen ( ' http : / / tycho . usno . navy . mil / cgi - bin / timer . pl ' ) NEW_LINE for line in page : NEW_LINE INDENT if ' ▁ UTC ' in line : NEW_LINE INDENT print line . strip ( ) [ 4 : ] NEW_LINE break NEW_LINE DEDENT DEDENT page . close ( ) NEW_LINE
def main ( ) : NEW_LINE INDENT start = time ( ) NEW_LINE n = 50 NEW_LINE xs = take ( n ) ( weirds ( ) ) NEW_LINE print ( ( tabulated ( ' First ▁ ' + str ( n ) + ' ▁ weird ▁ numbers : \n ' ) ( lambda i : str ( 1 + i ) ) ( str ) ( 5 ) ( index ( xs ) ) ( range ( 0 , n ) ) ) ) NEW_LINE print ( ' \n Approx ▁ computation ▁ time : ▁ ' + str ( int ( 1000 * ( time ( ) - start ) ) ) + ' ▁ ms ' ) NEW_LINE DEDENT
INDENT import Tkinter NEW_LINE w = Tkinter . Tk ( ) NEW_LINE w . mainloop ( ) NEW_LINE DEDENT
from Xlib import X , display NEW_LINE class Window : NEW_LINE INDENT def __init__ ( self , display , msg ) : NEW_LINE INDENT self . display = display NEW_LINE self . msg = msg NEW_LINE self . screen = self . display . screen ( ) NEW_LINE self . window = self . screen . root . create_window ( 10 , 10 , 100 , 100 , 1 , self . screen . root_depth , background_pixel = self . screen . white_pixel , event_mask = X . ExposureMask | X . KeyPressMask , ) NEW_LINE self . gc = self . window . create_gc ( foreground = self . screen . black_pixel , background = self . screen . white_pixel , ) NEW_LINE self . window . map ( ) NEW_LINE DEDENT def loop ( self ) : NEW_LINE INDENT while True : NEW_LINE INDENT e = self . display . next_event ( ) NEW_LINE if e . type == X . Expose : NEW_LINE INDENT self . window . fill_rectangle ( self . gc , 20 , 20 , 10 , 10 ) NEW_LINE self . window . draw_text ( self . gc , 10 , 50 , self . msg ) NEW_LINE DEDENT elif e . type == X . KeyPress : NEW_LINE INDENT raise SystemExit NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Window ( display . Display ( ) , " Hello , ▁ World ! " ) . loop ( ) NEW_LINE DEDENT
def main ( ) : NEW_LINE INDENT lexicon = ' a ▁ bc ▁ abc ▁ cd ▁ b ' . split ( ) NEW_LINE testSamples = ' abcd ▁ abbc ▁ abcbcd ▁ acdbc ▁ abcdd ' . split ( ) NEW_LINE print ( unlines ( map ( showParse , map ( stringParse ( lexicon ) , testSamples ) ) ) ) NEW_LINE DEDENT
import collections NEW_LINE import re NEW_LINE import string NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT counter = collections . Counter ( re . findall ( r " \w + " , open ( sys . argv [ 1 ] ) . read ( ) . lower ( ) ) ) NEW_LINE print counter . most_common ( int ( sys . argv [ 2 ] ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def read_words ( filename ) : NEW_LINE INDENT max_len = max ( n_rows , n_cols ) NEW_LINE words = [ ] NEW_LINE with open ( filename , " r " ) as file : NEW_LINE INDENT for line in file : NEW_LINE INDENT s = line . strip ( ) . lower ( ) NEW_LINE if re . match ( r ' ^ [ a - z ] {3 , ' + re . escape ( str ( max_len ) ) + r ' } $ ' , s ) is not None : NEW_LINE INDENT words . append ( s ) NEW_LINE DEDENT DEDENT DEDENT return words NEW_LINE DEDENT
def place_message ( grid , msg ) : NEW_LINE INDENT msg = re . sub ( r ' [ ^ A - Z ] ' , " " , msg . upper ( ) ) NEW_LINE message_len = len ( msg ) NEW_LINE if 0 < message_len < grid_size : NEW_LINE INDENT gap_size = grid_size // message_len NEW_LINE for i in range ( 0 , message_len ) : NEW_LINE INDENT pos = i * gap_size + randint ( 0 , gap_size ) NEW_LINE grid . cells [ pos // n_cols ] [ pos % n_cols ] = msg [ i ] NEW_LINE DEDENT return message_len NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def try_location ( grid , word , direction , pos ) : NEW_LINE INDENT r = pos // n_cols NEW_LINE c = pos % n_cols NEW_LINE length = len ( word ) NEW_LINE if ( dirs [ direction ] [ 0 ] == 1 and ( length + c ) > n_cols ) or ( dirs [ direction ] [ 0 ] == - 1 and ( length - 1 ) > c ) or ( dirs [ direction ] [ 1 ] == 1 and ( length + r ) > n_rows ) or ( dirs [ direction ] [ 1 ] == - 1 and ( length - 1 ) > r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT rr = r NEW_LINE cc = c NEW_LINE i = 0 NEW_LINE overlaps = 0 NEW_LINE while i < length : NEW_LINE INDENT if grid . cells [ rr ] [ cc ] != ' ' and grid . cells [ rr ] [ cc ] != word [ i ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT cc += dirs [ direction ] [ 0 ] NEW_LINE rr += dirs [ direction ] [ 1 ] NEW_LINE i += 1 NEW_LINE DEDENT rr = r NEW_LINE cc = c NEW_LINE i = 0 NEW_LINE while i < length : NEW_LINE INDENT if grid . cells [ rr ] [ cc ] == word [ i ] : NEW_LINE INDENT overlaps += 1 NEW_LINE DEDENT else : NEW_LINE INDENT grid . cells [ rr ] [ cc ] = word [ i ] NEW_LINE DEDENT if i < length - 1 : NEW_LINE INDENT cc += dirs [ direction ] [ 0 ] NEW_LINE rr += dirs [ direction ] [ 1 ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT letters_placed = length - overlaps NEW_LINE if letters_placed > 0 : NEW_LINE INDENT grid . solutions . append ( " { 0 : < 10 } ▁ ( {1 } , {2 } ) ( { 3 } , {4 } ) " . format ( word , c , r , cc , rr ) ) NEW_LINE DEDENT return letters_placed NEW_LINE DEDENT
def try_place_word ( grid , word ) : NEW_LINE INDENT rand_dir = randint ( 0 , len ( dirs ) ) NEW_LINE rand_pos = randint ( 0 , grid_size ) NEW_LINE for direction in range ( 0 , len ( dirs ) ) : NEW_LINE INDENT direction = ( direction + rand_dir ) % len ( dirs ) NEW_LINE for pos in range ( 0 , grid_size ) : NEW_LINE INDENT pos = ( pos + rand_pos ) % grid_size NEW_LINE letters_placed = try_location ( grid , word , direction , pos ) NEW_LINE if letters_placed > 0 : NEW_LINE INDENT return letters_placed NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT
def create_word_search ( words ) : NEW_LINE INDENT grid = None NEW_LINE num_attempts = 0 NEW_LINE while num_attempts < 100 : NEW_LINE INDENT num_attempts += 1 NEW_LINE shuffle ( words ) NEW_LINE grid = Grid ( ) NEW_LINE message_len = place_message ( grid , " Rosetta ▁ Code " ) NEW_LINE target = grid_size - message_len NEW_LINE cells_filled = 0 NEW_LINE for word in words : NEW_LINE INDENT cells_filled += try_place_word ( grid , word ) NEW_LINE if cells_filled == target : NEW_LINE INDENT if len ( grid . solutions ) >= min_words : NEW_LINE INDENT grid . num_attempts = num_attempts NEW_LINE return grid NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return grid NEW_LINE DEDENT
def print_result ( grid ) : NEW_LINE INDENT if grid is None or grid . num_attempts == 0 : NEW_LINE INDENT print ( " No ▁ grid ▁ to ▁ display " ) NEW_LINE return NEW_LINE DEDENT size = len ( grid . solutions ) NEW_LINE print ( " Attempts : ▁ { 0 } " . format ( grid . num_attempts ) ) NEW_LINE print ( " Number ▁ of ▁ words : ▁ { 0 } " . format ( size ) ) NEW_LINE print ( " \n ▁ ▁ ▁ ▁ ▁ 0 ▁ ▁ 1 ▁ ▁ 2 ▁ ▁ 3 ▁ ▁ 4 ▁ ▁ 5 ▁ ▁ 6 ▁ ▁ 7 ▁ ▁ 8 ▁ ▁ 9 \n " ) NEW_LINE for r in range ( 0 , n_rows ) : NEW_LINE INDENT print ( " { 0 } ▁ ▁ ▁ " . format ( r ) , end = ' ' ) NEW_LINE for c in range ( 0 , n_cols ) : NEW_LINE INDENT print ( " ▁ % c ▁ " % grid . cells [ r ] [ c ] , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT print ( ) NEW_LINE for i in range ( 0 , size - 1 , 2 ) : NEW_LINE INDENT print ( " { 0 } ▁ ▁ ▁ { 1 } " . format ( grid . solutions [ i ] , grid . solutions [ i + 1 ] ) ) NEW_LINE DEDENT if size % 2 == 1 : NEW_LINE INDENT print ( grid . solutions [ size - 1 ] ) NEW_LINE DEDENT DEDENT
import urllib . request NEW_LINE from collections import Counter NEW_LINE urllib . request . urlretrieve ( " http : / / wiki . puzzlers . org / pub / wordlists / unixdict . txt " , " unixdict . txt " ) NEW_LINE dictionary = open ( " unixdict . txt " , " r " ) NEW_LINE wordList = dictionary . read ( ) . split ( ' \n ' ) NEW_LINE dictionary . close ( ) NEW_LINE filteredWords = [ chosenWord for chosenWord in wordList if len ( chosenWord ) >= 9 ] NEW_LINE for word in filteredWords [ : - 9 ] : NEW_LINE INDENT position = filteredWords . index ( word ) NEW_LINE newWord = " " . join ( [ filteredWords [ position + i ] [ i ] for i in range ( 0 , 9 ) ] ) NEW_LINE if newWord in filteredWords : NEW_LINE INDENT print ( newWord ) NEW_LINE DEDENT DEDENT
from itertools import product , combinations , izip NEW_LINE scoring = [ 0 , 1 , 3 ] NEW_LINE histo = [ [ 0 ] * 10 for _ in xrange ( 4 ) ] NEW_LINE for results in product ( range ( 3 ) , repeat = 6 ) : NEW_LINE INDENT s = [ 0 ] * 4 NEW_LINE for r , g in izip ( results , combinations ( range ( 4 ) , 2 ) ) : NEW_LINE INDENT s [ g [ 0 ] ] += scoring [ r ] NEW_LINE s [ g [ 1 ] ] += scoring [ 2 - r ] NEW_LINE DEDENT for h , v in izip ( histo , sorted ( s ) ) : NEW_LINE INDENT h [ v ] += 1 NEW_LINE DEDENT DEDENT for x in reversed ( histo ) : NEW_LINE INDENT print x NEW_LINE DEDENT
with open ( filename , ' w ' ) as f : NEW_LINE INDENT f . write ( data ) NEW_LINE DEDENT
import itertools NEW_LINE def writedat ( filename , x , y , xprecision = 3 , yprecision = 5 ) : NEW_LINE INDENT with open ( filename , ' w ' ) as f : NEW_LINE INDENT for a , b in itertools . izip ( x , y ) : NEW_LINE INDENT print >> f , " % . * g\t % . * g " % ( xprecision , a , yprecision , b ) NEW_LINE DEDENT DEDENT DEDENT
py = ''' \ STRNEWLINE ▁ # # # # ▁ ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ # # # # # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ ▁ # # # ▁ ▁ ▁ # ▁ ▁ ▁ # STRNEWLINE ▁ # ▁ ▁ ▁ # ▁ ▁ ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ # ▁ ▁ ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ # # ▁ ▁ # STRNEWLINE ▁ # # # # ▁ ▁ ▁ ▁ ▁ # ▁ ▁ ▁ ▁ ▁ ▁ # ▁ ▁ ▁ ▁ # # # # # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ # ▁ # ▁ # STRNEWLINE ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ ▁ ▁ ▁ ▁ ▁ # ▁ ▁ ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ # ▁ ▁ # # STRNEWLINE ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ ▁ ▁ ▁ ▁ ▁ # ▁ ▁ ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ ▁ # # # ▁ ▁ ▁ # ▁ ▁ ▁ # ''' NEW_LINE lines = py . replace ( ' # ' , ' < < < ' ) . replace ( ' ▁ ' , ' X ' ) . replace ( ' X ' , ' ▁ ▁ ▁ ' ) . replace ( ' \n ' , ' ▁ Y ' ) . replace ( ' < ▁ ' , ' < > ' ) . split ( ' Y ' ) NEW_LINE for i , l in enumerate ( lines ) : NEW_LINE INDENT print ( ' ▁ ▁ ' * ( len ( lines ) - i ) + l ) NEW_LINE DEDENT
import win32api NEW_LINE import win32con NEW_LINE import win32evtlog NEW_LINE import win32security NEW_LINE import win32evtlogutil NEW_LINE ph = win32api . GetCurrentProcess ( ) NEW_LINE th = win32security . OpenProcessToken ( ph , win32con . TOKEN_READ ) NEW_LINE my_sid = win32security . GetTokenInformation ( th , win32security . TokenUser ) [ 0 ] NEW_LINE applicationName = " My ▁ Application " NEW_LINE eventID = 1 NEW_LINE category = 5 NEW_LINE myType = win32evtlog . EVENTLOG_WARNING_TYPE NEW_LINE descr = [ " A ▁ warning " , " An ▁ even ▁ more ▁ dire ▁ warning " ] NEW_LINE data = " Application\0Data " . encode ( " ascii " ) NEW_LINE win32evtlogutil . ReportEvent ( applicationName , eventID , eventCategory = category , eventType = myType , strings = descr , data = data , sid = my_sid ) NEW_LINE
from __future__ import print_function NEW_LINE import lxml NEW_LINE from lxml import etree NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT parser = etree . XMLParser ( dtd_validation = True ) NEW_LINE schema_root = etree . XML ( ''' \ STRNEWLINE TABSYMBOL TABSYMBOL < xsd : schema ▁ xmlns : xsd = " http : / / www . w3 . org / 2001 / XMLSchema " > STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL < xsd : element ▁ name = " a " ▁ type = " xsd : integer " / > STRNEWLINE TABSYMBOL TABSYMBOL < / xsd : schema > STRNEWLINE TABSYMBOL TABSYMBOL ''' ) NEW_LINE schema = etree . XMLSchema ( schema_root ) NEW_LINE parser = etree . XMLParser ( schema = schema ) NEW_LINE try : NEW_LINE INDENT root = etree . fromstring ( " < a > 5 < / a > " , parser ) NEW_LINE print ( " Finished ▁ validating ▁ good ▁ xml " ) NEW_LINE DEDENT except lxml . etree . XMLSyntaxError as err : NEW_LINE INDENT print ( err ) NEW_LINE DEDENT parser = etree . XMLParser ( schema = schema ) NEW_LINE try : NEW_LINE INDENT root = etree . fromstring ( " < a > 5 < b > foobar < / b > < / a > " , parser ) NEW_LINE DEDENT except lxml . etree . XMLSyntaxError as err : NEW_LINE INDENT print ( err ) NEW_LINE DEDENT DEDENT
from xml . dom . minidom import getDOMImplementation NEW_LINE dom = getDOMImplementation ( ) NEW_LINE document = dom . createDocument ( None , " root " , None ) NEW_LINE topElement = document . documentElement NEW_LINE firstElement = document . createElement ( " element " ) NEW_LINE topElement . appendChild ( firstElement ) NEW_LINE textNode = document . createTextNode ( " Some ▁ text ▁ here " ) NEW_LINE firstElement . appendChild ( textNode ) NEW_LINE xmlString = document . toprettyxml ( " ▁ " * 4 ) NEW_LINE
def main ( ) : NEW_LINE INDENT print ( showList ( take ( 30 ) ( yellowstone ( ) ) ) ) NEW_LINE pyplot . plot ( take ( 100 ) ( yellowstone ( ) ) ) NEW_LINE pyplot . xlabel ( main . __doc__ ) NEW_LINE pyplot . show ( ) NEW_LINE DEDENT
import copy NEW_LINE class Zeckendorf : NEW_LINE INDENT def __init__ ( self , x = '0' ) : NEW_LINE INDENT q = 1 NEW_LINE i = len ( x ) - 1 NEW_LINE self . dLen = int ( i / 2 ) NEW_LINE self . dVal = 0 NEW_LINE while i >= 0 : NEW_LINE INDENT self . dVal = self . dVal + ( ord ( x [ i ] ) - ord ( '0' ) ) * q NEW_LINE q = q * 2 NEW_LINE i = i - 1 NEW_LINE DEDENT DEDENT def a ( self , n ) : NEW_LINE INDENT i = n NEW_LINE while True : NEW_LINE INDENT if self . dLen < i : NEW_LINE INDENT self . dLen = i NEW_LINE DEDENT j = ( self . dVal >> ( i * 2 ) ) & 3 NEW_LINE if j == 0 or j == 1 : NEW_LINE INDENT return NEW_LINE DEDENT if j == 2 : NEW_LINE INDENT if ( self . dVal >> ( ( i + 1 ) * 2 ) & 1 ) != 1 : NEW_LINE INDENT return NEW_LINE DEDENT self . dVal = self . dVal + ( 1 << ( i * 2 + 1 ) ) NEW_LINE return NEW_LINE DEDENT if j == 3 : NEW_LINE INDENT temp = 3 << ( i * 2 ) NEW_LINE temp = temp ^ - 1 NEW_LINE self . dVal = self . dVal & temp NEW_LINE self . b ( ( i + 1 ) * 2 ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT def b ( self , pos ) : NEW_LINE INDENT if pos == 0 : NEW_LINE INDENT self . inc ( ) NEW_LINE return NEW_LINE DEDENT if ( self . dVal >> pos ) & 1 == 0 : NEW_LINE INDENT self . dVal = self . dVal + ( 1 << pos ) NEW_LINE self . a ( int ( pos / 2 ) ) NEW_LINE if pos > 1 : NEW_LINE INDENT self . a ( int ( pos / 2 ) - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp = 1 << pos NEW_LINE temp = temp ^ - 1 NEW_LINE self . dVal = self . dVal & temp NEW_LINE self . b ( pos + 1 ) NEW_LINE self . b ( pos - ( 2 if pos > 1 else 1 ) ) NEW_LINE DEDENT DEDENT def c ( self , pos ) : NEW_LINE INDENT if ( self . dVal >> pos ) & 1 == 1 : NEW_LINE INDENT temp = 1 << pos NEW_LINE temp = temp ^ - 1 NEW_LINE self . dVal = self . dVal & temp NEW_LINE return NEW_LINE DEDENT self . c ( pos + 1 ) NEW_LINE if pos > 0 : NEW_LINE INDENT self . b ( pos - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT self . inc ( ) NEW_LINE DEDENT DEDENT def inc ( self ) : NEW_LINE INDENT self . dVal = self . dVal + 1 NEW_LINE self . a ( 0 ) NEW_LINE DEDENT def __add__ ( self , rhs ) : NEW_LINE INDENT copy = self NEW_LINE rhs_dVal = rhs . dVal NEW_LINE limit = ( rhs . dLen + 1 ) * 2 NEW_LINE for gn in range ( 0 , limit ) : NEW_LINE INDENT if ( ( rhs_dVal >> gn ) & 1 ) == 1 : NEW_LINE INDENT copy . b ( gn ) NEW_LINE DEDENT DEDENT return copy NEW_LINE DEDENT def __sub__ ( self , rhs ) : NEW_LINE INDENT copy = self NEW_LINE rhs_dVal = rhs . dVal NEW_LINE limit = ( rhs . dLen + 1 ) * 2 NEW_LINE for gn in range ( 0 , limit ) : NEW_LINE INDENT if ( rhs_dVal >> gn ) & 1 == 1 : NEW_LINE INDENT copy . c ( gn ) NEW_LINE DEDENT DEDENT while ( ( ( copy . dVal >> ( ( copy . dLen * 2 ) & 31 ) ) & 3 ) == 0 ) or ( copy . dLen == 0 ) : NEW_LINE INDENT copy . dLen = copy . dLen - 1 NEW_LINE DEDENT return copy NEW_LINE DEDENT def __mul__ ( self , rhs ) : NEW_LINE INDENT na = copy . deepcopy ( rhs ) NEW_LINE nb = copy . deepcopy ( rhs ) NEW_LINE nr = Zeckendorf ( ) NEW_LINE dVal = self . dVal NEW_LINE for i in range ( 0 , ( self . dLen + 1 ) * 2 ) : NEW_LINE INDENT if ( ( dVal >> i ) & 1 ) > 0 : NEW_LINE INDENT nr = nr + nb NEW_LINE DEDENT nt = copy . deepcopy ( nb ) NEW_LINE nb = nb + na NEW_LINE na = copy . deepcopy ( nt ) NEW_LINE DEDENT return nr NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT dig = [ "00" , "01" , "10" ] NEW_LINE dig1 = [ " " , "1" , "10" ] NEW_LINE if self . dVal == 0 : NEW_LINE INDENT return '0' NEW_LINE DEDENT idx = ( self . dVal >> ( ( self . dLen * 2 ) & 31 ) ) & 3 NEW_LINE sb = dig1 [ idx ] NEW_LINE i = self . dLen - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT idx = ( self . dVal >> ( i * 2 ) ) & 3 NEW_LINE sb = sb + dig [ idx ] NEW_LINE i = i - 1 NEW_LINE DEDENT return sb NEW_LINE DEDENT DEDENT print " Addition : " NEW_LINE g = Zeckendorf ( "10" ) NEW_LINE g = g + Zeckendorf ( "10" ) NEW_LINE print g NEW_LINE g = g + Zeckendorf ( "10" ) NEW_LINE print g NEW_LINE g = g + Zeckendorf ( "1001" ) NEW_LINE print g NEW_LINE g = g + Zeckendorf ( "1000" ) NEW_LINE print g NEW_LINE g = g + Zeckendorf ( "10101" ) NEW_LINE print g NEW_LINE print NEW_LINE print " Subtraction : " NEW_LINE g = Zeckendorf ( "1000" ) NEW_LINE g = g - Zeckendorf ( "101" ) NEW_LINE print g NEW_LINE g = Zeckendorf ( "10101010" ) NEW_LINE g = g - Zeckendorf ( "1010101" ) NEW_LINE print g NEW_LINE print NEW_LINE print " Multiplication : " NEW_LINE g = Zeckendorf ( "1001" ) NEW_LINE g = g * Zeckendorf ( "101" ) NEW_LINE print g NEW_LINE g = Zeckendorf ( "101010" ) NEW_LINE g = g + Zeckendorf ( "101" ) NEW_LINE print g NEW_LINE
from decimal import Decimal NEW_LINE from fractions import Fraction NEW_LINE from itertools import product NEW_LINE zeroes = [ 0 , 0.0 , 0j , Decimal ( 0 ) , Fraction ( 0 , 1 ) , - 0.0 , - 0.0j , Decimal ( - 0.0 ) ] NEW_LINE for i , j in product ( zeroes , repeat = 2 ) : NEW_LINE INDENT try : NEW_LINE INDENT ans = i ** j NEW_LINE DEDENT except : NEW_LINE INDENT ans = ' < Exception ▁ raised > ' NEW_LINE DEDENT print ( f ' { i ! r : > 15 } ▁ * * ▁ { j ! r : < 15 } ▁ = ▁ { ans ! r } ' ) NEW_LINE DEDENT
for i in range ( 0 , 10 , 1 ) : NEW_LINE INDENT print ( ( " ▁ " * ( 10 - i ) ) + ( " * " * ( i * 2 + 1 ) ) ) NEW_LINE DEDENT for i in range ( 10 , - 1 , - 1 ) : NEW_LINE INDENT print ( ( " ▁ " * ( 10 - i ) ) + ( " * " * ( i * 2 + 1 ) ) ) NEW_LINE DEDENT
def binary_search ( array_list , key ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( array_list ) NEW_LINE while start < end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if array_list [ mid ] > key : NEW_LINE INDENT end = mid NEW_LINE DEDENT elif array_list [ mid ] < key : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT try : NEW_LINE INDENT xs = input_list ( args [ 0 ] ) NEW_LINE if len ( xs ) <= 1 : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT print ( bubble_sort ( xs ) ) NEW_LINE DEDENT except ( IndexError , ValueError ) : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE if len ( sys . argv ) != 2 or not sys . argv [ 1 ] : NEW_LINE INDENT print ( " Usage : ▁ please ▁ provide ▁ a ▁ string " ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT counter = dict ( ) NEW_LINE dupes = False NEW_LINE for char in sys . argv [ 1 ] : NEW_LINE INDENT counter . setdefault ( char , 0 ) NEW_LINE counter [ char ] += 1 NEW_LINE if counter [ char ] > 1 : NEW_LINE INDENT dupes = True NEW_LINE DEDENT DEDENT if dupes : NEW_LINE INDENT for key , value in counter . items ( ) : NEW_LINE INDENT if value > 1 : NEW_LINE INDENT print ( f " { key } : ▁ { value } " ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( " No ▁ duplicate ▁ characters " ) NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT try : NEW_LINE INDENT num = int ( args [ 0 ] ) NEW_LINE print ( even_odd ( num ) ) NEW_LINE DEDENT except ( IndexError , ValueError ) : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT DEDENT
def main ( args ) : NEW_LINE INDENT try : NEW_LINE INDENT n = int ( args [ 0 ] ) NEW_LINE if n < 0 : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT elif n >= 996 : NEW_LINE INDENT msg = f ' { n } ! ▁ is ▁ out ▁ of ▁ the ▁ reasonable ▁ bounds ▁ for ▁ calculation ' NEW_LINE exit_with_error ( msg ) NEW_LINE DEDENT print ( factorial ( n ) ) NEW_LINE DEDENT except ( IndexError , ValueError ) : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT DEDENT
def main ( args ) : NEW_LINE INDENT try : NEW_LINE INDENT fibonacci ( int ( args [ 0 ] ) ) NEW_LINE DEDENT except ( IndexError , ValueError ) : NEW_LINE INDENT print ( " Usage : ▁ please ▁ input ▁ the ▁ count ▁ of ▁ fibonacci ▁ numbers ▁ to ▁ output " ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT DEDENT
def read_file ( ) : NEW_LINE INDENT try : NEW_LINE INDENT with open ( " output . txt " , " r " ) as in_file : NEW_LINE INDENT for line in in_file : NEW_LINE INDENT print ( line . strip ( ) ) NEW_LINE DEDENT DEDENT DEDENT except OSError as e : NEW_LINE INDENT print ( f " Cannot ▁ open ▁ file ▁ to ▁ read : ▁ { e } " ) NEW_LINE return NEW_LINE DEDENT DEDENT
for n in range ( 1 , 101 ) : NEW_LINE INDENT if n % 3 == 0 : NEW_LINE INDENT print ( " FizzBuzz " if n % 5 == 0 else " Fizz " ) NEW_LINE continue NEW_LINE DEDENT print ( " Buzz " if n % 5 == 0 else n ) NEW_LINE DEDENT
print ( ' Hello , ▁ World ! ' ) NEW_LINE
def insertion_sort ( xs ) : NEW_LINE INDENT new_xs = [ ] NEW_LINE for x in xs : NEW_LINE INDENT new_xs = insert ( x , new_xs ) NEW_LINE DEDENT return new_xs NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT try : NEW_LINE INDENT xs = input_list ( args [ 0 ] ) NEW_LINE if len ( xs ) <= 1 : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT print ( insertion_sort ( xs ) ) NEW_LINE DEDENT except ( IndexError , ValueError ) : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT DEDENT
def main ( args ) : NEW_LINE INDENT try : NEW_LINE INDENT profits = input_list ( args [ 0 ] ) NEW_LINE deadlines = input_list ( args [ 1 ] ) NEW_LINE jobs = [ Job ( p , d ) for p , d in zip ( profits , deadlines ) ] NEW_LINE print ( max_profit ( jobs ) ) NEW_LINE DEDENT except ( IndexError , ValueError ) : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT DEDENT
def linear_search ( array : list , key : int ) -> bool : NEW_LINE INDENT for item in array : NEW_LINE INDENT if item == key : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT try : NEW_LINE INDENT lst1 = input_list ( args [ 0 ] ) NEW_LINE lst2 = input_list ( args [ 1 ] ) NEW_LINE print ( lcs ( lst1 , lst2 ) ) NEW_LINE DEDENT except ( IndexError , ValueError ) : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE error = " Usage : ▁ please ▁ provide ▁ a ▁ string " NEW_LINE if len ( sys . argv ) == 1 or sys . argv [ 1 ] == " " : NEW_LINE INDENT print ( error ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT input_string = sys . argv [ 1 ] NEW_LINE longest_word = max ( len ( word ) for word in input_string . split ( ) ) NEW_LINE print ( longest_word ) NEW_LINE
def merge_sort ( xs ) : NEW_LINE INDENT def sort ( xs ) : NEW_LINE INDENT if len ( xs ) <= 0 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT if len ( xs ) == 1 : NEW_LINE INDENT return xs NEW_LINE DEDENT return sort ( [ merge ( xs [ 0 ] , xs [ 1 ] ) ] + sort ( xs [ 2 : ] ) ) NEW_LINE DEDENT split_xs = [ [ x ] for x in xs ] NEW_LINE return sort ( split_xs ) [ 0 ] NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT try : NEW_LINE INDENT xs = input_list ( args [ 0 ] ) NEW_LINE if len ( xs ) <= 1 : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT print ( merge_sort ( xs ) ) NEW_LINE DEDENT except ( IndexError , ValueError ) : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT try : NEW_LINE INDENT palindromic_number ( int ( sys . argv [ 1 ] ) ) NEW_LINE DEDENT except ( IndexError , ValueError ) : NEW_LINE INDENT print ( " Usage : ▁ please ▁ input ▁ a ▁ non - negative ▁ integer " ) NEW_LINE sys . exit ( 1 ) NEW_LINE DEDENT DEDENT
def is_prime ( x ) : NEW_LINE INDENT if ( x % 2 == 0 and x is not 2 ) or ( x == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return not bool ( [ n for n in range ( 3 , int ( ceil ( sqrt ( x ) ) + 1 ) ) if x % n == 0 ] ) NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT try : NEW_LINE INDENT x = int ( args [ 0 ] ) NEW_LINE if x < 0 : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT print ( " Prime " if is_prime ( x ) else " Composite " ) NEW_LINE DEDENT except ( IndexError , ValueError ) : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT DEDENT
def main ( args ) : NEW_LINE INDENT try : NEW_LINE INDENT xs = input_list ( args [ 0 ] ) NEW_LINE if len ( xs ) <= 1 : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT print ( quick_sort ( xs ) ) NEW_LINE DEDENT except ( IndexError , ValueError ) : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT DEDENT
s = ' s = % r ; print ( s % % s ) ' ; print ( s % s ) NEW_LINE
import sys NEW_LINE if len ( sys . argv ) > 1 : NEW_LINE INDENT print ( sys . argv [ 1 ] [ : : - 1 ] ) NEW_LINE DEDENT
def main ( args ) : NEW_LINE INDENT try : NEW_LINE INDENT string = args [ 0 ] NEW_LINE if len ( string ) <= 0 : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT print ( rot_13 ( string ) ) NEW_LINE DEDENT except ( IndexError , ValueError ) : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT DEDENT
def main ( args ) : NEW_LINE INDENT try : NEW_LINE INDENT xs = input_list ( args [ 0 ] ) NEW_LINE if len ( xs ) <= 1 : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT print ( selection_sort ( xs ) ) NEW_LINE DEDENT except ( IndexError , ValueError ) : NEW_LINE INDENT exit_with_error ( ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def twoSum ( self , nums : List [ int ] , target : int ) -> List [ int ] : NEW_LINE INDENT numToIndex = { } NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT if target - num in numToIndex : NEW_LINE INDENT return numToIndex [ target - num ] , i NEW_LINE DEDENT numToIndex [ num ] = i NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def isMatch ( self , s : str , p : str ) -> bool : NEW_LINE INDENT m = len ( s ) NEW_LINE n = len ( p ) NEW_LINE dp = [ [ False ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = True NEW_LINE def isMatch ( i : int , j : int ) -> bool : NEW_LINE INDENT return j >= 0 and p [ j ] == ' . ' or s [ i ] == p [ j ] NEW_LINE DEDENT for j , c in enumerate ( p ) : NEW_LINE INDENT if c == ' * ' and dp [ 0 ] [ j - 1 ] : NEW_LINE INDENT dp [ 0 ] [ j + 1 ] = True NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if p [ j ] == ' * ' : NEW_LINE INDENT noRepeat = dp [ i + 1 ] [ j - 1 ] NEW_LINE doRepeat = isMatch ( i , j - 1 ) and dp [ i ] [ j + 1 ] NEW_LINE dp [ i + 1 ] [ j + 1 ] = noRepeat or doRepeat NEW_LINE DEDENT elif isMatch ( i , j ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isSameTree ( self , p : Optional [ TreeNode ] , q : Optional [ TreeNode ] ) -> bool : NEW_LINE INDENT if not p or not q : NEW_LINE INDENT return p == q NEW_LINE DEDENT return p . val == q . val and self . isSameTree ( p . left , q . left ) and self . isSameTree ( p . right , q . right ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def gridIllumination ( self , N : int , lamps : List [ List [ int ] ] , queries : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE rows = Counter ( ) NEW_LINE cols = Counter ( ) NEW_LINE diag1 = Counter ( ) NEW_LINE diag2 = Counter ( ) NEW_LINE lampsSet = set ( ) NEW_LINE for i , j in lamps : NEW_LINE INDENT if ( i , j ) not in lampsSet : NEW_LINE INDENT lampsSet . add ( ( i , j ) ) NEW_LINE rows [ i ] += 1 NEW_LINE cols [ j ] += 1 NEW_LINE diag1 [ i + j ] += 1 NEW_LINE diag2 [ i - j ] += 1 NEW_LINE DEDENT DEDENT for i , j in queries : NEW_LINE INDENT if rows [ i ] or cols [ j ] or diag1 [ i + j ] or diag2 [ i - j ] : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE for y in range ( max ( 0 , i - 1 ) , min ( N , i + 2 ) ) : NEW_LINE INDENT for x in range ( max ( 0 , j - 1 ) , min ( N , j + 2 ) ) : NEW_LINE INDENT if ( y , x ) in lampsSet : NEW_LINE INDENT lampsSet . remove ( ( y , x ) ) NEW_LINE rows [ y ] -= 1 NEW_LINE cols [ x ] -= 1 NEW_LINE diag1 [ y + x ] -= 1 NEW_LINE diag2 [ y - x ] -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def commonChars ( self , A : List [ str ] ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE commonCount = [ math . inf ] * 26 NEW_LINE for a in A : NEW_LINE INDENT count = [ 0 ] * 26 NEW_LINE for c in a : NEW_LINE INDENT count [ ord ( c ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT commonCount [ i ] = min ( commonCount [ i ] , count [ i ] ) NEW_LINE DEDENT DEDENT for c in string . ascii_lowercase : NEW_LINE INDENT for j in range ( commonCount [ ord ( c ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT ans . append ( c ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isValid ( self , s : str ) -> bool : NEW_LINE INDENT stack = [ ] NEW_LINE for c in s : NEW_LINE INDENT if c == ' c ' : NEW_LINE INDENT if len ( stack ) < 2 or stack [ - 2 ] != ' a ' or stack [ - 1 ] != ' b ' : NEW_LINE INDENT return False NEW_LINE DEDENT stack . pop ( ) NEW_LINE stack . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT stack . append ( c ) NEW_LINE DEDENT DEDENT return not stack NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def clumsy ( self , N : int ) -> int : NEW_LINE INDENT if N == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if N == 2 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if N == 3 : NEW_LINE INDENT return 6 NEW_LINE DEDENT if N == 4 : NEW_LINE INDENT return 7 NEW_LINE DEDENT if N % 4 == 1 : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT if N % 4 == 2 : NEW_LINE INDENT return N + 2 NEW_LINE DEDENT if N % 4 == 3 : NEW_LINE INDENT return N - 1 NEW_LINE DEDENT return N + 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def bstFromPreorder ( self , preorder : List [ int ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT root = TreeNode ( preorder [ 0 ] ) NEW_LINE stack = [ root ] NEW_LINE for i in range ( 1 , len ( preorder ) ) : NEW_LINE INDENT parent = stack [ - 1 ] NEW_LINE child = TreeNode ( preorder [ i ] ) NEW_LINE while stack and stack [ - 1 ] . val < child . val : NEW_LINE INDENT parent = stack . pop ( ) NEW_LINE DEDENT if parent . val > child . val : NEW_LINE INDENT parent . left = child NEW_LINE DEDENT else : NEW_LINE INDENT parent . right = child NEW_LINE DEDENT stack . append ( child ) NEW_LINE DEDENT return root NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def bitwiseComplement ( self , N : int ) -> int : NEW_LINE INDENT mask = 1 NEW_LINE while mask < N : NEW_LINE INDENT mask = ( mask << 1 ) + 1 NEW_LINE DEDENT return mask ^ N NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isSymmetric ( self , root : Optional [ TreeNode ] ) -> bool : NEW_LINE INDENT def isSymmetric ( p : Optional [ TreeNode ] , q : Optional [ TreeNode ] ) -> bool : NEW_LINE INDENT if not p or not q : NEW_LINE INDENT return p == q NEW_LINE DEDENT return p . val == q . val and isSymmetric ( p . left , q . right ) and isSymmetric ( p . right , q . left ) NEW_LINE DEDENT return isSymmetric ( root , root ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numPairsDivisibleBy60 ( self , time : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = [ 0 ] * 60 NEW_LINE for t in time : NEW_LINE INDENT t %= 60 NEW_LINE ans += count [ ( 60 - t ) % 60 ] NEW_LINE count [ t ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def shipWithinDays ( self , weights : List [ int ] , days : int ) -> int : NEW_LINE INDENT l = max ( weights ) NEW_LINE r = sum ( weights ) NEW_LINE def shipDays ( shipCapacity : int ) -> int : NEW_LINE INDENT days = 1 NEW_LINE capacity = 0 NEW_LINE for weight in weights : NEW_LINE INDENT if capacity + weight > shipCapacity : NEW_LINE INDENT days += 1 NEW_LINE capacity = weight NEW_LINE DEDENT else : NEW_LINE INDENT capacity += weight NEW_LINE DEDENT DEDENT return days NEW_LINE DEDENT while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if shipDays ( m ) <= days : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numDupDigitsAtMostN ( self , n : int ) -> int : NEW_LINE INDENT return n - self . _countSpecialNumbers ( n ) NEW_LINE DEDENT def _countSpecialNumbers ( self , n : int ) -> int : NEW_LINE INDENT s = str ( n ) NEW_LINE digitSize = int ( log10 ( n ) ) + 1 NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( digitSize : int , usedMask : int , isTight : bool ) -> int : NEW_LINE INDENT if digitSize == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE maxDigit = ord ( s [ len ( s ) - digitSize ] ) - ord ( '0' ) if isTight else 9 NEW_LINE for digit in range ( maxDigit + 1 ) : NEW_LINE INDENT if usedMask >> digit & 1 : NEW_LINE INDENT continue NEW_LINE DEDENT nextIsTight = isTight and ( digit == maxDigit ) NEW_LINE if usedMask == 0 and digit == 0 : NEW_LINE INDENT ans += dp ( digitSize - 1 , usedMask , nextIsTight ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += dp ( digitSize - 1 , usedMask | 1 << digit , nextIsTight ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return dp ( digitSize , 0 , True ) - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canThreePartsEqualSum ( self , A : List [ int ] ) -> bool : NEW_LINE INDENT summ = sum ( A ) NEW_LINE prefix = 0 NEW_LINE parts = 1 NEW_LINE for a in A : NEW_LINE INDENT prefix += a NEW_LINE if prefix == summ * parts // 3 : NEW_LINE INDENT parts += 1 NEW_LINE DEDENT DEDENT return summ % 3 == 0 and parts >= 3 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxScoreSightseeingPair ( self , A : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE bestPrev = 0 NEW_LINE for a in A : NEW_LINE INDENT ans = max ( ans , a + bestPrev ) NEW_LINE bestPrev = max ( bestPrev , a ) - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestRepunitDivByK ( self , K : int ) -> int : NEW_LINE INDENT if K % 10 not in { 1 , 3 , 7 , 9 } : NEW_LINE INDENT return - 1 NEW_LINE DEDENT seen = set ( ) NEW_LINE N = 0 NEW_LINE for length in range ( 1 , K + 1 ) : NEW_LINE INDENT N = ( N * 10 + 1 ) % K NEW_LINE if N == 0 : NEW_LINE INDENT return length NEW_LINE DEDENT if N in seen : NEW_LINE INDENT return - 1 NEW_LINE DEDENT seen . add ( N ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def queryString ( self , S : str , N : int ) -> bool : NEW_LINE INDENT if N > 1511 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( N , N // 2 , - 1 ) : NEW_LINE INDENT if format ( i , ' b ' ) not in S : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def baseNeg2 ( self , N : int ) -> str : NEW_LINE INDENT ans = ' ' NEW_LINE while N : NEW_LINE INDENT ans = str ( N & 1 ) + ans NEW_LINE N = - ( N >> 1 ) NEW_LINE DEDENT return '0' if ans == ' ' else ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def prefixesDivBy5 ( self , A : List [ int ] ) -> List [ bool ] : NEW_LINE INDENT ans = [ ] NEW_LINE num = 0 NEW_LINE for a in A : NEW_LINE INDENT num = ( num * 2 + a ) % 5 NEW_LINE ans . append ( num % 5 == 0 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nextLargerNodes ( self , head : ListNode ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE stack = [ ] NEW_LINE while head : NEW_LINE INDENT while stack and head . val > ans [ stack [ - 1 ] ] : NEW_LINE INDENT index = stack . pop ( ) NEW_LINE ans [ index ] = head . val NEW_LINE DEDENT stack . append ( len ( ans ) ) NEW_LINE ans . append ( head . val ) NEW_LINE head = head . next NEW_LINE DEDENT for i in stack : NEW_LINE INDENT ans [ i ] = 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def levelOrder ( self , root : Optional [ TreeNode ] ) -> List [ List [ int ] ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return [ ] NEW_LINE DEDENT ans = [ ] NEW_LINE q = deque ( [ root ] ) NEW_LINE while q : NEW_LINE INDENT currLevel = [ ] NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT node = q . popleft ( ) NEW_LINE currLevel . append ( node . val ) NEW_LINE if node . left : NEW_LINE INDENT q . append ( node . left ) NEW_LINE DEDENT if node . right : NEW_LINE INDENT q . append ( node . right ) NEW_LINE DEDENT DEDENT ans . append ( currLevel ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def camelMatch ( self , queries : List [ str ] , pattern : str ) -> List [ bool ] : NEW_LINE INDENT def isMatch ( q : str ) -> bool : NEW_LINE INDENT j = 0 NEW_LINE for i , c in enumerate ( q ) : NEW_LINE INDENT if j < len ( pattern ) and c == pattern [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif c . isupper ( ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return j == len ( pattern ) NEW_LINE DEDENT return [ isMatch ( q ) for q in queries ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def videoStitching ( self , clips : List [ List [ int ] ] , time : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE end = 0 NEW_LINE farthest = 0 NEW_LINE clips . sort ( ) NEW_LINE i = 0 NEW_LINE while farthest < time : NEW_LINE INDENT while i < len ( clips ) and clips [ i ] [ 0 ] <= end : NEW_LINE INDENT farthest = max ( farthest , clips [ i ] [ 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT if end == farthest : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans += 1 NEW_LINE end = farthest NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def divisorGame ( self , N : int ) -> bool : NEW_LINE INDENT return N % 2 == 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestArithSeqLength ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE ans = 0 NEW_LINE dp = [ [ 0 ] * 1001 for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT k = nums [ i ] - nums [ j ] + 500 NEW_LINE dp [ i ] [ k ] = max ( 2 , dp [ j ] [ k ] + 1 ) NEW_LINE ans = max ( ans , dp [ i ] [ k ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def twoCitySchedCost ( self , costs : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( costs ) // 2 NEW_LINE costs . sort ( key = lambda x : x [ 0 ] - x [ 1 ] ) NEW_LINE return sum ( costs [ i ] [ 0 ] + costs [ i + n ] [ 1 ] for i in range ( n ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def zigzagLevelOrder ( self , root : Optional [ TreeNode ] ) -> List [ List [ int ] ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return [ ] NEW_LINE DEDENT ans = [ ] NEW_LINE q = deque ( [ root ] ) NEW_LINE isLeftToRight = True NEW_LINE while q : NEW_LINE INDENT currLevel = [ ] NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT if isLeftToRight : NEW_LINE INDENT node = q . popleft ( ) NEW_LINE currLevel . append ( node . val ) NEW_LINE if node . left : NEW_LINE INDENT q . append ( node . left ) NEW_LINE DEDENT if node . right : NEW_LINE INDENT q . append ( node . right ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT node = q . pop ( ) NEW_LINE currLevel . append ( node . val ) NEW_LINE if node . right : NEW_LINE INDENT q . appendleft ( node . right ) NEW_LINE DEDENT if node . left : NEW_LINE INDENT q . appendleft ( node . left ) NEW_LINE DEDENT DEDENT DEDENT ans . append ( currLevel ) NEW_LINE isLeftToRight = not isLeftToRight NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxSumTwoNoOverlap ( self , nums : List [ int ] , firstLen : int , secondLen : int ) -> int : NEW_LINE INDENT def helper ( l : int , r : int ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE left = [ 0 ] * n NEW_LINE summ = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT summ += nums [ i ] NEW_LINE if i >= l : NEW_LINE INDENT summ -= nums [ i - l ] NEW_LINE DEDENT if i >= l - 1 : NEW_LINE INDENT left [ i ] = max ( left [ i - 1 ] , summ ) if i > 0 else summ NEW_LINE DEDENT DEDENT right = [ 0 ] * n NEW_LINE summ = 0 NEW_LINE for i in reversed ( range ( n ) ) : NEW_LINE INDENT summ += nums [ i ] NEW_LINE if i <= n - r - 1 : NEW_LINE INDENT summ -= nums [ i + r ] NEW_LINE DEDENT if i <= n - r : NEW_LINE INDENT right [ i ] = max ( right [ i + 1 ] , summ ) if i < n - 1 else summ NEW_LINE DEDENT DEDENT return max ( left [ i ] + right [ i + 1 ] for i in range ( n - 1 ) ) NEW_LINE DEDENT return max ( helper ( firstLen , secondLen ) , helper ( secondLen , firstLen ) ) NEW_LINE DEDENT DEDENT
class TrieNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . children : Dict [ str , TrieNode ] = defaultdict ( TrieNode ) NEW_LINE self . isWord = False NEW_LINE DEDENT DEDENT class StreamChecker : NEW_LINE INDENT def __init__ ( self , words : List [ str ] ) : NEW_LINE INDENT self . root = TrieNode ( ) NEW_LINE self . letters = [ ] NEW_LINE for word in words : NEW_LINE INDENT self . _insert ( word ) NEW_LINE DEDENT DEDENT def query ( self , letter : str ) -> bool : NEW_LINE INDENT self . letters . append ( letter ) NEW_LINE node = self . root NEW_LINE for c in reversed ( self . letters ) : NEW_LINE INDENT if c not in node . children : NEW_LINE INDENT return False NEW_LINE DEDENT node = node . children [ c ] NEW_LINE if node . isWord : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def _insert ( self , word : str ) -> None : NEW_LINE INDENT node = self . root NEW_LINE for c in reversed ( word ) : NEW_LINE INDENT if c not in node . children : NEW_LINE INDENT node . children [ c ] = TrieNode ( ) NEW_LINE DEDENT node = node . children [ c ] NEW_LINE DEDENT node . isWord = True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numMovesStones ( self , a : int , b : int , c : int ) -> List [ int ] : NEW_LINE INDENT nums = sorted ( [ a , b , c ] ) NEW_LINE if nums [ 2 ] - nums [ 0 ] == 2 : NEW_LINE INDENT return [ 0 , 0 ] NEW_LINE DEDENT return [ 1 if min ( nums [ 1 ] - nums [ 0 ] , nums [ 2 ] - nums [ 1 ] ) <= 2 else 2 , nums [ 2 ] - nums [ 0 ] - 2 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def colorBorder ( self , grid : List [ List [ int ] ] , r0 : int , c0 : int , color : int ) -> List [ List [ int ] ] : NEW_LINE INDENT def dfs ( i : int , j : int , originalColor : int ) -> None : NEW_LINE INDENT if not 0 <= i < len ( grid ) or not 0 <= j < len ( grid [ 0 ] ) or grid [ i ] [ j ] != originalColor : NEW_LINE INDENT return NEW_LINE DEDENT grid [ i ] [ j ] = - originalColor NEW_LINE dfs ( i + 1 , j , originalColor ) NEW_LINE dfs ( i - 1 , j , originalColor ) NEW_LINE dfs ( i , j + 1 , originalColor ) NEW_LINE dfs ( i , j - 1 , originalColor ) NEW_LINE if 0 < i < len ( grid ) - 1 and 0 < j < len ( grid [ 0 ] ) - 1 and abs ( grid [ i + 1 ] [ j ] ) == originalColor and abs ( grid [ i - 1 ] [ j ] ) == originalColor and abs ( grid [ i ] [ j + 1 ] ) == originalColor and abs ( grid [ i ] [ j - 1 ] ) == originalColor : NEW_LINE INDENT grid [ i ] [ j ] = originalColor NEW_LINE DEDENT DEDENT dfs ( r0 , c0 , grid [ r0 ] [ c0 ] ) NEW_LINE for i in range ( len ( grid ) ) : NEW_LINE INDENT for j in range ( len ( grid [ 0 ] ) ) : NEW_LINE INDENT if grid [ i ] [ j ] < 0 : NEW_LINE INDENT grid [ i ] [ j ] = color NEW_LINE DEDENT DEDENT DEDENT return grid NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxUncrossedLines ( self , A : List [ int ] , B : List [ int ] ) -> int : NEW_LINE INDENT m = len ( A ) NEW_LINE n = len ( B ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + 1 if A [ i - 1 ] == B [ j - 1 ] else max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isEscapePossible ( self , blocked : List [ List [ int ] ] , source : List [ int ] , target : List [ int ] ) -> bool : NEW_LINE INDENT def dfs ( i : int , j : int , target : List [ int ] , visited : set ) -> bool : NEW_LINE INDENT if not 0 <= i < 10 ** 6 or not 0 <= j < 10 ** 6 or ( i , j ) in blocked or ( i , j ) in visited : NEW_LINE INDENT return False NEW_LINE DEDENT visited . add ( ( i , j ) ) NEW_LINE if len ( visited ) > ( 1 + 199 ) * 199 // 2 or [ i , j ] == target : NEW_LINE INDENT return True NEW_LINE DEDENT return dfs ( i + 1 , j , target , visited ) or dfs ( i - 1 , j , target , visited ) or dfs ( i , j + 1 , target , visited ) or dfs ( i , j - 1 , target , visited ) NEW_LINE DEDENT blocked = set ( tuple ( b ) for b in blocked ) NEW_LINE return dfs ( source [ 0 ] , source [ 1 ] , target , set ( ) ) and dfs ( target [ 0 ] , target [ 1 ] , source , set ( ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isBoomerang ( self , points : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT return ( points [ 1 ] [ 0 ] - points [ 0 ] [ 0 ] ) * ( points [ 2 ] [ 1 ] - points [ 1 ] [ 1 ] ) != ( points [ 1 ] [ 1 ] - points [ 0 ] [ 1 ] ) * ( points [ 2 ] [ 0 ] - points [ 1 ] [ 0 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxDepth ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 + max ( self . maxDepth ( root . left ) , self . maxDepth ( root . right ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numMovesStonesII ( self , stones : List [ int ] ) -> List [ int ] : NEW_LINE INDENT n = len ( stones ) NEW_LINE minMoves = n NEW_LINE stones . sort ( ) NEW_LINE l = 0 NEW_LINE for r , stone in enumerate ( stones ) : NEW_LINE INDENT while stone - stones [ l ] + 1 > n : NEW_LINE INDENT l += 1 NEW_LINE DEDENT alreadyStored = r - l + 1 NEW_LINE if alreadyStored == n - 1 and stone - stones [ l ] + 1 == n - 1 : NEW_LINE INDENT minMoves = 2 NEW_LINE DEDENT else : NEW_LINE INDENT minMoves = min ( minMoves , n - alreadyStored ) NEW_LINE DEDENT DEDENT return [ minMoves , max ( stones [ n - 1 ] - stones [ 1 ] - n + 2 , stones [ n - 2 ] - stones [ 0 ] - n + 2 ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isRobotBounded ( self , instructions : str ) -> bool : NEW_LINE INDENT x = 0 NEW_LINE y = 0 NEW_LINE d = 0 NEW_LINE directions = [ ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ] NEW_LINE for instruction in instructions : NEW_LINE INDENT if instruction == ' G ' : NEW_LINE INDENT x += directions [ d ] [ 0 ] NEW_LINE y += directions [ d ] [ 1 ] NEW_LINE DEDENT elif instruction == ' L ' : NEW_LINE INDENT d = ( d + 3 ) % 4 NEW_LINE DEDENT else : NEW_LINE INDENT d = ( d + 1 ) % 4 NEW_LINE DEDENT DEDENT return ( x , y ) == ( 0 , 0 ) or d > 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def gardenNoAdj ( self , n : int , paths : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * n NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE for a , b in paths : NEW_LINE INDENT u = a - 1 NEW_LINE v = b - 1 NEW_LINE graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT used = [ False ] * 5 NEW_LINE for v in graph [ i ] : NEW_LINE INDENT used [ ans [ v ] ] = True NEW_LINE DEDENT for type in range ( 1 , 5 ) : NEW_LINE INDENT if not used [ type ] : NEW_LINE INDENT ans [ i ] = type NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestDupSubstring ( self , s : str ) -> str : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE bestStart = - 1 NEW_LINE l = 1 NEW_LINE r = len ( s ) NEW_LINE def val ( c : str ) -> int : NEW_LINE INDENT return ord ( c ) - ord ( ' a ' ) NEW_LINE DEDENT def getStart ( k : int ) -> Optional [ int ] : NEW_LINE INDENT maxPow = pow ( 26 , k - 1 , kMod ) NEW_LINE hashedToStart = defaultdict ( list ) NEW_LINE h = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT h = ( h * 26 + val ( s [ i ] ) ) % kMod NEW_LINE DEDENT hashedToStart [ h ] . append ( 0 ) NEW_LINE for i in range ( k , len ( s ) ) : NEW_LINE INDENT startIndex = i - k + 1 NEW_LINE h = ( h - maxPow * val ( s [ i - k ] ) ) % kMod NEW_LINE h = ( h * 26 + val ( s [ i ] ) ) % kMod NEW_LINE if h in hashedToStart : NEW_LINE INDENT currSub = s [ startIndex : startIndex + k ] NEW_LINE for start in hashedToStart [ h ] : NEW_LINE INDENT if s [ start : start + k ] == currSub : NEW_LINE INDENT return startIndex NEW_LINE DEDENT DEDENT DEDENT hashedToStart [ h ] . append ( startIndex ) NEW_LINE DEDENT DEDENT while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE start : Optional [ int ] = getStart ( m ) NEW_LINE if start : NEW_LINE INDENT bestStart = start NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT if bestStart == - 1 : NEW_LINE INDENT return ' ' NEW_LINE DEDENT if getStart ( l ) : NEW_LINE INDENT return s [ bestStart : bestStart + l ] NEW_LINE DEDENT return s [ bestStart : bestStart + l - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestStrChain ( self , words : List [ str ] ) -> int : NEW_LINE INDENT wordsSet = set ( words ) NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( s : str ) -> int : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT pred = s [ : i ] + s [ i + 1 : ] NEW_LINE if pred in wordsSet : NEW_LINE INDENT ans = max ( ans , dp ( pred ) + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return max ( dp ( word ) for word in words ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def lastStoneWeightII ( self , stones : List [ int ] ) -> int : NEW_LINE INDENT summ = sum ( stones ) NEW_LINE s = 0 NEW_LINE dp = [ True ] + [ False ] * summ NEW_LINE for stone in stones : NEW_LINE INDENT for w in range ( summ // 2 + 1 ) [ : : - 1 ] : NEW_LINE INDENT if w >= stone : NEW_LINE INDENT dp [ w ] = dp [ w ] or dp [ w - stone ] NEW_LINE DEDENT if dp [ w ] : NEW_LINE INDENT s = max ( s , w ) NEW_LINE DEDENT DEDENT DEDENT return summ - 2 * s NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def buildTree ( self , preorder : List [ int ] , inorder : List [ int ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT inToIndex = { num : i for i , num in enumerate ( inorder ) } NEW_LINE def build ( preStart : int , preEnd : int , inStart : int , inEnd : int ) -> Optional [ TreeNode ] : NEW_LINE INDENT if preStart > preEnd : NEW_LINE INDENT return None NEW_LINE DEDENT rootVal = preorder [ preStart ] NEW_LINE rootInIndex = inToIndex [ rootVal ] NEW_LINE leftSize = rootInIndex - inStart NEW_LINE root = TreeNode ( rootVal ) NEW_LINE root . left = build ( preStart + 1 , preStart + leftSize , inStart , rootInIndex - 1 ) NEW_LINE root . right = build ( preStart + leftSize + 1 , preEnd , rootInIndex + 1 , inEnd ) NEW_LINE return root NEW_LINE DEDENT return build ( 0 , len ( preorder ) - 1 , 0 , len ( inorder ) - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def heightChecker ( self , heights : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE currentHeight = 1 NEW_LINE count = [ 0 ] * 101 NEW_LINE for height in heights : NEW_LINE INDENT count [ height ] += 1 NEW_LINE DEDENT for height in heights : NEW_LINE INDENT while count [ currentHeight ] == 0 : NEW_LINE INDENT currentHeight += 1 NEW_LINE DEDENT if height != currentHeight : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT count [ currentHeight ] -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxSatisfied ( self , customers : List [ int ] , grumpy : List [ int ] , X : int ) -> int : NEW_LINE INDENT satisfied = sum ( c for i , c in enumerate ( customers ) if grumpy [ i ] == 0 ) NEW_LINE madeSatisfied = 0 NEW_LINE windowSatisfied = 0 NEW_LINE for i , customer in enumerate ( customers ) : NEW_LINE INDENT if grumpy [ i ] == 1 : NEW_LINE INDENT windowSatisfied += customer NEW_LINE DEDENT if i >= X and grumpy [ i - X ] == 1 : NEW_LINE INDENT windowSatisfied -= customers [ i - X ] NEW_LINE DEDENT madeSatisfied = max ( madeSatisfied , windowSatisfied ) NEW_LINE DEDENT return satisfied + madeSatisfied NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def prevPermOpt1 ( self , A : List [ int ] ) -> List [ int ] : NEW_LINE INDENT n = len ( A ) NEW_LINE l = n - 2 NEW_LINE r = n - 1 NEW_LINE while l >= 0 and A [ l ] <= A [ l + 1 ] : NEW_LINE INDENT l -= 1 NEW_LINE DEDENT if l < 0 : NEW_LINE INDENT return A NEW_LINE DEDENT while A [ r ] >= A [ l ] or A [ r ] == A [ r - 1 ] : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT A [ l ] , A [ r ] = A [ r ] , A [ l ] NEW_LINE return A NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rearrangeBarcodes ( self , barcodes : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * len ( barcodes ) NEW_LINE count = Counter ( barcodes ) NEW_LINE i = 0 NEW_LINE maxNum = max ( count , key = count . get ) NEW_LINE def fillAns ( num : int ) -> None : NEW_LINE INDENT nonlocal i NEW_LINE while count [ num ] : NEW_LINE INDENT ans [ i ] = num NEW_LINE i = i + 2 if i + 2 < len ( barcodes ) else 1 NEW_LINE count [ num ] -= 1 NEW_LINE DEDENT DEDENT fillAns ( maxNum ) NEW_LINE for num in count . keys ( ) : NEW_LINE INDENT fillAns ( num ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def assignBikes ( self , workers : List [ List [ int ] ] , bikes : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ - 1 ] * len ( workers ) NEW_LINE usedBikes = [ False ] * len ( bikes ) NEW_LINE buckets = [ [ ] for _ in range ( 2001 ) ] NEW_LINE def dist ( p1 : List [ int ] , p2 : List [ int ] ) -> int : NEW_LINE INDENT return abs ( p1 [ 0 ] - p2 [ 0 ] ) + abs ( p1 [ 1 ] - p2 [ 1 ] ) NEW_LINE DEDENT for i , worker in enumerate ( workers ) : NEW_LINE INDENT for j , bike in enumerate ( bikes ) : NEW_LINE INDENT buckets [ dist ( worker , bike ) ] . append ( ( i , j ) ) NEW_LINE DEDENT DEDENT for k in range ( 2001 ) : NEW_LINE INDENT for i , j in buckets [ k ] : NEW_LINE INDENT if ans [ i ] == - 1 and not usedBikes [ j ] : NEW_LINE INDENT ans [ i ] = j NEW_LINE usedBikes [ j ] = True NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimizeError ( self , prices : List [ str ] , target : int ) -> str : NEW_LINE INDENT A = [ ] NEW_LINE sumFloored = 0 NEW_LINE sumCeiled = 0 NEW_LINE for price in map ( float , prices ) : NEW_LINE INDENT floored = math . floor ( price ) NEW_LINE ceiled = math . ceil ( price ) NEW_LINE sumFloored += floored NEW_LINE sumCeiled += ceiled NEW_LINE costFloor = price - floored NEW_LINE costCeil = ceiled - price NEW_LINE A . append ( ( costCeil - costFloor , costCeil , costFloor ) ) NEW_LINE DEDENT if not sumFloored <= target <= sumCeiled : NEW_LINE INDENT return ' - 1' NEW_LINE DEDENT A . sort ( ) NEW_LINE nCeiled = target - sumFloored NEW_LINE return ' { : . 3f } ' . format ( sum ( a [ 1 ] for a in A [ : nCeiled ] ) + sum ( a [ 2 ] for a in A [ nCeiled : ] ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def buildTree ( self , inorder : List [ int ] , postorder : List [ int ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT inToIndex = { num : i for i , num in enumerate ( inorder ) } NEW_LINE def build ( inStart : int , inEnd : int , postStart : int , postEnd : int ) -> Optional [ TreeNode ] : NEW_LINE INDENT if inStart > inEnd : NEW_LINE INDENT return None NEW_LINE DEDENT rootVal = postorder [ postEnd ] NEW_LINE rootInIndex = inToIndex [ rootVal ] NEW_LINE leftSize = rootInIndex - inStart NEW_LINE root = TreeNode ( rootVal ) NEW_LINE root . left = build ( inStart , rootInIndex - 1 , postStart , postStart + leftSize - 1 ) NEW_LINE root . right = build ( rootInIndex + 1 , inEnd , postStart + leftSize , postEnd - 1 ) NEW_LINE return root NEW_LINE DEDENT return build ( 0 , len ( inorder ) - 1 , 0 , len ( postorder ) - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def validSubarrays ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE stack = [ ] NEW_LINE for num in nums : NEW_LINE INDENT while stack and stack [ - 1 ] > num : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT stack . append ( num ) NEW_LINE ans += len ( stack ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def assignBikes ( self , workers : List [ List [ int ] ] , bikes : List [ List [ int ] ] ) -> int : NEW_LINE INDENT def dist ( p1 : List [ int ] , p2 : List [ int ] ) -> int : NEW_LINE INDENT return abs ( p1 [ 0 ] - p2 [ 0 ] ) + abs ( p1 [ 1 ] - p2 [ 1 ] ) NEW_LINE DEDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( s : int , bikeUsed : int ) -> int : NEW_LINE INDENT if s == len ( workers ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = math . inf NEW_LINE for i , bike in enumerate ( bikes ) : NEW_LINE INDENT if bikeUsed >> i & 1 : NEW_LINE INDENT continue NEW_LINE DEDENT ans = min ( ans , dist ( workers [ s ] , bike ) + dp ( s + 1 , bikeUsed | 1 << i ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT return dp ( 0 , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def levelOrderBottom ( self , root : Optional [ TreeNode ] ) -> List [ List [ int ] ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return [ ] NEW_LINE DEDENT ans = [ ] NEW_LINE q = deque ( [ root ] ) NEW_LINE while q : NEW_LINE INDENT currLevel = [ ] NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT node = q . popleft ( ) NEW_LINE currLevel . append ( node . val ) NEW_LINE if node . left : NEW_LINE INDENT q . append ( node . left ) NEW_LINE DEDENT if node . right : NEW_LINE INDENT q . append ( node . right ) NEW_LINE DEDENT DEDENT ans . append ( currLevel ) NEW_LINE DEDENT return ans [ : : - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def gcdOfStrings ( self , str1 : str , str2 : str ) -> str : NEW_LINE INDENT def mod ( s1 : str , s2 : str ) -> str : NEW_LINE INDENT while s1 . startswith ( s2 ) : NEW_LINE INDENT s1 = s1 [ len ( s2 ) : ] NEW_LINE DEDENT return s1 NEW_LINE DEDENT if len ( str1 ) < len ( str2 ) : NEW_LINE INDENT return self . gcdOfStrings ( str2 , str1 ) NEW_LINE DEDENT if not str1 . startswith ( str2 ) : NEW_LINE INDENT return ' ' NEW_LINE DEDENT if not str2 : NEW_LINE INDENT return str1 NEW_LINE DEDENT return self . gcdOfStrings ( str2 , mod ( str1 , str2 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxEqualRowsAfterFlips ( self , matrix : List [ List [ int ] ] ) -> int : NEW_LINE INDENT patterns = [ tuple ( a ^ row [ 0 ] for a in row ) for row in matrix ] NEW_LINE return max ( Counter ( patterns ) . values ( ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def addNegabinary ( self , arr1 : List [ int ] , arr2 : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE carry = 0 NEW_LINE while carry or arr1 or arr2 : NEW_LINE INDENT if arr1 : NEW_LINE INDENT carry += arr1 . pop ( ) NEW_LINE DEDENT if arr2 : NEW_LINE INDENT carry += arr2 . pop ( ) NEW_LINE DEDENT ans . append ( carry & 1 ) NEW_LINE carry = - ( carry >> 1 ) NEW_LINE DEDENT while len ( ans ) > 1 and ans [ - 1 ] == 0 : NEW_LINE INDENT ans . pop ( ) NEW_LINE DEDENT return ans [ : : - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numSubmatrixSumTarget ( self , matrix : List [ List [ int ] ] , target : int ) -> int : NEW_LINE INDENT m = len ( matrix ) NEW_LINE n = len ( matrix [ 0 ] ) NEW_LINE ans = 0 NEW_LINE for row in matrix : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT row [ i ] += row [ i - 1 ] NEW_LINE DEDENT DEDENT for baseCol in range ( n ) : NEW_LINE INDENT for j in range ( baseCol , n ) : NEW_LINE INDENT prefixCount = Counter ( { 0 : 1 } ) NEW_LINE summ = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if baseCol > 0 : NEW_LINE INDENT summ -= matrix [ i ] [ baseCol - 1 ] NEW_LINE DEDENT summ += matrix [ i ] [ j ] NEW_LINE ans += prefixCount [ summ - target ] NEW_LINE prefixCount [ summ ] += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findOcurrences ( self , text : str , first : str , second : str ) -> List [ str ] : NEW_LINE INDENT words = text . split ( ) NEW_LINE return [ c for a , b , c in zip ( words , words [ 1 : ] , words [ 2 : ] ) if a == first and b == second ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numTilePossibilities ( self , tiles : str ) -> int : NEW_LINE INDENT count = Counter ( tiles ) NEW_LINE def dfs ( count : Dict [ int , int ] ) -> int : NEW_LINE INDENT possibleSequences = 0 NEW_LINE for k , v in count . items ( ) : NEW_LINE INDENT if v == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT count [ k ] -= 1 NEW_LINE possibleSequences += 1 + dfs ( count ) NEW_LINE count [ k ] += 1 NEW_LINE DEDENT return possibleSequences NEW_LINE DEDENT return dfs ( count ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sortedArrayToBST ( self , nums : List [ int ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT def build ( l : int , r : int ) -> Optional [ TreeNode ] : NEW_LINE INDENT if l > r : NEW_LINE INDENT return None NEW_LINE DEDENT m = ( l + r ) // 2 NEW_LINE return TreeNode ( nums [ m ] , build ( l , m - 1 ) , build ( m + 1 , r ) ) NEW_LINE DEDENT return build ( 0 , len ( nums ) - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestSubsequence ( self , text : str ) -> str : NEW_LINE INDENT ans = [ ] NEW_LINE count = Counter ( text ) NEW_LINE used = [ False ] * 26 NEW_LINE for c in text : NEW_LINE INDENT count [ c ] -= 1 NEW_LINE if used [ ord ( c ) - ord ( ' a ' ) ] : NEW_LINE INDENT continue NEW_LINE DEDENT while ans and ans [ - 1 ] > c and count [ ans [ - 1 ] ] > 0 : NEW_LINE INDENT used [ ord ( ans [ - 1 ] ) - ord ( ' a ' ) ] = False NEW_LINE ans . pop ( ) NEW_LINE DEDENT ans . append ( c ) NEW_LINE used [ ord ( ans [ - 1 ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def expand ( self , s : str ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( i : int , path : List [ str ] ) -> None : NEW_LINE INDENT if i == len ( s ) : NEW_LINE INDENT ans . append ( ' ' . join ( path ) ) NEW_LINE return NEW_LINE DEDENT if s [ i ] == ' { ' : NEW_LINE INDENT nextRightBraceIndex = s . find ( ' } ' , i ) NEW_LINE for c in s [ i + 1 : nextRightBraceIndex ] . split ( ' , ' ) : NEW_LINE INDENT path . append ( c ) NEW_LINE dfs ( nextRightBraceIndex + 1 , path ) NEW_LINE path . pop ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT path . append ( s [ i ] ) NEW_LINE dfs ( i + 1 , path ) NEW_LINE path . pop ( ) NEW_LINE DEDENT DEDENT dfs ( 0 , [ ] ) NEW_LINE return sorted ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def confusingNumberII ( self , n : int ) -> int : NEW_LINE INDENT digitToRotated = [ ( 0 , 0 ) , ( 1 , 1 ) , ( 6 , 9 ) , ( 8 , 8 ) , ( 9 , 6 ) ] NEW_LINE def dfs ( num : int , rotatedNum : int , unit : int ) -> int : NEW_LINE INDENT ans = 0 if num == rotatedNum else 1 NEW_LINE for digit , rotated in digitToRotated : NEW_LINE INDENT if digit == 0 and num == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT nextNum = num * 10 + digit NEW_LINE if nextNum > n : NEW_LINE INDENT break NEW_LINE DEDENT ans += dfs ( nextNum , rotated * unit + rotatedNum , unit * 10 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT return dfs ( 0 , 0 , 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def duplicateZeros ( self , arr : List [ int ] ) -> None : NEW_LINE INDENT zeros = arr . count ( 0 ) NEW_LINE i = len ( arr ) - 1 NEW_LINE j = len ( arr ) + zeros - 1 NEW_LINE while i < j : NEW_LINE INDENT if j < len ( arr ) : NEW_LINE INDENT arr [ j ] = arr [ i ] NEW_LINE DEDENT if arr [ i ] == 0 : NEW_LINE INDENT j -= 1 NEW_LINE if j < len ( arr ) : NEW_LINE INDENT arr [ j ] = arr [ i ] NEW_LINE DEDENT DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def sortedListToBST ( self , head : ListNode ) -> TreeNode : NEW_LINE INDENT def findMid ( head : ListNode ) -> ListNode : NEW_LINE INDENT prev = None NEW_LINE slow = head NEW_LINE fast = head NEW_LINE while fast and fast . next : NEW_LINE INDENT prev = slow NEW_LINE slow = slow . next NEW_LINE fast = fast . next . next NEW_LINE DEDENT prev . next = None NEW_LINE return slow NEW_LINE DEDENT if not head : NEW_LINE INDENT return None NEW_LINE DEDENT if not head . next : NEW_LINE INDENT return TreeNode ( head . val ) NEW_LINE DEDENT mid = findMid ( head ) NEW_LINE root = TreeNode ( mid . val ) NEW_LINE root . left = self . sortedListToBST ( head ) NEW_LINE root . right = self . sortedListToBST ( mid . next ) NEW_LINE return root NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sampleStats ( self , count : List [ int ] ) -> List [ float ] : NEW_LINE INDENT minimum = next ( ( i for i , num in enumerate ( count ) if num ) , None ) NEW_LINE maximum = next ( ( i for i , num in reversed ( list ( enumerate ( count ) ) ) if num ) , None ) NEW_LINE n = sum ( count ) NEW_LINE mean = sum ( i * c / n for i , c in enumerate ( count ) ) NEW_LINE mode = count . index ( max ( count ) ) NEW_LINE numCount = 0 NEW_LINE leftMedian = 0 NEW_LINE for i , c in enumerate ( count ) : NEW_LINE INDENT numCount += c NEW_LINE if numCount >= n / 2 : NEW_LINE INDENT leftMedian = i NEW_LINE break NEW_LINE DEDENT DEDENT numCount = 0 NEW_LINE rightMedian = 0 NEW_LINE for i , c in reversed ( list ( enumerate ( count ) ) ) : NEW_LINE INDENT numCount += c NEW_LINE if numCount >= n / 2 : NEW_LINE INDENT rightMedian = i NEW_LINE break NEW_LINE DEDENT DEDENT return [ minimum , maximum , mean , ( leftMedian + rightMedian ) / 2 , mode ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findInMountainArray ( self , target : int , mountain_arr : ' MountainArray ' ) -> int : NEW_LINE INDENT n = mountain_arr . length ( ) NEW_LINE peakIndex = self . peakIndexInMountainArray ( mountain_arr , 0 , n - 1 ) NEW_LINE leftIndex = self . searchLeft ( mountain_arr , target , 0 , peakIndex ) NEW_LINE if mountain_arr . get ( leftIndex ) == target : NEW_LINE INDENT return leftIndex NEW_LINE DEDENT rightIndex = self . searchRight ( mountain_arr , target , peakIndex + 1 , n - 1 ) NEW_LINE if mountain_arr . get ( rightIndex ) == target : NEW_LINE INDENT return rightIndex NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def peakIndexInMountainArray ( self , A : ' MountainArray ' , l : int , r : int ) -> int : NEW_LINE INDENT while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if A . get ( m ) < A . get ( m + 1 ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT def searchLeft ( self , A : ' MountainArray ' , target : int , l : int , r : int ) -> int : NEW_LINE INDENT while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if A . get ( m ) < target : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT def searchRight ( self , A : ' MountainArray ' , target : int , l : int , r : int ) -> int : NEW_LINE INDENT while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if A . get ( m ) > target : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def braceExpansionII ( self , expression : str ) -> List [ str ] : NEW_LINE INDENT def merge ( groups : List [ List [ str ] ] , group : List [ str ] ) -> None : NEW_LINE INDENT if not groups [ - 1 ] : NEW_LINE INDENT groups [ - 1 ] = group NEW_LINE return NEW_LINE DEDENT groups [ - 1 ] = [ word1 + word2 for word1 in groups [ - 1 ] for word2 in group ] NEW_LINE DEDENT def dfs ( s : int , e : int ) -> List [ str ] : NEW_LINE INDENT groups = [ [ ] ] NEW_LINE layer = 0 NEW_LINE for i in range ( s , e + 1 ) : NEW_LINE INDENT c = expression [ i ] NEW_LINE if c == ' { ' : NEW_LINE INDENT layer += 1 NEW_LINE if layer == 1 : NEW_LINE INDENT left = i + 1 NEW_LINE DEDENT DEDENT elif c == ' } ' : NEW_LINE INDENT layer -= 1 NEW_LINE if layer == 0 : NEW_LINE INDENT group = dfs ( left , i - 1 ) NEW_LINE merge ( groups , group ) NEW_LINE DEDENT DEDENT elif c == ' , ' and layer == 0 : NEW_LINE INDENT groups . append ( [ ] ) NEW_LINE DEDENT elif layer == 0 : NEW_LINE INDENT merge ( groups , [ c ] ) NEW_LINE DEDENT DEDENT return sorted ( list ( { word for group in groups for word in group } ) ) NEW_LINE DEDENT return dfs ( 0 , len ( expression ) - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxArea ( self , height : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE l = 0 NEW_LINE r = len ( height ) - 1 NEW_LINE while l < r : NEW_LINE INDENT minHeight = min ( height [ l ] , height [ r ] ) NEW_LINE ans = max ( ans , minHeight * ( r - l ) ) NEW_LINE if height [ l ] < height [ r ] : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isBalanced ( self , root : Optional [ TreeNode ] ) -> bool : NEW_LINE INDENT if not root : NEW_LINE INDENT return True NEW_LINE DEDENT def maxDepth ( root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 + max ( maxDepth ( root . left ) , maxDepth ( root . right ) ) NEW_LINE DEDENT return abs ( maxDepth ( root . left ) - maxDepth ( root . right ) ) <= 1 and self . isBalanced ( root . left ) and self . isBalanced ( root . right ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numKLenSubstrNoRepeats ( self , s : str , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE unique = 0 NEW_LINE count = Counter ( ) NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT count [ c ] += 1 NEW_LINE if count [ c ] == 1 : NEW_LINE INDENT unique += 1 NEW_LINE DEDENT if i >= k : NEW_LINE INDENT count [ s [ i - k ] ] -= 1 NEW_LINE if count [ s [ i - k ] ] == 0 : NEW_LINE INDENT unique -= 1 NEW_LINE DEDENT if unique == k : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class UnionFind : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . count = n NEW_LINE self . id = list ( range ( n ) ) NEW_LINE self . rank = [ 0 ] * n NEW_LINE DEDENT def union ( self , u : int , v : int ) -> None : NEW_LINE INDENT i = self . _find ( u ) NEW_LINE j = self . _find ( v ) NEW_LINE if i == j : NEW_LINE INDENT return NEW_LINE DEDENT if self . rank [ i ] > self . rank [ j ] : NEW_LINE INDENT i , j = j , i NEW_LINE DEDENT elif self . rank [ i ] == self . rank [ j ] : NEW_LINE INDENT self . rank [ j ] += 1 NEW_LINE DEDENT self . id [ i ] = j NEW_LINE self . count -= 1 NEW_LINE DEDENT def getCount ( self ) -> int : NEW_LINE INDENT return self . count NEW_LINE DEDENT def _find ( self , u : int ) -> int : NEW_LINE INDENT if self . id [ u ] != u : NEW_LINE INDENT self . id [ u ] = self . _find ( self . id [ u ] ) NEW_LINE DEDENT return self . id [ u ] NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def earliestAcq ( self , logs : List [ List [ int ] ] , n : int ) -> int : NEW_LINE INDENT uf = UnionFind ( n ) NEW_LINE for timestamp , x , y in logs : NEW_LINE INDENT uf . union ( x , y ) NEW_LINE if uf . getCount ( ) == 1 : NEW_LINE INDENT return timestamp NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def distributeCandies ( self , candies : int , n : int ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * n NEW_LINE rows = int ( ( - n + ( n ** 2 + 8 * n ** 2 * candies ) ** 0.5 ) / ( 2 * n ** 2 ) ) NEW_LINE accumN = rows * ( rows - 1 ) * n // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans [ i ] = accumN + rows * ( i + 1 ) NEW_LINE DEDENT givenCandies = ( n ** 2 * rows ** 2 + n * rows ) // 2 NEW_LINE candies -= givenCandies NEW_LINE lastGiven = rows * n NEW_LINE i = 0 NEW_LINE while candies > 0 : NEW_LINE INDENT lastGiven += 1 NEW_LINE actualGiven = min ( lastGiven , candies ) NEW_LINE candies -= actualGiven NEW_LINE ans [ i ] += actualGiven NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def pathInZigZagTree ( self , label : int ) -> List [ int ] : NEW_LINE INDENT def boundarySum ( level : int ) : NEW_LINE INDENT return 2 ** level + 2 ** ( level + 1 ) - 1 NEW_LINE DEDENT ans = [ ] NEW_LINE for l in range ( 21 ) : NEW_LINE INDENT if 2 ** l > label : NEW_LINE INDENT level = l - 1 NEW_LINE break NEW_LINE DEDENT DEDENT if level & 1 : NEW_LINE INDENT label = boundarySum ( level ) - label NEW_LINE DEDENT for l in reversed ( range ( level + 1 ) ) : NEW_LINE INDENT ans . append ( boundarySum ( l ) - label if l & 1 else label ) NEW_LINE label //= 2 NEW_LINE DEDENT return ans [ : : - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minHeightShelves ( self , books : List [ List [ int ] ] , shelfWidth : int ) -> int : NEW_LINE INDENT dp = [ 0 ] + [ math . inf ] * len ( books ) NEW_LINE for i in range ( len ( books ) ) : NEW_LINE INDENT sumThickness = 0 NEW_LINE maxHeight = 0 NEW_LINE for j in range ( i , - 1 , - 1 ) : NEW_LINE INDENT thickness , height = books [ j ] NEW_LINE sumThickness += thickness NEW_LINE if sumThickness > shelfWidth : NEW_LINE INDENT break NEW_LINE DEDENT maxHeight = max ( maxHeight , height ) NEW_LINE dp [ i + 1 ] = min ( dp [ i + 1 ] , dp [ j ] + maxHeight ) NEW_LINE DEDENT DEDENT return dp [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def parseBoolExpr ( self , expression : str ) -> bool : NEW_LINE INDENT def dfs ( s : int , e : int ) -> List [ str ] : NEW_LINE INDENT if s == e : NEW_LINE INDENT return True if expression [ s ] == ' t ' else False NEW_LINE DEDENT exps = [ ] NEW_LINE layer = 0 NEW_LINE for i in range ( s , e + 1 ) : NEW_LINE INDENT c = expression [ i ] NEW_LINE if layer == 0 and c in ' ! & | ' : NEW_LINE INDENT op = c NEW_LINE DEDENT elif c == ' ( ' : NEW_LINE INDENT layer += 1 NEW_LINE if layer == 1 : NEW_LINE INDENT left = i + 1 NEW_LINE DEDENT DEDENT elif c == ' ) ' : NEW_LINE INDENT layer -= 1 NEW_LINE if layer == 0 : NEW_LINE INDENT exps . append ( dfs ( left , i - 1 ) ) NEW_LINE DEDENT DEDENT elif c == ' , ' and layer == 1 : NEW_LINE INDENT exps . append ( dfs ( left , i - 1 ) ) NEW_LINE left = i + 1 NEW_LINE DEDENT DEDENT if op == ' | ' : NEW_LINE INDENT return functools . reduce ( lambda x , y : x | y , exps ) NEW_LINE DEDENT if op == ' & ' : NEW_LINE INDENT return functools . reduce ( lambda x , y : x & y , exps ) NEW_LINE DEDENT if op == ' ! ' : NEW_LINE INDENT return not exps [ 0 ] NEW_LINE DEDENT DEDENT return dfs ( 0 , len ( expression ) - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def defangIPaddr ( self , address : str ) -> str : NEW_LINE INDENT return address . replace ( ' . ' , ' [ . ] ' ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def corpFlightBookings ( self , bookings : List [ List [ int ] ] , n : int ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * n NEW_LINE for booking in bookings : NEW_LINE INDENT ans [ booking [ 0 ] - 1 ] += booking [ 2 ] NEW_LINE if booking [ 1 ] < n : NEW_LINE INDENT ans [ booking [ 1 ] ] -= booking [ 2 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT ans [ i ] += ans [ i - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minDepth ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT if not root . left : NEW_LINE INDENT return self . minDepth ( root . right ) + 1 NEW_LINE DEDENT if not root . right : NEW_LINE INDENT return self . minDepth ( root . left ) + 1 NEW_LINE DEDENT return min ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def delNodes ( self , root : TreeNode , to_delete : List [ int ] ) -> List [ TreeNode ] : NEW_LINE INDENT ans = [ ] NEW_LINE toDeleteSet = set ( to_delete ) NEW_LINE def dfs ( root : TreeNode , isRoot : bool ) -> TreeNode : NEW_LINE INDENT if not root : NEW_LINE INDENT return None NEW_LINE DEDENT deleted = root . val in toDeleteSet NEW_LINE if isRoot and not deleted : NEW_LINE INDENT ans . append ( root ) NEW_LINE DEDENT root . left = dfs ( root . left , deleted ) NEW_LINE root . right = dfs ( root . right , deleted ) NEW_LINE return None if deleted else root NEW_LINE DEDENT dfs ( root , True ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxDepthAfterSplit ( self , seq : str ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE depth = 1 NEW_LINE for c in seq : NEW_LINE INDENT if c == ' ( ' : NEW_LINE INDENT depth += 1 NEW_LINE ans . append ( depth % 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( depth % 2 ) NEW_LINE depth -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
from threading import Lock NEW_LINE class Foo : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . firstDone = Lock ( ) NEW_LINE self . secondDone = Lock ( ) NEW_LINE self . firstDone . acquire ( ) NEW_LINE self . secondDone . acquire ( ) NEW_LINE DEDENT def first ( self , printFirst : ' Callable [ [ ] , ▁ None ] ' ) -> None : NEW_LINE INDENT printFirst ( ) NEW_LINE self . firstDone . release ( ) NEW_LINE DEDENT def second ( self , printSecond : ' Callable [ [ ] , ▁ None ] ' ) -> None : NEW_LINE INDENT self . firstDone . acquire ( ) NEW_LINE printSecond ( ) NEW_LINE self . secondDone . release ( ) NEW_LINE DEDENT def third ( self , printThird : ' Callable [ [ ] , ▁ None ] ' ) -> None : NEW_LINE INDENT self . secondDone . acquire ( ) NEW_LINE printThird ( ) NEW_LINE DEDENT DEDENT
from threading import Semaphore NEW_LINE class FooBar : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . n = n NEW_LINE self . fooSemaphore = Semaphore ( 1 ) NEW_LINE self . barSemaphore = Semaphore ( 0 ) NEW_LINE DEDENT def foo ( self , printFoo : ' Callable [ [ ] , ▁ None ] ' ) -> None : NEW_LINE INDENT for _ in range ( self . n ) : NEW_LINE INDENT self . fooSemaphore . acquire ( ) NEW_LINE printFoo ( ) NEW_LINE self . barSemaphore . release ( ) NEW_LINE DEDENT DEDENT def bar ( self , printBar : ' Callable [ [ ] , ▁ None ] ' ) -> None : NEW_LINE INDENT for _ in range ( self . n ) : NEW_LINE INDENT self . barSemaphore . acquire ( ) NEW_LINE printBar ( ) NEW_LINE self . fooSemaphore . release ( ) NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def hasPathSum ( self , root : TreeNode , summ : int ) -> bool : NEW_LINE INDENT if not root : NEW_LINE INDENT return False NEW_LINE DEDENT if root . val == summ and not root . left and not root . right : NEW_LINE INDENT return True NEW_LINE DEDENT return self . hasPathSum ( root . left , summ - root . val ) or self . hasPathSum ( root . right , summ - root . val ) NEW_LINE DEDENT DEDENT
class T : NEW_LINE INDENT def __init__ ( self , summ : int , count : int , maxAverage : float ) : NEW_LINE INDENT self . summ = summ NEW_LINE self . count = count NEW_LINE self . maxAverage = maxAverage NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def maximumAverageSubtree ( self , root : Optional [ TreeNode ] ) -> float : NEW_LINE INDENT def maximumAverage ( root : Optional [ TreeNode ] ) -> T : NEW_LINE INDENT if not root : NEW_LINE INDENT return T ( 0 , 0 , 0 ) NEW_LINE DEDENT l = maximumAverage ( root . left ) NEW_LINE r = maximumAverage ( root . right ) NEW_LINE summ = root . val + l . summ + r . summ NEW_LINE count = 1 + l . count + r . count NEW_LINE maxAverage = max ( summ / count , l . maxAverage , r . maxAverage ) NEW_LINE return T ( summ , count , maxAverage ) NEW_LINE DEDENT return maximumAverage ( root ) . maxAverage NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canDivideIntoSubsequences ( self , nums : List [ int ] , k : int ) -> bool : NEW_LINE INDENT return len ( nums ) >= k * max ( Counter ( nums ) . values ( ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def relativeSortArray ( self , arr1 : List [ int ] , arr2 : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE count = [ 0 ] * 1001 NEW_LINE for a in arr1 : NEW_LINE INDENT count [ a ] += 1 NEW_LINE DEDENT for a in arr2 : NEW_LINE INDENT while count [ a ] > 0 : NEW_LINE INDENT ans . append ( a ) NEW_LINE count [ a ] -= 1 NEW_LINE DEDENT DEDENT for num in range ( 1001 ) : NEW_LINE INDENT for _ in range ( count [ num ] ) : NEW_LINE INDENT ans . append ( num ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numEquivDominoPairs ( self , dominoes : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = Counter ( ) NEW_LINE for domino in dominoes : NEW_LINE INDENT key = min ( domino [ 0 ] , domino [ 1 ] ) * 10 + max ( domino [ 0 ] , domino [ 1 ] ) NEW_LINE ans += count [ key ] NEW_LINE count [ key ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def pathSum ( self , root : TreeNode , summ : int ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( root : TreeNode , summ : int , path : List [ int ] ) -> None : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT if root . val == summ and not root . left and not root . right : NEW_LINE INDENT ans . append ( path + [ root . val ] ) NEW_LINE return NEW_LINE DEDENT dfs ( root . left , summ - root . val , path + [ root . val ] ) NEW_LINE dfs ( root . right , summ - root . val , path + [ root . val ] ) NEW_LINE DEDENT dfs ( root , summ , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mctFromLeafValues ( self , arr : List [ int ] ) -> int : NEW_LINE INDENT n = len ( arr ) NEW_LINE dp = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE maxVal = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxVal [ i ] [ i ] = arr [ i ] NEW_LINE DEDENT for d in range ( 1 , n ) : NEW_LINE INDENT for i in range ( n - d ) : NEW_LINE INDENT j = i + d NEW_LINE maxVal [ i ] [ j ] = max ( maxVal [ i ] [ j - 1 ] , maxVal [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT for d in range ( 1 , n ) : NEW_LINE INDENT for i in range ( n - d ) : NEW_LINE INDENT j = i + d NEW_LINE dp [ i ] [ j ] = math . inf NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxAbsValExpr ( self , arr1 : List [ int ] , arr2 : List [ int ] ) -> int : NEW_LINE INDENT n = len ( arr1 ) NEW_LINE a = [ arr1 [ i ] + arr2 [ i ] + i for i in range ( n ) ] NEW_LINE b = [ arr1 [ i ] + arr2 [ i ] - i for i in range ( n ) ] NEW_LINE c = [ arr1 [ i ] - arr2 [ i ] + i for i in range ( n ) ] NEW_LINE d = [ arr1 [ i ] - arr2 [ i ] - i for i in range ( n ) ] NEW_LINE return max ( map ( lambda x : max ( x ) - min ( x ) , ( a , b , c , d ) ) ) NEW_LINE DEDENT DEDENT
from enum import Enum NEW_LINE class State ( Enum ) : NEW_LINE INDENT INIT = 0 NEW_LINE VISITING = 1 NEW_LINE VISITED = 2 NEW_LINE DEDENT class Solution : NEW_LINE INDENT def minimumSemesters ( self , n : int , relations : List [ List [ int ] ] ) -> int : NEW_LINE INDENT graph = [ [ ] for _ in range ( n ) ] NEW_LINE state = [ State . INIT ] * n NEW_LINE depth = [ 1 ] * n NEW_LINE for u , v in relations : NEW_LINE INDENT graph [ u - 1 ] . append ( v - 1 ) NEW_LINE DEDENT def hasCycle ( u : int ) -> bool : NEW_LINE INDENT if state [ u ] == State . VISITING : NEW_LINE INDENT return True NEW_LINE DEDENT if state [ u ] == State . VISITED : NEW_LINE INDENT return False NEW_LINE DEDENT state [ u ] = State . VISITING NEW_LINE for v in graph [ u ] : NEW_LINE INDENT if hasCycle ( v ) : NEW_LINE INDENT return True NEW_LINE DEDENT depth [ u ] = max ( depth [ u ] , 1 + depth [ v ] ) NEW_LINE DEDENT state [ u ] = State . VISITED NEW_LINE return False NEW_LINE DEDENT if any ( hasCycle ( i ) for i in range ( n ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return max ( depth ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def flatten ( self , root : Optional [ TreeNode ] ) -> None : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT self . flatten ( root . left ) NEW_LINE self . flatten ( root . right ) NEW_LINE left = root . left NEW_LINE right = root . right NEW_LINE root . left = None NEW_LINE root . right = left NEW_LINE rightmost = root NEW_LINE while rightmost . right : NEW_LINE INDENT rightmost = rightmost . right NEW_LINE DEDENT rightmost . right = right NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestCommonSubsequence ( self , text1 : str , text2 : str ) -> int : NEW_LINE INDENT m = len ( text1 ) NEW_LINE n = len ( text2 ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = 1 + dp [ i ] [ j ] if text1 [ i ] == text2 [ j ] else max ( dp [ i ] [ j + 1 ] , dp [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def movesToMakeZigzag ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT decreasing = [ 0 ] * 2 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT l = nums [ i - 1 ] if i > 0 else 1001 NEW_LINE r = nums [ i + 1 ] if i + 1 < len ( nums ) else 1001 NEW_LINE decreasing [ i % 2 ] += max ( 0 , num - min ( l , r ) + 1 ) NEW_LINE DEDENT return min ( decreasing [ 0 ] , decreasing [ 1 ] ) NEW_LINE DEDENT DEDENT
class SnapshotArray : NEW_LINE INDENT def __init__ ( self , length : int ) : NEW_LINE INDENT self . snaps = [ [ [ 0 , 0 ] ] for _ in range ( length ) ] NEW_LINE self . snap_id = 0 NEW_LINE DEDENT def set ( self , index : int , val : int ) -> None : NEW_LINE INDENT snap = self . snaps [ index ] [ - 1 ] NEW_LINE if snap [ 0 ] == self . snap_id : NEW_LINE INDENT snap [ 1 ] = val NEW_LINE DEDENT else : NEW_LINE INDENT self . snaps [ index ] . append ( [ self . snap_id , val ] ) NEW_LINE DEDENT DEDENT def snap ( self ) -> int : NEW_LINE INDENT self . snap_id += 1 NEW_LINE return self . snap_id - 1 NEW_LINE DEDENT def get ( self , index : int , snap_id : int ) -> int : NEW_LINE INDENT i = bisect_left ( self . snaps [ index ] , [ snap_id + 1 ] ) - 1 NEW_LINE return self . snaps [ index ] [ i ] [ 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numDistinct ( self , s : str , t : str ) -> int : NEW_LINE INDENT m = len ( s ) NEW_LINE n = len ( t ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if s [ i - 1 ] == t [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minSwaps ( self , data : List [ int ] ) -> int : NEW_LINE INDENT k = data . count ( 1 ) NEW_LINE ones = 0 NEW_LINE maxOnes = 0 NEW_LINE for i , num in enumerate ( data ) : NEW_LINE INDENT if i >= k and data [ i - k ] : NEW_LINE INDENT ones -= 1 NEW_LINE DEDENT if num : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT maxOnes = max ( maxOnes , ones ) NEW_LINE DEDENT return k - maxOnes NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canConvert ( self , str1 : str , str2 : str ) -> bool : NEW_LINE INDENT if str1 == str2 : NEW_LINE INDENT return True NEW_LINE DEDENT mappings = { } NEW_LINE for a , b in zip ( str1 , str2 ) : NEW_LINE INDENT if mappings . get ( a , b ) != b : NEW_LINE INDENT return False NEW_LINE DEDENT mappings [ a ] = b NEW_LINE DEDENT return len ( set ( str2 ) ) < 26 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def dayOfYear ( self , date : str ) -> int : NEW_LINE INDENT def isLeapYear ( year : int ) -> bool : NEW_LINE INDENT return ( year % 4 == 0 and year % 100 != 0 ) or year % 400 == 0 NEW_LINE DEDENT year = int ( date [ : 4 ] ) NEW_LINE month = int ( date [ 5 : 7 ] ) NEW_LINE day = int ( date [ 8 : ] ) NEW_LINE days = [ 31 , 29 if isLeapYear ( year ) else 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE return sum ( days [ : month - 1 ] ) + day NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numRollsToTarget ( self , n : int , k : int , target : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE dp = [ 1 ] + [ 0 ] * target NEW_LINE for _ in range ( n ) : NEW_LINE INDENT newDp = [ 0 ] * ( target + 1 ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT for t in range ( i , target + 1 ) : NEW_LINE INDENT newDp [ t ] += dp [ t - i ] NEW_LINE newDp [ t ] %= kMod NEW_LINE DEDENT DEDENT dp = newDp NEW_LINE DEDENT return dp [ target ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxRepOpt1 ( self , text : str ) -> int : NEW_LINE INDENT count = Counter ( text ) NEW_LINE groups = [ [ c , len ( list ( group ) ) ] for c , group in itertools . groupby ( text ) ] NEW_LINE ans = max ( min ( length + 1 , count [ c ] ) for c , length in groups ) NEW_LINE for i in range ( 1 , len ( groups ) - 1 ) : NEW_LINE INDENT if groups [ i - 1 ] [ 0 ] == groups [ i + 1 ] [ 0 ] and groups [ i ] [ 1 ] == 1 : NEW_LINE INDENT ans = max ( ans , min ( groups [ i - 1 ] [ 1 ] + groups [ i + 1 ] [ 1 ] + 1 , count [ groups [ i - 1 ] [ 0 ] ] ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class MajorityChecker : NEW_LINE INDENT def __init__ ( self , arr : List [ int ] ) : NEW_LINE INDENT self . A = arr NEW_LINE self . kTimes = 20 NEW_LINE self . numToIndices = defaultdict ( list ) NEW_LINE for i , a in enumerate ( self . A ) : NEW_LINE INDENT self . numToIndices [ a ] . append ( i ) NEW_LINE DEDENT DEDENT def query ( self , left : int , right : int , threshold : int ) -> int : NEW_LINE INDENT for _ in range ( self . kTimes ) : NEW_LINE INDENT randIndex = randint ( 0 , len ( self . A ) - 1 ) NEW_LINE num = self . A [ randIndex ] NEW_LINE indices = self . numToIndices [ num ] NEW_LINE l = bisect . bisect_left ( indices , left ) NEW_LINE r = bisect . bisect_right ( indices , right ) NEW_LINE if r - l >= threshold : NEW_LINE INDENT return num NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def connect ( self , root : ' Optional [ Node ] ' ) -> ' Optional [ Node ] ' : NEW_LINE INDENT if not root : NEW_LINE INDENT return None NEW_LINE DEDENT def connectTwoNodes ( p , q ) -> None : NEW_LINE INDENT if not p : NEW_LINE INDENT return NEW_LINE DEDENT p . next = q NEW_LINE connectTwoNodes ( p . left , p . right ) NEW_LINE connectTwoNodes ( q . left , q . right ) NEW_LINE connectTwoNodes ( p . right , q . left ) NEW_LINE DEDENT connectTwoNodes ( root . left , root . right ) NEW_LINE return root NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countCharacters ( self , words : List [ str ] , chars : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = Counter ( chars ) NEW_LINE for word in words : NEW_LINE INDENT tempCount = count . copy ( ) NEW_LINE for c in word : NEW_LINE INDENT tempCount [ c ] -= 1 NEW_LINE if tempCount [ c ] < 0 : NEW_LINE INDENT ans -= len ( word ) NEW_LINE break NEW_LINE DEDENT DEDENT ans += len ( word ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def lastSubstring ( self , s : str ) -> str : NEW_LINE INDENT i = 0 NEW_LINE j = 1 NEW_LINE k = 0 NEW_LINE while j + k < len ( s ) : NEW_LINE INDENT if s [ i + k ] == s [ j + k ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif s [ i + k ] > s [ j + k ] : NEW_LINE INDENT j += k + 1 NEW_LINE k = 0 NEW_LINE DEDENT else : NEW_LINE INDENT i = max ( i + k + 1 , j ) NEW_LINE j = i + 1 NEW_LINE k = 0 NEW_LINE DEDENT DEDENT return s [ i : ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def connectSticks ( self , sticks : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE heapq . heapify ( sticks ) NEW_LINE while len ( sticks ) > 1 : NEW_LINE INDENT x = heapq . heappop ( sticks ) NEW_LINE y = heapq . heappop ( sticks ) NEW_LINE ans += x + y NEW_LINE heapq . heappush ( sticks , x + y ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minCostToSupplyWater ( self , n : int , wells : List [ int ] , pipes : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE graph = [ [ ] for _ in range ( n + 1 ) ] NEW_LINE minHeap = [ ] NEW_LINE for u , v , w in pipes : NEW_LINE INDENT graph [ u ] . append ( ( v , w ) ) NEW_LINE graph [ v ] . append ( ( u , w ) ) NEW_LINE DEDENT for i , well in enumerate ( wells ) : NEW_LINE INDENT graph [ 0 ] . append ( ( i + 1 , well ) ) NEW_LINE heapq . heappush ( minHeap , ( well , i + 1 ) ) NEW_LINE DEDENT mst = { 0 } NEW_LINE while len ( mst ) < n + 1 : NEW_LINE INDENT d , u = heapq . heappop ( minHeap ) NEW_LINE if u in mst : NEW_LINE INDENT continue NEW_LINE DEDENT mst . add ( u ) NEW_LINE ans += d NEW_LINE for v , w in graph [ u ] : NEW_LINE INDENT if v not in mst : NEW_LINE INDENT heapq . heappush ( minHeap , ( w , v ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def invalidTransactions ( self , transactions : List [ str ] ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE nameToTranses = defaultdict ( list ) NEW_LINE for t in transactions : NEW_LINE INDENT name , time , amount , city = t . split ( ' , ' ) NEW_LINE time , amount = int ( time ) , int ( amount ) NEW_LINE nameToTranses [ name ] . append ( { ' time ' : time , ' city ' : city } ) NEW_LINE DEDENT for t in transactions : NEW_LINE INDENT name , time , amount , city = t . split ( ' , ' ) NEW_LINE time , amount = int ( time ) , int ( amount ) NEW_LINE if amount > 1000 : NEW_LINE INDENT ans . append ( t ) NEW_LINE DEDENT elif name in nameToTranses : NEW_LINE INDENT for sameName in nameToTranses [ name ] : NEW_LINE INDENT if abs ( sameName [ ' time ' ] - time ) <= 60 and sameName [ ' city ' ] != city : NEW_LINE INDENT ans . append ( t ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def connect ( self , root : ' Node ' ) -> ' Node ' : NEW_LINE INDENT node = root NEW_LINE while node : NEW_LINE INDENT dummy = Node ( 0 ) NEW_LINE needle = dummy NEW_LINE while node : NEW_LINE INDENT if node . left : NEW_LINE INDENT needle . next = node . left NEW_LINE needle = needle . next NEW_LINE DEDENT if node . right : NEW_LINE INDENT needle . next = node . right NEW_LINE needle = needle . next NEW_LINE DEDENT node = node . next NEW_LINE DEDENT node = dummy . next NEW_LINE DEDENT return root NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numSmallerByFrequency ( self , queries : List [ str ] , words : List [ str ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE wordsFreq = sorted ( [ word . count ( min ( word ) ) for word in words ] ) NEW_LINE for q in queries : NEW_LINE INDENT count = q . count ( min ( q ) ) NEW_LINE index = bisect . bisect ( wordsFreq , count ) NEW_LINE ans . append ( len ( words ) - index ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeZeroSumSublists ( self , head : ListNode ) -> ListNode : NEW_LINE INDENT dummy = ListNode ( 0 , head ) NEW_LINE prefix = 0 NEW_LINE prefixToNode = { 0 : dummy } NEW_LINE while head : NEW_LINE INDENT prefix += head . val NEW_LINE prefixToNode [ prefix ] = head NEW_LINE head = head . next NEW_LINE DEDENT prefix = 0 NEW_LINE head = dummy NEW_LINE while head : NEW_LINE INDENT prefix += head . val NEW_LINE head . next = prefixToNode [ prefix ] . next NEW_LINE head = head . next NEW_LINE DEDENT return dummy . next NEW_LINE DEDENT DEDENT
class DinnerPlates : NEW_LINE INDENT def __init__ ( self , capacity : int ) : NEW_LINE INDENT self . capacity = capacity NEW_LINE self . stacks = [ ] NEW_LINE self . minHeap = [ 0 ] NEW_LINE DEDENT def push ( self , val : int ) -> None : NEW_LINE INDENT index = self . minHeap [ 0 ] NEW_LINE if index == len ( self . stacks ) : NEW_LINE INDENT self . stacks . append ( [ ] ) NEW_LINE DEDENT self . stacks [ index ] . append ( val ) NEW_LINE if len ( self . stacks [ index ] ) == self . capacity : NEW_LINE INDENT heapq . heappop ( self . minHeap ) NEW_LINE if not self . minHeap : NEW_LINE INDENT heapq . heappush ( self . minHeap , len ( self . stacks ) ) NEW_LINE DEDENT DEDENT DEDENT def pop ( self ) -> int : NEW_LINE INDENT while self . stacks and not self . stacks [ - 1 ] : NEW_LINE INDENT self . stacks . pop ( ) NEW_LINE DEDENT if not self . stacks : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return self . popAtStack ( len ( self . stacks ) - 1 ) NEW_LINE DEDENT def popAtStack ( self , index : int ) -> int : NEW_LINE INDENT if index >= len ( self . stacks ) or not self . stacks [ index ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if len ( self . stacks [ index ] ) == self . capacity : NEW_LINE INDENT heapq . heappush ( self . minHeap , index ) NEW_LINE DEDENT return self . stacks [ index ] . pop ( ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numPrimeArrangements ( self , n : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE def countPrimes ( n : int ) -> int : NEW_LINE INDENT isPrime = [ False ] * 2 + [ True ] * ( n - 1 ) NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT for j in range ( i * i , n + 1 , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return sum ( isPrime ) NEW_LINE DEDENT def factorial ( n : int ) -> int : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact = fact * i % kMod NEW_LINE DEDENT return fact NEW_LINE DEDENT count = countPrimes ( n ) NEW_LINE return factorial ( count ) * factorial ( n - count ) % kMod NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canMakePaliQueries ( self , s : str , queries : List [ List [ int ] ] ) -> List [ bool ] : NEW_LINE INDENT def ones ( x ) : NEW_LINE INDENT return bin ( x ) . count ( '1' ) NEW_LINE DEDENT dp = [ 0 ] * ( len ( s ) + 1 ) NEW_LINE for i in range ( 1 , len ( s ) + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] ^ 1 << ord ( s [ i - 1 ] ) - ord ( ' a ' ) NEW_LINE DEDENT return [ ones ( dp [ right + 1 ] ^ dp [ left ] ) // 2 <= k for left , right , k in queries ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findNumOfValidWords ( self , words : List [ str ] , puzzles : List [ str ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE binaryCount = Counter ( ) NEW_LINE for word in words : NEW_LINE INDENT mask = 0 NEW_LINE for c in word : NEW_LINE INDENT mask |= 1 << ( ord ( c ) - ord ( ' a ' ) ) NEW_LINE DEDENT binaryCount [ mask ] += 1 NEW_LINE DEDENT for puzzle in puzzles : NEW_LINE INDENT valid = 0 NEW_LINE n = len ( puzzle ) - 1 NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT mask = 1 << ord ( puzzle [ 0 ] ) - ord ( ' a ' ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT if i & 1 << j : NEW_LINE INDENT mask |= 1 << ord ( puzzle [ j + 1 ] ) - ord ( ' a ' ) NEW_LINE DEDENT DEDENT if mask in binaryCount : NEW_LINE INDENT valid += binaryCount [ mask ] NEW_LINE DEDENT DEDENT ans . append ( valid ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def generate ( self , numRows : int ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( numRows ) : NEW_LINE INDENT ans . append ( [ 1 ] * ( i + 1 ) ) NEW_LINE DEDENT for i in range ( 2 , numRows ) : NEW_LINE INDENT for j in range ( 1 , len ( ans [ i ] ) - 1 ) : NEW_LINE INDENT ans [ i ] [ j ] = ans [ i - 1 ] [ j - 1 ] + ans [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumNumberOfOnes ( self , width : int , height : int , sideLength : int , maxOnes : int ) -> int : NEW_LINE INDENT submatrix = [ [ 0 ] * sideLength for _ in range ( sideLength ) ] NEW_LINE for i in range ( width ) : NEW_LINE INDENT for j in range ( height ) : NEW_LINE INDENT submatrix [ i % sideLength ] [ j % sideLength ] += 1 NEW_LINE DEDENT DEDENT return sum ( heapq . nlargest ( maxOnes , [ a for row in submatrix for a in row ] ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def distanceBetweenBusStops ( self , distance : List [ int ] , start : int , destination : int ) -> int : NEW_LINE INDENT clockwise = 0 NEW_LINE counterclockwise = 0 NEW_LINE if start > destination : NEW_LINE INDENT start , destination = destination , start NEW_LINE DEDENT for i , d in enumerate ( distance ) : NEW_LINE INDENT if i >= start and i < destination : NEW_LINE INDENT clockwise += d NEW_LINE DEDENT else : NEW_LINE INDENT counterclockwise += d NEW_LINE DEDENT DEDENT return min ( clockwise , counterclockwise ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def dayOfTheWeek ( self , day : int , month : int , year : int ) -> str : NEW_LINE INDENT def isLeapYear ( year : int ) -> bool : NEW_LINE INDENT return ( year % 4 == 0 and year % 100 != 0 ) or year % 400 == 0 NEW_LINE DEDENT week = [ " Sunday " , " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " ] NEW_LINE days = [ 31 , 29 if isLeapYear ( year ) else 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE count = 0 NEW_LINE for i in range ( 1971 , year ) : NEW_LINE INDENT count += 366 if i % 4 == 0 else 365 NEW_LINE DEDENT for i in range ( month - 1 ) : NEW_LINE INDENT count += days [ i ] NEW_LINE DEDENT count += day NEW_LINE return week [ ( count + 4 ) % 7 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def makeArrayIncreasing ( self , arr1 : List [ int ] , arr2 : List [ int ] ) -> int : NEW_LINE INDENT dp = { - 1 : 0 } NEW_LINE arr2 . sort ( ) NEW_LINE for a in arr1 : NEW_LINE INDENT nextDp = defaultdict ( lambda : math . inf ) NEW_LINE for val , steps in dp . items ( ) : NEW_LINE INDENT if a > val : NEW_LINE INDENT nextDp [ a ] = min ( nextDp [ a ] , steps ) NEW_LINE DEDENT i = bisect_right ( arr2 , val ) NEW_LINE if i < len ( arr2 ) : NEW_LINE INDENT nextDp [ arr2 [ i ] ] = min ( nextDp [ arr2 [ i ] ] , steps + 1 ) NEW_LINE DEDENT DEDENT if not nextDp : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dp = nextDp NEW_LINE DEDENT return min ( dp . values ( ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxNumberOfBalloons ( self , text : str ) -> int : NEW_LINE INDENT count = Counter ( text ) NEW_LINE return min ( count [ ' b ' ] , count [ ' a ' ] , count [ ' l ' ] // 2 , count [ ' o ' ] // 2 , count [ ' n ' ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getRow ( self , rowIndex : int ) -> List [ int ] : NEW_LINE INDENT ans = [ 1 ] * ( rowIndex + 1 ) NEW_LINE for i in range ( 2 , rowIndex + 1 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT ans [ i - j ] += ans [ i - j - 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minBuildTime ( self , blocks : List [ int ] , split : int ) -> int : NEW_LINE INDENT minHeap = blocks . copy ( ) NEW_LINE heapify ( minHeap ) NEW_LINE while len ( minHeap ) > 1 : NEW_LINE INDENT heapq . heappop ( minHeap ) NEW_LINE x = heapq . heappop ( minHeap ) NEW_LINE heapq . heappush ( minHeap , x + split ) NEW_LINE DEDENT return minHeap [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def intToRoman ( self , num : int ) -> str : NEW_LINE INDENT valueSymbols = [ ( 1000 , ' M ' ) , ( 900 , ' CM ' ) , ( 500 , ' D ' ) , ( 400 , ' CD ' ) , ( 100 , ' C ' ) , ( 90 , ' XC ' ) , ( 50 , ' L ' ) , ( 40 , ' XL ' ) , ( 10 , ' X ' ) , ( 9 , ' IX ' ) , ( 5 , ' V ' ) , ( 4 , ' IV ' ) , ( 1 , ' I ' ) ] NEW_LINE ans = [ ] NEW_LINE for value , symbol in valueSymbols : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT break NEW_LINE DEDENT count , num = divmod ( num , value ) NEW_LINE ans . append ( symbol * count ) NEW_LINE DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumTotal ( self , triangle : List [ List [ int ] ] ) -> int : NEW_LINE INDENT for i in reversed ( range ( len ( triangle ) - 1 ) ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT triangle [ i ] [ j ] += min ( triangle [ i + 1 ] [ j ] , triangle [ i + 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return triangle [ 0 ] [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumAbsDifference ( self , arr : List [ int ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE min = math . inf NEW_LINE arr . sort ( ) NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if diff < min : NEW_LINE INDENT min = diff NEW_LINE ans = [ ] NEW_LINE DEDENT if diff == min : NEW_LINE INDENT ans . append ( [ arr [ i ] , arr [ i + 1 ] ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nthUglyNumber ( self , n : int , a : int , b : int , c : int ) -> int : NEW_LINE INDENT ab = a * b // math . gcd ( a , b ) NEW_LINE ac = a * c // math . gcd ( a , c ) NEW_LINE bc = b * c // math . gcd ( b , c ) NEW_LINE abc = a * bc // math . gcd ( a , bc ) NEW_LINE l = 1 NEW_LINE r = 2 * int ( 1e9 ) NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if m // a + m // b + m // c - m // ab - m // ac - m // bc + m // abc >= n : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class UnionFind : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . id = list ( range ( n ) ) NEW_LINE DEDENT def union ( self , u : int , v : int ) -> None : NEW_LINE INDENT self . id [ self . find ( u ) ] = self . find ( v ) NEW_LINE DEDENT def find ( self , u : int ) -> int : NEW_LINE INDENT if self . id [ u ] != u : NEW_LINE INDENT self . id [ u ] = self . find ( self . id [ u ] ) NEW_LINE DEDENT return self . id [ u ] NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def smallestStringWithSwaps ( self , s : str , pairs : List [ List [ int ] ] ) -> str : NEW_LINE INDENT ans = ' ' NEW_LINE uf = UnionFind ( len ( s ) ) NEW_LINE map = defaultdict ( list ) NEW_LINE for p , q in pairs : NEW_LINE INDENT uf . union ( p , q ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT map [ uf . find ( i ) ] . append ( s [ i ] ) NEW_LINE DEDENT for key in map . keys ( ) : NEW_LINE INDENT map [ key ] . sort ( reverse = True ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT ans += map [ uf . find ( i ) ] . pop ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , val = - 1 , next = None , down = None ) : NEW_LINE INDENT self . val = val NEW_LINE self . next = next NEW_LINE self . down = down NEW_LINE DEDENT DEDENT class Skiplist : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . dummy = Node ( ) NEW_LINE DEDENT def search ( self , target : int ) -> bool : NEW_LINE INDENT node = self . dummy NEW_LINE while node : NEW_LINE INDENT while node . next and node . next . val < target : NEW_LINE INDENT node = node . next NEW_LINE DEDENT if node . next and node . next . val == target : NEW_LINE INDENT return True NEW_LINE DEDENT node = node . down NEW_LINE DEDENT return False NEW_LINE DEDENT def add ( self , num : int ) -> None : NEW_LINE INDENT nodes = [ ] NEW_LINE node = self . dummy NEW_LINE while node : NEW_LINE INDENT while node . next and node . next . val < num : NEW_LINE INDENT node = node . next NEW_LINE DEDENT nodes . append ( node ) NEW_LINE node = node . down NEW_LINE DEDENT shouldInsert = True NEW_LINE down = None NEW_LINE while shouldInsert and nodes : NEW_LINE INDENT node = nodes . pop ( ) NEW_LINE node . next = Node ( num , node . next , down ) NEW_LINE down = node . next NEW_LINE shouldInsert = random . getrandbits ( 1 ) == 0 NEW_LINE DEDENT if shouldInsert : NEW_LINE INDENT self . dummy = Node ( - 1 , None , self . dummy ) NEW_LINE DEDENT DEDENT def erase ( self , num : int ) -> bool : NEW_LINE INDENT node = self . dummy NEW_LINE found = False NEW_LINE while node : NEW_LINE INDENT while node . next and node . next . val < num : NEW_LINE INDENT node = node . next NEW_LINE DEDENT if node . next and node . next . val == num : NEW_LINE INDENT node . next = node . next . next NEW_LINE found = True NEW_LINE DEDENT node = node . down NEW_LINE DEDENT return found NEW_LINE DEDENT def _advance ( self , node : Node , target : int ) -> None : NEW_LINE INDENT while node . next and node . next . val < target : NEW_LINE INDENT node = node . next NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def uniqueOccurrences ( self , arr : List [ int ] ) -> bool : NEW_LINE INDENT count = Counter ( arr ) NEW_LINE occurrences = set ( ) NEW_LINE for value in count . values ( ) : NEW_LINE INDENT if value in occurrences : NEW_LINE INDENT return False NEW_LINE DEDENT occurrences . add ( value ) NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def equalSubstring ( self , s : str , t : str , maxCost : int ) -> int : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT maxCost -= abs ( ord ( s [ i ] ) - ord ( t [ i ] ) ) NEW_LINE if maxCost < 0 : NEW_LINE INDENT maxCost += abs ( ord ( s [ j ] ) - ord ( t [ j ] ) ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return len ( s ) - j NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeDuplicates ( self , s : str , k : int ) -> str : NEW_LINE INDENT stack = [ ] NEW_LINE for c in s : NEW_LINE INDENT if not stack or stack [ - 1 ] [ 0 ] != c : NEW_LINE INDENT stack . append ( [ c , 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stack [ - 1 ] [ 1 ] += 1 NEW_LINE if stack [ - 1 ] [ 1 ] == k : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT DEDENT DEDENT return ' ' . join ( c * count for c , count in stack ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxProfit ( self , prices : List [ int ] ) -> int : NEW_LINE INDENT sellOne = 0 NEW_LINE holdOne = - math . inf NEW_LINE for price in prices : NEW_LINE INDENT sellOne = max ( sellOne , holdOne + price ) NEW_LINE holdOne = max ( holdOne , - price ) NEW_LINE DEDENT return sellOne NEW_LINE DEDENT DEDENT
from enum import IntEnum NEW_LINE class Pos ( IntEnum ) : NEW_LINE INDENT HORIZONTAL = 0 NEW_LINE VERTICAL = 1 NEW_LINE DEDENT class Solution : NEW_LINE INDENT def minimumMoves ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( grid ) NEW_LINE ans = 0 NEW_LINE q = deque ( [ ( 0 , 0 , Pos . HORIZONTAL ) ] ) NEW_LINE seen = { ( 0 , 0 , Pos . HORIZONTAL ) } NEW_LINE def canMoveRight ( x : int , y : int , pos : Pos ) -> bool : NEW_LINE INDENT if pos == Pos . HORIZONTAL : NEW_LINE INDENT return y + 2 < n and not grid [ x ] [ y + 2 ] NEW_LINE DEDENT return y + 1 < n and not grid [ x ] [ y + 1 ] and not grid [ x + 1 ] [ y + 1 ] NEW_LINE DEDENT def canMoveDown ( x : int , y : int , pos : Pos ) -> bool : NEW_LINE INDENT if pos == Pos . VERTICAL : NEW_LINE INDENT return x + 2 < n and not grid [ x + 2 ] [ y ] NEW_LINE DEDENT return x + 1 < n and not grid [ x + 1 ] [ y ] and not grid [ x + 1 ] [ y + 1 ] NEW_LINE DEDENT def canRotateClockwise ( x : int , y : int , pos : Pos ) -> bool : NEW_LINE INDENT return pos == Pos . HORIZONTAL and x + 1 < n and not grid [ x + 1 ] [ y + 1 ] and not grid [ x + 1 ] [ y ] NEW_LINE DEDENT def canRotateCounterclockwise ( x : int , y : int , pos : Pos ) -> bool : NEW_LINE INDENT return pos == Pos . VERTICAL and y + 1 < n and not grid [ x + 1 ] [ y + 1 ] and not grid [ x ] [ y + 1 ] NEW_LINE DEDENT while q : NEW_LINE INDENT for _ in range ( len ( q ) ) : NEW_LINE INDENT x , y , pos = q . popleft ( ) NEW_LINE if x == n - 1 and y == n - 2 and pos == Pos . HORIZONTAL : NEW_LINE INDENT return ans NEW_LINE DEDENT if canMoveRight ( x , y , pos ) and ( x , y + 1 , pos ) not in seen : NEW_LINE INDENT q . append ( ( x , y + 1 , pos ) ) NEW_LINE seen . add ( ( x , y + 1 , pos ) ) NEW_LINE DEDENT if canMoveDown ( x , y , pos ) and ( x + 1 , y , pos ) not in seen : NEW_LINE INDENT q . append ( ( x + 1 , y , pos ) ) NEW_LINE seen . add ( ( x + 1 , y , pos ) ) NEW_LINE DEDENT newPos = Pos . VERTICAL if pos == Pos . HORIZONTAL else Pos . HORIZONTAL NEW_LINE if ( canRotateClockwise ( x , y , pos ) or canRotateCounterclockwise ( x , y , pos ) ) and ( x , y , newPos ) not in seen : NEW_LINE INDENT q . append ( ( x , y , newPos ) ) NEW_LINE seen . add ( ( x , y , newPos ) ) NEW_LINE DEDENT DEDENT ans += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isValidPalindrome ( self , s : str , k : int ) -> bool : NEW_LINE INDENT return len ( s ) - self . _longestPalindromeSubseq ( s ) <= k NEW_LINE DEDENT def _longestPalindromeSubseq ( self , s : str ) -> int : NEW_LINE INDENT n = len ( s ) NEW_LINE dp = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] [ i ] = 1 NEW_LINE DEDENT for d in range ( 1 , n ) : NEW_LINE INDENT for i in range ( n - d ) : NEW_LINE INDENT j = i + d NEW_LINE if s [ i ] == s [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minCostToMoveChips ( self , chips : List [ int ] ) -> int : NEW_LINE INDENT count = [ 0 ] * 2 NEW_LINE for chip in chips : NEW_LINE INDENT count [ chip % 2 ] += 1 NEW_LINE DEDENT return min ( count [ 0 ] , count [ 1 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestSubsequence ( self , arr : List [ int ] , difference : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE lengthAt = { } NEW_LINE for a in arr : NEW_LINE INDENT lengthAt [ a ] = lengthAt . get ( a - difference , 0 ) + 1 NEW_LINE ans = max ( ans , lengthAt [ a ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxProfit ( self , prices : List [ int ] ) -> int : NEW_LINE INDENT sell = 0 NEW_LINE hold = - math . inf NEW_LINE for price in prices : NEW_LINE INDENT sell = max ( sell , hold + price ) NEW_LINE hold = max ( hold , sell - price ) NEW_LINE DEDENT return sell NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def queensAttacktheKing ( self , queens : List [ List [ int ] ] , king : List [ int ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE queens = { ( i , j ) for i , j in queens } NEW_LINE for d in [ [ - 1 , - 1 ] , [ - 1 , 0 ] , [ - 1 , 1 ] , [ 0 , - 1 ] , [ 0 , 1 ] , [ 1 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] ] : NEW_LINE INDENT i = king [ 0 ] + d [ 0 ] NEW_LINE j = king [ 1 ] + d [ 1 ] NEW_LINE while 0 <= i < 8 and 0 <= j < 8 : NEW_LINE INDENT if ( i , j ) in queens : NEW_LINE INDENT ans . append ( [ i , j ] ) NEW_LINE break NEW_LINE DEDENT i += d [ 0 ] NEW_LINE j += d [ 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxEqualFreq ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE maxFreq = 0 NEW_LINE count = Counter ( ) NEW_LINE freq = Counter ( ) NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT freq [ count [ num ] ] -= 1 NEW_LINE count [ num ] += 1 NEW_LINE freq [ count [ num ] ] += 1 NEW_LINE maxFreq = max ( maxFreq , count [ num ] ) NEW_LINE if maxFreq == 1 or maxFreq * freq [ maxFreq ] == i or ( maxFreq - 1 ) * ( freq [ maxFreq - 1 ] + 1 ) == i : NEW_LINE INDENT ans = i + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nthPersonGetsNthSeat ( self , n : int ) -> float : NEW_LINE INDENT return 1 if n == 1 else 0.5 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxProfit ( self , prices : List [ int ] ) -> int : NEW_LINE INDENT sellTwo = 0 NEW_LINE holdTwo = - math . inf NEW_LINE sellOne = 0 NEW_LINE holdOne = - math . inf NEW_LINE for price in prices : NEW_LINE INDENT sellTwo = max ( sellTwo , holdTwo + price ) NEW_LINE holdTwo = max ( holdTwo , sellOne - price ) NEW_LINE sellOne = max ( sellOne , holdOne + price ) NEW_LINE holdOne = max ( holdOne , - price ) NEW_LINE DEDENT return sellTwo NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximizeSweetness ( self , sweetness : List [ int ] , k : int ) -> int : NEW_LINE INDENT l = len ( sweetness ) // ( k + 1 ) NEW_LINE r = sum ( sweetness ) // ( k + 1 ) NEW_LINE def canEat ( m : int ) -> bool : NEW_LINE INDENT pieces = 0 NEW_LINE summ = 0 NEW_LINE for s in sweetness : NEW_LINE INDENT summ += s NEW_LINE if summ >= m : NEW_LINE INDENT pieces += 1 NEW_LINE if pieces > k : NEW_LINE INDENT return True NEW_LINE DEDENT summ = 0 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if canEat ( m ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return l if canEat ( l ) else l - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkStraightLine ( self , coordinates : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT x0 , y0 , x1 , y1 = * coordinates [ 0 ] , * coordinates [ 1 ] NEW_LINE dx = x1 - x0 NEW_LINE dy = y1 - y0 NEW_LINE return all ( ( x - x0 ) * dy == ( y - y0 ) * dx for x , y in coordinates ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeSubfolders ( self , folder : List [ str ] ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE prev = " " NEW_LINE folder . sort ( ) NEW_LINE for f in folder : NEW_LINE INDENT if len ( prev ) > 0 and f . startswith ( prev ) and f [ len ( prev ) ] == ' / ' : NEW_LINE INDENT continue NEW_LINE DEDENT ans . append ( f ) NEW_LINE prev = f NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def balancedString ( self , s : str ) -> int : NEW_LINE INDENT ans = len ( s ) NEW_LINE count = Counter ( s ) NEW_LINE j = 0 NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT count [ c ] -= 1 NEW_LINE while j < len ( s ) and all ( count [ c ] <= len ( s ) // 4 for c in ' QWER ' ) : NEW_LINE INDENT ans = min ( ans , i - j + 1 ) NEW_LINE count [ s [ j ] ] += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def jobScheduling ( self , startTime : List [ int ] , endTime : List [ int ] , profit : List [ int ] ) -> int : NEW_LINE INDENT jobs = sorted ( [ ( s , e , p ) for s , e , p in zip ( startTime , endTime , profit ) ] ) NEW_LINE for i in range ( len ( startTime ) ) : NEW_LINE INDENT startTime [ i ] = jobs [ i ] [ 0 ] NEW_LINE DEDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int ) -> int : NEW_LINE INDENT if i == len ( startTime ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT j = bisect_left ( startTime , jobs [ i ] [ 1 ] ) NEW_LINE return max ( jobs [ i ] [ 2 ] + dp ( j ) , dp ( i + 1 ) ) NEW_LINE DEDENT return dp ( 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def crawl ( self , startUrl : str , htmlParser : ' HtmlParser ' ) -> List [ str ] : NEW_LINE INDENT q = deque ( [ startUrl ] ) NEW_LINE seen = { startUrl } NEW_LINE hostname = startUrl . split ( ' / ' ) [ 2 ] NEW_LINE while q : NEW_LINE INDENT currUrl = q . popleft ( ) NEW_LINE for url in htmlParser . getUrls ( currUrl ) : NEW_LINE INDENT if url in seen : NEW_LINE INDENT continue NEW_LINE DEDENT if hostname in url : NEW_LINE INDENT q . append ( url ) NEW_LINE seen . add ( url ) NEW_LINE DEDENT DEDENT DEDENT return seen NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findSolution ( self , customfunction : ' CustomFunction ' , z : int ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE x = 1 NEW_LINE y = 1000 NEW_LINE while x <= 1000 and y >= 1 : NEW_LINE INDENT f = customfunction . f ( x , y ) NEW_LINE if f < z : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif f > z : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( [ x , y ] ) NEW_LINE x += 1 NEW_LINE y -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def circularPermutation ( self , n : int , start : int ) -> List [ int ] : NEW_LINE INDENT return [ start ^ i ^ i >> 1 for i in range ( 1 << n ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxPathSum ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT ans = - math . inf NEW_LINE def maxPathSumDownFrom ( root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT nonlocal ans NEW_LINE if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = max ( 0 , maxPathSumDownFrom ( root . left ) ) NEW_LINE r = max ( 0 , maxPathSumDownFrom ( root . right ) ) NEW_LINE ans = max ( ans , root . val + l + r ) NEW_LINE return root . val + max ( l , r ) NEW_LINE DEDENT maxPathSumDownFrom ( root ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def tilingRectangle ( self , n : int , m : int ) -> int : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( heights : int ) -> int : NEW_LINE INDENT minHeight = min ( heights ) NEW_LINE if minHeight == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = m * n NEW_LINE heightsList = list ( heights ) NEW_LINE start = heightsList . index ( minHeight ) NEW_LINE for sz in range ( 1 , min ( m - start + 1 , n - minHeight + 1 ) ) : NEW_LINE INDENT if heights [ start + sz - 1 ] != minHeight : NEW_LINE INDENT break NEW_LINE DEDENT heightsList [ start : start + sz ] = [ minHeight + sz ] * sz NEW_LINE ans = min ( ans , dp ( tuple ( heightsList ) ) ) NEW_LINE DEDENT return 1 + ans NEW_LINE DEDENT return dp ( tuple ( [ 0 ] * m ) ) NEW_LINE DEDENT DEDENT
class Leaderboard : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . idToScore = Counter ( ) NEW_LINE DEDENT def addScore ( self , playerId : int , score : int ) -> None : NEW_LINE INDENT self . idToScore [ playerId ] += score NEW_LINE DEDENT def top ( self , K : int ) -> int : NEW_LINE INDENT return sum ( score for _ , score in self . idToScore . most_common ( K ) ) NEW_LINE DEDENT def reset ( self , playerId : int ) -> None : NEW_LINE INDENT del self . idToScore [ playerId ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumMoves ( self , arr : List [ int ] ) -> int : NEW_LINE INDENT n = len ( arr ) NEW_LINE dp = [ [ n ] * n for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] [ i ] = 1 NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 1 if arr [ i ] == arr [ i + 1 ] else 2 NEW_LINE DEDENT for d in range ( 2 , n ) : NEW_LINE INDENT for i in range ( n - d ) : NEW_LINE INDENT j = i + d NEW_LINE if arr [ i ] == arr [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberOfSubarrays ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT def numberOfSubarraysAtMost ( k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while r <= len ( nums ) : NEW_LINE INDENT if k >= 0 : NEW_LINE INDENT ans += r - l NEW_LINE if r == len ( nums ) : NEW_LINE INDENT break NEW_LINE DEDENT if nums [ r ] & 1 : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT r += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if nums [ l ] & 1 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return numberOfSubarraysAtMost ( k ) - numberOfSubarraysAtMost ( k - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minRemoveToMakeValid ( self , s : str ) -> str : NEW_LINE INDENT stack = [ ] NEW_LINE chars = [ c for c in s ] NEW_LINE for i , c in enumerate ( chars ) : NEW_LINE INDENT if c == ' ( ' : NEW_LINE INDENT stack . append ( i ) NEW_LINE DEDENT elif c == ' ) ' : NEW_LINE INDENT if stack : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT chars [ i ] = ' * ' NEW_LINE DEDENT DEDENT DEDENT while stack : NEW_LINE INDENT chars [ stack . pop ( ) ] = ' * ' NEW_LINE DEDENT return ' ' . join ( chars ) . replace ( ' * ' , ' ' ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isPalindrome ( self , s : str ) -> bool : NEW_LINE INDENT l = 0 NEW_LINE r = len ( s ) - 1 NEW_LINE while l < r : NEW_LINE INDENT while l < r and not s [ l ] . isalnum ( ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT while l < r and not s [ r ] . isalnum ( ) : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT if s [ l ] . lower ( ) != s [ r ] . lower ( ) : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def oddCells ( self , m : int , n : int , indices : List [ List [ int ] ] ) -> int : NEW_LINE INDENT rows = [ False ] * m NEW_LINE cols = [ False ] * n NEW_LINE for r , c in indices : NEW_LINE INDENT rows [ r ] ^= True NEW_LINE cols [ c ] ^= True NEW_LINE DEDENT return sum ( rows [ i ] ^ cols [ j ] for i in range ( m ) for j in range ( n ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reconstructMatrix ( self , upper : int , lower : int , colsum : List [ int ] ) -> List [ List [ int ] ] : NEW_LINE INDENT if upper + lower != sum ( colsum ) : NEW_LINE INDENT return [ ] NEW_LINE DEDENT if min ( upper , lower ) < colsum . count ( 2 ) : NEW_LINE INDENT return [ ] NEW_LINE DEDENT ans = [ [ 0 ] * len ( colsum ) for _ in range ( 2 ) ] NEW_LINE for j , c in enumerate ( colsum ) : NEW_LINE INDENT if c == 2 : NEW_LINE INDENT ans [ 0 ] [ j ] = 1 NEW_LINE ans [ 1 ] [ j ] = 1 NEW_LINE upper -= 1 NEW_LINE lower -= 1 NEW_LINE DEDENT DEDENT for j , c in enumerate ( colsum ) : NEW_LINE INDENT if c == 1 and upper > 0 : NEW_LINE INDENT ans [ 0 ] [ j ] = 1 NEW_LINE c -= 1 NEW_LINE upper -= 1 NEW_LINE DEDENT if c == 1 and lower > 0 : NEW_LINE INDENT ans [ 1 ] [ j ] = 1 NEW_LINE lower -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def closedIsland ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE def dfs ( i : int , j : int ) -> None : NEW_LINE INDENT if i < 0 or i == m or j < 0 or j == n : NEW_LINE INDENT return NEW_LINE DEDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT return NEW_LINE DEDENT grid [ i ] [ j ] = 1 NEW_LINE dfs ( i + 1 , j ) NEW_LINE dfs ( i - 1 , j ) NEW_LINE dfs ( i , j + 1 ) NEW_LINE dfs ( i , j - 1 ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i * j == 0 or i == m - 1 or j == n - 1 : NEW_LINE INDENT if grid [ i ] [ j ] == 0 : NEW_LINE INDENT dfs ( i , j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] == 0 : NEW_LINE INDENT dfs ( i , j ) NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxScoreWords ( self , words : List [ str ] , letters : List [ chr ] , score : List [ int ] ) -> int : NEW_LINE INDENT count = Counter ( letters ) NEW_LINE def useWord ( i : int ) -> int : NEW_LINE INDENT isValid = True NEW_LINE earned = 0 NEW_LINE for c in words [ i ] : NEW_LINE INDENT count [ c ] -= 1 NEW_LINE if count [ c ] < 0 : NEW_LINE INDENT isValid = False NEW_LINE DEDENT earned += score [ ord ( c ) - ord ( ' a ' ) ] NEW_LINE DEDENT return earned if isValid else - 1 NEW_LINE DEDENT def unuseWord ( i : int ) -> None : NEW_LINE INDENT for c in words [ i ] : NEW_LINE INDENT count [ c ] += 1 NEW_LINE DEDENT DEDENT def dfs ( s : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( s , len ( words ) ) : NEW_LINE INDENT earned = useWord ( i ) NEW_LINE if earned > 0 : NEW_LINE INDENT ans = max ( ans , earned + dfs ( i + 1 ) ) NEW_LINE DEDENT unuseWord ( i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT return dfs ( 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberOfWays ( self , numPeople : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE dp = [ 1 ] + [ 0 ] * ( numPeople // 2 ) NEW_LINE for i in range ( 1 , numPeople // 2 + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT dp [ i ] += dp [ j ] * dp [ i - 1 - j ] NEW_LINE dp [ i ] %= kMod NEW_LINE DEDENT DEDENT return dp [ numPeople // 2 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findLadders ( self , beginWord : str , endWord : str , wordList : List [ str ] ) -> List [ List [ str ] ] : NEW_LINE INDENT wordSet = set ( wordList ) NEW_LINE if endWord not in wordList : NEW_LINE INDENT return [ ] NEW_LINE DEDENT graph : Dict [ str , List [ str ] ] = defaultdict ( list ) NEW_LINE if not self . _bfs ( beginWord , endWord , wordSet , graph ) : NEW_LINE INDENT return [ ] NEW_LINE DEDENT ans = [ ] NEW_LINE self . _dfs ( graph , beginWord , endWord , [ beginWord ] , ans ) NEW_LINE return ans NEW_LINE DEDENT def _bfs ( self , beginWord : str , endWord : str , wordSet : Set [ str ] , graph : Dict [ str , List [ str ] ] ) -> bool : NEW_LINE INDENT currentLevelWords = { beginWord } NEW_LINE while currentLevelWords : NEW_LINE INDENT for word in currentLevelWords : NEW_LINE INDENT wordSet . discard ( word ) NEW_LINE DEDENT nextLevelWords = set ( ) NEW_LINE reachEndWord = False NEW_LINE for parent in currentLevelWords : NEW_LINE INDENT for child in self . _getChildren ( parent , wordSet ) : NEW_LINE INDENT if child in wordSet : NEW_LINE INDENT nextLevelWords . add ( child ) NEW_LINE graph [ parent ] . append ( child ) NEW_LINE DEDENT if child == endWord : NEW_LINE INDENT reachEndWord = True NEW_LINE DEDENT DEDENT DEDENT if reachEndWord : NEW_LINE INDENT return True NEW_LINE DEDENT currentLevelWords = nextLevelWords NEW_LINE DEDENT return False NEW_LINE DEDENT def _getChildren ( self , parent : str , wordSet : Set [ str ] ) -> List [ str ] : NEW_LINE INDENT children = [ ] NEW_LINE s = list ( parent ) NEW_LINE for i , cache in enumerate ( s ) : NEW_LINE INDENT for c in string . ascii_lowercase : NEW_LINE INDENT if c == cache : NEW_LINE INDENT continue NEW_LINE DEDENT s [ i ] = c NEW_LINE child = ' ' . join ( s ) NEW_LINE if child in wordSet : NEW_LINE INDENT children . append ( child ) NEW_LINE DEDENT DEDENT s [ i ] = cache NEW_LINE DEDENT return children NEW_LINE DEDENT def _dfs ( self , graph : Dict [ str , List [ str ] ] , word : str , endWord : str , path : List [ str ] , ans : List [ List [ str ] ] ) -> None : NEW_LINE INDENT if word == endWord : NEW_LINE INDENT ans . append ( path . copy ( ) ) NEW_LINE return NEW_LINE DEDENT for child in graph . get ( word , [ ] ) : NEW_LINE INDENT path . append ( child ) NEW_LINE self . _dfs ( graph , child , endWord , path , ans ) NEW_LINE path . pop ( ) NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def shiftGrid ( self , grid : List [ List [ int ] ] , k : int ) -> List [ List [ int ] ] : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE ans = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE k %= m * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT index = ( i * n + j + k ) % ( m * n ) NEW_LINE x = index // n NEW_LINE y = index % n NEW_LINE ans [ x ] [ y ] = grid [ i ] [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class FindElements : NEW_LINE INDENT def __init__ ( self , root : Optional [ TreeNode ] ) : NEW_LINE INDENT self . vals = set ( ) NEW_LINE self . dfs ( root , 0 ) NEW_LINE DEDENT def find ( self , target : int ) -> bool : NEW_LINE INDENT return target in self . vals NEW_LINE DEDENT def dfs ( self , root : Optional [ TreeNode ] , val : int ) -> None : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT root . val = val NEW_LINE self . vals . add ( val ) NEW_LINE self . dfs ( root . left , val * 2 + 1 ) NEW_LINE self . dfs ( root . right , val * 2 + 2 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minPushBox ( self , grid : List [ List [ chr ] ] ) -> int : NEW_LINE INDENT dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] == ' B ' : NEW_LINE INDENT box = ( i , j ) NEW_LINE DEDENT elif grid [ i ] [ j ] == ' S ' : NEW_LINE INDENT player = ( i , j ) NEW_LINE DEDENT elif grid [ i ] [ j ] == ' T ' : NEW_LINE INDENT target = ( i , j ) NEW_LINE DEDENT DEDENT DEDENT def isInvalid ( playerX : int , playerY : int ) -> bool : NEW_LINE INDENT return playerX < 0 or playerX == m or playerY < 0 or playerY == n or grid [ playerX ] [ playerY ] == ' # ' NEW_LINE DEDENT def canGoTo ( playerX : int , playerY : int , fromX : int , fromY : int , boxX : int , boxY : int ) -> bool : NEW_LINE INDENT q = deque ( [ ( playerX , playerY ) ] ) NEW_LINE seen = { ( playerX , playerY ) } NEW_LINE while q : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE if i == fromX and j == fromY : NEW_LINE INDENT return True NEW_LINE DEDENT for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if isInvalid ( x , y ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( x , y ) in seen : NEW_LINE INDENT continue NEW_LINE DEDENT if x == boxX and y == boxY : NEW_LINE INDENT continue NEW_LINE DEDENT q . append ( ( x , y ) ) NEW_LINE seen . add ( ( x , y ) ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT ans = 0 NEW_LINE q = deque ( [ ( box [ 0 ] , box [ 1 ] , player [ 0 ] , player [ 1 ] ) ] ) NEW_LINE seen = { ( box [ 0 ] , box [ 1 ] , player [ 0 ] , player [ 1 ] ) } NEW_LINE while q : NEW_LINE INDENT for _ in range ( len ( q ) ) : NEW_LINE INDENT boxX , boxY , playerX , playerY = q . popleft ( ) NEW_LINE if boxX == target [ 0 ] and boxY == target [ 1 ] : NEW_LINE INDENT return ans NEW_LINE DEDENT for k in range ( 4 ) : NEW_LINE INDENT nextBoxX = boxX + dirs [ k ] NEW_LINE nextBoxY = boxY + dirs [ k + 1 ] NEW_LINE if isInvalid ( nextBoxX , nextBoxY ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( nextBoxX , nextBoxY , boxX , boxY ) in seen : NEW_LINE INDENT continue NEW_LINE DEDENT fromX = boxX + dirs [ ( k + 2 ) % 4 ] NEW_LINE fromY = boxY + dirs [ ( k + 3 ) % 4 ] NEW_LINE if isInvalid ( fromX , fromY ) : NEW_LINE INDENT continue NEW_LINE DEDENT if canGoTo ( playerX , playerY , fromX , fromY , boxX , boxY ) : NEW_LINE INDENT q . append ( ( nextBoxX , nextBoxY , boxX , boxY ) ) NEW_LINE seen . add ( ( nextBoxX , nextBoxY , boxX , boxY ) ) NEW_LINE DEDENT DEDENT DEDENT ans += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minTimeToVisitAllPoints ( self , points : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , len ( points ) ) : NEW_LINE INDENT ans += max ( abs ( points [ i ] [ 0 ] - points [ i - 1 ] [ 0 ] ) , abs ( points [ i ] [ 1 ] - points [ i - 1 ] [ 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countServers ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE ans = 0 NEW_LINE rows = [ 0 ] * m NEW_LINE cols = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT rows [ i ] += 1 NEW_LINE cols [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 and ( rows [ i ] > 1 or cols [ j ] > 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numWays ( self , steps : int , arrLen : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE dp = [ 0 ] * min ( steps // 2 + 1 , arrLen ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for _ in range ( steps ) : NEW_LINE INDENT newDp = [ 0 ] * min ( steps // 2 + 1 , arrLen ) NEW_LINE for i , ways in enumerate ( dp ) : NEW_LINE INDENT if ways > 0 : NEW_LINE INDENT for dx in ( - 1 , 0 , 1 ) : NEW_LINE INDENT nextIndex = i + dx NEW_LINE if 0 <= nextIndex < len ( dp ) : NEW_LINE INDENT newDp [ nextIndex ] += ways NEW_LINE newDp [ nextIndex ] %= kMod NEW_LINE DEDENT DEDENT DEDENT DEDENT dp = newDp NEW_LINE DEDENT return dp [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def ladderLength ( self , beginWord : str , endWord : str , wordList : List [ str ] ) -> int : NEW_LINE INDENT wordSet = set ( wordList ) NEW_LINE if endWord not in wordSet : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE q = deque ( [ beginWord ] ) NEW_LINE while q : NEW_LINE INDENT ans += 1 NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT wordList = list ( q . popleft ( ) ) NEW_LINE for i , cache in enumerate ( wordList ) : NEW_LINE INDENT for c in string . ascii_lowercase : NEW_LINE INDENT wordList [ i ] = c NEW_LINE word = ' ' . join ( wordList ) NEW_LINE if word == endWord : NEW_LINE INDENT return ans + 1 NEW_LINE DEDENT if word in wordSet : NEW_LINE INDENT q . append ( word ) NEW_LINE wordSet . remove ( word ) NEW_LINE DEDENT DEDENT wordList [ i ] = cache NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def countShips ( self , sea : ' Sea ' , topRight : ' Point ' , bottomLeft : ' Point ' ) -> int : NEW_LINE INDENT if topRight . x < bottomLeft . x or topRight . y < bottomLeft . y : NEW_LINE INDENT return 0 NEW_LINE DEDENT if not sea . hasShips ( topRight , bottomLeft ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if topRight . x == bottomLeft . x and topRight . y == bottomLeft . y : NEW_LINE INDENT return 1 NEW_LINE DEDENT mx = ( topRight . x + bottomLeft . x ) // 2 NEW_LINE my = ( topRight . y + bottomLeft . y ) // 2 NEW_LINE ans = 0 NEW_LINE ans += self . countShips ( sea , topRight , Point ( mx + 1 , my + 1 ) ) NEW_LINE ans += self . countShips ( sea , Point ( topRight . x , my ) , Point ( mx + 1 , bottomLeft . y ) ) NEW_LINE ans += self . countShips ( sea , Point ( mx , topRight . y ) , Point ( bottomLeft . x , my + 1 ) ) NEW_LINE ans += self . countShips ( sea , Point ( mx , my ) , bottomLeft ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def tictactoe ( self , moves : List [ List [ int ] ] ) -> str : NEW_LINE INDENT row = [ [ 0 ] * 3 for _ in range ( 2 ) ] NEW_LINE col = [ [ 0 ] * 3 for _ in range ( 2 ) ] NEW_LINE diag1 = [ 0 ] * 2 NEW_LINE diag2 = [ 0 ] * 2 NEW_LINE i = 0 NEW_LINE for r , c in moves : NEW_LINE INDENT row [ i ] [ r ] += 1 NEW_LINE col [ i ] [ c ] += 1 NEW_LINE diag1 [ i ] += r == c NEW_LINE diag2 [ i ] += r + c == 2 NEW_LINE if 3 in ( row [ i ] [ r ] , col [ i ] [ c ] , diag1 [ i ] , diag2 [ i ] ) : NEW_LINE INDENT return " A " if i == 0 else " B " NEW_LINE DEDENT i ^= 1 NEW_LINE DEDENT return " Draw " if len ( moves ) == 9 else " Pending " NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numOfBurgers ( self , tomatoSlices : int , cheeseSlices : int ) -> List [ int ] : NEW_LINE INDENT if tomatoSlices % 2 == 1 or tomatoSlices < 2 * cheeseSlices or tomatoSlices > cheeseSlices * 4 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT jumboBurgers = ( tomatoSlices - 2 * cheeseSlices ) // 2 NEW_LINE return [ jumboBurgers , cheeseSlices - jumboBurgers ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countSquares ( self , matrix : List [ List [ int ] ] ) -> int : NEW_LINE INDENT for i in range ( len ( matrix ) ) : NEW_LINE INDENT for j in range ( len ( matrix [ 0 ] ) ) : NEW_LINE INDENT if matrix [ i ] [ j ] == 1 and i > 0 and j > 0 : NEW_LINE INDENT matrix [ i ] [ j ] += min ( matrix [ i - 1 ] [ j - 1 ] , matrix [ i - 1 ] [ j ] , matrix [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return sum ( sum ( row ) for row in matrix ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestConsecutive ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE seen = set ( nums ) NEW_LINE for num in nums : NEW_LINE INDENT if num - 1 in seen : NEW_LINE INDENT continue NEW_LINE DEDENT length = 0 NEW_LINE while num in seen : NEW_LINE INDENT num += 1 NEW_LINE length += 1 NEW_LINE DEDENT ans = max ( ans , length ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def subtractProductAndSum ( self , n : int ) -> int : NEW_LINE INDENT prod = 1 NEW_LINE summ = 0 NEW_LINE while n > 0 : NEW_LINE INDENT prod *= n % 10 NEW_LINE summ += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return prod - summ NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minFlips ( self , mat : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( mat ) NEW_LINE n = len ( mat [ 0 ] ) NEW_LINE hashed = self . _hash ( mat , m , n ) NEW_LINE if hashed == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE step = 0 NEW_LINE q = deque ( [ hashed ] ) NEW_LINE seen = { hashed } NEW_LINE while q : NEW_LINE INDENT step += 1 NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT curr = q . popleft ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT next = curr ^ 1 << ( i * n + j ) NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT next ^= 1 << ( x * n + y ) NEW_LINE DEDENT if next == 0 : NEW_LINE INDENT return step NEW_LINE DEDENT if next in seen : NEW_LINE INDENT continue NEW_LINE DEDENT q . append ( next ) NEW_LINE seen . add ( next ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT def _hash ( self , mat : List [ List [ int ] ] , m : int , n : int ) -> int : NEW_LINE INDENT hashed = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] : NEW_LINE INDENT hashed |= 1 << ( i * n + j ) NEW_LINE DEDENT DEDENT DEDENT return hashed NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findSpecialInteger ( self , arr : List [ int ] ) -> int : NEW_LINE INDENT n = len ( arr ) NEW_LINE quarter = n // 4 NEW_LINE for i in range ( n - quarter ) : NEW_LINE INDENT if arr [ i ] == arr [ i + quarter ] : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def minFallingPathSum ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( grid ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ( firstMinNum , firstMinIndex ) , ( secondMinNum , _ ) = sorted ( { ( a , i ) for i , a in enumerate ( grid [ i - 1 ] ) } ) [ : 2 ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j == firstMinIndex : NEW_LINE INDENT grid [ i ] [ j ] += secondMinNum NEW_LINE DEDENT else : NEW_LINE INDENT grid [ i ] [ j ] += firstMinNum NEW_LINE DEDENT DEDENT DEDENT return min ( grid [ - 1 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sumNumbers ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE def dfs ( root : Optional [ TreeNode ] , path : int ) -> None : NEW_LINE INDENT nonlocal ans NEW_LINE if not root : NEW_LINE INDENT return NEW_LINE DEDENT if not root . left and not root . right : NEW_LINE INDENT ans += path * 10 + root . val NEW_LINE return NEW_LINE DEDENT dfs ( root . left , path * 10 + root . val ) NEW_LINE dfs ( root . right , path * 10 + root . val ) NEW_LINE DEDENT dfs ( root , 0 ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getDecimalValue ( self , head : ListNode ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE while head : NEW_LINE INDENT ans = ans * 2 + head . val NEW_LINE head = head . next NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxSideLength ( self , mat : List [ List [ int ] ] , threshold : int ) -> int : NEW_LINE INDENT m = len ( mat ) NEW_LINE n = len ( mat [ 0 ] ) NEW_LINE ans = 0 NEW_LINE prefix = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT prefix [ i + 1 ] [ j + 1 ] = mat [ i ] [ j ] + prefix [ i ] [ j + 1 ] + prefix [ i + 1 ] [ j ] - prefix [ i ] [ j ] NEW_LINE DEDENT DEDENT def squareSum ( r1 : int , c1 : int , r2 : int , c2 : int ) -> int : NEW_LINE INDENT return prefix [ r2 + 1 ] [ c2 + 1 ] - prefix [ r1 ] [ c2 + 1 ] - prefix [ r2 + 1 ] [ c1 ] + prefix [ r1 ] [ c1 ] NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for length in range ( ans , min ( m - i , n - j ) ) : NEW_LINE INDENT if squareSum ( i , j , i + length , j + length ) > threshold : NEW_LINE INDENT break NEW_LINE DEDENT ans = max ( ans , length + 1 ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def shortestPath ( self , grid : List [ List [ int ] ] , k : int ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE if m == 1 and n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE steps = 0 NEW_LINE q = deque ( [ ( 0 , 0 , k ) ] ) NEW_LINE seen = { ( 0 , 0 , k ) } NEW_LINE while q : NEW_LINE INDENT steps += 1 NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT i , j , eliminate = q . popleft ( ) NEW_LINE for l in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ l ] NEW_LINE y = j + dirs [ l + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT if x == m - 1 and y == n - 1 : NEW_LINE INDENT return steps NEW_LINE DEDENT if grid [ x ] [ y ] == 1 and eliminate == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT newEliminate = eliminate - grid [ x ] [ y ] NEW_LINE if ( x , y , newEliminate ) in seen : NEW_LINE INDENT continue NEW_LINE DEDENT q . append ( ( x , y , newEliminate ) ) NEW_LINE seen . add ( ( x , y , newEliminate ) ) NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findNumbers ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for num in nums : NEW_LINE INDENT if 9 < num < 100 or 999 < num < 10000 or num == 100000 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isPossibleDivide ( self , nums : List [ int ] , k : int ) -> bool : NEW_LINE INDENT count = Counter ( nums ) NEW_LINE for start in sorted ( count ) : NEW_LINE INDENT value = count [ start ] NEW_LINE if value > 0 : NEW_LINE INDENT for i in range ( start , start + k ) : NEW_LINE INDENT count [ i ] -= value NEW_LINE if count [ i ] < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxCandies ( self , status : List [ int ] , candies : List [ int ] , keys : List [ List [ int ] ] , containedBoxes : List [ List [ int ] ] , initialBoxes : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE q = deque ( ) NEW_LINE reachedClosedBoxes = [ 0 ] * len ( status ) NEW_LINE def pushBoxesIfPossible ( boxes : List [ int ] ) -> None : NEW_LINE INDENT for box in boxes : NEW_LINE INDENT if status [ box ] : NEW_LINE INDENT q . append ( box ) NEW_LINE DEDENT else : NEW_LINE INDENT reachedClosedBoxes [ box ] = True NEW_LINE DEDENT DEDENT DEDENT pushBoxesIfPossible ( initialBoxes ) NEW_LINE while q : NEW_LINE INDENT currBox = q . popleft ( ) NEW_LINE ans += candies [ currBox ] NEW_LINE for key in keys [ currBox ] : NEW_LINE INDENT if not status [ key ] and reachedClosedBoxes [ key ] : NEW_LINE INDENT q . append ( key ) NEW_LINE DEDENT status [ key ] = 1 NEW_LINE DEDENT pushBoxesIfPossible ( containedBoxes [ currBox ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def replaceElements ( self , arr : List [ int ] ) -> List [ int ] : NEW_LINE INDENT maxOfRight = - 1 NEW_LINE for i in reversed ( range ( len ( arr ) ) ) : NEW_LINE INDENT arr [ i ] , maxOfRight = maxOfRight , max ( maxOfRight , arr [ i ] ) NEW_LINE DEDENT return arr NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def romanToInt ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE roman = { ' I ' : 1 , ' V ' : 5 , ' X ' : 10 , ' L ' : 50 , ' C ' : 100 , ' D ' : 500 , ' M ' : 1000 } NEW_LINE for a , b in zip ( s , s [ 1 : ] ) : NEW_LINE INDENT if roman [ a ] < roman [ b ] : NEW_LINE INDENT ans -= roman [ a ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += roman [ a ] NEW_LINE DEDENT DEDENT return ans + roman [ s [ - 1 ] ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def solve ( self , board : List [ List [ str ] ] ) -> None : NEW_LINE INDENT if not board : NEW_LINE INDENT return NEW_LINE DEDENT m = len ( board ) NEW_LINE n = len ( board [ 0 ] ) NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE q = deque ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i * j == 0 or i == m - 1 or j == n - 1 : NEW_LINE INDENT if board [ i ] [ j ] == ' O ' : NEW_LINE INDENT q . append ( ( i , j ) ) NEW_LINE board [ i ] [ j ] = ' * ' NEW_LINE DEDENT DEDENT DEDENT DEDENT while q : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT if board [ x ] [ y ] != ' O ' : NEW_LINE INDENT continue NEW_LINE DEDENT q . append ( ( x , y ) ) NEW_LINE board [ x ] [ y ] = ' * ' NEW_LINE DEDENT DEDENT for row in board : NEW_LINE INDENT for i , c in enumerate ( row ) : NEW_LINE INDENT row [ i ] = ' O ' if c == ' * ' else ' X ' NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def findBestValue ( self , arr : List [ int ] , target : int ) -> int : NEW_LINE INDENT prefix = 0 NEW_LINE arr . sort ( ) NEW_LINE for i , a in enumerate ( arr ) : NEW_LINE INDENT ans = round ( ( target - prefix ) / ( len ( arr ) - i ) ) NEW_LINE if ans <= a : NEW_LINE INDENT return ans NEW_LINE DEDENT prefix += a NEW_LINE DEDENT return arr [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def pathsWithMaxScore ( self , board : List [ str ] ) -> List [ int ] : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE n = len ( board ) NEW_LINE dirs = [ ( 0 , 1 ) , ( 1 , 0 ) , ( 1 , 1 ) ] NEW_LINE dp = [ [ - 1 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE count = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE dp [ n - 1 ] [ n - 1 ] = 0 NEW_LINE count [ n - 1 ] [ n - 1 ] = 1 NEW_LINE for i in reversed ( range ( n ) ) : NEW_LINE INDENT for j in reversed ( range ( n ) ) : NEW_LINE INDENT if board [ i ] [ j ] == ' S ' or board [ i ] [ j ] == ' X ' : NEW_LINE INDENT continue NEW_LINE DEDENT for dx , dy in dirs : NEW_LINE INDENT x = i + dx NEW_LINE y = j + dy NEW_LINE if dp [ i ] [ j ] < dp [ x ] [ y ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ x ] [ y ] NEW_LINE count [ i ] [ j ] = count [ x ] [ y ] NEW_LINE DEDENT elif dp [ i ] [ j ] == dp [ x ] [ y ] : NEW_LINE INDENT count [ i ] [ j ] += count [ x ] [ y ] NEW_LINE count [ i ] [ j ] %= kMod NEW_LINE DEDENT DEDENT if dp [ i ] [ j ] != - 1 and board [ i ] [ j ] != ' E ' : NEW_LINE INDENT dp [ i ] [ j ] += int ( board [ i ] [ j ] ) NEW_LINE dp [ i ] [ j ] %= kMod NEW_LINE DEDENT DEDENT DEDENT return [ dp [ 0 ] [ 0 ] , count [ 0 ] [ 0 ] ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sumZero ( self , n : int ) -> List [ int ] : NEW_LINE INDENT return list ( range ( 1 - n , n , 2 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isSolvable ( self , words : List [ str ] , result : str ) -> bool : NEW_LINE INDENT words . append ( result ) NEW_LINE rows = len ( words ) NEW_LINE cols = max ( map ( len , words ) ) NEW_LINE letterToDigit = { } NEW_LINE usedDigit = [ False ] * 10 NEW_LINE def dfs ( row : int , col : int , summ : int ) -> bool : NEW_LINE INDENT if col == cols : NEW_LINE INDENT return summ == 0 NEW_LINE DEDENT if row == rows : NEW_LINE INDENT return summ % 10 == 0 and dfs ( 0 , col + 1 , summ // 10 ) NEW_LINE DEDENT word = words [ row ] NEW_LINE if col >= len ( word ) : NEW_LINE INDENT return dfs ( row + 1 , col , summ ) NEW_LINE DEDENT letter = word [ ~ col ] NEW_LINE sign = - 1 if row == rows - 1 else 1 NEW_LINE if letter in letterToDigit and ( letterToDigit [ letter ] > 0 or col < len ( word ) - 1 ) : NEW_LINE INDENT return dfs ( row + 1 , col , summ + sign * letterToDigit [ letter ] ) NEW_LINE DEDENT for digit , used in enumerate ( usedDigit ) : NEW_LINE INDENT if not used and ( digit > 0 or col < len ( word ) - 1 ) : NEW_LINE INDENT letterToDigit [ letter ] = digit NEW_LINE usedDigit [ digit ] = True NEW_LINE if dfs ( row + 1 , col , summ + sign * digit ) : NEW_LINE INDENT return True NEW_LINE DEDENT usedDigit [ digit ] = False NEW_LINE if letter in letterToDigit : NEW_LINE INDENT del letterToDigit [ letter ] NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT return dfs ( 0 , 0 , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def freqAlphabets ( self , s : str ) -> str : NEW_LINE INDENT ans = ' ' NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if i + 2 < len ( s ) and s [ i + 2 ] == ' # ' : NEW_LINE INDENT ans += chr ( int ( s [ i : i + 2 ] ) + ord ( ' a ' ) - 1 ) NEW_LINE i += 3 NEW_LINE DEDENT else : NEW_LINE INDENT ans += chr ( int ( s [ i ] ) + ord ( ' a ' ) - 1 ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def partition ( self , s : str ) -> List [ List [ str ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE def isPalindrome ( s : str ) -> bool : NEW_LINE INDENT return s == s [ : : - 1 ] NEW_LINE DEDENT def dfs ( s : str , j : int , path : List [ str ] , ans : List [ List [ str ] ] ) -> None : NEW_LINE INDENT if j == len ( s ) : NEW_LINE INDENT ans . append ( path ) NEW_LINE return NEW_LINE DEDENT for i in range ( j , len ( s ) ) : NEW_LINE INDENT if isPalindrome ( s [ j : i + 1 ] ) : NEW_LINE INDENT dfs ( s , i + 1 , path + [ s [ j : i + 1 ] ] , ans ) NEW_LINE DEDENT DEDENT DEDENT dfs ( s , 0 , [ ] , ans ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def xorQueries ( self , arr : List [ int ] , queries : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE xors = [ 0 ] * ( len ( arr ) + 1 ) NEW_LINE for i , a in enumerate ( arr ) : NEW_LINE INDENT xors [ i + 1 ] ^= xors [ i ] ^ a NEW_LINE DEDENT for l , r in queries : NEW_LINE INDENT ans . append ( xors [ l ] ^ xors [ r + 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def watchedVideosByFriends ( self , watchedVideos : List [ List [ str ] ] , friends : List [ List [ int ] ] , id : int , level : int ) -> List [ str ] : NEW_LINE INDENT visited = [ False ] * 100 NEW_LINE visited [ id ] = True NEW_LINE q = deque ( [ id ] ) NEW_LINE count = Counter ( ) NEW_LINE for _ in range ( level ) : NEW_LINE INDENT for _ in range ( len ( q ) ) : NEW_LINE INDENT curr = q . popleft ( ) NEW_LINE for friend in friends [ curr ] : NEW_LINE INDENT if not visited [ friend ] : NEW_LINE INDENT visited [ friend ] = True NEW_LINE q . append ( friend ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for friend in q : NEW_LINE INDENT for video in watchedVideos [ friend ] : NEW_LINE INDENT count [ video ] += 1 NEW_LINE DEDENT DEDENT return sorted ( count . keys ( ) , key = lambda video : ( count [ video ] , video ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minInsertions ( self , s : str ) -> int : NEW_LINE INDENT return len ( s ) - self . _longestPalindromeSubseq ( s ) NEW_LINE DEDENT def _longestPalindromeSubseq ( self , s : str ) -> int : NEW_LINE INDENT n = len ( s ) NEW_LINE dp = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] [ i ] = 1 NEW_LINE DEDENT for d in range ( 1 , n ) : NEW_LINE INDENT for i in range ( n - d ) : NEW_LINE INDENT j = i + d NEW_LINE if s [ i ] == s [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def decompressRLElist ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( 0 , len ( nums ) , 2 ) : NEW_LINE INDENT ans += [ nums [ i + 1 ] ] * nums [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def distinctEchoSubstrings ( self , text : str ) -> int : NEW_LINE INDENT seen = set ( ) NEW_LINE for k in range ( 1 , len ( text ) // 2 + 1 ) : NEW_LINE INDENT same = 0 NEW_LINE l = 0 NEW_LINE for r in range ( k , len ( text ) ) : NEW_LINE INDENT if text [ l ] == text [ r ] : NEW_LINE INDENT same += 1 NEW_LINE DEDENT else : NEW_LINE INDENT same = 0 NEW_LINE DEDENT if same == k : NEW_LINE INDENT seen . add ( text [ l - k + 1 : l + 1 ] ) NEW_LINE same -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT return len ( seen ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getNoZeroIntegers ( self , n : int ) -> List [ int ] : NEW_LINE INDENT for A in range ( n ) : NEW_LINE INDENT B = n - A NEW_LINE if '0' not in str ( A ) and '0' not in str ( B ) : NEW_LINE INDENT return A , B NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def minCut ( self , s : str ) -> int : NEW_LINE INDENT n = len ( s ) NEW_LINE cut = [ 0 ] * n NEW_LINE dp = [ [ False ] * n for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT mini = i NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT if s [ j ] == s [ i ] and ( j + 1 > i - 1 or dp [ j + 1 ] [ i - 1 ] ) : NEW_LINE INDENT dp [ j ] [ i ] = True NEW_LINE mini = 0 if j == 0 else min ( mini , cut [ j - 1 ] + 1 ) NEW_LINE DEDENT DEDENT cut [ i ] = mini NEW_LINE DEDENT return cut [ n - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumDistance ( self , word : str ) -> int : NEW_LINE INDENT def dist ( a : int , b : int ) -> int : NEW_LINE INDENT if a == 26 : NEW_LINE INDENT return 0 NEW_LINE DEDENT x1 , y1 = a // 6 , a % 6 NEW_LINE x2 , y2 = b // 6 , b % 6 NEW_LINE return abs ( x1 - x2 ) + abs ( y1 - y2 ) NEW_LINE DEDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int , j : int , k : int ) -> int : NEW_LINE INDENT if k == len ( word ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT nxt = ord ( word [ k ] ) - ord ( ' A ' ) NEW_LINE moveLeft = dist ( i , nxt ) + dp ( nxt , j , k + 1 ) NEW_LINE moveRight = dist ( j , nxt ) + dp ( i , nxt , k + 1 ) NEW_LINE return min ( moveLeft , moveRight ) NEW_LINE DEDENT return dp ( 26 , 26 , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximum69Number ( self , num : int ) -> int : NEW_LINE INDENT return int ( str ( num ) . replace ( '6' , '9' , 1 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minTaps ( self , n : int , ranges : List [ int ] ) -> int : NEW_LINE INDENT nums = [ 0 ] * ( n + 1 ) NEW_LINE for i , range_ in enumerate ( ranges ) : NEW_LINE INDENT l = max ( 0 , i - range_ ) NEW_LINE r = min ( n , range_ + i ) NEW_LINE nums [ l ] = max ( nums [ l ] , r - l ) NEW_LINE DEDENT ans = 0 NEW_LINE end = 0 NEW_LINE farthest = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT farthest = max ( farthest , i + nums [ i ] ) NEW_LINE if i == end : NEW_LINE INDENT ans += 1 NEW_LINE end = farthest NEW_LINE DEDENT DEDENT return ans if end == n else - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def diagonalSort ( self , mat : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT m = len ( mat ) NEW_LINE n = len ( mat [ 0 ] ) NEW_LINE count = defaultdict ( list ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT count [ i - j ] . append ( mat [ i ] [ j ] ) NEW_LINE DEDENT DEDENT for value in count . values ( ) : NEW_LINE INDENT value . sort ( reverse = 1 ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT mat [ i ] [ j ] = count [ i - j ] . pop ( ) NEW_LINE DEDENT DEDENT return mat NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def cloneGraph ( self , node : ' Node ' ) -> ' Node ' : NEW_LINE INDENT if not node : NEW_LINE INDENT return None NEW_LINE DEDENT q = deque ( [ node ] ) NEW_LINE map = { node : Node ( node . val ) } NEW_LINE while q : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE for v in u . neighbors : NEW_LINE INDENT if v not in map : NEW_LINE INDENT map [ v ] = Node ( v . val ) NEW_LINE q . append ( v ) NEW_LINE DEDENT map [ u ] . neighbors . append ( map [ v ] ) NEW_LINE DEDENT DEDENT return map [ node ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxValueAfterReverse ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT mini = math . inf NEW_LINE maxi = - math . inf NEW_LINE for a , b in zip ( nums , nums [ 1 : ] ) : NEW_LINE INDENT mini = min ( mini , max ( a , b ) ) NEW_LINE maxi = max ( maxi , min ( a , b ) ) NEW_LINE DEDENT diff = max ( 0 , ( maxi - mini ) * 2 ) NEW_LINE for a , b in zip ( nums , nums [ 1 : ] ) : NEW_LINE INDENT headDiff = - abs ( a - b ) + abs ( nums [ 0 ] - b ) NEW_LINE tailDiff = - abs ( a - b ) + abs ( nums [ - 1 ] - a ) NEW_LINE diff = max ( diff , headDiff , tailDiff ) NEW_LINE DEDENT return sum ( abs ( a - b ) for a , b in zip ( nums , nums [ 1 : ] ) ) + diff NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def arrayRankTransform ( self , arr : List [ int ] ) -> List [ int ] : NEW_LINE INDENT rank = { } NEW_LINE for a in sorted ( arr ) : NEW_LINE INDENT if a not in rank : NEW_LINE INDENT rank [ a ] = len ( rank ) + 1 NEW_LINE DEDENT DEDENT return map ( rank . get , arr ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def filterRestaurants ( self , restaurants : List [ List [ int ] ] , veganFriendly : int , maxPrice : int , maxDistance : int ) -> List [ int ] : NEW_LINE INDENT restaurants . sort ( key = lambda r : ( - r [ 1 ] , - r [ 0 ] ) ) NEW_LINE return [ i for i , _ , v , p , d in restaurants if v >= veganFriendly and p <= maxPrice and d <= maxDistance ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minDifficulty ( self , jobDifficulty : List [ int ] , d : int ) -> int : NEW_LINE INDENT n = len ( jobDifficulty ) NEW_LINE if d > n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dp = [ [ math . inf ] * ( d + 1 ) for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for k in range ( 1 , d + 1 ) : NEW_LINE INDENT maxDifficulty = 0 NEW_LINE for j in range ( i - 1 , k - 2 , - 1 ) : NEW_LINE INDENT maxDifficulty = max ( maxDifficulty , jobDifficulty [ j ] ) NEW_LINE dp [ i ] [ k ] = min ( dp [ i ] [ k ] , dp [ j ] [ k - 1 ] + maxDifficulty ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ d ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def kWeakestRows ( self , mat : List [ List [ int ] ] , k : int ) -> List [ int ] : NEW_LINE INDENT candidates = [ ] NEW_LINE for i , row in enumerate ( mat ) : NEW_LINE INDENT candidates . append ( [ sum ( row ) , i ] ) NEW_LINE DEDENT candidates . sort ( key = lambda c : ( c [ 0 ] , c [ 1 ] ) ) NEW_LINE return [ i for _ , i in candidates [ : k ] ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minSetSize ( self , arr : List [ int ] ) -> int : NEW_LINE INDENT n = len ( arr ) NEW_LINE count = Counter ( arr ) . most_common ( ) NEW_LINE count . sort ( key = lambda c : - c [ 1 ] ) NEW_LINE summ = 0 NEW_LINE for i , c in enumerate ( count ) : NEW_LINE INDENT summ += c [ 1 ] NEW_LINE if summ >= n // 2 : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def canCompleteCircuit ( self , gas : List [ int ] , cost : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE net = 0 NEW_LINE summ = 0 NEW_LINE for i in range ( len ( gas ) ) : NEW_LINE INDENT net += gas [ i ] - cost [ i ] NEW_LINE summ += gas [ i ] - cost [ i ] NEW_LINE if summ < 0 : NEW_LINE INDENT summ = 0 NEW_LINE ans = i + 1 NEW_LINE DEDENT DEDENT return - 1 if net < 0 else ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxJumps ( self , arr : List [ int ] , d : int ) -> int : NEW_LINE INDENT n = len ( arr ) NEW_LINE dp = [ 1 ] * n NEW_LINE stack = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT while stack and ( i == n or arr [ stack [ - 1 ] ] < arr [ i ] ) : NEW_LINE INDENT indices = [ stack . pop ( ) ] NEW_LINE while stack and arr [ stack [ - 1 ] ] == arr [ indices [ 0 ] ] : NEW_LINE INDENT indices . append ( stack . pop ( ) ) NEW_LINE DEDENT for j in indices : NEW_LINE INDENT if i < n and i - j <= d : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT if stack and j - stack [ - 1 ] <= d : NEW_LINE INDENT dp [ stack [ - 1 ] ] = max ( dp [ stack [ - 1 ] ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT stack . append ( i ) NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def angleClock ( self , hour : int , minutes : int ) -> float : NEW_LINE INDENT hourAngle = ( hour % 12 ) * 30 + minutes * 0.5 NEW_LINE minuteAngle = minutes * 6 NEW_LINE ans = abs ( hourAngle - minuteAngle ) NEW_LINE return min ( ans , 360 - ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minJumps ( self , arr : List [ int ] ) -> int : NEW_LINE INDENT n = len ( arr ) NEW_LINE graph = defaultdict ( list ) NEW_LINE steps = 0 NEW_LINE q = deque ( [ 0 ] ) NEW_LINE seen = { 0 } NEW_LINE for i , a in enumerate ( arr ) : NEW_LINE INDENT graph [ a ] . append ( i ) NEW_LINE DEDENT while q : NEW_LINE INDENT for _ in range ( len ( q ) ) : NEW_LINE INDENT i = q . popleft ( ) NEW_LINE if i == n - 1 : NEW_LINE INDENT return steps NEW_LINE DEDENT seen . add ( i ) NEW_LINE u = arr [ i ] NEW_LINE if i + 1 < n : NEW_LINE INDENT graph [ u ] . append ( i + 1 ) NEW_LINE DEDENT if i - 1 >= 0 : NEW_LINE INDENT graph [ u ] . append ( i - 1 ) NEW_LINE DEDENT for v in graph [ u ] : NEW_LINE INDENT if v in seen : NEW_LINE INDENT continue NEW_LINE DEDENT q . append ( v ) NEW_LINE DEDENT graph [ u ] . clear ( ) NEW_LINE DEDENT steps += 1 NEW_LINE DEDENT DEDENT DEDENT
from sortedcontainers import SortedList NEW_LINE class TweetCounts : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . tweetNameToTimes = defaultdict ( SortedList ) NEW_LINE DEDENT def recordTweet ( self , tweetName : str , time : int ) -> None : NEW_LINE INDENT self . tweetNameToTimes [ tweetName ] . add ( time ) NEW_LINE DEDENT def getTweetCountsPerFrequency ( self , freq : str , tweetName : str , startTime : int , endTime : int ) -> List [ int ] : NEW_LINE INDENT counts = [ ] NEW_LINE times = self . tweetNameToTimes [ tweetName ] NEW_LINE chunk = 60 if freq == ' minute ' else 3600 if freq == ' hour ' else 86400 NEW_LINE for i in range ( startTime , endTime + 1 , chunk ) : NEW_LINE INDENT j = min ( i + chunk , endTime + 1 ) NEW_LINE counts . append ( bisect_left ( times , j ) - bisect_left ( times , i ) ) NEW_LINE DEDENT return counts NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxStudents ( self , seats : List [ List [ str ] ] ) -> int : NEW_LINE INDENT m = len ( seats ) NEW_LINE n = len ( seats [ 0 ] ) NEW_LINE dirs = [ ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , - 1 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) ] NEW_LINE seen = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE match = [ [ - 1 ] * n for _ in range ( m ) ] NEW_LINE def dfs ( i : int , j : int , sessionId : int ) -> int : NEW_LINE INDENT for dx , dy in dirs : NEW_LINE INDENT x = i + dx NEW_LINE y = j + dy NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT if seats [ x ] [ y ] != ' . ' or seen [ x ] [ y ] == sessionId : NEW_LINE INDENT continue NEW_LINE DEDENT seen [ x ] [ y ] = sessionId NEW_LINE if match [ x ] [ y ] == - 1 or dfs ( * divmod ( match [ x ] [ y ] , n ) , sessionId ) : NEW_LINE INDENT match [ x ] [ y ] = i * n + j NEW_LINE match [ i ] [ j ] = x * n + y NEW_LINE return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def hungarian ( ) -> int : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if seats [ i ] [ j ] == ' . ' and match [ i ] [ j ] == - 1 : NEW_LINE INDENT sessionId = i * n + j NEW_LINE seen [ i ] [ j ] = sessionId NEW_LINE count += dfs ( i , j , sessionId ) NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT return sum ( seats [ i ] [ j ] == ' . ' for i in range ( m ) for j in range ( n ) ) - hungarian ( ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def candy ( self , ratings : List [ int ] ) -> int : NEW_LINE INDENT n = len ( ratings ) NEW_LINE ans = 0 NEW_LINE l = [ 1 ] * n NEW_LINE r = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ratings [ i ] > ratings [ i - 1 ] : NEW_LINE INDENT l [ i ] = l [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ratings [ i ] > ratings [ i + 1 ] : NEW_LINE INDENT r [ i ] = r [ i + 1 ] + 1 NEW_LINE DEDENT DEDENT for a , b in zip ( l , r ) : NEW_LINE INDENT ans += max ( a , b ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countNegatives ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE ans = 0 NEW_LINE i = m - 1 NEW_LINE j = 0 NEW_LINE while i >= 0 and j < n : NEW_LINE INDENT if grid [ i ] [ j ] < 0 : NEW_LINE INDENT ans += n - j NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxEvents ( self , events : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE minHeap = [ ] NEW_LINE i = 0 NEW_LINE events . sort ( key = lambda x : x [ 0 ] ) NEW_LINE while minHeap or i < len ( events ) : NEW_LINE INDENT if not minHeap : NEW_LINE INDENT d = events [ i ] [ 0 ] NEW_LINE DEDENT while i < len ( events ) and events [ i ] [ 0 ] == d : NEW_LINE INDENT heapq . heappush ( minHeap , events [ i ] [ 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT heapq . heappop ( minHeap ) NEW_LINE ans += 1 NEW_LINE d += 1 NEW_LINE while minHeap and minHeap [ 0 ] < d : NEW_LINE INDENT heapq . heappop ( minHeap ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isPossible ( self , target : List [ int ] ) -> bool : NEW_LINE INDENT if len ( target ) == 1 : NEW_LINE INDENT return target [ 0 ] == 1 NEW_LINE DEDENT summ = sum ( target ) NEW_LINE maxHeap = [ - num for num in target ] NEW_LINE heapq . heapify ( maxHeap ) NEW_LINE while - maxHeap [ 0 ] > 1 : NEW_LINE INDENT maxi = - heapq . heappop ( maxHeap ) NEW_LINE restSum = summ - maxi NEW_LINE if restSum == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT updated = maxi % restSum NEW_LINE if updated == 0 or updated == maxi : NEW_LINE INDENT return False NEW_LINE DEDENT heapq . heappush ( maxHeap , - updated ) NEW_LINE summ = summ - maxi + updated NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countOrders ( self , n : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i * ( i * 2 - 1 ) % kMod NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def singleNumber ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT return functools . reduce ( lambda x , y : x ^ y , nums , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def closestDivisors ( self , num : int ) -> List [ int ] : NEW_LINE INDENT for root in reversed ( range ( int ( sqrt ( num + 2 ) ) + 1 ) ) : NEW_LINE INDENT for cand in [ num + 1 , num + 2 ] : NEW_LINE INDENT if cand % root == 0 : NEW_LINE INDENT return [ root , cand // root ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestMultipleOfThree ( self , digits : List [ int ] ) -> str : NEW_LINE INDENT ans = ' ' NEW_LINE mod1 = [ 1 , 4 , 7 , 2 , 5 , 8 ] NEW_LINE mod2 = [ 2 , 5 , 8 , 1 , 4 , 7 ] NEW_LINE count = Counter ( digits ) NEW_LINE summ = sum ( digits ) NEW_LINE while summ % 3 != 0 : NEW_LINE INDENT for digit in ( mod1 if summ % 3 == 1 else mod2 ) : NEW_LINE INDENT if count [ digit ] : NEW_LINE INDENT count [ digit ] -= 1 NEW_LINE summ -= digit NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT for digit in reversed ( range ( 10 ) ) : NEW_LINE INDENT ans += str ( digit ) * count [ digit ] NEW_LINE DEDENT return '0' if len ( ans ) and ans [ 0 ] == '0' else ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minCost ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE dirs = ( ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) ) NEW_LINE dp = [ [ - 1 ] * n for _ in range ( m ) ] NEW_LINE q = deque ( ) NEW_LINE def dfs ( i : int , j : int , cost : int ) -> None : NEW_LINE INDENT if i < 0 or i == m or j < 0 or j == n : NEW_LINE INDENT return NEW_LINE DEDENT if dp [ i ] [ j ] != - 1 : NEW_LINE INDENT return NEW_LINE DEDENT dp [ i ] [ j ] = cost NEW_LINE q . append ( ( i , j ) ) NEW_LINE dx , dy = dirs [ grid [ i ] [ j ] - 1 ] NEW_LINE dfs ( i + dx , j + dy , cost ) NEW_LINE DEDENT dfs ( 0 , 0 , 0 ) NEW_LINE cost = 0 NEW_LINE while q : NEW_LINE INDENT cost += 1 NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE for dx , dy in dirs : NEW_LINE INDENT dfs ( i + dx , j + dy , cost ) NEW_LINE DEDENT DEDENT DEDENT return dp [ - 1 ] [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def singleNumber ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE for num in nums : NEW_LINE INDENT ones ^= num & ~ twos NEW_LINE twos ^= num & ~ ones NEW_LINE DEDENT return ones NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findTheLongestSubstring ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prefix = 0 NEW_LINE prefixToIndex = { 0 : - 1 } NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT index = ' aeiou ' . find ( c ) NEW_LINE if index != - 1 : NEW_LINE INDENT prefix ^= 1 << index NEW_LINE DEDENT prefixToIndex . setdefault ( prefix , i ) NEW_LINE ans = max ( ans , i - prefixToIndex [ prefix ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class T : NEW_LINE INDENT def __init__ ( self , isBST : bool = False , max : Optional [ int ] = None , min : Optional [ int ] = None , sum : Optional [ int ] = None ) : NEW_LINE INDENT self . isBST = isBST NEW_LINE self . max = max NEW_LINE self . min = min NEW_LINE self . sum = sum NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def maxSumBST ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT self . ans = 0 NEW_LINE def traverse ( root : Optional [ TreeNode ] ) -> T : NEW_LINE INDENT if not root : NEW_LINE INDENT return T ( True , - math . inf , math . inf , 0 ) NEW_LINE DEDENT left : T = traverse ( root . left ) NEW_LINE right : T = traverse ( root . right ) NEW_LINE if not left . isBST or not right . isBST : NEW_LINE INDENT return T ( ) NEW_LINE DEDENT if root . val <= left . max or root . val >= right . min : NEW_LINE INDENT return T ( ) NEW_LINE DEDENT summ = root . val + left . sum + right . sum NEW_LINE self . ans = max ( self . ans , summ ) NEW_LINE return T ( True , max ( root . val , right . max ) , min ( root . val , left . min ) , summ ) NEW_LINE DEDENT traverse ( root ) NEW_LINE return self . ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def frogPosition ( self , n : int , edges : List [ List [ int ] ] , t : int , target : int ) -> float : NEW_LINE INDENT graph = [ [ ] for _ in range ( n + 1 ) ] NEW_LINE q = deque ( [ 1 ] ) NEW_LINE seen = [ False ] * ( n + 1 ) NEW_LINE prob = [ 0 ] * ( n + 1 ) NEW_LINE prob [ 1 ] = 1 NEW_LINE seen [ 1 ] = True NEW_LINE for a , b in edges : NEW_LINE INDENT graph [ a ] . append ( b ) NEW_LINE graph [ b ] . append ( a ) NEW_LINE DEDENT for _ in range ( t ) : NEW_LINE INDENT for _ in range ( len ( q ) ) : NEW_LINE INDENT a = q . popleft ( ) NEW_LINE nChildren = sum ( not seen [ b ] for b in graph [ a ] ) NEW_LINE for b in graph [ a ] : NEW_LINE INDENT if seen [ b ] : NEW_LINE INDENT continue NEW_LINE DEDENT seen [ b ] = True NEW_LINE prob [ b ] = prob [ a ] / nChildren NEW_LINE q . append ( b ) NEW_LINE DEDENT if nChildren > 0 : NEW_LINE INDENT prob [ a ] = 0 NEW_LINE DEDENT DEDENT DEDENT return prob [ target ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def copyRandomList ( self , head : ' Node ' ) -> ' Node ' : NEW_LINE INDENT if not head : NEW_LINE INDENT return None NEW_LINE DEDENT if head in self . map : NEW_LINE INDENT return self . map [ head ] NEW_LINE DEDENT newNode = Node ( head . val ) NEW_LINE self . map [ head ] = newNode NEW_LINE newNode . next = self . copyRandomList ( head . next ) NEW_LINE newNode . random = self . copyRandomList ( head . random ) NEW_LINE return newNode NEW_LINE DEDENT map = { } NEW_LINE DEDENT
class Solution : NEW_LINE INDENT def maxPerformance ( self , n : int , speed : List [ int ] , efficiency : List [ int ] , k : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE ans = 0 NEW_LINE speedSum = 0 NEW_LINE A = sorted ( [ ( e , s ) for s , e in zip ( speed , efficiency ) ] , reverse = True ) NEW_LINE minHeap = [ ] NEW_LINE for e , s in A : NEW_LINE INDENT heapq . heappush ( minHeap , s ) NEW_LINE speedSum += s NEW_LINE if len ( minHeap ) > k : NEW_LINE INDENT speedSum -= heapq . heappop ( minHeap ) NEW_LINE DEDENT ans = max ( ans , speedSum * e ) NEW_LINE DEDENT return ans % kMod NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def wordBreak ( self , s : str , wordDict : List [ str ] ) -> bool : NEW_LINE INDENT wordSet = set ( wordDict ) NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def wordBreak ( s : str ) -> bool : NEW_LINE INDENT if s in wordSet : NEW_LINE INDENT return True NEW_LINE DEDENT return any ( s [ : i ] in wordSet and wordBreak ( s [ i : ] ) for i in range ( len ( s ) ) ) NEW_LINE DEDENT return wordBreak ( s ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sumFourDivisors ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for num in nums : NEW_LINE INDENT divisor = 0 NEW_LINE for i in range ( 2 , int ( sqrt ( num ) ) + 1 ) : NEW_LINE INDENT if num % i == 0 : NEW_LINE INDENT if divisor == 0 : NEW_LINE INDENT divisor = i NEW_LINE DEDENT else : NEW_LINE INDENT divisor = 0 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if divisor > 0 and divisor * divisor < num : NEW_LINE INDENT ans += 1 + num + divisor + num // divisor NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestPrefix ( self , s : str ) -> str : NEW_LINE INDENT kBase = 26 NEW_LINE kMod = 1_000_000_007 NEW_LINE n = len ( s ) NEW_LINE maxLength = 0 NEW_LINE pow = 1 NEW_LINE prefixHash = 0 NEW_LINE suffixHash = 0 NEW_LINE def val ( c : str ) -> int : NEW_LINE INDENT return ord ( c ) - ord ( ' a ' ) NEW_LINE DEDENT j = n - 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT prefixHash = ( prefixHash * kBase + val ( s [ i ] ) ) % kMod NEW_LINE suffixHash = ( val ( s [ j ] ) * pow + suffixHash ) % kMod NEW_LINE pow = pow * kBase % kMod NEW_LINE if prefixHash == suffixHash : NEW_LINE INDENT maxLength = i + 1 NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT return s [ : maxLength ] NEW_LINE DEDENT DEDENT
class UndergroundSystem : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . checkIns = { } NEW_LINE self . checkOuts = defaultdict ( lambda : [ 0 , 0 ] ) NEW_LINE DEDENT def checkIn ( self , id : int , stationName : str , t : int ) -> None : NEW_LINE INDENT self . checkIns [ id ] = ( stationName , t ) NEW_LINE DEDENT def checkOut ( self , id : int , stationName : str , t : int ) -> None : NEW_LINE INDENT startStation , startTime = self . checkIns . pop ( id ) NEW_LINE route = ( startStation , stationName ) NEW_LINE self . checkOuts [ route ] [ 0 ] += 1 NEW_LINE self . checkOuts [ route ] [ 1 ] += t - startTime NEW_LINE DEDENT def getAverageTime ( self , startStation : str , endStation : str ) -> float : NEW_LINE INDENT numTrips , totalTime = self . checkOuts [ ( startStation , endStation ) ] NEW_LINE return totalTime / numTrips NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findGoodStrings ( self , n : int , s1 : str , s2 : str , evil : str ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE evilLPS = self . _getLPS ( evil ) NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def getNextMatchedEvilCount ( j : int , currChar : str ) -> int : NEW_LINE INDENT while j > 0 and evil [ j ] != currChar : NEW_LINE INDENT j = evilLPS [ j - 1 ] NEW_LINE DEDENT return j + 1 if evil [ j ] == currChar else j NEW_LINE DEDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int , matchedEvilCount : int , isS1Prefix : bool , isS2Prefix : bool ) -> int : NEW_LINE INDENT if matchedEvilCount == len ( evil ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if i == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE minCharIndex = ord ( s1 [ i ] ) if isS1Prefix else ord ( ' a ' ) NEW_LINE maxCharIndex = ord ( s2 [ i ] ) if isS2Prefix else ord ( ' z ' ) NEW_LINE for charIndex in range ( minCharIndex , maxCharIndex + 1 ) : NEW_LINE INDENT c = chr ( charIndex ) NEW_LINE nextMatchedEvilCount = getNextMatchedEvilCount ( matchedEvilCount , c ) NEW_LINE ans += dp ( i + 1 , nextMatchedEvilCount , isS1Prefix and c == s1 [ i ] , isS2Prefix and c == s2 [ i ] ) NEW_LINE ans %= kMod NEW_LINE DEDENT return ans NEW_LINE DEDENT return dp ( 0 , 0 , True , True ) NEW_LINE DEDENT def _getLPS ( self , s : str ) -> List [ int ] : NEW_LINE INDENT lps = [ 0 ] * len ( s ) NEW_LINE j = 0 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT while j > 0 and s [ j ] != s [ i ] : NEW_LINE INDENT j = lps [ j - 1 ] NEW_LINE DEDENT if s [ i ] == s [ j ] : NEW_LINE INDENT lps [ i ] = j + 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return lps NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestCommonPrefix ( self , strs : List [ str ] ) -> str : NEW_LINE INDENT if not strs : NEW_LINE INDENT return ' ' NEW_LINE DEDENT for i in range ( len ( strs [ 0 ] ) ) : NEW_LINE INDENT for j in range ( 1 , len ( strs ) ) : NEW_LINE INDENT if i == len ( strs [ j ] ) or strs [ j ] [ i ] != strs [ 0 ] [ i ] : NEW_LINE INDENT return strs [ 0 ] [ : i ] NEW_LINE DEDENT DEDENT DEDENT return strs [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def wordBreak ( self , s : str , wordDict : List [ str ] ) -> List [ str ] : NEW_LINE INDENT wordSet = set ( wordDict ) NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def wordBreak ( s : str ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT prefix = s [ 0 : i ] NEW_LINE suffix = s [ i : ] NEW_LINE if prefix in wordSet : NEW_LINE INDENT for word in wordBreak ( suffix ) : NEW_LINE INDENT ans . append ( prefix + ' ▁ ' + word ) NEW_LINE DEDENT DEDENT DEDENT if s in wordSet : NEW_LINE INDENT ans . append ( s ) NEW_LINE DEDENT return ans NEW_LINE DEDENT return wordBreak ( s ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxSatisfaction ( self , satisfaction : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE sumSatisfaction = 0 NEW_LINE for s in sorted ( satisfaction , reverse = True ) : NEW_LINE INDENT sumSatisfaction += s NEW_LINE if sumSatisfaction <= 0 : NEW_LINE INDENT return ans NEW_LINE DEDENT ans += sumSatisfaction NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def stoneGameIII ( self , stoneValue : List [ int ] ) -> str : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int ) -> int : NEW_LINE INDENT if i == len ( stoneValue ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = - math . inf NEW_LINE summ = 0 NEW_LINE for j in range ( i , i + 3 ) : NEW_LINE INDENT if j == len ( stoneValue ) : NEW_LINE INDENT break NEW_LINE DEDENT summ += stoneValue [ j ] NEW_LINE res = max ( res , summ - dp ( j + 1 ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT score = dp ( 0 ) NEW_LINE if score == 0 : NEW_LINE INDENT return ' Tie ' NEW_LINE DEDENT return ' Alice ' if score > 0 else ' Bob ' NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def hasCycle ( self , head : ListNode ) -> bool : NEW_LINE INDENT slow = head NEW_LINE fast = head NEW_LINE while fast and fast . next : NEW_LINE INDENT slow = slow . next NEW_LINE fast = fast . next . next NEW_LINE if slow == fast : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def detectCycle ( self , head : ListNode ) -> ListNode : NEW_LINE INDENT slow = head NEW_LINE fast = head NEW_LINE while fast and fast . next : NEW_LINE INDENT slow = slow . next NEW_LINE fast = fast . next . next NEW_LINE if slow == fast : NEW_LINE INDENT slow = head NEW_LINE while slow != fast : NEW_LINE INDENT slow = slow . next NEW_LINE fast = fast . next NEW_LINE DEDENT return slow NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numOfArrays ( self , n : int , m : int , k : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE dp = [ [ [ 0 ] * ( k + 1 ) for j in range ( m + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE for j in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ 1 ] [ j ] [ 1 ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT for cost in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ cost ] = j * dp [ i - 1 ] [ j ] [ cost ] % kMod NEW_LINE for prevMax in range ( 1 , j ) : NEW_LINE INDENT dp [ i ] [ j ] [ cost ] += dp [ i - 1 ] [ prevMax ] [ cost - 1 ] NEW_LINE dp [ i ] [ j ] [ cost ] %= kMod NEW_LINE DEDENT DEDENT DEDENT DEDENT return sum ( dp [ n ] [ j ] [ k ] for j in range ( 1 , m + 1 ) ) % kMod NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxScore ( self , cardPoints : List [ int ] , k : int ) -> int : NEW_LINE INDENT n = len ( cardPoints ) NEW_LINE summ = sum ( cardPoints ) NEW_LINE windowSum = sum ( cardPoints [ : n - k ] ) NEW_LINE ans = summ - windowSum NEW_LINE for i in range ( k ) : NEW_LINE INDENT windowSum -= cardPoints [ i ] NEW_LINE windowSum += cardPoints [ i + n - k ] NEW_LINE ans = max ( ans , summ - windowSum ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def constrainedSubsetSum ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT dp = [ 0 ] * len ( nums ) NEW_LINE q = deque ( ) NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT if q : NEW_LINE INDENT dp [ i ] = max ( q [ 0 ] , 0 ) + num NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = num NEW_LINE DEDENT while q and q [ - 1 ] < dp [ i ] : NEW_LINE INDENT q . pop ( ) NEW_LINE DEDENT q . append ( dp [ i ] ) NEW_LINE if i >= k and dp [ i - k ] == q [ 0 ] : NEW_LINE INDENT q . popleft ( ) NEW_LINE DEDENT DEDENT return max ( dp ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def leftMostColumnWithOne ( self , binaryMatrix : ' BinaryMatrix ' ) -> int : NEW_LINE INDENT m , n = binaryMatrix . dimensions ( ) NEW_LINE ans = - 1 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if any ( binaryMatrix . get ( i , mid ) for i in range ( m ) ) : NEW_LINE INDENT ans = mid NEW_LINE r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reorderList ( self , head : ListNode ) -> None : NEW_LINE INDENT def findMid ( head : ListNode ) : NEW_LINE INDENT prev = None NEW_LINE slow = head NEW_LINE fast = head NEW_LINE while fast and fast . next : NEW_LINE INDENT prev = slow NEW_LINE slow = slow . next NEW_LINE fast = fast . next . next NEW_LINE DEDENT prev . next = None NEW_LINE return slow NEW_LINE DEDENT def reverse ( head : ListNode ) -> ListNode : NEW_LINE INDENT prev = None NEW_LINE curr = head NEW_LINE while curr : NEW_LINE INDENT next = curr . next NEW_LINE curr . next = prev NEW_LINE prev = curr NEW_LINE curr = next NEW_LINE DEDENT return prev NEW_LINE DEDENT def merge ( l1 : ListNode , l2 : ListNode ) -> None : NEW_LINE INDENT while l2 : NEW_LINE INDENT next = l1 . next NEW_LINE l1 . next = l2 NEW_LINE l1 = l2 NEW_LINE l2 = next NEW_LINE DEDENT DEDENT if not head or not head . next : NEW_LINE INDENT return NEW_LINE DEDENT mid = findMid ( head ) NEW_LINE reversed = reverse ( mid ) NEW_LINE merge ( head , reversed ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def preorderTraversal ( self , root : Optional [ TreeNode ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE def preorder ( root : Optional [ TreeNode ] ) -> None : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT ans . append ( root . val ) NEW_LINE preorder ( root . left ) NEW_LINE preorder ( root . right ) NEW_LINE DEDENT preorder ( root ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def ways ( self , pizza : List [ str ] , k : int ) -> int : NEW_LINE INDENT M = len ( pizza ) NEW_LINE N = len ( pizza [ 0 ] ) NEW_LINE prefix = [ [ 0 ] * ( N + 1 ) for _ in range ( M + 1 ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT prefix [ i + 1 ] [ j + 1 ] = ( pizza [ i ] [ j ] == ' A ' ) + prefix [ i ] [ j + 1 ] + prefix [ i + 1 ] [ j ] - prefix [ i ] [ j ] NEW_LINE DEDENT DEDENT def hasApple ( row1 : int , row2 : int , col1 : int , col2 : int ) -> bool : NEW_LINE INDENT return ( prefix [ row2 ] [ col2 ] - prefix [ row1 ] [ col2 ] - prefix [ row2 ] [ col1 ] + prefix [ row1 ] [ col1 ] ) > 0 NEW_LINE DEDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( m : int , n : int , k : int ) -> int : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( m + 1 , M ) : NEW_LINE INDENT if hasApple ( m , i , n , N ) and hasApple ( i , M , n , N ) : NEW_LINE INDENT ans += dp ( i , n , k - 1 ) NEW_LINE DEDENT DEDENT for j in range ( n + 1 , N ) : NEW_LINE INDENT if hasApple ( m , M , n , j ) and hasApple ( m , M , j , N ) : NEW_LINE INDENT ans += dp ( m , j , k - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return dp ( 0 , 0 , k - 1 ) % ( 10 ** 9 + 7 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def postorderTraversal ( self , root : Optional [ TreeNode ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE def postorder ( root : Optional [ TreeNode ] ) -> None : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT postorder ( root . left ) NEW_LINE postorder ( root . right ) NEW_LINE ans . append ( root . val ) NEW_LINE DEDENT postorder ( root ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Point : NEW_LINE INDENT def __init__ ( self , x : float , y : float ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def numPoints ( self , darts : List [ List [ int ] ] , r : int ) -> int : NEW_LINE INDENT kErr = 1e-6 NEW_LINE ans = 1 NEW_LINE points = [ Point ( x , y ) for x , y in darts ] NEW_LINE def dist ( p : Point , q : Point ) -> float : NEW_LINE INDENT return ( ( p . x - q . x ) ** 2 + ( p . y - q . y ) ** 2 ) ** 0.5 NEW_LINE DEDENT def getCircles ( p : Point , q : Point ) -> List [ Point ] : NEW_LINE INDENT if dist ( p , q ) - 2.0 * r > kErr : NEW_LINE INDENT return [ ] NEW_LINE DEDENT m = Point ( ( p . x + q . x ) / 2 , ( p . y + q . y ) / 2 ) NEW_LINE distCM = ( r ** 2 - ( dist ( p , q ) / 2 ) ** 2 ) ** 0.5 NEW_LINE alpha = math . atan2 ( p . y - q . y , q . x - p . x ) NEW_LINE return [ Point ( m . x - distCM * math . sin ( alpha ) , m . y - distCM * math . cos ( alpha ) ) , Point ( m . x + distCM * math . sin ( alpha ) , m . y + distCM * math . cos ( alpha ) ) ] NEW_LINE DEDENT for i in range ( len ( points ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( points ) ) : NEW_LINE INDENT for c in getCircles ( points [ i ] , points [ j ] ) : NEW_LINE INDENT count = 0 NEW_LINE for point in points : NEW_LINE INDENT if dist ( c , point ) - r <= kErr : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def pseudoPalindromicPaths ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE def dfs ( root : Optional [ TreeNode ] , path : int ) -> None : NEW_LINE INDENT nonlocal ans NEW_LINE if not root : NEW_LINE INDENT return NEW_LINE DEDENT if not root . left and not root . right : NEW_LINE INDENT path ^= 1 << root . val NEW_LINE if path & ( path - 1 ) == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return NEW_LINE DEDENT dfs ( root . left , path ^ 1 << root . val ) NEW_LINE dfs ( root . right , path ^ 1 << root . val ) NEW_LINE DEDENT dfs ( root , 0 ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxDotProduct ( self , A : List [ int ] , B : List [ int ] ) -> int : NEW_LINE INDENT m = len ( A ) NEW_LINE n = len ( B ) NEW_LINE dp = [ [ - math . inf ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = max ( dp [ i ] [ j + 1 ] , dp [ i + 1 ] [ j ] , max ( 0 , dp [ i ] [ j ] ) + A [ i ] * B [ j ] ) NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , key : int , value : int ) : NEW_LINE INDENT self . key = key NEW_LINE self . value = value NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class LRUCache : NEW_LINE INDENT def __init__ ( self , capacity : int ) : NEW_LINE INDENT self . capacity = capacity NEW_LINE self . keyToNode = { } NEW_LINE self . head = Node ( - 1 , - 1 ) NEW_LINE self . tail = Node ( - 1 , - 1 ) NEW_LINE self . join ( self . head , self . tail ) NEW_LINE DEDENT def get ( self , key : int ) -> int : NEW_LINE INDENT if key not in self . keyToNode : NEW_LINE INDENT return - 1 NEW_LINE DEDENT node = self . keyToNode [ key ] NEW_LINE self . remove ( node ) NEW_LINE self . moveToHead ( node ) NEW_LINE return node . value NEW_LINE DEDENT def put ( self , key : int , value : int ) -> None : NEW_LINE INDENT if key in self . keyToNode : NEW_LINE INDENT node = self . keyToNode [ key ] NEW_LINE node . value = value NEW_LINE self . remove ( node ) NEW_LINE self . moveToHead ( node ) NEW_LINE return NEW_LINE DEDENT if len ( self . keyToNode ) == self . capacity : NEW_LINE INDENT lastNode = self . tail . prev NEW_LINE del self . keyToNode [ lastNode . key ] NEW_LINE self . remove ( lastNode ) NEW_LINE DEDENT self . moveToHead ( Node ( key , value ) ) NEW_LINE self . keyToNode [ key ] = self . head . next NEW_LINE DEDENT def join ( self , node1 : Node , node2 : Node ) : NEW_LINE INDENT node1 . next = node2 NEW_LINE node2 . prev = node1 NEW_LINE DEDENT def moveToHead ( self , node : Node ) : NEW_LINE INDENT self . join ( node , self . head . next ) NEW_LINE self . join ( self . head , node ) NEW_LINE DEDENT def remove ( self , node : Node ) : NEW_LINE INDENT self . join ( node . prev , node . next ) NEW_LINE DEDENT DEDENT
from enum import Enum NEW_LINE class BoxCase ( Enum ) : NEW_LINE INDENT EqualDistantBalls = 0 NEW_LINE EqualBalls = 1 NEW_LINE DEDENT class Solution : NEW_LINE INDENT def getProbability ( self , balls : List [ int ] ) -> float : NEW_LINE INDENT n = sum ( balls ) // 2 NEW_LINE fact = [ 1 , 1 , 2 , 6 , 24 , 120 , 720 ] NEW_LINE def cases ( i : int , ballsCountA : int , ballsCountB : int , colorsCountA : int , colorsCountB , boxCase : BoxCase ) -> float : NEW_LINE INDENT if ballsCountA > n or ballsCountB > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if i == len ( balls ) : NEW_LINE INDENT return 1 if boxCase == BoxCase . EqualBalls else colorsCountA == colorsCountB NEW_LINE DEDENT ans = 0.0 NEW_LINE for ballsTakenA in range ( balls [ i ] + 1 ) : NEW_LINE INDENT ballsTakenB = balls [ i ] - ballsTakenA NEW_LINE newcolorsCountA = colorsCountA + ( ballsTakenA > 0 ) NEW_LINE newcolorsCountB = colorsCountB + ( ballsTakenB > 0 ) NEW_LINE ans += cases ( i + 1 , ballsCountA + ballsTakenA , ballsCountB + ballsTakenB , newcolorsCountA , newcolorsCountB , boxCase ) / ( fact [ ballsTakenA ] * fact [ ballsTakenB ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT return cases ( 0 , 0 , 0 , 0 , 0 , BoxCase . EqualDistantBalls ) / cases ( 0 , 0 , 0 , 0 , 0 , BoxCase . EqualBalls ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def insertionSortList ( self , head : ListNode ) -> ListNode : NEW_LINE INDENT dummy = ListNode ( 0 ) NEW_LINE curr = head NEW_LINE while curr : NEW_LINE INDENT prev = dummy NEW_LINE while prev . next and prev . next . val < curr . val : NEW_LINE INDENT prev = prev . next NEW_LINE DEDENT next = curr . next NEW_LINE curr . next = prev . next NEW_LINE prev . next = curr NEW_LINE curr = next NEW_LINE DEDENT return dummy . next NEW_LINE DEDENT DEDENT
class BrowserHistory : NEW_LINE INDENT def __init__ ( self , homepage : str ) : NEW_LINE INDENT self . urls = [ ] NEW_LINE self . index = - 1 NEW_LINE self . lastIndex = - 1 NEW_LINE self . visit ( homepage ) NEW_LINE DEDENT def visit ( self , url : str ) -> None : NEW_LINE INDENT self . index += 1 NEW_LINE if self . index < len ( self . urls ) : NEW_LINE INDENT self . urls [ self . index ] = url NEW_LINE DEDENT else : NEW_LINE INDENT self . urls . append ( url ) NEW_LINE DEDENT self . lastIndex = self . index NEW_LINE DEDENT def back ( self , steps : int ) -> str : NEW_LINE INDENT self . index = max ( 0 , self . index - steps ) NEW_LINE return self . urls [ self . index ] NEW_LINE DEDENT def forward ( self , steps : int ) -> str : NEW_LINE INDENT self . index = min ( self . lastIndex , self . index + steps ) NEW_LINE return self . urls [ self . index ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sortList ( self , head : ListNode ) -> ListNode : NEW_LINE INDENT def split ( head : ListNode , k : int ) -> ListNode : NEW_LINE INDENT while k > 1 and head : NEW_LINE INDENT head = head . next NEW_LINE k -= 1 NEW_LINE DEDENT rest = head . next if head else None NEW_LINE if head : NEW_LINE INDENT head . next = None NEW_LINE DEDENT return rest NEW_LINE DEDENT def merge ( l1 : ListNode , l2 : ListNode ) -> tuple : NEW_LINE INDENT dummy = ListNode ( 0 ) NEW_LINE tail = dummy NEW_LINE while l1 and l2 : NEW_LINE INDENT if l1 . val > l2 . val : NEW_LINE INDENT l1 , l2 = l2 , l1 NEW_LINE DEDENT tail . next = l1 NEW_LINE l1 = l1 . next NEW_LINE tail = tail . next NEW_LINE DEDENT tail . next = l1 if l1 else l2 NEW_LINE while tail . next : NEW_LINE INDENT tail = tail . next NEW_LINE DEDENT return dummy . next , tail NEW_LINE DEDENT length = 0 NEW_LINE curr = head NEW_LINE while curr : NEW_LINE INDENT length += 1 NEW_LINE curr = curr . next NEW_LINE DEDENT dummy = ListNode ( 0 , head ) NEW_LINE k = 1 NEW_LINE while k < length : NEW_LINE INDENT curr = dummy . next NEW_LINE tail = dummy NEW_LINE while curr : NEW_LINE INDENT l = curr NEW_LINE r = split ( l , k ) NEW_LINE curr = split ( r , k ) NEW_LINE mergedHead , mergedTail = merge ( l , r ) NEW_LINE tail . next = mergedHead NEW_LINE tail = mergedTail NEW_LINE DEDENT k *= 2 NEW_LINE DEDENT return dummy . next NEW_LINE DEDENT DEDENT
class UnionFind : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . id = list ( range ( n ) ) NEW_LINE self . rank = [ 0 ] * n NEW_LINE DEDENT def union ( self , u : int , v : int ) -> None : NEW_LINE INDENT i = self . find ( u ) NEW_LINE j = self . find ( v ) NEW_LINE if i == j : NEW_LINE INDENT return NEW_LINE DEDENT if self . rank [ i ] > self . rank [ j ] : NEW_LINE INDENT i , j = j , i NEW_LINE DEDENT elif self . rank [ i ] == self . rank [ j ] : NEW_LINE INDENT self . rank [ j ] += 1 NEW_LINE DEDENT self . id [ i ] = j NEW_LINE DEDENT def find ( self , u : int ) -> int : NEW_LINE INDENT if self . id [ u ] != u : NEW_LINE INDENT self . id [ u ] = self . find ( self . id [ u ] ) NEW_LINE DEDENT return self . id [ u ] NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def findCriticalAndPseudoCriticalEdges ( self , n : int , edges : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT criticalEdges = [ ] NEW_LINE pseudoCriticalEdges = [ ] NEW_LINE for i in range ( len ( edges ) ) : NEW_LINE INDENT edges [ i ] . append ( i ) NEW_LINE DEDENT edges . sort ( key = lambda x : x [ 2 ] ) NEW_LINE def getMSTWeight ( firstEdge : List [ int ] , deletedEdgeIndex : int ) -> int : NEW_LINE INDENT mstWeight = 0 NEW_LINE uf = UnionFind ( n ) NEW_LINE if firstEdge : NEW_LINE INDENT uf . union ( firstEdge [ 0 ] , firstEdge [ 1 ] ) NEW_LINE mstWeight += firstEdge [ 2 ] NEW_LINE DEDENT for u , v , weight , index in edges : NEW_LINE INDENT if index == deletedEdgeIndex : NEW_LINE INDENT continue NEW_LINE DEDENT if uf . find ( u ) == uf . find ( v ) : NEW_LINE INDENT continue NEW_LINE DEDENT uf . union ( u , v ) NEW_LINE mstWeight += weight NEW_LINE DEDENT root = uf . find ( 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if uf . find ( i ) != root : NEW_LINE INDENT return math . inf NEW_LINE DEDENT DEDENT return mstWeight NEW_LINE DEDENT mstWeight = getMSTWeight ( [ ] , - 1 ) NEW_LINE for e in edges : NEW_LINE INDENT index = e [ 3 ] NEW_LINE if getMSTWeight ( [ ] , index ) > mstWeight : NEW_LINE INDENT criticalEdges . append ( index ) NEW_LINE DEDENT elif getMSTWeight ( e , - 1 ) == mstWeight : NEW_LINE INDENT pseudoCriticalEdges . append ( index ) NEW_LINE DEDENT DEDENT return [ criticalEdges , pseudoCriticalEdges ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxPoints ( self , points : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE def gcd ( a : int , b : int ) -> int : NEW_LINE INDENT return a if b == 0 else gcd ( b , a % b ) NEW_LINE DEDENT def getSlope ( p : List [ int ] , q : List [ int ] ) -> Tuple [ int , int ] : NEW_LINE INDENT dx = p [ 0 ] - q [ 0 ] NEW_LINE dy = p [ 1 ] - q [ 1 ] NEW_LINE if dx == 0 : NEW_LINE INDENT return ( 0 , p [ 0 ] ) NEW_LINE DEDENT if dy == 0 : NEW_LINE INDENT return ( p [ 1 ] , 0 ) NEW_LINE DEDENT d = gcd ( dx , dy ) NEW_LINE return ( dx // d , dy // d ) NEW_LINE DEDENT for i , p in enumerate ( points ) : NEW_LINE INDENT slopeCount = defaultdict ( int ) NEW_LINE samePoints = 1 NEW_LINE maxPoints = 0 NEW_LINE for j in range ( i + 1 , len ( points ) ) : NEW_LINE INDENT q = points [ j ] NEW_LINE if p == q : NEW_LINE INDENT samePoints += 1 NEW_LINE DEDENT else : NEW_LINE INDENT slope = getSlope ( p , q ) NEW_LINE slopeCount [ slope ] += 1 NEW_LINE maxPoints = max ( maxPoints , slopeCount [ slope ] ) NEW_LINE DEDENT DEDENT ans = max ( ans , samePoints + maxPoints ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minNumberOfSemesters ( self , n : int , relations : List [ List [ int ] ] , k : int ) -> int : NEW_LINE INDENT dp = [ n ] * ( 1 << n ) NEW_LINE prereq = [ 0 ] * n NEW_LINE for prevCourse , nextCourse in relations : NEW_LINE INDENT prereq [ nextCourse - 1 ] |= 1 << prevCourse - 1 NEW_LINE DEDENT dp [ 0 ] = 0 NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT coursesCanBeTaken = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i & prereq [ j ] ) == prereq [ j ] : NEW_LINE INDENT coursesCanBeTaken |= 1 << j NEW_LINE DEDENT DEDENT coursesCanBeTaken &= ~ i NEW_LINE s = coursesCanBeTaken NEW_LINE while s : NEW_LINE INDENT if bin ( s ) . count ( '1' ) <= k : NEW_LINE INDENT dp [ i | s ] = min ( dp [ i | s ] , dp [ i ] + 1 ) NEW_LINE DEDENT s = ( s - 1 ) & coursesCanBeTaken NEW_LINE DEDENT DEDENT return dp [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numSubseq ( self , nums : List [ int ] , target : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE n = len ( nums ) NEW_LINE ans = 0 NEW_LINE nums . sort ( ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while l <= r : NEW_LINE INDENT if nums [ l ] + nums [ r ] <= target : NEW_LINE INDENT ans += pow ( 2 , r - l , kMod ) NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return ans % kMod NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMaxValueOfEquation ( self , points : List [ List [ int ] ] , k : int ) -> int : NEW_LINE INDENT ans = - math . inf NEW_LINE maxHeap = [ ] NEW_LINE for x , y in points : NEW_LINE INDENT while maxHeap and x + maxHeap [ 0 ] [ 1 ] > k : NEW_LINE INDENT heapq . heappop ( maxHeap ) NEW_LINE DEDENT if maxHeap : NEW_LINE INDENT ans = max ( ans , x + y - maxHeap [ 0 ] [ 0 ] ) NEW_LINE DEDENT heapq . heappush ( maxHeap , ( x - y , - x ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def threeSum ( self , nums : List [ int ] ) -> List [ List [ int ] ] : NEW_LINE INDENT if len ( nums ) < 3 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT ans = [ ] NEW_LINE nums . sort ( ) NEW_LINE for i in range ( len ( nums ) - 2 ) : NEW_LINE INDENT if i > 0 and nums [ i ] == nums [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT l = i + 1 NEW_LINE r = len ( nums ) - 1 NEW_LINE while l < r : NEW_LINE INDENT summ = nums [ i ] + nums [ l ] + nums [ r ] NEW_LINE if summ == 0 : NEW_LINE INDENT ans . append ( ( nums [ i ] , nums [ l ] , nums [ r ] ) ) NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE while nums [ l ] == nums [ l - 1 ] and l < r : NEW_LINE INDENT l += 1 NEW_LINE DEDENT while nums [ r ] == nums [ r + 1 ] and l < r : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT elif summ < 0 : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def evalRPN ( self , tokens : List [ str ] ) -> int : NEW_LINE INDENT stack = [ ] NEW_LINE operators = { ' + ' : lambda a , b : a + b , ' - ' : lambda a , b : a - b , ' * ' : lambda a , b : a * b , ' / ' : lambda a , b : int ( a / b ) , } NEW_LINE for token in tokens : NEW_LINE INDENT if token in operators : NEW_LINE INDENT b = stack . pop ( ) NEW_LINE a = stack . pop ( ) NEW_LINE stack . append ( operators [ token ] ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT stack . append ( int ( token ) ) NEW_LINE DEDENT DEDENT return stack [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minDifference ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE if n < 5 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = math . inf NEW_LINE nums . sort ( ) NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT ans = min ( ans , nums [ n - 4 + i ] - nums [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reverseWords ( self , s : str ) -> str : NEW_LINE INDENT return ' ▁ ' . join ( reversed ( s . split ( ) ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxProbability ( self , n : int , edges : List [ List [ int ] ] , succProb : List [ float ] , start : int , end : int ) -> float : NEW_LINE INDENT graph = [ [ ] for _ in range ( n ) ] NEW_LINE maxHeap = [ ( - 1.0 , start ) ] NEW_LINE seen = [ False ] * n NEW_LINE for i , ( ( u , v ) , prob ) in enumerate ( zip ( edges , succProb ) ) : NEW_LINE INDENT graph [ u ] . append ( ( v , prob ) ) NEW_LINE graph [ v ] . append ( ( u , prob ) ) NEW_LINE DEDENT while maxHeap : NEW_LINE INDENT prob , u = heapq . heappop ( maxHeap ) NEW_LINE prob *= - 1 NEW_LINE if u == end : NEW_LINE INDENT return prob NEW_LINE DEDENT if seen [ u ] : NEW_LINE INDENT continue NEW_LINE DEDENT seen [ u ] = True NEW_LINE for nextNode , edgeProb in graph [ u ] : NEW_LINE INDENT if seen [ nextNode ] : NEW_LINE INDENT continue NEW_LINE DEDENT heapq . heappush ( maxHeap , ( - prob * edgeProb , nextNode ) ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxProduct ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = nums [ 0 ] NEW_LINE prevMin = nums [ 0 ] NEW_LINE prevMax = nums [ 0 ] NEW_LINE for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT mini = prevMin * nums [ i ] NEW_LINE maxi = prevMax * nums [ i ] NEW_LINE prevMin = min ( nums [ i ] , mini , maxi ) NEW_LINE prevMax = max ( nums [ i ] , mini , maxi ) NEW_LINE ans = max ( ans , prevMax ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numSplits ( self , s : str ) -> int : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = 0 NEW_LINE seen = set ( ) NEW_LINE prefix = [ 0 ] * n NEW_LINE suffix = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT seen . add ( s [ i ] ) NEW_LINE prefix [ i ] = len ( seen ) NEW_LINE DEDENT seen . clear ( ) NEW_LINE for i in reversed ( range ( n ) ) : NEW_LINE INDENT seen . add ( s [ i ] ) NEW_LINE suffix [ i ] = len ( seen ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if prefix [ i ] == suffix [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minNumberOperations ( self , target : List [ int ] ) -> int : NEW_LINE INDENT ans = target [ 0 ] NEW_LINE for a , b in zip ( target , target [ 1 : ] ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT ans += b - a NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMin ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT l = 0 NEW_LINE r = len ( nums ) - 1 NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if nums [ m ] < nums [ r ] : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return nums [ l ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getLengthOfOptimalCompression ( self , s : str , k : int ) -> int : NEW_LINE INDENT def getLength ( maxFreq ) : NEW_LINE INDENT if maxFreq == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if maxFreq < 10 : NEW_LINE INDENT return 2 NEW_LINE DEDENT if maxFreq < 100 : NEW_LINE INDENT return 3 NEW_LINE DEDENT return 4 NEW_LINE DEDENT @ functools . lru_cache ( None ) NEW_LINE def compression ( i , k ) : NEW_LINE INDENT if k < 0 : NEW_LINE INDENT return math . inf NEW_LINE DEDENT if i == len ( s ) or len ( s ) - i <= k : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = math . inf NEW_LINE maxFreq = 0 NEW_LINE count = Counter ( ) NEW_LINE for j in range ( i , len ( s ) ) : NEW_LINE INDENT count [ s [ j ] ] += 1 NEW_LINE maxFreq = max ( maxFreq , count [ s [ j ] ] ) NEW_LINE ans = min ( ans , getLength ( maxFreq ) + compression ( j + 1 , k - ( j - i + 1 - maxFreq ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT return compression ( 0 , k ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxSum ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( nums1 ) and j < len ( nums2 ) : NEW_LINE INDENT if nums1 [ i ] < nums2 [ j ] : NEW_LINE INDENT sum1 += nums1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT elif nums1 [ i ] > nums2 [ j ] : NEW_LINE INDENT sum2 += nums2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += max ( sum1 , sum2 ) + nums1 [ i ] NEW_LINE sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while i < len ( nums1 ) : NEW_LINE INDENT sum1 += nums1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while j < len ( nums2 ) : NEW_LINE INDENT sum2 += nums2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT return ( ans + max ( sum1 , sum2 ) ) % ( 10 ** 9 + 7 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMin ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT l = 0 NEW_LINE r = len ( nums ) - 1 NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if nums [ m ] == nums [ r ] : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT elif nums [ m ] < nums [ r ] : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return nums [ l ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestAwesome ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prefix = 0 NEW_LINE prefixToIndex = [ len ( s ) ] * 1024 NEW_LINE prefixToIndex [ 0 ] = - 1 NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT prefix ^= 1 << ord ( c ) - ord ( '0' ) NEW_LINE ans = max ( ans , i - prefixToIndex [ prefix ] ) NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT ans = max ( ans , i - prefixToIndex [ prefix ^ 1 << j ] ) NEW_LINE DEDENT prefixToIndex [ prefix ] = min ( prefixToIndex [ prefix ] , i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minCost ( self , n : int , cuts : List [ int ] ) -> int : NEW_LINE INDENT A = sorted ( [ 0 ] + cuts + [ n ] ) NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( i , j ) : NEW_LINE INDENT if j - i <= 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( A [ j ] - A [ i ] + dp ( i , k ) + dp ( k , j ) for k in range ( i + 1 , j ) ) NEW_LINE DEDENT return dp ( 0 , len ( A ) - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mostSimilar ( self , n : int , roads : List [ List [ int ] ] , names : List [ str ] , targetPath : List [ str ] ) -> List [ int ] : NEW_LINE INDENT cost = [ [ - 1 ] * len ( targetPath ) for _ in range ( len ( names ) ) ] NEW_LINE next = [ [ 0 ] * len ( targetPath ) for _ in range ( len ( names ) ) ] NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE for u , v in roads : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT minDist = math . inf NEW_LINE start = 0 NEW_LINE def dfs ( nameIndex : int , pathIndex : int ) -> int : NEW_LINE INDENT if cost [ nameIndex ] [ pathIndex ] != - 1 : NEW_LINE INDENT return cost [ nameIndex ] [ pathIndex ] NEW_LINE DEDENT editDist = names [ nameIndex ] != targetPath [ pathIndex ] NEW_LINE if pathIndex == len ( targetPath ) - 1 : NEW_LINE INDENT return editDist NEW_LINE DEDENT minDist = math . inf NEW_LINE for v in graph [ nameIndex ] : NEW_LINE INDENT dist = dfs ( v , pathIndex + 1 ) NEW_LINE if dist < minDist : NEW_LINE INDENT minDist = dist NEW_LINE next [ nameIndex ] [ pathIndex ] = v NEW_LINE DEDENT DEDENT cost [ nameIndex ] [ pathIndex ] = editDist + minDist NEW_LINE return editDist + minDist NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT dist = dfs ( i , 0 ) NEW_LINE if dist < minDist : NEW_LINE INDENT minDist = dist NEW_LINE start = i NEW_LINE DEDENT DEDENT ans = [ ] NEW_LINE while len ( ans ) < len ( targetPath ) : NEW_LINE INDENT ans . append ( start ) NEW_LINE start = next [ start ] [ len ( ans ) - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class MinStack : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE DEDENT def push ( self , x : int ) -> None : NEW_LINE INDENT mini = x if not self . stack else min ( self . stack [ - 1 ] [ 1 ] , x ) NEW_LINE self . stack . append ( [ x , mini ] ) NEW_LINE DEDENT def pop ( self ) -> None : NEW_LINE INDENT self . stack . pop ( ) NEW_LINE DEDENT def top ( self ) -> int : NEW_LINE INDENT return self . stack [ - 1 ] [ 0 ] NEW_LINE DEDENT def getMin ( self ) -> int : NEW_LINE INDENT return self . stack [ - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def upsideDownBinaryTree ( self , root : Optional [ TreeNode ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT if not root or not root . left : NEW_LINE INDENT return root NEW_LINE DEDENT newRoot = self . upsideDownBinaryTree ( root . left ) NEW_LINE root . left . left = root . right NEW_LINE root . left . right = root NEW_LINE root . left = None NEW_LINE root . right = None NEW_LINE return newRoot NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def read ( self , buf : List [ str ] , n : int ) -> int : NEW_LINE INDENT buf4 = [ ' ▁ ' ] * 4 NEW_LINE i4 = 0 NEW_LINE n4 = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if i4 == n4 : NEW_LINE INDENT i4 = 0 NEW_LINE n4 = read4 ( buf4 ) NEW_LINE if n4 == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT buf [ i ] = buf4 [ i4 ] NEW_LINE i += 1 NEW_LINE i4 += 1 NEW_LINE DEDENT return i NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def read ( self , buf : List [ str ] , n : int ) -> int : NEW_LINE INDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if self . i4 == self . n4 : NEW_LINE INDENT self . i4 = 0 NEW_LINE self . n4 = read4 ( self . buf4 ) NEW_LINE if self . n4 == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT buf [ i ] = self . buf4 [ self . i4 ] NEW_LINE i += 1 NEW_LINE self . i4 += 1 NEW_LINE DEDENT return i NEW_LINE DEDENT buf4 = [ ' ▁ ' ] * 4 NEW_LINE i4 = 0 NEW_LINE n4 = 0 NEW_LINE DEDENT
class Solution : NEW_LINE INDENT def unhappyFriends ( self , n : int , preferences : List [ List [ int ] ] , pairs : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE matches = [ 0 ] * n NEW_LINE prefer = [ { } for _ in range ( n ) ] NEW_LINE for x , y in pairs : NEW_LINE INDENT matches [ x ] = y NEW_LINE matches [ y ] = x NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT prefer [ i ] [ preferences [ i ] [ j ] ] = j NEW_LINE DEDENT DEDENT for x in range ( n ) : NEW_LINE INDENT for u in prefer [ x ] . keys ( ) : NEW_LINE INDENT y = matches [ x ] NEW_LINE v = matches [ u ] NEW_LINE if prefer [ x ] [ u ] < prefer [ x ] [ y ] and prefer [ u ] [ x ] < prefer [ u ] [ v ] : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def lengthOfLongestSubstringTwoDistinct ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE distinct = 0 NEW_LINE count = [ 0 ] * 128 NEW_LINE l = 0 NEW_LINE for r , c in enumerate ( s ) : NEW_LINE INDENT count [ ord ( c ) ] += 1 NEW_LINE if count [ ord ( c ) ] == 1 : NEW_LINE INDENT distinct += 1 NEW_LINE DEDENT while distinct == 3 : NEW_LINE INDENT count [ ord ( s [ l ] ) ] -= 1 NEW_LINE if count [ ord ( s [ l ] ) ] == 0 : NEW_LINE INDENT distinct -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def threeSumClosest ( self , nums : List [ int ] , target : int ) -> int : NEW_LINE INDENT ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] NEW_LINE nums . sort ( ) NEW_LINE for i in range ( len ( nums ) - 2 ) : NEW_LINE INDENT if i > 0 and nums [ i ] == nums [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT l = i + 1 NEW_LINE r = len ( nums ) - 1 NEW_LINE while l < r : NEW_LINE INDENT summ = nums [ i ] + nums [ l ] + nums [ r ] NEW_LINE if summ == target : NEW_LINE INDENT return summ NEW_LINE DEDENT if abs ( summ - target ) < abs ( ans - target ) : NEW_LINE INDENT ans = summ NEW_LINE DEDENT if summ < target : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getIntersectionNode ( self , headA : ListNode , headB : ListNode ) -> Optional [ ListNode ] : NEW_LINE INDENT a = headA NEW_LINE b = headB NEW_LINE while a != b : NEW_LINE INDENT a = a . next if a else headB NEW_LINE b = b . next if b else headA NEW_LINE DEDENT return a NEW_LINE DEDENT DEDENT
class ParkingSystem : NEW_LINE INDENT def __init__ ( self , big : int , medium : int , small : int ) : NEW_LINE INDENT self . count = [ big , medium , small ] NEW_LINE DEDENT def addCar ( self , carType : int ) -> bool : NEW_LINE INDENT self . count [ carType - 1 ] -= 1 NEW_LINE return self . count [ carType - 1 ] >= 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isOneEditDistance ( self , s : str , t : str ) -> bool : NEW_LINE INDENT m = len ( s ) NEW_LINE n = len ( t ) NEW_LINE if m > n : NEW_LINE INDENT return self . isOneEditDistance ( t , s ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if s [ i ] != t [ i ] : NEW_LINE INDENT if m == n : NEW_LINE INDENT return s [ i + 1 : ] == t [ i + 1 : ] NEW_LINE DEDENT return s [ i : ] == t [ i + 1 : ] NEW_LINE DEDENT DEDENT return m + 1 == n NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def visiblePoints ( self , points : List [ List [ int ] ] , angle : int , location : List [ int ] ) -> int : NEW_LINE INDENT posX , posY = location NEW_LINE maxVisible = 0 NEW_LINE same = 0 NEW_LINE A = [ ] NEW_LINE for x , y in points : NEW_LINE INDENT if x == posX and y == posY : NEW_LINE INDENT same += 1 NEW_LINE DEDENT else : NEW_LINE INDENT A . append ( math . atan2 ( y - posY , x - posX ) ) NEW_LINE DEDENT DEDENT A . sort ( ) NEW_LINE A = A + [ a + 2.0 * math . pi for a in A ] NEW_LINE angleInRadians = math . pi * ( angle / 180 ) NEW_LINE l = 0 NEW_LINE for r in range ( len ( A ) ) : NEW_LINE INDENT while A [ r ] - A [ l ] > angleInRadians : NEW_LINE INDENT l += 1 NEW_LINE DEDENT maxVisible = max ( maxVisible , r - l + 1 ) NEW_LINE DEDENT return maxVisible + same NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findPeakElement ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT l = 0 NEW_LINE r = len ( nums ) - 1 NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if nums [ m ] >= nums [ m + 1 ] : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMissingRanges ( self , nums : List [ int ] , lower : int , upper : int ) -> List [ str ] : NEW_LINE INDENT def getRange ( lo : int , hi : int ) -> str : NEW_LINE INDENT if lo == hi : NEW_LINE INDENT return str ( lo ) NEW_LINE DEDENT return str ( lo ) + ' - > ' + str ( hi ) NEW_LINE DEDENT if not nums : NEW_LINE INDENT return [ getRange ( lower , upper ) ] NEW_LINE DEDENT ans = [ ] NEW_LINE if nums [ 0 ] > lower : NEW_LINE INDENT ans . append ( getRange ( lower , nums [ 0 ] - 1 ) ) NEW_LINE DEDENT for prev , curr in zip ( nums , nums [ 1 : ] ) : NEW_LINE INDENT if curr > prev + 1 : NEW_LINE INDENT ans . append ( getRange ( prev + 1 , curr - 1 ) ) NEW_LINE DEDENT DEDENT if nums [ - 1 ] < upper : NEW_LINE INDENT ans . append ( getRange ( nums [ - 1 ] + 1 , upper ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumEffortPath ( self , heights : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( heights ) NEW_LINE n = len ( heights [ 0 ] ) NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE diff = [ [ math . inf ] * n for _ in range ( m ) ] NEW_LINE seen = set ( ) NEW_LINE minHeap = [ ( 0 , 0 , 0 ) ] NEW_LINE diff [ 0 ] [ 0 ] = 0 NEW_LINE while minHeap : NEW_LINE INDENT d , i , j = heapq . heappop ( minHeap ) NEW_LINE if i == m - 1 and j == n - 1 : NEW_LINE INDENT return d NEW_LINE DEDENT seen . add ( ( i , j ) ) NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT if ( x , y ) in seen : NEW_LINE INDENT continue NEW_LINE DEDENT newDiff = abs ( heights [ i ] [ j ] - heights [ x ] [ y ] ) NEW_LINE maxDiff = max ( diff [ i ] [ j ] , newDiff ) NEW_LINE if diff [ x ] [ y ] > maxDiff : NEW_LINE INDENT diff [ x ] [ y ] = maxDiff NEW_LINE heapq . heappush ( minHeap , ( diff [ x ] [ y ] , x , y ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
class Bucket : NEW_LINE INDENT def __init__ ( self , mini : int , maxi : int ) : NEW_LINE INDENT self . mini = mini NEW_LINE self . maxi = maxi NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def maximumGap ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT if len ( nums ) < 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT mini = min ( nums ) NEW_LINE maxi = max ( nums ) NEW_LINE if mini == maxi : NEW_LINE INDENT return 0 NEW_LINE DEDENT gap = ceil ( ( maxi - mini ) / ( len ( nums ) - 1 ) ) NEW_LINE bucketSize = ( maxi - mini ) // gap + 1 NEW_LINE buckets = [ Bucket ( math . inf , - math . inf ) for _ in range ( bucketSize ) ] NEW_LINE for num in nums : NEW_LINE INDENT i = ( num - mini ) // gap NEW_LINE buckets [ i ] . mini = min ( buckets [ i ] . mini , num ) NEW_LINE buckets [ i ] . maxi = max ( buckets [ i ] . maxi , num ) NEW_LINE DEDENT ans = 0 NEW_LINE prevMax = mini NEW_LINE for bucket in buckets : NEW_LINE INDENT if bucket . mini == math . inf : NEW_LINE INDENT continue NEW_LINE DEDENT ans = max ( ans , bucket . mini - prevMax ) NEW_LINE prevMax = bucket . maxi NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def compareVersion ( self , version1 : str , version2 : str ) -> int : NEW_LINE INDENT levels1 = version1 . split ( ' . ' ) NEW_LINE levels2 = version2 . split ( ' . ' ) NEW_LINE length = max ( len ( levels1 ) , len ( levels2 ) ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT v1 = int ( levels1 [ i ] ) if i < len ( levels1 ) else 0 NEW_LINE v2 = int ( levels2 [ i ] ) if i < len ( levels2 ) else 0 NEW_LINE if v1 < v2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if v1 > v2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def closeStrings ( self , word1 : str , word2 : str ) -> bool : NEW_LINE INDENT if len ( word1 ) != len ( word2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT count1 = Counter ( word1 ) NEW_LINE count2 = Counter ( word2 ) NEW_LINE if count1 . keys ( ) != count2 . keys ( ) : NEW_LINE INDENT return False NEW_LINE DEDENT return sorted ( count1 . values ( ) ) == sorted ( count2 . values ( ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def fractionToDecimal ( self , numerator : int , denominator : int ) -> str : NEW_LINE INDENT if numerator == 0 : NEW_LINE INDENT return '0' NEW_LINE DEDENT ans = ' ' NEW_LINE if ( numerator < 0 ) ^ ( denominator < 0 ) : NEW_LINE INDENT ans += ' - ' NEW_LINE DEDENT numerator = abs ( numerator ) NEW_LINE denominator = abs ( denominator ) NEW_LINE ans += str ( numerator // denominator ) NEW_LINE if numerator % denominator == 0 : NEW_LINE INDENT return ans NEW_LINE DEDENT ans += ' . ' NEW_LINE dict = { } NEW_LINE remainder = numerator % denominator NEW_LINE while remainder : NEW_LINE INDENT if remainder in dict : NEW_LINE INDENT ans = ans [ : dict [ remainder ] ] + ' ( ' + ans [ dict [ remainder ] : ] + ' ) ' NEW_LINE break NEW_LINE DEDENT dict [ remainder ] = len ( ans ) NEW_LINE remainder *= 10 NEW_LINE ans += str ( remainder // denominator ) NEW_LINE remainder %= denominator NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def twoSum ( self , numbers : List [ int ] , target : int ) -> List [ int ] : NEW_LINE INDENT l = 0 NEW_LINE r = len ( numbers ) - 1 NEW_LINE while l < r : NEW_LINE INDENT summ = numbers [ l ] + numbers [ r ] NEW_LINE if summ == target : NEW_LINE INDENT return [ l + 1 , r + 1 ] NEW_LINE DEDENT if summ < target : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def lowestCommonAncestor ( self , root : ' TreeNode ' , nodes : ' List [ TreeNode ] ' ) -> ' TreeNode ' : NEW_LINE INDENT nodes = set ( nodes ) NEW_LINE def lca ( root : ' TreeNode ' ) -> ' TreeNode ' : NEW_LINE INDENT if not root : NEW_LINE INDENT return None NEW_LINE DEDENT if root in nodes : NEW_LINE INDENT return root NEW_LINE DEDENT l = lca ( root . left ) NEW_LINE r = lca ( root . right ) NEW_LINE if l and r : NEW_LINE INDENT return root NEW_LINE DEDENT return l or r NEW_LINE DEDENT return lca ( root ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def convertToTitle ( self , n : int ) -> str : NEW_LINE INDENT return self . convertToTitle ( ( n - 1 ) // 26 ) + chr ( ord ( ' A ' ) + ( n - 1 ) % 26 ) if n else ' ' NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def boxDelivering ( self , boxes : List [ List [ int ] ] , portsCount : int , maxBoxes : int , maxWeight : int ) -> int : NEW_LINE INDENT n = len ( boxes ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE trips = 2 NEW_LINE weight = 0 NEW_LINE l = 0 NEW_LINE for r in range ( n ) : NEW_LINE INDENT weight += boxes [ r ] [ 1 ] NEW_LINE if r > 0 and boxes [ r ] [ 0 ] != boxes [ r - 1 ] [ 0 ] : NEW_LINE INDENT trips += 1 NEW_LINE DEDENT while r - l + 1 > maxBoxes or weight > maxWeight or ( l < r and dp [ l + 1 ] == dp [ l ] ) : NEW_LINE INDENT weight -= boxes [ l ] [ 1 ] NEW_LINE if boxes [ l ] [ 0 ] != boxes [ l + 1 ] [ 0 ] : NEW_LINE INDENT trips -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT dp [ r + 1 ] = dp [ l ] + trips NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def majorityElement ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = None NEW_LINE count = 0 NEW_LINE for num in nums : NEW_LINE INDENT if count == 0 : NEW_LINE INDENT ans = num NEW_LINE DEDENT count += ( 1 if num == ans else - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def letterCombinations ( self , digits : str ) -> List [ str ] : NEW_LINE INDENT if not digits : NEW_LINE INDENT return [ ] NEW_LINE DEDENT digitToLetters = [ ' ' , ' ' , ' abc ' , ' def ' , ' ghi ' , ' jkl ' , ' mno ' , ' pqrs ' , ' tuv ' , ' wxyz ' ] NEW_LINE ans = [ ] NEW_LINE def dfs ( i : int , path : List [ chr ] ) -> None : NEW_LINE INDENT if i == len ( digits ) : NEW_LINE INDENT ans . append ( ' ' . join ( path ) ) NEW_LINE return NEW_LINE DEDENT for letter in digitToLetters [ ord ( digits [ i ] ) - ord ( '0' ) ] : NEW_LINE INDENT path . append ( letter ) NEW_LINE dfs ( i + 1 , path ) NEW_LINE path . pop ( ) NEW_LINE DEDENT DEDENT dfs ( 0 , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class TwoSum : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . count = Counter ( ) NEW_LINE DEDENT def add ( self , number : int ) -> None : NEW_LINE INDENT self . count [ number ] += 1 NEW_LINE DEDENT def find ( self , value : int ) -> bool : NEW_LINE INDENT for key , freq in self . count . items ( ) : NEW_LINE INDENT remain = value - key NEW_LINE if key == remain and freq > 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if key != remain and remain in self . count : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findBall ( self , grid : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE dp = [ i for i in range ( n ) ] NEW_LINE ans = [ - 1 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT newDp = [ - 1 ] * n NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j + grid [ i ] [ j ] < 0 or j + grid [ i ] [ j ] == n : NEW_LINE INDENT continue NEW_LINE DEDENT if grid [ i ] [ j ] == 1 and grid [ i ] [ j + 1 ] == - 1 or grid [ i ] [ j ] == - 1 and grid [ i ] [ j - 1 ] == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT newDp [ j + grid [ i ] [ j ] ] = dp [ j ] NEW_LINE DEDENT dp = newDp NEW_LINE DEDENT for i , ball in enumerate ( dp ) : NEW_LINE INDENT if ball != - 1 : NEW_LINE INDENT ans [ ball ] = i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def titleToNumber ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for c in s : NEW_LINE INDENT ans = ans * 26 + ord ( c ) - ord ( ' @ ' ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def waysToSplit ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE n = len ( nums ) NEW_LINE ans = 0 NEW_LINE prefix = list ( itertools . accumulate ( nums ) ) NEW_LINE def firstGreaterEqual ( i : int ) -> int : NEW_LINE INDENT l = i + 1 NEW_LINE r = n - 1 NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if prefix [ m ] - prefix [ i ] >= prefix [ i ] : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT def firstGreater ( i : int ) -> int : NEW_LINE INDENT l = i + 1 NEW_LINE r = n - 1 NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if prefix [ m ] - prefix [ i ] > prefix [ - 1 ] - prefix [ m ] : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT for i in range ( n - 2 ) : NEW_LINE INDENT j = firstGreaterEqual ( i ) NEW_LINE if j == n - 1 : NEW_LINE INDENT break NEW_LINE DEDENT mid = prefix [ j ] - prefix [ i ] NEW_LINE right = prefix [ - 1 ] - prefix [ j ] NEW_LINE if mid > right : NEW_LINE INDENT continue NEW_LINE DEDENT k = firstGreater ( i ) NEW_LINE ans = ( ans + k - j ) % kMod NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def trailingZeroes ( self , n : int ) -> int : NEW_LINE INDENT return 0 if n == 0 else n // 5 + self . trailingZeroes ( n // 5 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestSubmatrix ( self , matrix : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE hist = [ 0 ] * len ( matrix [ 0 ] ) NEW_LINE for row in matrix : NEW_LINE INDENT for i , num in enumerate ( row ) : NEW_LINE INDENT hist [ i ] = 0 if num == 0 else hist [ i ] + 1 NEW_LINE DEDENT sortedHist = sorted ( hist ) NEW_LINE for i , h in enumerate ( sortedHist ) : NEW_LINE INDENT ans = max ( ans , h * ( len ( row ) - i ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canMouseWin ( self , grid : List [ str ] , catJump : int , mouseJump : int ) -> bool : NEW_LINE INDENT dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE nFloors = 0 NEW_LINE cat = 0 NEW_LINE mouse = 0 NEW_LINE def hash ( i : int , j : int ) -> int : NEW_LINE INDENT return i * n + j NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] != ' # ' : NEW_LINE INDENT nFloors += 1 NEW_LINE DEDENT if grid [ i ] [ j ] == ' C ' : NEW_LINE INDENT cat = hash ( i , j ) NEW_LINE DEDENT elif grid [ i ] [ j ] == ' M ' : NEW_LINE INDENT mouse = hash ( i , j ) NEW_LINE DEDENT DEDENT DEDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( cat : int , mouse : int , turn : int ) -> bool : NEW_LINE INDENT if turn == nFloors * 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if turn % 2 == 0 : NEW_LINE INDENT i = mouse // n NEW_LINE j = mouse % n NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT for jump in range ( mouseJump + 1 ) : NEW_LINE INDENT x = i + dirs [ k ] * jump NEW_LINE y = j + dirs [ k + 1 ] * jump NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT break NEW_LINE DEDENT if grid [ x ] [ y ] == ' # ' : NEW_LINE INDENT break NEW_LINE DEDENT if grid [ x ] [ y ] == ' F ' : NEW_LINE INDENT return True NEW_LINE DEDENT if dp ( cat , hash ( x , y ) , turn + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT i = cat // n NEW_LINE j = cat % n NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT for jump in range ( catJump + 1 ) : NEW_LINE INDENT x = i + dirs [ k ] * jump NEW_LINE y = j + dirs [ k + 1 ] * jump NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT break NEW_LINE DEDENT if grid [ x ] [ y ] == ' # ' : NEW_LINE INDENT break NEW_LINE DEDENT if grid [ x ] [ y ] == ' F ' : NEW_LINE INDENT return False NEW_LINE DEDENT nextCat = hash ( x , y ) NEW_LINE if nextCat == mouse : NEW_LINE INDENT return False NEW_LINE DEDENT if not dp ( nextCat , mouse , turn + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT return dp ( cat , mouse , 0 ) NEW_LINE DEDENT DEDENT
class BSTIterator : NEW_LINE INDENT def __init__ ( self , root : Optional [ TreeNode ] ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . pushLeftsUntilNone ( root ) NEW_LINE DEDENT def next ( self ) -> int : NEW_LINE INDENT root = self . stack . pop ( ) NEW_LINE self . pushLeftsUntilNone ( root . right ) NEW_LINE return root . val NEW_LINE DEDENT def hasNext ( self ) -> bool : NEW_LINE INDENT return self . stack NEW_LINE DEDENT def pushLeftsUntilNone ( self , root : Optional [ TreeNode ] ) : NEW_LINE INDENT while root : NEW_LINE INDENT self . stack . append ( root ) NEW_LINE root = root . left NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumBoxes ( self , n : int ) -> int : NEW_LINE INDENT nBoxes = 0 NEW_LINE nextTouchings = 0 NEW_LINE currLevelBoxes = 0 NEW_LINE while nBoxes < n : NEW_LINE INDENT nextTouchings += 1 NEW_LINE currLevelBoxes += nextTouchings NEW_LINE nBoxes += currLevelBoxes NEW_LINE DEDENT if nBoxes == n : NEW_LINE INDENT return currLevelBoxes NEW_LINE DEDENT nBoxes -= currLevelBoxes NEW_LINE currLevelBoxes -= nextTouchings NEW_LINE nextTouchings = 0 NEW_LINE while nBoxes < n : NEW_LINE INDENT nextTouchings += 1 NEW_LINE nBoxes += nextTouchings NEW_LINE DEDENT return currLevelBoxes + nextTouchings NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def calculateMinimumHP ( self , dungeon : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( dungeon ) NEW_LINE n = len ( dungeon [ 0 ] ) NEW_LINE dp = [ math . inf ] * ( n + 1 ) NEW_LINE dp [ n - 1 ] = 1 NEW_LINE for i in reversed ( range ( m ) ) : NEW_LINE INDENT for j in reversed ( range ( n ) ) : NEW_LINE INDENT dp [ j ] = min ( dp [ j ] , dp [ j + 1 ] ) - dungeon [ i ] [ j ] NEW_LINE dp [ j ] = max ( dp [ j ] , 1 ) NEW_LINE DEDENT DEDENT return dp [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findDistance ( self , root : TreeNode , p : int , q : int ) -> int : NEW_LINE INDENT def getLCA ( root , p , q ) : NEW_LINE INDENT if not root or root . val == p or root . val == q : NEW_LINE INDENT return root NEW_LINE DEDENT l = getLCA ( root . left , p , q ) NEW_LINE r = getLCA ( root . right , p , q ) NEW_LINE if l and r : NEW_LINE INDENT return root NEW_LINE DEDENT return l or r NEW_LINE DEDENT def dist ( lca , target ) : NEW_LINE INDENT if not lca : NEW_LINE INDENT return 10000 NEW_LINE DEDENT if lca . val == target : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 + min ( dist ( lca . left , target ) , dist ( lca . right , target ) ) NEW_LINE DEDENT lca = getLCA ( root , p , q ) NEW_LINE return dist ( lca , p ) + dist ( lca , q ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def restoreArray ( self , adjacentPairs : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE numToAdjs = defaultdict ( list ) NEW_LINE for a , b in adjacentPairs : NEW_LINE INDENT numToAdjs [ a ] . append ( b ) NEW_LINE numToAdjs [ b ] . append ( a ) NEW_LINE DEDENT for num , adjs in numToAdjs . items ( ) : NEW_LINE INDENT if len ( adjs ) == 1 : NEW_LINE INDENT ans . append ( num ) NEW_LINE ans . append ( adjs [ 0 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT while len ( ans ) < len ( adjacentPairs ) + 1 : NEW_LINE INDENT tail = ans [ - 1 ] NEW_LINE prev = ans [ - 2 ] NEW_LINE adjs = numToAdjs [ tail ] NEW_LINE if adjs [ 0 ] == prev : NEW_LINE INDENT ans . append ( adjs [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( adjs [ 0 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canEat ( self , candiesCount : List [ int ] , queries : List [ List [ int ] ] ) -> List [ bool ] : NEW_LINE INDENT prefix = [ 0 ] + list ( itertools . accumulate ( candiesCount ) ) NEW_LINE return [ prefix [ t ] // c <= d < prefix [ t + 1 ] for t , d , c in queries ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkPartitioning ( self , s : str ) -> bool : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( i , j ) : NEW_LINE INDENT if i > j - 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if s [ i ] == s [ j - 1 ] : NEW_LINE INDENT return dp ( i + 1 , j - 1 ) NEW_LINE DEDENT return False NEW_LINE DEDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if dp ( 0 , i ) and dp ( i , j ) and dp ( j , n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxValue ( self , events : List [ List [ int ] ] , k : int ) -> int : NEW_LINE INDENT e = sorted ( events ) NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( i , k ) : NEW_LINE INDENT if k == 0 or i == len ( e ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT j = bisect . bisect ( e , [ e [ i ] [ 1 ] , math . inf , math . inf ] , i + 1 ) NEW_LINE return max ( dp ( i + 1 , k ) , e [ i ] [ 2 ] + dp ( j , k - 1 ) ) NEW_LINE DEDENT return dp ( 0 , k ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minAbsDifference ( self , nums : List [ int ] , goal : int ) -> int : NEW_LINE INDENT n = len ( nums ) // 2 NEW_LINE ans = math . inf NEW_LINE lSums = [ ] NEW_LINE rSums = [ ] NEW_LINE def dfs ( A : List [ int ] , i : int , path : int , sums : List [ int ] ) -> None : NEW_LINE INDENT if i == len ( A ) : NEW_LINE INDENT sums . append ( path ) NEW_LINE return NEW_LINE DEDENT dfs ( A , i + 1 , path + A [ i ] , sums ) NEW_LINE dfs ( A , i + 1 , path , sums ) NEW_LINE DEDENT dfs ( nums [ : n ] , 0 , 0 , lSums ) NEW_LINE dfs ( nums [ n : ] , 0 , 0 , rSums ) NEW_LINE rSums . sort ( ) NEW_LINE for lSum in lSums : NEW_LINE INDENT i = bisect_left ( rSums , goal - lSum ) NEW_LINE if i < len ( rSums ) : NEW_LINE INDENT ans = min ( ans , abs ( goal - lSum - rSums [ i ] ) ) NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT ans = min ( ans , abs ( goal - lSum - rSums [ i - 1 ] ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findBuildings ( self , heights : List [ int ] ) -> List [ int ] : NEW_LINE INDENT stack = [ ] NEW_LINE for i , height in enumerate ( heights ) : NEW_LINE INDENT while stack and heights [ stack [ - 1 ] ] <= height : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT return stack NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mergeAlternately ( self , word1 : str , word2 : str ) -> str : NEW_LINE INDENT return ' ' . join ( a + b for a , b in zip_longest ( word1 , word2 , fillvalue = ' ' ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumScore ( self , nums : List [ int ] , multipliers : List [ int ] ) -> int : NEW_LINE INDENT @ functools . lru_cache ( 2000 ) NEW_LINE def dp ( s : int , i : int ) -> int : NEW_LINE INDENT if i == len ( multipliers ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT e = len ( nums ) - ( i - s ) - 1 NEW_LINE pickStart = nums [ s ] * multipliers [ i ] + dp ( s + 1 , i + 1 ) NEW_LINE pickEnd = nums [ e ] * multipliers [ i ] + dp ( s , i + 1 ) NEW_LINE return max ( pickStart , pickEnd ) NEW_LINE DEDENT return dp ( 0 , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getCollisionTimes ( self , cars : List [ List [ int ] ] ) -> List [ float ] : NEW_LINE INDENT ans = [ ] NEW_LINE stack = [ ] NEW_LINE def getCollisionTime ( car : Tuple [ int , int , int ] , pos : int , speed : int ) -> float : NEW_LINE INDENT return ( car [ 0 ] - pos ) / ( speed - car [ 1 ] ) NEW_LINE DEDENT for pos , speed in reversed ( cars ) : NEW_LINE INDENT while stack and ( speed <= stack [ - 1 ] [ 1 ] or getCollisionTime ( stack [ - 1 ] , pos , speed ) >= stack [ - 1 ] [ 2 ] ) : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT if stack : NEW_LINE INDENT collisionTime = getCollisionTime ( stack [ - 1 ] , pos , speed ) NEW_LINE stack . append ( ( pos , speed , collisionTime ) ) NEW_LINE ans . append ( collisionTime ) NEW_LINE DEDENT else : NEW_LINE INDENT stack . append ( ( pos , speed , math . inf ) ) NEW_LINE ans . append ( - 1 ) NEW_LINE DEDENT DEDENT return ans [ : : - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkPowersOfThree ( self , n : int ) -> bool : NEW_LINE INDENT while n > 1 : NEW_LINE INDENT n , r = divmod ( n , 3 ) NEW_LINE if r == 2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countPairs ( self , n : int , edges : List [ List [ int ] ] , queries : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * len ( queries ) NEW_LINE count = [ 0 ] * ( n + 1 ) NEW_LINE shared = [ Counter ( ) for _ in range ( n + 1 ) ] NEW_LINE for u , v in edges : NEW_LINE INDENT count [ u ] += 1 NEW_LINE count [ v ] += 1 NEW_LINE shared [ min ( u , v ) ] [ max ( u , v ) ] += 1 NEW_LINE DEDENT sortedCount = sorted ( count ) NEW_LINE for k , q in enumerate ( queries ) : NEW_LINE INDENT i = 1 NEW_LINE j = n NEW_LINE while i < j : NEW_LINE INDENT if sortedCount [ i ] + sortedCount [ j ] > q : NEW_LINE INDENT ans [ k ] += j - i NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j , sh in shared [ i ] . items ( ) : NEW_LINE INDENT if count [ i ] + count [ j ] > q and count [ i ] + count [ j ] - sh <= q : NEW_LINE INDENT ans [ k ] -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkOnesSegment ( self , s : str ) -> bool : NEW_LINE INDENT return '01' not in s NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def fourSum ( self , nums : List [ int ] , target : int ) : NEW_LINE INDENT ans = [ ] NEW_LINE def nSum ( l : int , r : int , target : int , n : int , path : List [ int ] , ans : List [ List [ int ] ] ) -> None : NEW_LINE INDENT if r - l + 1 < n or n < 2 or target < nums [ l ] * n or target > nums [ r ] * n : NEW_LINE INDENT return NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT while l < r : NEW_LINE INDENT summ = nums [ l ] + nums [ r ] NEW_LINE if summ == target : NEW_LINE INDENT ans . append ( path + [ nums [ l ] , nums [ r ] ] ) NEW_LINE l += 1 NEW_LINE while nums [ l ] == nums [ l - 1 ] and l < r : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT elif summ < target : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT if i > l and nums [ i ] == nums [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT nSum ( i + 1 , r , target - nums [ i ] , n - 1 , path + [ nums [ i ] ] , ans ) NEW_LINE DEDENT DEDENT nums . sort ( ) NEW_LINE nSum ( 0 , len ( nums ) - 1 , target , 4 , [ ] , ans ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def areSentencesSimilar ( self , sentence1 : str , sentence2 : str ) -> bool : NEW_LINE INDENT if len ( sentence1 ) == len ( sentence2 ) : NEW_LINE INDENT return sentence1 == sentence2 NEW_LINE DEDENT words1 = sentence1 . split ( ) NEW_LINE words2 = sentence2 . split ( ) NEW_LINE m , n = map ( len , ( words1 , words2 ) ) NEW_LINE if m > n : NEW_LINE INDENT return self . areSentencesSimilar ( sentence2 , sentence1 ) NEW_LINE DEDENT i = 0 NEW_LINE while i < m and words1 [ i ] == words2 [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while i < m and words1 [ i ] == words2 [ i + n - m ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return i == m NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countNicePairs ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT freqs = Counter ( num - int ( str ( num ) [ : : - 1 ] ) for num in nums ) NEW_LINE return sum ( freq * ( freq - 1 ) // 2 for freq in freqs . values ( ) ) % 1000000007 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxHappyGroups ( self , batchSize : int , groups : List [ int ] ) -> int : NEW_LINE INDENT happy = 0 NEW_LINE freq = [ 0 ] * batchSize NEW_LINE for g in groups : NEW_LINE INDENT g %= batchSize NEW_LINE if g == 0 : NEW_LINE INDENT happy += 1 NEW_LINE DEDENT elif freq [ batchSize - g ] : NEW_LINE INDENT freq [ batchSize - g ] -= 1 NEW_LINE happy += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ g ] += 1 NEW_LINE DEDENT DEDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( freq , r ) : NEW_LINE INDENT ans = 0 NEW_LINE if any ( freq ) : NEW_LINE INDENT for i , f in enumerate ( freq ) : NEW_LINE INDENT if f : NEW_LINE INDENT ans = max ( ans , dp ( freq [ : i ] + ( f - 1 , ) + freq [ i + 1 : ] , ( r + i ) % batchSize ) ) NEW_LINE DEDENT DEDENT if r == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return happy + dp ( tuple ( freq ) , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def truncateSentence ( self , s : str , k : int ) -> str : NEW_LINE INDENT return ' ▁ ' . join ( s . split ( ) [ : k ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findingUsersActiveMinutes ( self , logs : List [ List [ int ] ] , k : int ) -> List [ int ] : NEW_LINE INDENT idToTimes = defaultdict ( set ) NEW_LINE for id , time in logs : NEW_LINE INDENT idToTimes [ id ] . add ( time ) NEW_LINE DEDENT c = Counter ( len ( times ) for times in idToTimes . values ( ) ) NEW_LINE return [ c [ i ] for i in range ( 1 , k + 1 ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minAbsoluteSumDiff ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> int : NEW_LINE INDENT ans = math . inf NEW_LINE diffs = [ abs ( a - b ) for a , b in zip ( nums1 , nums2 ) ] NEW_LINE sumDiff = sum ( diffs ) NEW_LINE nums1 . sort ( ) NEW_LINE for num , diff in zip ( nums2 , diffs ) : NEW_LINE INDENT i = bisect . bisect_left ( nums1 , num ) NEW_LINE if i > 0 : NEW_LINE INDENT ans = min ( ans , sumDiff - diff + abs ( num - nums1 [ i - 1 ] ) ) NEW_LINE DEDENT if i < len ( nums1 ) : NEW_LINE INDENT ans = min ( ans , sumDiff - diff + abs ( num - nums1 [ i ] ) ) NEW_LINE DEDENT DEDENT return ans % int ( 1e9 + 7 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumInvitations ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE ans = 0 NEW_LINE mate = [ - 1 ] * n NEW_LINE def canInvite ( i , seen ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if not grid [ i ] [ j ] or seen [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT seen [ j ] = True NEW_LINE if mate [ j ] == - 1 or canInvite ( mate [ j ] , seen ) : NEW_LINE INDENT mate [ j ] = i NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT seen = [ False ] * n NEW_LINE if canInvite ( i , seen ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def arraySign ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT sign = 1 NEW_LINE for num in nums : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if num < 0 : NEW_LINE INDENT sign = - sign NEW_LINE DEDENT DEDENT return sign NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findTheWinner ( self , n : int , k : int ) -> int : NEW_LINE INDENT friends = [ False ] * n NEW_LINE friendCount = n NEW_LINE fp = 0 NEW_LINE while friendCount > 1 : NEW_LINE INDENT for _ in range ( k ) : NEW_LINE INDENT while friends [ fp % n ] : NEW_LINE INDENT fp += 1 NEW_LINE DEDENT fp += 1 NEW_LINE DEDENT friends [ ( fp - 1 ) % n ] = True NEW_LINE friendCount -= 1 NEW_LINE DEDENT fp = 0 NEW_LINE while friends [ fp ] : NEW_LINE INDENT fp += 1 NEW_LINE DEDENT return fp + 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minSideJumps ( self , obstacles : List [ int ] ) -> int : NEW_LINE INDENT kInf = 1e6 NEW_LINE dp = [ kInf , 1 , 0 , 1 ] NEW_LINE for obstacle in obstacles : NEW_LINE INDENT print ( dp ) NEW_LINE if obstacle > 0 : NEW_LINE INDENT dp [ obstacle ] = kInf NEW_LINE DEDENT for i in range ( 1 , 4 ) : NEW_LINE INDENT if i != obstacle : NEW_LINE INDENT for j in range ( 1 , 4 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ j ] + ( 0 if i == j else 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return min ( dp ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def badSensor ( self , sensor1 : List [ int ] , sensor2 : List [ int ] ) -> int : NEW_LINE INDENT def canReplace ( A , B ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE droppedValue = - 1 NEW_LINE while i < len ( A ) : NEW_LINE INDENT if A [ i ] == B [ j ] : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT droppedValue = A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return j == len ( B ) - 1 and B [ - 1 ] != droppedValue NEW_LINE DEDENT oneDefect = canReplace ( sensor2 , sensor1 ) NEW_LINE twoDefect = canReplace ( sensor1 , sensor2 ) NEW_LINE if oneDefect and twoDefect : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if not oneDefect and not twoDefect : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 1 if oneDefect else 2 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minOperations ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE last = 0 NEW_LINE for num in nums : NEW_LINE INDENT ans += max ( 0 , last - num + 1 ) NEW_LINE last = max ( num , last + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countPoints ( self , points : List [ List [ int ] ] , queries : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE def squared ( x ) : NEW_LINE INDENT return x * x NEW_LINE DEDENT for xj , yj , r in queries : NEW_LINE INDENT rSquared = r ** 2 NEW_LINE count = 0 NEW_LINE for xi , yi in points : NEW_LINE INDENT count += ( xi - xj ) ** 2 + ( yi - yj ) ** 2 <= rSquared NEW_LINE DEDENT ans . append ( count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getMaximumXor ( self , nums : List [ int ] , maximumBit : int ) -> List [ int ] : NEW_LINE INDENT max = ( 1 << maximumBit ) - 1 NEW_LINE ans = [ ] NEW_LINE xors = 0 NEW_LINE for num in nums : NEW_LINE INDENT xors ^= num NEW_LINE ans . append ( xors ^ max ) NEW_LINE DEDENT return ans [ : : - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkIfPangram ( self , sentence : str ) -> bool : NEW_LINE INDENT return len ( set ( sentence ) ) == 26 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxIceCream ( self , costs : List [ int ] , coins : int ) -> int : NEW_LINE INDENT for i , cost in enumerate ( sorted ( costs ) ) : NEW_LINE INDENT if coins >= cost : NEW_LINE INDENT coins -= cost NEW_LINE DEDENT else : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return len ( costs ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getOrder ( self , tasks : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT n = len ( tasks ) NEW_LINE A = [ [ * task , i ] for i , task in enumerate ( tasks ) ] NEW_LINE ans = [ ] NEW_LINE minHeap = [ ] NEW_LINE i = 0 NEW_LINE time = 0 NEW_LINE A . sort ( ) NEW_LINE while i < n or minHeap : NEW_LINE INDENT if not minHeap : NEW_LINE INDENT time = max ( time , A [ i ] [ 0 ] ) NEW_LINE DEDENT while i < n and time >= A [ i ] [ 0 ] : NEW_LINE INDENT heapq . heappush ( minHeap , ( A [ i ] [ 1 ] , A [ i ] [ 2 ] ) ) NEW_LINE i += 1 NEW_LINE DEDENT procTime , index = heapq . heappop ( minHeap ) NEW_LINE time += procTime NEW_LINE ans . append ( index ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getXORSum ( self , arr1 : List [ int ] , arr2 : List [ int ] ) -> int : NEW_LINE INDENT return functools . reduce ( operator . xor , arr1 ) & functools . reduce ( operator . xor , arr2 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def deleteDuplicatesUnsorted ( self , head : ListNode ) -> ListNode : NEW_LINE INDENT dummy = ListNode ( 0 , head ) NEW_LINE count = Counter ( ) NEW_LINE curr = head NEW_LINE while curr : NEW_LINE INDENT count [ curr . val ] += 1 NEW_LINE curr = curr . next NEW_LINE DEDENT curr = dummy NEW_LINE while curr : NEW_LINE INDENT while curr . next and curr . next . val in count and count [ curr . next . val ] > 1 : NEW_LINE INDENT curr . next = curr . next . next NEW_LINE DEDENT curr = curr . next NEW_LINE DEDENT return dummy . next NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sumBase ( self , n : int , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE while n : NEW_LINE INDENT ans += n % k NEW_LINE n //= k NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxFrequency ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE summ = 0 NEW_LINE nums . sort ( ) NEW_LINE l = 0 NEW_LINE for r , num in enumerate ( nums ) : NEW_LINE INDENT summ += num NEW_LINE while summ + k < num * ( r - l + 1 ) : NEW_LINE INDENT summ -= nums [ l ] NEW_LINE l += 1 NEW_LINE DEDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestBeautifulSubstring ( self , word : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = 1 NEW_LINE l = 0 NEW_LINE for r in range ( 1 , len ( word ) ) : NEW_LINE INDENT curr = word [ r ] NEW_LINE prev = word [ r - 1 ] NEW_LINE if curr >= prev : NEW_LINE INDENT if curr > prev : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == 5 : NEW_LINE INDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE l = r NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxBuilding ( self , n : int , restrictions : List [ List [ int ] ] ) -> int : NEW_LINE INDENT A = sorted ( restrictions + [ [ 1 , 0 ] ] + [ [ n , n - 1 ] ] ) NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT dist = A [ i ] [ 0 ] - A [ i - 1 ] [ 0 ] NEW_LINE A [ i ] [ 1 ] = min ( A [ i ] [ 1 ] , A [ i - 1 ] [ 1 ] + dist ) NEW_LINE DEDENT for i in reversed ( range ( len ( A ) - 1 ) ) : NEW_LINE INDENT dist = A [ i + 1 ] [ 0 ] - A [ i ] [ 0 ] NEW_LINE A [ i ] [ 1 ] = min ( A [ i ] [ 1 ] , A [ i + 1 ] [ 1 ] + dist ) NEW_LINE DEDENT ans = 0 NEW_LINE for ( l , hL ) , ( r , hR ) in zip ( A , A [ 1 : ] ) : NEW_LINE INDENT ans = max ( ans , max ( hL , hR ) + ( r - l - abs ( hL - hR ) ) // 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nextPalindrome ( self , num : str ) -> str : NEW_LINE INDENT def nextPermutation ( nums : List [ int ] ) -> bool : NEW_LINE INDENT n = len ( nums ) NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if nums [ i ] < nums [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if i < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for j in range ( n - 1 , i , - 1 ) : NEW_LINE INDENT if nums [ j ] > nums [ i ] : NEW_LINE INDENT nums [ i ] , nums [ j ] = nums [ j ] , nums [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT def reverse ( nums , l , r ) : NEW_LINE INDENT while l < r : NEW_LINE INDENT nums [ l ] , nums [ r ] = nums [ r ] , nums [ l ] NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT reverse ( nums , i + 1 , len ( nums ) - 1 ) NEW_LINE return True NEW_LINE DEDENT n = len ( num ) NEW_LINE A = [ ord ( num [ i ] ) - ord ( '0' ) for i in range ( len ( num ) // 2 ) ] NEW_LINE if not nextPermutation ( A ) : NEW_LINE INDENT return ' ' NEW_LINE DEDENT s = ' ' . join ( [ chr ( ord ( '0' ) + a ) for a in A ] ) NEW_LINE if n & 1 : NEW_LINE INDENT return s + num [ n // 2 ] + s [ : : - 1 ] NEW_LINE DEDENT return s + s [ : : - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def replaceDigits ( self , s : str ) -> str : NEW_LINE INDENT A = list ( s ) NEW_LINE for i in range ( 1 , len ( A ) , 2 ) : NEW_LINE INDENT A [ i ] = chr ( ord ( A [ i - 1 ] ) + ord ( A [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ' ' . join ( A ) NEW_LINE DEDENT DEDENT
class SeatManager : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . minHeap = [ i + 1 for i in range ( n ) ] NEW_LINE DEDENT def reserve ( self ) -> int : NEW_LINE INDENT return heapq . heappop ( self . minHeap ) NEW_LINE DEDENT def unreserve ( self , seatNumber : int ) -> None : NEW_LINE INDENT heapq . heappush ( self . minHeap , seatNumber ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumElementAfterDecrementingAndRearranging ( self , arr : List [ int ] ) -> int : NEW_LINE INDENT arr . sort ( ) NEW_LINE arr [ 0 ] = 1 NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT arr [ i ] = min ( arr [ i ] , arr [ i - 1 ] + 1 ) NEW_LINE DEDENT return arr [ - 1 ] NEW_LINE DEDENT DEDENT
from sortedcontainers import SortedList NEW_LINE class Solution : NEW_LINE INDENT def closestRoom ( self , rooms : List [ List [ int ] ] , queries : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * len ( queries ) NEW_LINE qs = [ [ * q , i ] for i , q in enumerate ( queries ) ] NEW_LINE roomIds = SortedList ( ) NEW_LINE rooms . sort ( key = lambda x : - x [ 1 ] ) NEW_LINE qs . sort ( key = lambda x : - x [ 1 ] ) NEW_LINE def searchClosestRoomId ( roomIds : SortedList , preferred : int ) : NEW_LINE INDENT if not roomIds : NEW_LINE INDENT return - 1 NEW_LINE DEDENT candIds = [ ] NEW_LINE i = roomIds . bisect_right ( preferred ) NEW_LINE if i > 0 : NEW_LINE INDENT candIds . append ( roomIds [ i - 1 ] ) NEW_LINE DEDENT if i < len ( roomIds ) : NEW_LINE INDENT candIds . append ( roomIds [ i ] ) NEW_LINE DEDENT return min ( candIds , key = lambda x : abs ( x - preferred ) ) NEW_LINE DEDENT i = 0 NEW_LINE for preferred , minSize , index in qs : NEW_LINE INDENT while i < len ( rooms ) and rooms [ i ] [ 1 ] >= minSize : NEW_LINE INDENT roomIds . add ( rooms [ i ] [ 0 ] ) NEW_LINE i += 1 NEW_LINE DEDENT ans [ index ] = searchClosestRoomId ( roomIds , preferred ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getMinDistance ( self , nums : List [ int ] , target : int , start : int ) -> int : NEW_LINE INDENT ans = math . inf NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT if num == target : NEW_LINE INDENT ans = min ( ans , abs ( i - start ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def splitString ( self , s : str ) -> bool : NEW_LINE INDENT def isValid ( s : str , start : int , prev : int , segment : int ) -> bool : NEW_LINE INDENT if start == len ( s ) and segment > 1 : NEW_LINE INDENT return True NEW_LINE DEDENT curr = 0 NEW_LINE for i in range ( start , len ( s ) ) : NEW_LINE INDENT curr = curr * 10 + ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if curr > 9999999999 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( prev == - 1 or curr == prev - 1 ) and isValid ( s , i + 1 , curr , segment + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT return isValid ( s , 0 , - 1 , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getMinSwaps ( self , num : str , k : int ) -> int : NEW_LINE INDENT def nextPermutation ( nums : List [ int ] ) : NEW_LINE INDENT n = len ( nums ) NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if nums [ i ] < nums [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if i >= 0 : NEW_LINE INDENT for j in range ( n - 1 , i , - 1 ) : NEW_LINE INDENT if nums [ j ] > nums [ i ] : NEW_LINE INDENT nums [ i ] , nums [ j ] = nums [ j ] , nums [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT def reverse ( nums , l , r ) : NEW_LINE INDENT while l < r : NEW_LINE INDENT nums [ l ] , nums [ r ] = nums [ r ] , nums [ l ] NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT reverse ( nums , i + 1 , len ( nums ) - 1 ) NEW_LINE DEDENT A = [ int ( c ) for c in num ] NEW_LINE B = A . copy ( ) NEW_LINE for _ in range ( k ) : NEW_LINE INDENT nextPermutation ( B ) NEW_LINE DEDENT def countSteps ( A : List [ int ] , B : List [ int ] ) -> int : NEW_LINE INDENT count = 0 NEW_LINE j = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT j = i NEW_LINE while A [ i ] != B [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT while i < j : NEW_LINE INDENT B [ j ] , B [ j - 1 ] = B [ j - 1 ] , B [ j ] NEW_LINE j -= 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT return countSteps ( A , B ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxDistance ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( nums1 ) and j < len ( nums2 ) : NEW_LINE INDENT if nums1 [ i ] > nums2 [ j ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , j - i ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxSumMinProduct ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE stack = [ ] NEW_LINE prefix = [ 0 ] + list ( itertools . accumulate ( nums ) ) NEW_LINE for i in range ( len ( nums ) + 1 ) : NEW_LINE INDENT while stack and ( i == len ( nums ) or nums [ stack [ - 1 ] ] > nums [ i ] ) : NEW_LINE INDENT minVal = nums [ stack . pop ( ) ] NEW_LINE summ = prefix [ i ] - prefix [ stack [ - 1 ] + 1 ] if stack else prefix [ i ] NEW_LINE ans = max ( ans , minVal * summ ) NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT return ans % int ( 1e9 + 7 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestPathValue ( self , colors : str , edges : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( colors ) NEW_LINE ans = 0 NEW_LINE processed = 0 NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE inDegree = [ 0 ] * n NEW_LINE q = deque ( ) NEW_LINE count = [ [ 0 ] * 26 for _ in range ( n ) ] NEW_LINE for u , v in edges : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE inDegree [ v ] += 1 NEW_LINE DEDENT for i , degree in enumerate ( inDegree ) : NEW_LINE INDENT if degree == 0 : NEW_LINE INDENT q . append ( i ) NEW_LINE DEDENT DEDENT while q : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE processed += 1 NEW_LINE count [ u ] [ ord ( colors [ u ] ) - ord ( ' a ' ) ] += 1 NEW_LINE ans = max ( ans , count [ u ] [ ord ( colors [ u ] ) - ord ( ' a ' ) ] ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT for i in range ( 26 ) : NEW_LINE INDENT count [ v ] [ i ] = max ( count [ v ] [ i ] , count [ u ] [ i ] ) NEW_LINE DEDENT inDegree [ v ] -= 1 NEW_LINE if inDegree [ v ] == 0 : NEW_LINE INDENT q . append ( v ) NEW_LINE DEDENT DEDENT DEDENT return ans if processed == n else - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . root = { } NEW_LINE DEDENT def longestWord ( self , words : List [ str ] ) -> str : NEW_LINE INDENT ans = ' ' NEW_LINE for word in words : NEW_LINE INDENT self . insert ( word ) NEW_LINE DEDENT for word in words : NEW_LINE INDENT if not self . allPrefixed ( word ) : NEW_LINE INDENT continue NEW_LINE DEDENT if len ( ans ) < len ( word ) or ( len ( ans ) == len ( word ) and ans > word ) : NEW_LINE INDENT ans = word NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def insert ( self , word : str ) -> None : NEW_LINE INDENT node = self . root NEW_LINE for c in word : NEW_LINE INDENT if c not in node : NEW_LINE INDENT node [ c ] = { } NEW_LINE DEDENT node = node [ c ] NEW_LINE DEDENT node [ ' isWord ' ] = True NEW_LINE DEDENT def allPrefixed ( self , word : str ) -> bool : NEW_LINE INDENT node = self . root NEW_LINE for c in word : NEW_LINE INDENT node = node [ c ] NEW_LINE if ' isWord ' not in node : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sortSentence ( self , s : str ) -> str : NEW_LINE INDENT return ' ▁ ' . join ( [ w [ : - 1 ] for w in sorted ( s . split ( ) , key = lambda x : x [ - 1 ] ) ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reverseWords ( self , s : List [ str ] ) -> None : NEW_LINE INDENT def reverse ( l : int , r : int ) -> None : NEW_LINE INDENT while l < r : NEW_LINE INDENT s [ l ] , s [ r ] = s [ r ] , s [ l ] NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT def reverseWords ( n : int ) -> None : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while i < n : NEW_LINE INDENT while i < j or ( i < n and s [ i ] == ' ▁ ' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while j < i or ( j < n and s [ j ] != ' ▁ ' ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT reverse ( i , j - 1 ) NEW_LINE DEDENT DEDENT reverse ( 0 , len ( s ) - 1 ) NEW_LINE reverseWords ( len ( s ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def memLeak ( self , memory1 : int , memory2 : int ) -> List [ int ] : NEW_LINE INDENT i = 1 NEW_LINE while memory1 >= i or memory2 >= i : NEW_LINE INDENT if memory1 >= memory2 : NEW_LINE INDENT memory1 -= i NEW_LINE DEDENT else : NEW_LINE INDENT memory2 -= i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return [ i , memory1 , memory2 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rotateTheBox ( self , box : List [ List [ str ] ] ) -> List [ List [ str ] ] : NEW_LINE INDENT m = len ( box ) NEW_LINE n = len ( box [ 0 ] ) NEW_LINE rotated = [ [ ' . ' ] * m for _ in range ( n ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT k = n - 1 NEW_LINE for j in reversed ( range ( n ) ) : NEW_LINE INDENT if box [ i ] [ j ] != ' . ' : NEW_LINE INDENT if box [ i ] [ j ] == ' * ' : NEW_LINE INDENT k = j NEW_LINE DEDENT rotated [ k ] [ m - i - 1 ] = box [ i ] [ j ] NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT return [ ' ' . join ( row ) for row in rotated ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sumOfFlooredPairs ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE kMax = max ( nums ) NEW_LINE ans = 0 NEW_LINE count = [ 0 ] * ( kMax + 1 ) NEW_LINE for num in nums : NEW_LINE INDENT count [ num ] += 1 NEW_LINE DEDENT for i in range ( 1 , kMax + 1 ) : NEW_LINE INDENT count [ i ] += count [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , kMax + 1 ) : NEW_LINE INDENT if count [ i ] > count [ i - 1 ] : NEW_LINE INDENT summ = 0 NEW_LINE j = 1 NEW_LINE while i * j <= kMax : NEW_LINE INDENT lo = i * j - 1 NEW_LINE hi = i * ( j + 1 ) - 1 NEW_LINE summ += ( count [ min ( hi , kMax ) ] - count [ lo ] ) * j NEW_LINE j += 1 NEW_LINE DEDENT ans += summ * ( count [ i ] - count [ i - 1 ] ) NEW_LINE ans %= kMod NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def subsetXORSum ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT def dfs ( i : int , xors : int ) -> int : NEW_LINE INDENT if i == len ( nums ) : NEW_LINE INDENT return xors NEW_LINE DEDENT x = dfs ( i + 1 , xors ) NEW_LINE y = dfs ( i + 1 , nums [ i ] ^ xors ) NEW_LINE return x + y NEW_LINE DEDENT return dfs ( 0 , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minSwaps ( self , s : str ) -> int : NEW_LINE INDENT ones = s . count ( '1' ) NEW_LINE zeros = len ( s ) - ones NEW_LINE if abs ( ones - zeros ) > 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT def countSwaps ( curr : chr ) -> int : NEW_LINE INDENT swaps = 0 NEW_LINE for c in s : NEW_LINE INDENT if c != curr : NEW_LINE INDENT swaps += 1 NEW_LINE DEDENT curr = chr ( ord ( curr ) ^ 1 ) NEW_LINE DEDENT return swaps // 2 NEW_LINE DEDENT if ones > zeros : NEW_LINE INDENT return countSwaps ( '1' ) NEW_LINE DEDENT if zeros > ones : NEW_LINE INDENT return countSwaps ( '0' ) NEW_LINE DEDENT return min ( countSwaps ( '1' ) , countSwaps ( '0' ) ) NEW_LINE DEDENT DEDENT
class FindSumPairs : NEW_LINE INDENT def __init__ ( self , nums1 : List [ int ] , nums2 : List [ int ] ) : NEW_LINE INDENT self . nums1 = nums1 NEW_LINE self . nums2 = nums2 NEW_LINE self . count2 = Counter ( nums2 ) NEW_LINE DEDENT def add ( self , index : int , val : int ) -> None : NEW_LINE INDENT self . count2 [ self . nums2 [ index ] ] -= 1 NEW_LINE self . nums2 [ index ] += val NEW_LINE self . count2 [ self . nums2 [ index ] ] += 1 NEW_LINE DEDENT def count ( self , tot : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for num in self . nums1 : NEW_LINE INDENT ans += self . count2 [ tot - num ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def rearrangeSticks ( self , n : int , k : int ) -> int : NEW_LINE INDENT if n == k : NEW_LINE INDENT return 1 NEW_LINE DEDENT if k == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( self . rearrangeSticks ( n - 1 , k - 1 ) + self . rearrangeSticks ( n - 1 , k ) * ( n - 1 ) ) % self . kMod NEW_LINE DEDENT kMod = 1_000_000_007 NEW_LINE DEDENT
class Solution : NEW_LINE INDENT def findRLEArray ( self , encoded1 : List [ List [ int ] ] , encoded2 : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( encoded1 ) and j < len ( encoded2 ) : NEW_LINE INDENT mult = encoded1 [ i ] [ 0 ] * encoded2 [ j ] [ 0 ] NEW_LINE minFreq = min ( encoded1 [ i ] [ 1 ] , encoded2 [ j ] [ 1 ] ) NEW_LINE if ans and mult == ans [ - 1 ] [ 0 ] : NEW_LINE INDENT ans [ - 1 ] [ 1 ] += minFreq NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( [ mult , minFreq ] ) NEW_LINE DEDENT encoded1 [ i ] [ 1 ] -= minFreq NEW_LINE encoded2 [ j ] [ 1 ] -= minFreq NEW_LINE if encoded1 [ i ] [ 1 ] == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if encoded2 [ j ] [ 1 ] == 0 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkZeroOnes ( self , s : str ) -> bool : NEW_LINE INDENT longestOnes = 0 NEW_LINE longestZeros = 0 NEW_LINE currentOnes = 0 NEW_LINE currentZeros = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == '0' : NEW_LINE INDENT currentOnes = 0 NEW_LINE currentZeros += 1 NEW_LINE longestZeros = max ( longestZeros , currentZeros ) NEW_LINE DEDENT else : NEW_LINE INDENT currentZeros = 0 NEW_LINE currentOnes += 1 NEW_LINE longestOnes = max ( longestOnes , currentOnes ) NEW_LINE DEDENT DEDENT return longestOnes > longestZeros NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findRepeatedDnaSequences ( self , s : str ) -> List [ str ] : NEW_LINE INDENT ans = set ( ) NEW_LINE seen = set ( ) NEW_LINE for i in range ( len ( s ) - 9 ) : NEW_LINE INDENT seq = s [ i : i + 10 ] NEW_LINE if seq in seen : NEW_LINE INDENT ans . add ( seq ) NEW_LINE DEDENT seen . add ( seq ) NEW_LINE DEDENT return list ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minSpeedOnTime ( self , dist : List [ int ] , hour : float ) -> int : NEW_LINE INDENT ans = - 1 NEW_LINE l = 1 NEW_LINE r = int ( 1e7 ) NEW_LINE def time ( speed : int ) -> float : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( len ( dist ) - 1 ) : NEW_LINE INDENT summ += ceil ( dist [ i ] / speed ) NEW_LINE DEDENT return summ + dist [ - 1 ] / speed NEW_LINE DEDENT while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if time ( m ) > hour : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = m NEW_LINE r = m - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canReach ( self , s : str , minJump : int , maxJump : int ) -> bool : NEW_LINE INDENT count = 0 NEW_LINE dp = [ True ] + [ False ] * ( len ( s ) - 1 ) NEW_LINE for i in range ( minJump , len ( s ) ) : NEW_LINE INDENT count += dp [ i - minJump ] NEW_LINE if i - maxJump > 0 : NEW_LINE INDENT count -= dp [ i - maxJump - 1 ] NEW_LINE DEDENT dp [ i ] = count and s [ i ] == '0' NEW_LINE DEDENT return dp [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def stoneGameVIII ( self , stones : List [ int ] ) -> int : NEW_LINE INDENT n = len ( stones ) NEW_LINE prefix = list ( itertools . accumulate ( stones ) ) NEW_LINE dp = [ - math . inf ] * n NEW_LINE dp [ n - 2 ] = prefix [ - 1 ] NEW_LINE for i in reversed ( range ( n - 2 ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i + 1 ] , prefix [ i + 1 ] - dp [ i + 1 ] ) NEW_LINE DEDENT return dp [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minProductSum ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> int : NEW_LINE INDENT return sum ( [ a * b for a , b in zip ( sorted ( nums1 ) , sorted ( nums2 , reverse = True ) ) ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countGoodSubstrings ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for a , b , c in zip ( s , s [ 1 : ] , s [ 2 : ] ) : NEW_LINE INDENT if a == b or a == c or b == c : NEW_LINE INDENT continue NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minPairSum ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT nums . sort ( ) NEW_LINE return max ( nums [ i ] + nums [ len ( nums ) - 1 - i ] for i in range ( len ( nums ) // 2 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumXORSum ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> int : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( mask : int ) -> int : NEW_LINE INDENT i = bin ( mask ) . count ( "1" ) NEW_LINE if i == len ( nums1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( ( nums1 [ i ] ^ nums2 [ j ] ) + dp ( mask | 1 << j ) for j in range ( len ( nums2 ) ) if not mask >> j & 1 ) NEW_LINE DEDENT return dp ( 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxProfit ( self , k : int , prices : List [ int ] ) -> int : NEW_LINE INDENT if k >= len ( prices ) // 2 : NEW_LINE INDENT sell = 0 NEW_LINE hold = - math . inf NEW_LINE for price in prices : NEW_LINE INDENT sell = max ( sell , hold + price ) NEW_LINE hold = max ( hold , sell - price ) NEW_LINE DEDENT return sell NEW_LINE DEDENT sell = [ 0 ] * ( k + 1 ) NEW_LINE hold = [ - math . inf ] * ( k + 1 ) NEW_LINE for price in prices : NEW_LINE INDENT for i in range ( k , 0 , - 1 ) : NEW_LINE INDENT sell [ i ] = max ( sell [ i ] , hold [ i ] + price ) NEW_LINE hold [ i ] = max ( hold [ i ] , sell [ i - 1 ] - price ) NEW_LINE DEDENT DEDENT return sell [ k ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxValue ( self , n : str , x : int ) -> str : NEW_LINE INDENT isNegative = n [ 0 ] == ' - ' NEW_LINE for i , c in enumerate ( n ) : NEW_LINE INDENT if not isNegative and ord ( c ) - ord ( '0' ) < x or isNegative and ord ( c ) - ord ( '0' ) > x : NEW_LINE INDENT return n [ : i ] + str ( x ) + n [ i : ] NEW_LINE DEDENT DEDENT return n + str ( x ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def assignTasks ( self , servers : List [ int ] , tasks : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE free = [ ] NEW_LINE used = [ ] NEW_LINE for i , weight in enumerate ( servers ) : NEW_LINE INDENT heapq . heappush ( free , ( weight , i , 0 ) ) NEW_LINE DEDENT for i , executionTime in enumerate ( tasks ) : NEW_LINE INDENT while used and used [ 0 ] [ 0 ] <= i : NEW_LINE INDENT curr = heapq . heappop ( used ) NEW_LINE heapq . heappush ( free , ( curr [ 1 ] , curr [ 2 ] , curr [ 0 ] ) ) NEW_LINE DEDENT if free : NEW_LINE INDENT curr = heapq . heappop ( free ) NEW_LINE ans . append ( curr [ 1 ] ) NEW_LINE heapq . heappush ( used , ( i + executionTime , curr [ 0 ] , curr [ 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT curr = heapq . heappop ( used ) NEW_LINE ans . append ( curr [ 2 ] ) NEW_LINE heapq . heappush ( used , ( curr [ 0 ] + executionTime , curr [ 1 ] , curr [ 2 ] ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minSkips ( self , dist : List [ int ] , speed : int , hoursBefore : int ) -> int : NEW_LINE INDENT kInf = 10 ** 7 NEW_LINE kEps = 1e-9 NEW_LINE n = len ( dist ) NEW_LINE dp = [ [ kInf ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i , d in enumerate ( dist , 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ceil ( dp [ i - 1 ] [ 0 ] + d / speed - kEps ) NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j - 1 ] + d / speed , ceil ( dp [ i - 1 ] [ j ] + d / speed - kEps ) ) NEW_LINE DEDENT DEDENT for j , time in enumerate ( dp [ - 1 ] ) : NEW_LINE INDENT if time <= hoursBefore : NEW_LINE INDENT return j NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countPairs ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE A = sorted ( [ x - y for x , y in zip ( nums1 , nums2 ) ] ) NEW_LINE for i , a in enumerate ( A ) : NEW_LINE INDENT index = bisect_left ( A , - a + 1 ) NEW_LINE ans += len ( A ) - max ( i + 1 , index ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findRotation ( self , mat : List [ List [ int ] ] , target : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT for _ in range ( 4 ) : NEW_LINE INDENT if mat == target : NEW_LINE INDENT return True NEW_LINE DEDENT mat = [ list ( x ) for x in zip ( * mat [ : : - 1 ] ) ] NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reductionOperations ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE nums . sort ( ) NEW_LINE for i in range ( len ( nums ) - 1 , 0 , - 1 ) : NEW_LINE INDENT if nums [ i ] != nums [ i - 1 ] : NEW_LINE INDENT ans += len ( nums ) - i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minFlips ( self , s : str ) -> int : NEW_LINE INDENT n = len ( s ) NEW_LINE count = [ [ 0 ] * 2 for _ in range ( 2 ) ] NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT count [ ord ( c ) - ord ( '0' ) ] [ i % 2 ] += 1 NEW_LINE DEDENT ans = min ( count [ 1 ] [ 0 ] + count [ 0 ] [ 1 ] , count [ 0 ] [ 0 ] + count [ 1 ] [ 1 ] ) NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT count [ ord ( c ) - ord ( '0' ) ] [ i % 2 ] -= 1 NEW_LINE count [ ord ( c ) - ord ( '0' ) ] [ ( n + i ) % 2 ] += 1 NEW_LINE ans = min ( ans , count [ 1 ] [ 0 ] + count [ 0 ] [ 1 ] , count [ 0 ] [ 0 ] + count [ 1 ] [ 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minWastedSpace ( self , packages : List [ int ] , boxes : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = math . inf NEW_LINE packages . sort ( ) NEW_LINE for box in boxes : NEW_LINE INDENT box . sort ( ) NEW_LINE if box [ - 1 ] < packages [ - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT accu = 0 NEW_LINE i = 0 NEW_LINE for b in box : NEW_LINE INDENT j = bisect . bisect ( packages , b , i ) NEW_LINE accu += b * ( j - i ) NEW_LINE i = j NEW_LINE DEDENT ans = min ( ans , accu ) NEW_LINE DEDENT return - 1 if ans == math . inf else ( ans - sum ( packages ) ) % int ( 1e9 + 7 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rotate ( self , nums : List [ int ] , k : int ) -> None : NEW_LINE INDENT k %= len ( nums ) NEW_LINE self . reverse ( nums , 0 , len ( nums ) - 1 ) NEW_LINE self . reverse ( nums , 0 , k - 1 ) NEW_LINE self . reverse ( nums , k , len ( nums ) - 1 ) NEW_LINE DEDENT def reverse ( self , nums : List [ int ] , l : int , r : int ) -> None : NEW_LINE INDENT while l < r : NEW_LINE INDENT nums [ l ] , nums [ r ] = nums [ r ] , nums [ l ] NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxLength ( self , ribbons : List [ int ] , k : int ) -> int : NEW_LINE INDENT def isCutPossible ( length : int ) -> bool : NEW_LINE INDENT count = 0 NEW_LINE for ribbon in ribbons : NEW_LINE INDENT count += ribbon // length NEW_LINE DEDENT return count >= k NEW_LINE DEDENT l = 1 NEW_LINE r = sum ( ribbons ) // k + 1 NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if not isCutPossible ( m ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isCovered ( self , ranges : List [ List [ int ] ] , left : int , right : int ) -> bool : NEW_LINE INDENT return all ( any ( l <= i <= r for l , r in ranges ) for i in range ( left , right + 1 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def chalkReplacer ( self , chalk : List [ int ] , k : int ) -> int : NEW_LINE INDENT k %= sum ( chalk ) NEW_LINE if k == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i , c in enumerate ( chalk ) : NEW_LINE INDENT k -= c NEW_LINE if k < 0 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def makeEqual ( self , words : List [ str ] ) -> bool : NEW_LINE INDENT return all ( c % len ( words ) == 0 for c in Counter ( ' ' . join ( words ) ) . values ( ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumRemovals ( self , s : str , p : str , removable : List [ int ] ) -> int : NEW_LINE INDENT l = 0 NEW_LINE r = len ( removable ) + 1 NEW_LINE def remove ( k : int ) -> str : NEW_LINE INDENT removed = [ c for c in s ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT removed [ removable [ i ] ] = ' * ' NEW_LINE DEDENT return ' ' . join ( removed ) NEW_LINE DEDENT def isSubsequence ( p : str , s : str ) -> bool : NEW_LINE INDENT i = 0 NEW_LINE for j , c in enumerate ( s ) : NEW_LINE INDENT if p [ i ] == s [ j ] : NEW_LINE INDENT i += 1 NEW_LINE if i == len ( p ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE removed = remove ( m ) NEW_LINE if isSubsequence ( p , removed ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return l - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mergeTriplets ( self , triplets : List [ List [ int ] ] , target : List [ int ] ) -> bool : NEW_LINE INDENT merged = [ 0 ] * len ( target ) NEW_LINE for t in triplets : NEW_LINE INDENT if all ( a <= b for a , b in zip ( t , target ) ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT merged [ i ] = max ( merged [ i ] , t [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return merged == target NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeNthFromEnd ( self , head : ListNode , n : int ) -> ListNode : NEW_LINE INDENT slow = head NEW_LINE fast = head NEW_LINE for _ in range ( n ) : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT if not fast : NEW_LINE INDENT return head . next NEW_LINE DEDENT while fast . next : NEW_LINE INDENT slow = slow . next NEW_LINE fast = fast . next NEW_LINE DEDENT slow . next = slow . next . next NEW_LINE return head NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reverseBits ( self , n : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT if n >> i & 1 : NEW_LINE INDENT ans |= 1 << 31 - i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def earliestAndLatest ( self , n : int , firstPlayer : int , secondPlayer : int ) -> List [ int ] : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( l : int , r : int , k : int ) -> List [ int ] : NEW_LINE INDENT if l == r : NEW_LINE INDENT return [ 1 , 1 ] NEW_LINE DEDENT if l > r : NEW_LINE INDENT return dp ( r , l , k ) NEW_LINE DEDENT a = math . inf NEW_LINE b = - math . inf NEW_LINE for i in range ( 1 , l + 1 ) : NEW_LINE INDENT for j in range ( l - i + 1 , r - i + 1 ) : NEW_LINE INDENT if not l + r - k // 2 <= i + j <= ( k + 1 ) // 2 : NEW_LINE INDENT continue NEW_LINE DEDENT x , y = dp ( i , j , ( k + 1 ) // 2 ) NEW_LINE a = min ( a , x + 1 ) NEW_LINE b = max ( b , y + 1 ) NEW_LINE DEDENT DEDENT return [ a , b ] NEW_LINE DEDENT return dp ( firstPlayer , n - secondPlayer + 1 , n ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findPeakGrid ( self , mat : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT l = 0 NEW_LINE r = len ( mat ) - 1 NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if max ( mat [ m ] ) >= max ( mat [ m + 1 ] ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return [ l , mat [ l ] . index ( max ( mat [ l ] ) ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestOddNumber ( self , num : str ) -> str : NEW_LINE INDENT for i , n in reversed ( list ( enumerate ( num ) ) ) : NEW_LINE INDENT if int ( n ) & 1 : NEW_LINE INDENT return num [ : i + 1 ] NEW_LINE DEDENT DEDENT return ' ' NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberOfRounds ( self , startTime : str , finishTime : str ) -> int : NEW_LINE INDENT def getMinutes ( s : str ) -> int : NEW_LINE INDENT return 60 * int ( s [ : 2 ] ) + int ( s [ 3 : ] ) NEW_LINE DEDENT start = getMinutes ( startTime ) NEW_LINE finish = getMinutes ( finishTime ) NEW_LINE if start > finish : NEW_LINE INDENT finish += 60 * 24 NEW_LINE DEDENT return max ( 0 , finish // 15 - ( start + 14 ) // 15 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countSubIslands ( self , grid1 : List [ List [ int ] ] , grid2 : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid2 ) NEW_LINE n = len ( grid2 [ 0 ] ) NEW_LINE def dfs ( i : int , j : int ) -> int : NEW_LINE INDENT if i < 0 or i == m or j < 0 or j == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if grid2 [ i ] [ j ] != 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT grid2 [ i ] [ j ] = 2 NEW_LINE return dfs ( i + 1 , j ) & dfs ( i - 1 , j ) & dfs ( i , j + 1 ) & dfs ( i , j - 1 ) & grid1 [ i ] [ j ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid2 [ i ] [ j ] == 1 : NEW_LINE INDENT ans += dfs ( i , j ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minDifference ( self , nums : List [ int ] , queries : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT numToIndices = [ [ ] for _ in range ( 101 ) ] NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT numToIndices [ num ] . append ( i ) NEW_LINE DEDENT if len ( numToIndices [ nums [ 0 ] ] ) == len ( nums ) : NEW_LINE INDENT return [ - 1 ] * len ( queries ) NEW_LINE DEDENT ans = [ ] NEW_LINE for l , r in queries : NEW_LINE INDENT prevNum = - 1 NEW_LINE minDiff = 101 NEW_LINE for num in range ( 1 , 101 ) : NEW_LINE INDENT indices = numToIndices [ num ] NEW_LINE i = bisect_left ( indices , l ) NEW_LINE if i == len ( indices ) or indices [ i ] > r : NEW_LINE INDENT continue NEW_LINE DEDENT if prevNum != - 1 : NEW_LINE INDENT minDiff = min ( minDiff , num - prevNum ) NEW_LINE DEDENT prevNum = num NEW_LINE DEDENT ans . append ( - 1 if minDiff == 101 else minDiff ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canBeIncreasing ( self , nums : List [ int ] ) -> bool : NEW_LINE INDENT removed = False NEW_LINE for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT if nums [ i - 1 ] >= nums [ i ] : NEW_LINE INDENT if removed : NEW_LINE INDENT return False NEW_LINE DEDENT removed = True NEW_LINE if i > 1 and nums [ i - 2 ] >= nums [ i ] : NEW_LINE INDENT nums [ i ] = nums [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def hammingWeight ( self , n : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT if ( n >> i ) & 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeOccurrences ( self , s : str , part : str ) -> str : NEW_LINE INDENT n = len ( s ) NEW_LINE k = len ( part ) NEW_LINE t = [ ' ▁ ' ] * n NEW_LINE j = 0 NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT t [ j ] = c NEW_LINE j += 1 NEW_LINE if j >= k and ' ' . join ( t [ j - k : j ] ) == part : NEW_LINE INDENT j -= k NEW_LINE DEDENT DEDENT return ' ' . join ( t [ : j ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxAlternatingSum ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for num in nums : NEW_LINE INDENT even = max ( even , odd + num ) NEW_LINE odd = even - num NEW_LINE DEDENT return even NEW_LINE DEDENT DEDENT
from sortedcontainers import SortedList NEW_LINE class MovieRentingSystem : NEW_LINE INDENT def __init__ ( self , n : int , entries : List [ List [ int ] ] ) : NEW_LINE INDENT self . unrented = defaultdict ( SortedList ) NEW_LINE self . shopAndMovieToPrice = { } NEW_LINE self . rented = SortedList ( ) NEW_LINE for shop , movie , price in entries : NEW_LINE INDENT self . unrented [ movie ] . add ( ( price , shop ) ) NEW_LINE self . shopAndMovieToPrice [ ( shop , movie ) ] = price NEW_LINE DEDENT DEDENT def search ( self , movie : int ) -> List [ int ] : NEW_LINE INDENT return [ shop for _ , shop in self . unrented [ movie ] [ : 5 ] ] NEW_LINE DEDENT def rent ( self , shop : int , movie : int ) -> None : NEW_LINE INDENT price = self . shopAndMovieToPrice [ ( shop , movie ) ] NEW_LINE self . unrented [ movie ] . remove ( ( price , shop ) ) NEW_LINE self . rented . add ( ( price , shop , movie ) ) NEW_LINE DEDENT def drop ( self , shop : int , movie : int ) -> None : NEW_LINE INDENT price = self . shopAndMovieToPrice [ ( shop , movie ) ] NEW_LINE self . unrented [ movie ] . add ( ( price , shop ) ) NEW_LINE self . rented . remove ( ( price , shop , movie ) ) NEW_LINE DEDENT def report ( self ) -> List [ List [ int ] ] : NEW_LINE INDENT return [ [ shop , movie ] for _ , shop , movie in self . rented [ : 5 ] ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxProductDifference ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT max1 = - math . inf NEW_LINE max2 = - math . inf NEW_LINE min1 = math . inf NEW_LINE min2 = math . inf NEW_LINE for num in nums : NEW_LINE INDENT if num > max1 : NEW_LINE INDENT max2 = max1 NEW_LINE max1 = num NEW_LINE DEDENT elif num > max2 : NEW_LINE INDENT max2 = num NEW_LINE DEDENT if num < min1 : NEW_LINE INDENT min2 = min1 NEW_LINE min1 = num NEW_LINE DEDENT elif num < min2 : NEW_LINE INDENT min2 = num NEW_LINE DEDENT DEDENT return max1 * max2 - min1 * min2 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rotateGrid ( self , grid : List [ List [ int ] ] , k : int ) -> List [ List [ int ] ] : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE t = 0 NEW_LINE l = 0 NEW_LINE b = m - 1 NEW_LINE r = n - 1 NEW_LINE while t < b and l < r : NEW_LINE INDENT elementInThisLayer = 2 * ( b - t + 1 ) + 2 * ( r - l + 1 ) - 4 NEW_LINE netRotations = k % elementInThisLayer NEW_LINE for _ in range ( netRotations ) : NEW_LINE INDENT topLeft = grid [ t ] [ l ] NEW_LINE for j in range ( l , r ) : NEW_LINE INDENT grid [ t ] [ j ] = grid [ t ] [ j + 1 ] NEW_LINE DEDENT for i in range ( t , b ) : NEW_LINE INDENT grid [ i ] [ r ] = grid [ i + 1 ] [ r ] NEW_LINE DEDENT for j in range ( r , l , - 1 ) : NEW_LINE INDENT grid [ b ] [ j ] = grid [ b ] [ j - 1 ] NEW_LINE DEDENT for i in range ( b , t , - 1 ) : NEW_LINE INDENT grid [ i ] [ l ] = grid [ i - 1 ] [ l ] NEW_LINE DEDENT grid [ t + 1 ] [ l ] = topLeft NEW_LINE DEDENT t += 1 NEW_LINE l += 1 NEW_LINE b -= 1 NEW_LINE r -= 1 NEW_LINE DEDENT return grid NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def wonderfulSubstrings ( self , word : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prefix = 0 NEW_LINE count = [ 0 ] * 1024 NEW_LINE count [ 0 ] = 1 NEW_LINE for c in word : NEW_LINE INDENT prefix ^= 1 << ord ( c ) - ord ( ' a ' ) NEW_LINE ans += count [ prefix ] NEW_LINE ans += sum ( count [ prefix ^ 1 << i ] for i in range ( 10 ) ) NEW_LINE count [ prefix ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def buildArray ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT n = len ( nums ) NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT nums [ i ] += n * ( nums [ num ] % n ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT nums [ i ] //= n NEW_LINE DEDENT return nums NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def eliminateMaximum ( self , dist : List [ int ] , speed : List [ int ] ) -> int : NEW_LINE INDENT for i , arrivalTime in enumerate ( sorted ( [ ( d - 1 ) // s for d , s in zip ( dist , speed ) ] ) ) : NEW_LINE INDENT if i > arrivalTime : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return len ( dist ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countGoodNumbers ( self , n : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE def myPow ( x : int , n : int ) -> int : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n & 1 : NEW_LINE INDENT return x * myPow ( x , n - 1 ) % kMod NEW_LINE DEDENT return myPow ( x * x % kMod , n // 2 ) NEW_LINE DEDENT return myPow ( 4 * 5 , n // 2 ) * ( 5 if n & 1 else 1 ) % kMod NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countTriples ( self , n : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE squared = set ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT squared . add ( i * i ) NEW_LINE DEDENT for a in squared : NEW_LINE INDENT for b in squared : NEW_LINE INDENT if a + b in squared : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nearestExit ( self , maze : List [ List [ str ] ] , entrance : List [ int ] ) -> int : NEW_LINE INDENT m = len ( maze ) NEW_LINE n = len ( maze [ 0 ] ) NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE ans = 0 NEW_LINE q = deque ( [ ( entrance [ 0 ] , entrance [ 1 ] ) ] ) NEW_LINE seen = { ( entrance [ 0 ] , entrance [ 1 ] ) } NEW_LINE while q : NEW_LINE INDENT ans += 1 NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT if ( x , y ) in seen or maze [ x ] [ y ] == ' + ' : NEW_LINE INDENT continue NEW_LINE DEDENT if x == 0 or x == m - 1 or y == 0 or y == n - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT q . append ( ( x , y ) ) NEW_LINE seen . add ( ( x , y ) ) NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sumGame ( self , num : str ) -> bool : NEW_LINE INDENT n = len ( num ) NEW_LINE ans = 0.0 NEW_LINE def getExpectation ( c : chr ) -> float : NEW_LINE INDENT return 4.5 if c == ' ? ' else ord ( c ) - ord ( '0' ) NEW_LINE DEDENT for i in range ( n // 2 ) : NEW_LINE INDENT ans += getExpectation ( num [ i ] ) NEW_LINE DEDENT for i in range ( n // 2 , n ) : NEW_LINE INDENT ans -= getExpectation ( num [ i ] ) NEW_LINE DEDENT return ans != 0.0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minCost ( self , maxTime : int , edges : List [ List [ int ] ] , passingFees : List [ int ] ) -> int : NEW_LINE INDENT n = len ( passingFees ) NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE minHeap = [ ] NEW_LINE cost = [ math . inf ] * n NEW_LINE time = [ math . inf ] * n NEW_LINE for x , y , t in edges : NEW_LINE INDENT graph [ x ] . append ( ( y , t ) ) NEW_LINE graph [ y ] . append ( ( x , t ) ) NEW_LINE DEDENT heapq . heappush ( minHeap , ( passingFees [ 0 ] , 0 , 0 ) ) NEW_LINE cost [ 0 ] = passingFees [ 0 ] NEW_LINE time [ 0 ] = 0 NEW_LINE while minHeap : NEW_LINE INDENT currCost , currTime , x = heapq . heappop ( minHeap ) NEW_LINE for y , pathTime in graph [ x ] : NEW_LINE INDENT if currTime + pathTime <= maxTime : NEW_LINE INDENT newCost = currCost + passingFees [ y ] NEW_LINE newTime = currTime + pathTime NEW_LINE if cost [ y ] > newCost : NEW_LINE INDENT cost [ y ] = newCost NEW_LINE time [ y ] = newTime NEW_LINE heapq . heappush ( minHeap , ( newCost , newTime , y ) ) NEW_LINE DEDENT elif time [ y ] > newTime : NEW_LINE INDENT time [ y ] = newTime NEW_LINE heapq . heappush ( minHeap , ( newCost , newTime , y ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return - 1 if cost [ - 1 ] == math . inf else cost [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getConcatenation ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT return nums * 2 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countPalindromicSubsequence ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE first = [ len ( s ) ] * 26 NEW_LINE last = [ 0 ] * 26 NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT index = ord ( c ) - ord ( ' a ' ) NEW_LINE first [ index ] = min ( first [ index ] , i ) NEW_LINE last [ index ] = i NEW_LINE DEDENT for f , l in zip ( first , last ) : NEW_LINE INDENT if f < l : NEW_LINE INDENT ans += len ( set ( s [ f + 1 : l ] ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def colorTheGrid ( self , m : int , n : int ) -> int : NEW_LINE INDENT def getColor ( mask : int , r : int ) -> int : NEW_LINE INDENT return mask >> r * 2 & 3 NEW_LINE DEDENT def setColor ( mask : int , r : int , color : int ) -> int : NEW_LINE INDENT return mask | color << r * 2 NEW_LINE DEDENT kMod = 1_000_000_007 NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( r : int , c : int , prevColMask : int , currColMask : int ) -> int : NEW_LINE INDENT if c == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if r == m : NEW_LINE INDENT return dp ( 0 , c + 1 , currColMask , 0 ) NEW_LINE DEDENT ans = 0 NEW_LINE for color in range ( 1 , 4 ) : NEW_LINE INDENT if getColor ( prevColMask , r ) == color : NEW_LINE INDENT continue NEW_LINE DEDENT if r > 0 and getColor ( currColMask , r - 1 ) == color : NEW_LINE INDENT continue NEW_LINE DEDENT ans += dp ( r + 1 , c , prevColMask , setColor ( currColMask , r , color ) ) NEW_LINE ans %= kMod NEW_LINE DEDENT return ans NEW_LINE DEDENT return dp ( 0 , 0 , 0 , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canMerge ( self , trees : List [ TreeNode ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT valToNode = { } NEW_LINE count = Counter ( ) NEW_LINE for tree in trees : NEW_LINE INDENT valToNode [ tree . val ] = tree NEW_LINE count [ tree . val ] += 1 NEW_LINE if tree . left : NEW_LINE INDENT count [ tree . left . val ] += 1 NEW_LINE DEDENT if tree . right : NEW_LINE INDENT count [ tree . right . val ] += 1 NEW_LINE DEDENT DEDENT def isValidBST ( tree : Optional [ TreeNode ] , minNode : Optional [ TreeNode ] , maxNode : Optional [ TreeNode ] ) -> bool : NEW_LINE INDENT if not tree : NEW_LINE INDENT return True NEW_LINE DEDENT if minNode and tree . val <= minNode . val : NEW_LINE INDENT return False NEW_LINE DEDENT if maxNode and tree . val >= maxNode . val : NEW_LINE INDENT return False NEW_LINE DEDENT if not tree . left and not tree . right and tree . val in valToNode : NEW_LINE INDENT val = tree . val NEW_LINE tree . left = valToNode [ val ] . left NEW_LINE tree . right = valToNode [ val ] . right NEW_LINE del valToNode [ val ] NEW_LINE DEDENT return isValidBST ( tree . left , minNode , tree ) and isValidBST ( tree . right , tree , maxNode ) NEW_LINE DEDENT for tree in trees : NEW_LINE INDENT if count [ tree . val ] == 1 : NEW_LINE INDENT if isValidBST ( tree , None , None ) and len ( valToNode ) <= 1 : NEW_LINE INDENT return tree NEW_LINE DEDENT return None NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canBeTypedWords ( self , text : str , brokenLetters : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE broken = set ( brokenLetters ) NEW_LINE for word in text . split ( ) : NEW_LINE INDENT ans += all ( c not in broken for c in word ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def addRungs ( self , rungs : List [ int ] , dist : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prev = 0 NEW_LINE for rung in rungs : NEW_LINE INDENT ans += ( rung - prev - 1 ) // dist NEW_LINE prev = rung NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxPoints ( self , points : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( points [ 0 ] ) NEW_LINE dp = [ 0 ] * n NEW_LINE for row in points : NEW_LINE INDENT leftToRight = [ 0 ] * n NEW_LINE runningMax = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT runningMax = max ( runningMax - 1 , dp [ j ] ) NEW_LINE leftToRight [ j ] = runningMax NEW_LINE DEDENT rightToLeft = [ 0 ] * n NEW_LINE runningMax = 0 NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT runningMax = max ( runningMax - 1 , dp [ j ] ) NEW_LINE rightToLeft [ j ] = runningMax NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT dp [ j ] = max ( leftToRight [ j ] , rightToLeft [ j ] ) + row [ j ] NEW_LINE DEDENT DEDENT return max ( dp ) NEW_LINE DEDENT DEDENT
class TrieNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . children = [ None ] * 2 NEW_LINE self . count = 0 NEW_LINE DEDENT DEDENT class Trie : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . root = TrieNode ( ) NEW_LINE self . kHeight = 17 NEW_LINE DEDENT def update ( self , num : int , val : int ) -> None : NEW_LINE INDENT node = self . root NEW_LINE for i in range ( self . kHeight , - 1 , - 1 ) : NEW_LINE INDENT bit = ( num >> i ) & 1 NEW_LINE if not node . children [ bit ] : NEW_LINE INDENT node . children [ bit ] = TrieNode ( ) NEW_LINE DEDENT node = node . children [ bit ] NEW_LINE node . count += val NEW_LINE DEDENT DEDENT def query ( self , num : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE node = self . root NEW_LINE for i in range ( self . kHeight , - 1 , - 1 ) : NEW_LINE INDENT bit = ( num >> i ) & 1 NEW_LINE targetBit = bit ^ 1 NEW_LINE if node . children [ targetBit ] and node . children [ targetBit ] . count > 0 : NEW_LINE INDENT ans += 1 << i NEW_LINE node = node . children [ targetBit ] NEW_LINE DEDENT else : NEW_LINE INDENT node = node . children [ targetBit ^ 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def maxGeneticDifference ( self , parents : List [ int ] , queries : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT n = len ( parents ) NEW_LINE ans = [ 0 ] * len ( queries ) NEW_LINE rootVal = - 1 NEW_LINE tree = [ [ ] for _ in range ( n ) ] NEW_LINE nodeToQueries = defaultdict ( list ) NEW_LINE trie = Trie ( ) NEW_LINE for i , parent in enumerate ( parents ) : NEW_LINE INDENT if parent == - 1 : NEW_LINE INDENT rootVal = i NEW_LINE DEDENT else : NEW_LINE INDENT tree [ parent ] . append ( i ) NEW_LINE DEDENT DEDENT for i , ( node , val ) in enumerate ( queries ) : NEW_LINE INDENT nodeToQueries [ node ] . append ( ( i , val ) ) NEW_LINE DEDENT def dfs ( node : int ) -> None : NEW_LINE INDENT trie . update ( node , 1 ) NEW_LINE for i , val in nodeToQueries [ node ] : NEW_LINE INDENT ans [ i ] = trie . query ( val ) NEW_LINE DEDENT for child in tree [ node ] : NEW_LINE INDENT dfs ( child ) NEW_LINE DEDENT trie . update ( node , - 1 ) NEW_LINE DEDENT dfs ( rootVal ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canSeePersonsCount ( self , heights : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * len ( heights ) NEW_LINE stack = [ ] NEW_LINE for i , height in enumerate ( heights ) : NEW_LINE INDENT while stack and heights [ stack [ - 1 ] ] <= height : NEW_LINE INDENT ans [ stack . pop ( ) ] += 1 NEW_LINE DEDENT if stack : NEW_LINE INDENT ans [ stack [ - 1 ] ] += 1 NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class TrieNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . children : Dict [ str , TrieNode ] = defaultdict ( TrieNode ) NEW_LINE self . deleted = False NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def deleteDuplicateFolder ( self , paths : List [ List [ str ] ] ) -> List [ List [ str ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE root = TrieNode ( ) NEW_LINE subtreeToNodes : Dict [ str , List [ TrieNode ] ] = defaultdict ( list ) NEW_LINE for path in sorted ( paths ) : NEW_LINE INDENT node = root NEW_LINE for s in path : NEW_LINE INDENT node = node . children [ s ] NEW_LINE DEDENT DEDENT def buildSubtreeToRoots ( node : TrieNode ) -> str : NEW_LINE INDENT subtree = ' ( ' + ' ' . join ( s + buildSubtreeToRoots ( node . children [ s ] ) for s in node . children ) + ' ) ' NEW_LINE if subtree != ' ( ) ' : NEW_LINE INDENT subtreeToNodes [ subtree ] . append ( node ) NEW_LINE DEDENT return subtree NEW_LINE DEDENT buildSubtreeToRoots ( root ) NEW_LINE for nodes in subtreeToNodes . values ( ) : NEW_LINE INDENT if len ( nodes ) > 1 : NEW_LINE INDENT for node in nodes : NEW_LINE INDENT node . deleted = True NEW_LINE DEDENT DEDENT DEDENT def constructPath ( node : TrieNode , path : List [ str ] ) -> None : NEW_LINE INDENT for s , child in node . children . items ( ) : NEW_LINE INDENT if not child . deleted : NEW_LINE INDENT constructPath ( child , path + [ s ] ) NEW_LINE DEDENT DEDENT if path : NEW_LINE INDENT ans . append ( path ) NEW_LINE DEDENT DEDENT constructPath ( root , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countSpecialSubsequences ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int , prev : int ) -> int : NEW_LINE INDENT if i == len ( nums ) : NEW_LINE INDENT return prev == 2 NEW_LINE DEDENT ans = 0 NEW_LINE ans += dp ( i + 1 , prev ) NEW_LINE if nums [ i ] == prev : NEW_LINE INDENT ans += dp ( i + 1 , prev ) NEW_LINE DEDENT if prev == - 1 and nums [ i ] == 0 : NEW_LINE INDENT ans += dp ( i + 1 , 0 ) NEW_LINE DEDENT if prev == 0 and nums [ i ] == 1 : NEW_LINE INDENT ans += dp ( i + 1 , 1 ) NEW_LINE DEDENT if prev == 1 and nums [ i ] == 2 : NEW_LINE INDENT ans += dp ( i + 1 , 2 ) NEW_LINE DEDENT ans %= kMod NEW_LINE return ans NEW_LINE DEDENT return dp ( 0 , - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxProduct ( self , s : str ) -> int : NEW_LINE INDENT n = len ( s ) NEW_LINE def manacher ( s : str ) -> List [ int ] : NEW_LINE INDENT maxExtends = [ 0 ] * n NEW_LINE l2r = [ 1 ] * n NEW_LINE center = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r = center + maxExtends [ center ] - 1 NEW_LINE mirrorIndex = center - ( i - center ) NEW_LINE extend = 1 if i > r else min ( maxExtends [ mirrorIndex ] , r - i + 1 ) NEW_LINE while i - extend >= 0 and i + extend < n and s [ i - extend ] == s [ i + extend ] : NEW_LINE INDENT l2r [ i + extend ] = 2 * extend + 1 NEW_LINE extend += 1 NEW_LINE DEDENT maxExtends [ i ] = extend NEW_LINE if i + maxExtends [ i ] >= r : NEW_LINE INDENT center = i NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT l2r [ i ] = max ( l2r [ i ] , l2r [ i - 1 ] ) NEW_LINE DEDENT return l2r NEW_LINE DEDENT l = manacher ( s ) NEW_LINE r = manacher ( s [ : : - 1 ] ) [ : : - 1 ] NEW_LINE return max ( l [ i ] * r [ i + 1 ] for i in range ( n - 1 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestObstacleCourseAtEachPosition ( self , obstacles : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE tail = [ ] NEW_LINE for obstacle in obstacles : NEW_LINE INDENT if not tail or obstacle >= tail [ - 1 ] : NEW_LINE INDENT tail . append ( obstacle ) NEW_LINE ans . append ( len ( tail ) ) NEW_LINE DEDENT else : NEW_LINE INDENT index = bisect_right ( tail , obstacle ) NEW_LINE tail [ index ] = obstacle NEW_LINE ans . append ( index + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def latestDayToCross ( self , row : int , col : int , cells : List [ List [ int ] ] ) -> int : NEW_LINE INDENT dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE def canWalk ( day : int ) -> bool : NEW_LINE INDENT matrix = [ [ 0 ] * col for _ in range ( row ) ] NEW_LINE for i in range ( day ) : NEW_LINE INDENT x , y = cells [ i ] NEW_LINE matrix [ x - 1 ] [ y - 1 ] = 1 NEW_LINE DEDENT q = deque ( ) NEW_LINE for j in range ( col ) : NEW_LINE INDENT if matrix [ 0 ] [ j ] == 0 : NEW_LINE INDENT q . append ( ( 0 , j ) ) NEW_LINE matrix [ 0 ] [ j ] = 1 NEW_LINE DEDENT DEDENT while q : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == row or y < 0 or y == col : NEW_LINE INDENT continue NEW_LINE DEDENT if matrix [ x ] [ y ] == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if x == row - 1 : NEW_LINE INDENT return True NEW_LINE DEDENT q . append ( ( x , y ) ) NEW_LINE matrix [ x ] [ y ] = 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT ans = 0 NEW_LINE l = 1 NEW_LINE r = len ( cells ) - 1 NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if canWalk ( m ) : NEW_LINE INDENT ans = m NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rob ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT if not nums : NEW_LINE INDENT return 0 NEW_LINE DEDENT if len ( nums ) == 1 : NEW_LINE INDENT return nums [ 0 ] NEW_LINE DEDENT dp = [ 0 ] * len ( nums ) NEW_LINE dp [ 0 ] = nums [ 0 ] NEW_LINE dp [ 1 ] = max ( nums [ 0 ] , nums [ 1 ] ) NEW_LINE for i in range ( 2 , len ( nums ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + nums [ i ] ) NEW_LINE DEDENT return dp [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rightSideView ( self , root : Optional [ TreeNode ] ) -> List [ int ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return [ ] NEW_LINE DEDENT ans = [ ] NEW_LINE q = deque ( [ root ] ) NEW_LINE while q : NEW_LINE INDENT size = len ( q ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT root = q . popleft ( ) NEW_LINE if i == size - 1 : NEW_LINE INDENT ans . append ( root . val ) NEW_LINE DEDENT if root . left : NEW_LINE INDENT q . append ( root . left ) NEW_LINE DEDENT if root . right : NEW_LINE INDENT q . append ( root . right ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : NEW_LINE INDENT dummy = ListNode ( 0 ) NEW_LINE curr = dummy NEW_LINE carry = 0 NEW_LINE while carry or l1 or l2 : NEW_LINE INDENT if l1 : NEW_LINE INDENT carry += l1 . val NEW_LINE l1 = l1 . next NEW_LINE DEDENT if l2 : NEW_LINE INDENT carry += l2 . val NEW_LINE l2 = l2 . next NEW_LINE DEDENT curr . next = ListNode ( carry % 10 ) NEW_LINE carry //= 10 NEW_LINE curr = curr . next NEW_LINE DEDENT return dummy . next NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isValid ( self , s : str ) -> bool : NEW_LINE INDENT stack = [ ] NEW_LINE for c in s : NEW_LINE INDENT if c == ' ( ' : NEW_LINE INDENT stack . append ( ' ) ' ) NEW_LINE DEDENT elif c == ' { ' : NEW_LINE INDENT stack . append ( ' } ' ) NEW_LINE DEDENT elif c == ' [ ' : NEW_LINE INDENT stack . append ( ' ] ' ) NEW_LINE DEDENT elif not stack or stack . pop ( ) != c : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return not stack NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numIslands ( self , grid : List [ List [ str ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE def bfs ( r , c ) : NEW_LINE INDENT q = deque ( [ ( r , c ) ] ) NEW_LINE grid [ r ] [ c ] = '2' NEW_LINE while q : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT if grid [ x ] [ y ] != '1' : NEW_LINE INDENT continue NEW_LINE DEDENT q . append ( ( x , y ) ) NEW_LINE grid [ x ] [ y ] = '2' NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] == '1' : NEW_LINE INDENT bfs ( i , j ) NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reversePrefix ( self , word : str , ch : str ) -> str : NEW_LINE INDENT i = word . find ( ch ) + 1 NEW_LINE return word [ : i ] [ : : - 1 ] + word [ i : ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def interchangeableRectangles ( self , rectangles : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ratioCount = Counter ( ) NEW_LINE for width , height in rectangles : NEW_LINE INDENT ratioCount [ width / height ] += 1 NEW_LINE DEDENT return sum ( c * ( c - 1 ) // 2 for c in ratioCount . values ( ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxProduct ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE def isPalindrome ( s : str ) -> bool : NEW_LINE INDENT i = 0 NEW_LINE j = len ( s ) - 1 NEW_LINE while i < j : NEW_LINE INDENT if s [ i ] != s [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT @ functools . lru_cache ( None ) NEW_LINE def dfs ( i : int , s1 : str , s2 : str ) -> None : NEW_LINE INDENT nonlocal ans NEW_LINE if i == len ( s ) : NEW_LINE INDENT if isPalindrome ( s1 ) and isPalindrome ( s2 ) : NEW_LINE INDENT ans = max ( ans , len ( s1 ) * len ( s2 ) ) NEW_LINE DEDENT return NEW_LINE DEDENT dfs ( i + 1 , s1 + s [ i ] , s2 ) NEW_LINE dfs ( i + 1 , s1 , s2 + s [ i ] ) NEW_LINE dfs ( i + 1 , s1 , s2 ) NEW_LINE DEDENT dfs ( 0 , ' ' , ' ' ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestMissingValueSubtree ( self , parents : List [ int ] , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT n = len ( parents ) NEW_LINE ans = [ 1 ] * n NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE seen = set ( ) NEW_LINE minMiss = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT graph [ parents [ i ] ] . append ( i ) NEW_LINE DEDENT def getNode ( nums : List [ int ] ) -> int : NEW_LINE INDENT for i , num in enumerate ( nums ) : NEW_LINE INDENT if num == 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT nodeThatsOne = getNode ( nums ) NEW_LINE if nodeThatsOne == - 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT u = nodeThatsOne NEW_LINE prev = - 1 NEW_LINE def dfs ( u : int ) -> None : NEW_LINE INDENT seen . add ( nums [ u ] ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT dfs ( v ) NEW_LINE DEDENT DEDENT while u != - 1 : NEW_LINE INDENT for v in graph [ u ] : NEW_LINE INDENT if v == prev : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( v ) NEW_LINE DEDENT seen . add ( nums [ u ] ) NEW_LINE while minMiss in seen : NEW_LINE INDENT minMiss += 1 NEW_LINE DEDENT ans [ u ] = minMiss NEW_LINE prev = u NEW_LINE u = parents [ u ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findGameWinner ( self , n : int ) -> bool : NEW_LINE INDENT return n % 6 != 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countKDifference ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT count = Counter ( nums ) NEW_LINE return sum ( count [ i ] * count [ i - k ] for i in range ( k + 1 , 101 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findOriginalArray ( self , changed : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE q = deque ( ) NEW_LINE for num in sorted ( changed ) : NEW_LINE INDENT if q and num == q [ 0 ] : NEW_LINE INDENT q . popleft ( ) NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( num * 2 ) NEW_LINE ans . append ( num ) NEW_LINE DEDENT DEDENT return [ ] if q else ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxTaxiEarnings ( self , n : int , rides : List [ List [ int ] ] ) -> int : NEW_LINE INDENT startToEndAndEarns = [ [ ] for _ in range ( n ) ] NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE for start , end , tip in rides : NEW_LINE INDENT earn = end - start + tip NEW_LINE startToEndAndEarns [ start ] . append ( ( end , earn ) ) NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i + 1 ] NEW_LINE for end , earn in startToEndAndEarns [ i ] : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ end ] + earn ) NEW_LINE DEDENT DEDENT return dp [ 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minOperations ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE ans = n NEW_LINE nums = sorted ( set ( nums ) ) NEW_LINE for i , start in enumerate ( nums ) : NEW_LINE INDENT end = start + n - 1 NEW_LINE index = bisect_right ( nums , end ) NEW_LINE uniqueLength = index - i NEW_LINE ans = min ( ans , n - uniqueLength ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rangeBitwiseAnd ( self , m : int , n : int ) -> int : NEW_LINE INDENT return self . rangeBitwiseAnd ( m >> 1 , n >> 1 ) << 1 if m < n else m NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def finalValueAfterOperations ( self , operations : List [ str ] ) -> int : NEW_LINE INDENT return sum ( op [ 1 ] == ' + ' or - 1 for op in operations ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sumOfBeauties ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE ans = 0 NEW_LINE minOfRight = [ 0 ] * ( n - 1 ) + [ nums [ - 1 ] ] NEW_LINE for i in range ( n - 2 , 1 , - 1 ) : NEW_LINE INDENT minOfRight [ i ] = min ( nums [ i ] , minOfRight [ i + 1 ] ) NEW_LINE DEDENT maxOfLeft = nums [ 0 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if maxOfLeft < nums [ i ] < minOfRight [ i + 1 ] : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT elif nums [ i - 1 ] < nums [ i ] < nums [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT maxOfLeft = max ( maxOfLeft , nums [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class DetectSquares : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . pointCount = Counter ( ) NEW_LINE DEDENT def add ( self , point : List [ int ] ) -> None : NEW_LINE INDENT self . pointCount [ tuple ( point ) ] += 1 NEW_LINE DEDENT def count ( self , point : List [ int ] ) -> int : NEW_LINE INDENT x1 , y1 = point NEW_LINE ans = 0 NEW_LINE for ( x3 , y3 ) , c in self . pointCount . items ( ) : NEW_LINE INDENT if x1 != x3 and abs ( x1 - x3 ) == abs ( y1 - y3 ) : NEW_LINE INDENT ans += c * self . pointCount [ ( x1 , y3 ) ] * self . pointCount [ ( x3 , y1 ) ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestSubsequenceRepeatedK ( self , s : str , k : int ) -> str : NEW_LINE INDENT ans = ' ' NEW_LINE count = [ 0 ] * 26 NEW_LINE possibleChars = [ ] NEW_LINE q = deque ( [ ' ' ] ) NEW_LINE for c in s : NEW_LINE INDENT count [ ord ( c ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for c in string . ascii_lowercase : NEW_LINE INDENT if count [ ord ( c ) - ord ( ' a ' ) ] >= k : NEW_LINE INDENT possibleChars . append ( c ) NEW_LINE DEDENT DEDENT def isSubsequence ( subseq : str , s : str , k : int ) -> bool : NEW_LINE INDENT i = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == subseq [ i ] : NEW_LINE INDENT i += 1 NEW_LINE if i == len ( subseq ) : NEW_LINE INDENT k -= 1 NEW_LINE if k == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT i = 0 NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT while q : NEW_LINE INDENT currSubseq = q . popleft ( ) NEW_LINE if len ( currSubseq ) * k > len ( s ) : NEW_LINE INDENT return ans NEW_LINE DEDENT for c in possibleChars : NEW_LINE INDENT newSubseq = currSubseq + c NEW_LINE if isSubsequence ( newSubseq , s , k ) : NEW_LINE INDENT q . append ( newSubseq ) NEW_LINE ans = newSubseq NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def averageHeightOfBuildings ( self , buildings : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE events = [ ] NEW_LINE for start , end , height in buildings : NEW_LINE INDENT events . append ( ( start , height ) ) NEW_LINE events . append ( ( end , - height ) ) NEW_LINE DEDENT prev = 0 NEW_LINE count = 0 NEW_LINE sumHeight = 0 NEW_LINE for curr , h in sorted ( events ) : NEW_LINE INDENT height = abs ( h ) NEW_LINE if sumHeight > 0 and curr > prev : NEW_LINE INDENT avgHeight = sumHeight // count NEW_LINE if ans and ans [ - 1 ] [ 1 ] == prev and avgHeight == ans [ - 1 ] [ 2 ] : NEW_LINE INDENT ans [ - 1 ] [ 1 ] = curr NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( [ prev , curr , avgHeight ] ) NEW_LINE DEDENT DEDENT sumHeight += h NEW_LINE count += 1 if h > 0 else - 1 NEW_LINE prev = curr NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumDifference ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = - 1 NEW_LINE mini = nums [ 0 ] NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT if nums [ i ] > mini : NEW_LINE INDENT ans = max ( ans , nums [ i ] - mini ) NEW_LINE DEDENT mini = min ( mini , nums [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def gridGame ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( grid [ 0 ] ) NEW_LINE ans = math . inf NEW_LINE sumRow0 = sum ( grid [ 0 ] ) NEW_LINE sumRow1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sumRow0 -= grid [ 0 ] [ i ] NEW_LINE ans = min ( ans , max ( sumRow0 , sumRow1 ) ) NEW_LINE sumRow1 += grid [ 1 ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def placeWordInCrossword ( self , board : List [ List [ str ] ] , word : str ) -> bool : NEW_LINE INDENT for x in board , zip ( * board ) : NEW_LINE INDENT for row in x : NEW_LINE INDENT for token in ' ' . join ( row ) . split ( ' # ' ) : NEW_LINE INDENT for letters in word , word [ : : - 1 ] : NEW_LINE INDENT if len ( token ) == len ( letters ) : NEW_LINE INDENT if all ( c in ( ' ▁ ' , letter ) for c , letter in zip ( token , letters ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def scoreOfStudents ( self , s : str , answers : List [ int ] ) -> int : NEW_LINE INDENT n = len ( s ) // 2 + 1 NEW_LINE ans = 0 NEW_LINE func = { ' + ' : operator . add , ' * ' : operator . mul } NEW_LINE dp = [ [ set ( ) for j in range ( n ) ] for _ in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] [ i ] . add ( int ( s [ i * 2 ] ) ) NEW_LINE DEDENT for d in range ( 1 , n ) : NEW_LINE INDENT for i in range ( n - d ) : NEW_LINE INDENT j = i + d NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT op = s [ k * 2 + 1 ] NEW_LINE for a in dp [ i ] [ k ] : NEW_LINE INDENT for b in dp [ k + 1 ] [ j ] : NEW_LINE INDENT res = func [ op ] ( a , b ) NEW_LINE if res <= 1000 : NEW_LINE INDENT dp [ i ] [ j ] . add ( res ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT correctAnswer = eval ( s ) NEW_LINE for answer , freq in Counter ( answers ) . items ( ) : NEW_LINE INDENT if answer == correctAnswer : NEW_LINE INDENT ans += 5 * freq NEW_LINE DEDENT elif answer in dp [ 0 ] [ n - 1 ] : NEW_LINE INDENT ans += 2 * freq NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isHappy ( self , n : int ) -> bool : NEW_LINE INDENT def squaredSum ( n : int ) -> bool : NEW_LINE INDENT summ = 0 NEW_LINE while n : NEW_LINE INDENT summ += pow ( n % 10 , 2 ) NEW_LINE n //= 10 NEW_LINE DEDENT return summ NEW_LINE DEDENT slow = squaredSum ( n ) NEW_LINE fast = squaredSum ( squaredSum ( n ) ) NEW_LINE while slow != fast : NEW_LINE INDENT slow = squaredSum ( slow ) NEW_LINE fast = squaredSum ( squaredSum ( fast ) ) NEW_LINE DEDENT return slow == 1 NEW_LINE DEDENT DEDENT
from sortedcontainers import SortedDict NEW_LINE class Solution : NEW_LINE INDENT def brightestPosition ( self , lights : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = math . inf NEW_LINE maxBrightness = - 1 NEW_LINE currBrightness = 0 NEW_LINE timeline = SortedDict ( ) NEW_LINE for position , rg in lights : NEW_LINE INDENT start = position - rg NEW_LINE end = position + rg + 1 NEW_LINE timeline [ start ] = timeline . get ( start , 0 ) + 1 NEW_LINE timeline [ end ] = timeline . get ( end , 0 ) - 1 NEW_LINE DEDENT for pos , brightness in timeline . items ( ) : NEW_LINE INDENT currBrightness += brightness NEW_LINE if currBrightness > maxBrightness : NEW_LINE INDENT maxBrightness = currBrightness NEW_LINE ans = pos NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def construct2DArray ( self , original : List [ int ] , m : int , n : int ) -> List [ List [ int ] ] : NEW_LINE INDENT if len ( original ) != m * n : NEW_LINE INDENT return [ ] NEW_LINE DEDENT ans = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE for i , num in enumerate ( original ) : NEW_LINE INDENT ans [ i // n ] [ i % n ] = num NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numOfPairs ( self , nums : List [ str ] , target : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = Counter ( ) NEW_LINE for num in nums : NEW_LINE INDENT k = len ( num ) NEW_LINE if target [ : k ] == num : NEW_LINE INDENT ans += count [ target [ k : ] ] NEW_LINE DEDENT if target [ - k : ] == num : NEW_LINE INDENT ans += count [ target [ : - k ] ] NEW_LINE DEDENT count [ num ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxConsecutiveAnswers ( self , answerKey : str , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE maxCount = 0 NEW_LINE count = Counter ( ) NEW_LINE l = 0 NEW_LINE for r , c in enumerate ( answerKey ) : NEW_LINE INDENT count [ c == ' T ' ] += 1 NEW_LINE maxCount = max ( maxCount , count [ c == ' T ' ] ) NEW_LINE while maxCount + k < r - l + 1 : NEW_LINE INDENT count [ answerKey [ l ] == ' T ' ] -= 1 NEW_LINE l += 1 NEW_LINE DEDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def waysToPartition ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE summ = sum ( nums ) NEW_LINE prefix = 0 NEW_LINE l = Counter ( ) NEW_LINE r = Counter ( ) NEW_LINE for pivot in range ( 1 , n ) : NEW_LINE INDENT prefix += nums [ pivot - 1 ] NEW_LINE suffix = summ - prefix NEW_LINE r [ prefix - suffix ] += 1 NEW_LINE DEDENT ans = r [ 0 ] NEW_LINE prefix = 0 NEW_LINE for num in nums : NEW_LINE INDENT ans = max ( ans , l [ k - num ] + r [ num - k ] ) NEW_LINE prefix += num NEW_LINE suffix = summ - prefix NEW_LINE diff = prefix - suffix NEW_LINE r [ diff ] -= 1 NEW_LINE l [ diff ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def missingRolls ( self , rolls : List [ int ] , mean : int , n : int ) -> List [ int ] : NEW_LINE INDENT targetSum = ( len ( rolls ) + n ) * mean NEW_LINE missingSum = targetSum - sum ( rolls ) NEW_LINE if missingSum > n * 6 or missingSum < n : NEW_LINE INDENT return [ ] NEW_LINE DEDENT ans = [ missingSum // n ] * n NEW_LINE for i in range ( missingSum % n ) : NEW_LINE INDENT ans [ i ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def stoneGameIX ( self , stones : List [ int ] ) -> bool : NEW_LINE INDENT count = Counter ( stone % 3 for stone in stones ) NEW_LINE if count [ 0 ] % 2 == 0 : NEW_LINE INDENT return min ( count [ 1 ] , count [ 2 ] ) > 0 NEW_LINE DEDENT return abs ( count [ 1 ] - count [ 2 ] ) > 2 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeElements ( self , head : ListNode , val : int ) -> ListNode : NEW_LINE INDENT dummy = ListNode ( 0 , head ) NEW_LINE prev = dummy NEW_LINE while head : NEW_LINE INDENT if head . val != val : NEW_LINE INDENT prev . next = head NEW_LINE prev = prev . next NEW_LINE DEDENT head = head . next NEW_LINE DEDENT prev . next = None NEW_LINE return dummy . next NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestSubsequence ( self , s : str , k : int , letter : str , repetition : int ) -> str : NEW_LINE INDENT stack = [ ] NEW_LINE required = repetition NEW_LINE nLetters = s . count ( letter ) NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT while stack and stack [ - 1 ] > c and len ( stack ) + len ( s ) - i - 1 >= k and ( stack [ - 1 ] != letter or nLetters > required ) : NEW_LINE INDENT if stack . pop ( ) == letter : NEW_LINE INDENT required += 1 NEW_LINE DEDENT DEDENT if len ( stack ) < k : NEW_LINE INDENT if c == letter : NEW_LINE INDENT stack . append ( c ) NEW_LINE required -= 1 NEW_LINE DEDENT elif k - len ( stack ) > required : NEW_LINE INDENT stack . append ( c ) NEW_LINE DEDENT DEDENT if c == letter : NEW_LINE INDENT nLetters -= 1 NEW_LINE DEDENT DEDENT return ' ' . join ( stack ) NEW_LINE DEDENT DEDENT
class FenwichTree : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . n = n NEW_LINE self . sums = [ 0 ] * ( 2 * n + 1 ) NEW_LINE DEDENT def update ( self , i : int , delta : int ) -> None : NEW_LINE INDENT i += self . n + 1 NEW_LINE while i < len ( self . sums ) : NEW_LINE INDENT self . sums [ i ] += delta NEW_LINE i += i & - i NEW_LINE DEDENT DEDENT def get ( self , i : int ) -> int : NEW_LINE INDENT i += self . n + 1 NEW_LINE summ = 0 NEW_LINE while i > 0 : NEW_LINE INDENT summ += self . sums [ i ] NEW_LINE i -= i & - i NEW_LINE DEDENT return summ NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def subarraysWithMoreZerosThanOnes ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE ans = 0 NEW_LINE prefix = 0 NEW_LINE tree = FenwichTree ( len ( nums ) ) NEW_LINE tree . update ( 0 , 1 ) NEW_LINE for num in nums : NEW_LINE INDENT prefix += - 1 if num == 0 else 1 NEW_LINE ans += tree . get ( prefix - 1 ) NEW_LINE ans %= kMod NEW_LINE tree . update ( prefix , 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def twoOutOfThree ( self , nums1 : List [ int ] , nums2 : List [ int ] , nums3 : List [ int ] ) -> List [ int ] : NEW_LINE INDENT count = Counter ( ) NEW_LINE for nums in nums1 , nums2 , nums3 : NEW_LINE INDENT count . update ( set ( nums ) ) NEW_LINE DEDENT return [ i for i , c in count . items ( ) if c >= 2 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minOperations ( self , grid : List [ List [ int ] ] , x : int ) -> int : NEW_LINE INDENT A = sorted ( [ a for row in grid for a in row ] ) NEW_LINE if any ( ( a - A [ 0 ] ) % x for a in A ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = 0 NEW_LINE for a in A : NEW_LINE INDENT ans += abs ( a - A [ len ( A ) // 2 ] ) // x NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
from sortedcontainers import SortedDict NEW_LINE class StockPrice : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . timestampToPrice = SortedDict ( ) NEW_LINE self . pricesCount = SortedDict ( ) NEW_LINE DEDENT def update ( self , timestamp : int , price : int ) -> None : NEW_LINE INDENT if timestamp in self . timestampToPrice : NEW_LINE INDENT prevPrice = self . timestampToPrice [ timestamp ] NEW_LINE self . pricesCount [ prevPrice ] -= 1 NEW_LINE if self . pricesCount [ prevPrice ] == 0 : NEW_LINE INDENT del self . pricesCount [ prevPrice ] NEW_LINE DEDENT DEDENT self . timestampToPrice [ timestamp ] = price NEW_LINE self . pricesCount [ price ] = self . pricesCount . get ( price , 0 ) + 1 NEW_LINE DEDENT def current ( self ) -> int : NEW_LINE INDENT return self . timestampToPrice . peekitem ( - 1 ) [ 1 ] NEW_LINE DEDENT def maximum ( self ) -> int : NEW_LINE INDENT return self . pricesCount . peekitem ( - 1 ) [ 0 ] NEW_LINE DEDENT def minimum ( self ) -> int : NEW_LINE INDENT return self . pricesCount . peekitem ( 0 ) [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumDifference ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT n = len ( nums ) // 2 NEW_LINE summ = sum ( nums ) NEW_LINE goal = summ // 2 NEW_LINE lNums = nums [ : n ] NEW_LINE rNums = nums [ n : ] NEW_LINE ans = abs ( sum ( lNums ) - sum ( rNums ) ) NEW_LINE lSums = [ [ ] for _ in range ( n + 1 ) ] NEW_LINE rSums = [ [ ] for _ in range ( n + 1 ) ] NEW_LINE def dfs ( A : List [ int ] , i : int , count : int , path : int , sums : List [ List [ int ] ] ) : NEW_LINE INDENT if i == len ( A ) : NEW_LINE INDENT sums [ count ] . append ( path ) NEW_LINE return NEW_LINE DEDENT dfs ( A , i + 1 , count + 1 , path + A [ i ] , sums ) NEW_LINE dfs ( A , i + 1 , count , path , sums ) NEW_LINE DEDENT dfs ( lNums , 0 , 0 , 0 , lSums ) NEW_LINE dfs ( rNums , 0 , 0 , 0 , rSums ) NEW_LINE for lCount in range ( n ) : NEW_LINE INDENT l = lSums [ lCount ] NEW_LINE r = rSums [ n - lCount ] NEW_LINE r . sort ( ) NEW_LINE for lSum in l : NEW_LINE INDENT i = bisect_left ( r , goal - lSum ) NEW_LINE if i < len ( r ) : NEW_LINE INDENT sumPartOne = summ - lSum - r [ i ] NEW_LINE sumPartTwo = summ - sumPartOne NEW_LINE ans = min ( ans , abs ( sumPartOne - sumPartTwo ) ) NEW_LINE DEDENT if i > 0 : NEW_LINE INDENT sumPartOne = summ - lSum - r [ i - 1 ] NEW_LINE sumPartTwo = summ - sumPartOne NEW_LINE ans = min ( ans , abs ( sumPartOne - sumPartTwo ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumAlternatingSubarraySum ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = - math . inf NEW_LINE even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT if ( i & 1 ) == 0 : NEW_LINE INDENT even += nums [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT even = max ( 0 , even - nums [ i ] ) NEW_LINE DEDENT ans = max ( ans , even ) NEW_LINE DEDENT for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT if i & 1 : NEW_LINE INDENT odd += nums [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT odd = max ( 0 , odd - nums [ i ] ) NEW_LINE DEDENT ans = max ( ans , odd ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minMovesToSeat ( self , seats : List [ int ] , students : List [ int ] ) -> int : NEW_LINE INDENT return sum ( abs ( seat - student ) for seat , student in zip ( sorted ( seats ) , sorted ( students ) ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def winnerOfGame ( self , colors : str ) -> bool : NEW_LINE INDENT countAAA = 0 NEW_LINE countBBB = 0 NEW_LINE for a , b , c in zip ( colors , colors [ 1 : ] , colors [ 2 : ] ) : NEW_LINE INDENT if ' A ' == a == b == c : NEW_LINE INDENT countAAA += 1 NEW_LINE DEDENT elif ' B ' == a == b == c : NEW_LINE INDENT countBBB += 1 NEW_LINE DEDENT DEDENT return countAAA > countBBB NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def networkBecomesIdle ( self , edges : List [ List [ int ] ] , patience : List [ int ] ) -> int : NEW_LINE INDENT n = len ( patience ) NEW_LINE ans = 0 NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE q = deque ( [ 0 ] ) NEW_LINE dist = [ math . inf ] * n NEW_LINE dist [ 0 ] = 0 NEW_LINE for u , v in edges : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT while q : NEW_LINE INDENT for _ in range ( len ( q ) ) : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT if dist [ v ] == math . inf : NEW_LINE INDENT dist [ v ] = dist [ u ] + 1 NEW_LINE q . append ( v ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT numResending = ( dist [ i ] * 2 - 1 ) // patience [ i ] NEW_LINE lastResendingTime = patience [ i ] * numResending NEW_LINE lastArrivingTime = lastResendingTime + dist [ i ] * 2 NEW_LINE ans = max ( ans , lastArrivingTime ) NEW_LINE DEDENT return ans + 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countPrimes ( self , n : int ) -> int : NEW_LINE INDENT if n <= 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT isPrime = [ False ] * 2 + [ True ] * ( n - 2 ) NEW_LINE for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT for j in range ( i * i , n , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return sum ( isPrime ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def kthSmallestProduct ( self , nums1 : List [ int ] , nums2 : List [ int ] , k : int ) -> int : NEW_LINE INDENT A1 = [ - num for num in nums1 if num < 0 ] [ : : - 1 ] NEW_LINE A2 = [ num for num in nums1 if num >= 0 ] NEW_LINE B1 = [ - num for num in nums2 if num < 0 ] [ : : - 1 ] NEW_LINE B2 = [ num for num in nums2 if num >= 0 ] NEW_LINE negCount = len ( A1 ) * len ( B2 ) + len ( A2 ) * len ( B1 ) NEW_LINE if k > negCount : NEW_LINE INDENT k -= negCount NEW_LINE sign = 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = negCount - k + 1 NEW_LINE sign = - 1 NEW_LINE B1 , B2 = B2 , B1 NEW_LINE DEDENT def numProductNoGreaterThan ( A : List [ int ] , B : List [ int ] , m : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE j = len ( B ) - 1 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT while j >= 0 and A [ i ] * B [ j ] > m : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT ans += j + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT l = 0 NEW_LINE r = 10 ** 10 NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if numProductNoGreaterThan ( A1 , B1 , m ) + numProductNoGreaterThan ( A2 , B2 , m ) >= k : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return sign * l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def areNumbersAscending ( self , s : str ) -> bool : NEW_LINE INDENT prev = 0 NEW_LINE for token in s . split ( ) : NEW_LINE INDENT if token . isdigit ( ) : NEW_LINE INDENT num = int ( token ) NEW_LINE if num <= prev : NEW_LINE INDENT return False NEW_LINE DEDENT prev = num NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Bank : NEW_LINE INDENT def __init__ ( self , balance : List [ int ] ) : NEW_LINE INDENT self . balance = balance NEW_LINE DEDENT def transfer ( self , account1 : int , account2 : int , money : int ) -> bool : NEW_LINE INDENT if not self . _isValid ( account2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return self . withdraw ( account1 , money ) and self . deposit ( account2 , money ) NEW_LINE DEDENT def deposit ( self , account : int , money : int ) -> bool : NEW_LINE INDENT if not self . _isValid ( account ) : NEW_LINE INDENT return False NEW_LINE DEDENT self . balance [ account - 1 ] += money NEW_LINE return True NEW_LINE DEDENT def withdraw ( self , account : int , money : int ) -> bool : NEW_LINE INDENT if not self . _isValid ( account ) : NEW_LINE INDENT return False NEW_LINE DEDENT if self . balance [ account - 1 ] < money : NEW_LINE INDENT return False NEW_LINE DEDENT self . balance [ account - 1 ] -= money NEW_LINE return True NEW_LINE DEDENT def _isValid ( self , account : int ) -> bool : NEW_LINE INDENT return 1 <= account <= len ( self . balance ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countMaxOrSubsets ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ors = functools . reduce ( operator . or_ , nums ) NEW_LINE ans = 0 NEW_LINE def dfs ( i : int , path : int ) -> None : NEW_LINE INDENT nonlocal ans NEW_LINE if i == len ( nums ) : NEW_LINE INDENT if path == ors : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return NEW_LINE DEDENT dfs ( i + 1 , path ) NEW_LINE dfs ( i + 1 , path | nums [ i ] ) NEW_LINE DEDENT dfs ( 0 , 0 ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def secondMinimum ( self , n : int , edges : List [ List [ int ] ] , time : int , change : int ) -> int : NEW_LINE INDENT graph = [ [ ] for _ in range ( n + 1 ) ] NEW_LINE q = deque ( [ ( 1 , 0 ) ] ) NEW_LINE minTime = [ [ math . inf ] * 2 for _ in range ( n + 1 ) ] NEW_LINE minTime [ 1 ] [ 0 ] = 0 NEW_LINE for u , v in edges : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT while q : NEW_LINE INDENT i , prevTime = q . popleft ( ) NEW_LINE numChangeSignal = prevTime // change NEW_LINE waitTime = change - ( prevTime % change ) if numChangeSignal & 1 else 0 NEW_LINE newTime = prevTime + waitTime + time NEW_LINE for j in graph [ i ] : NEW_LINE INDENT if newTime < minTime [ j ] [ 0 ] : NEW_LINE INDENT minTime [ j ] [ 0 ] = newTime NEW_LINE q . append ( ( j , newTime ) ) NEW_LINE DEDENT elif minTime [ j ] [ 0 ] < newTime < minTime [ j ] [ 1 ] : NEW_LINE INDENT if j == n : NEW_LINE INDENT return newTime NEW_LINE DEDENT minTime [ j ] [ 1 ] = newTime NEW_LINE q . append ( ( j , newTime ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def sortLinkedList ( self , head : Optional [ ListNode ] ) -> Optional [ ListNode ] : NEW_LINE INDENT prev = head NEW_LINE curr = head . next NEW_LINE while curr : NEW_LINE INDENT if curr . val < 0 : NEW_LINE INDENT prev . next = curr . next NEW_LINE curr . next = head NEW_LINE head = curr NEW_LINE curr = prev . next NEW_LINE DEDENT else : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT return head NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countValidWords ( self , sentence : str ) -> int : NEW_LINE INDENT def isValid ( token : str ) -> bool : NEW_LINE INDENT countHyphen = 0 NEW_LINE for i , c in enumerate ( token ) : NEW_LINE INDENT if c . isdigit ( ) : NEW_LINE INDENT return False NEW_LINE DEDENT if c == ' - ' : NEW_LINE INDENT if i == 0 or not token [ i - 1 ] . isalpha ( ) : NEW_LINE INDENT return False NEW_LINE DEDENT if i == len ( token ) - 1 or not token [ i + 1 ] . isalpha ( ) : NEW_LINE INDENT return False NEW_LINE DEDENT if countHyphen == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT countHyphen += 1 NEW_LINE DEDENT if c in [ ' ! ' , ' . ' , ' , ' ] : NEW_LINE INDENT if i != len ( token ) - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT return sum ( isValid ( token ) for token in sentence . split ( ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nextBeautifulNumber ( self , n : int ) -> int : NEW_LINE INDENT def isBalance ( num : int ) -> bool : NEW_LINE INDENT count = [ 0 ] * 10 NEW_LINE while num : NEW_LINE INDENT if num % 10 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT count [ num % 10 ] += 1 NEW_LINE num //= 10 NEW_LINE DEDENT return all ( c == i for i , c in enumerate ( count ) if c ) NEW_LINE DEDENT n += 1 NEW_LINE while not isBalance ( n ) : NEW_LINE INDENT n += 1 NEW_LINE DEDENT return n NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countHighestScoreNodes ( self , parents : List [ int ] ) -> int : NEW_LINE INDENT tree = [ [ ] for _ in range ( len ( parents ) ) ] NEW_LINE for i , parent in enumerate ( parents ) : NEW_LINE INDENT if parent == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT tree [ parent ] . append ( i ) NEW_LINE DEDENT ans = 0 NEW_LINE maxScore = 0 NEW_LINE def dfs ( u : int ) -> int : NEW_LINE INDENT nonlocal ans NEW_LINE nonlocal maxScore NEW_LINE count = 1 NEW_LINE score = 1 NEW_LINE for v in tree [ u ] : NEW_LINE INDENT childCount = dfs ( v ) NEW_LINE count += childCount NEW_LINE score *= childCount NEW_LINE DEDENT score *= len ( parents ) - count or 1 NEW_LINE if score > maxScore : NEW_LINE INDENT maxScore = score NEW_LINE ans = 1 NEW_LINE DEDENT elif score == maxScore : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT dfs ( 0 ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isIsomorphic ( self , s : str , t : str ) -> bool : NEW_LINE INDENT return [ * map ( s . index , s ) ] == [ * map ( t . index , t ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumTime ( self , n : int , relations : List [ List [ int ] ] , time : List [ int ] ) -> int : NEW_LINE INDENT graph = [ [ ] for _ in range ( n ) ] NEW_LINE inDegree = [ 0 ] * n NEW_LINE dist = time . copy ( ) NEW_LINE for a , b in relations : NEW_LINE INDENT u = a - 1 NEW_LINE v = b - 1 NEW_LINE graph [ u ] . append ( v ) NEW_LINE inDegree [ v ] += 1 NEW_LINE DEDENT q = deque ( [ i for i , d in enumerate ( inDegree ) if d == 0 ] ) NEW_LINE while q : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT dist [ v ] = max ( dist [ v ] , dist [ u ] + time [ v ] ) NEW_LINE inDegree [ v ] -= 1 NEW_LINE if inDegree [ v ] == 0 : NEW_LINE INDENT q . append ( v ) NEW_LINE DEDENT DEDENT DEDENT return max ( dist ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumCost ( self , sentence : str , k : int ) -> int : NEW_LINE INDENT if len ( sentence ) <= k : NEW_LINE INDENT return 0 NEW_LINE DEDENT words = sentence . split ( ) NEW_LINE dp = [ 0 ] * ( len ( words ) + 1 ) NEW_LINE for i in range ( 1 , len ( words ) + 1 ) : NEW_LINE INDENT n = len ( words [ i - 1 ] ) NEW_LINE dp [ i ] = dp [ i - 1 ] + ( k - n ) ** 2 NEW_LINE for j in range ( i - 1 , 0 , - 1 ) : NEW_LINE INDENT n += len ( words [ j - 1 ] ) + 1 NEW_LINE if n > k : NEW_LINE INDENT break NEW_LINE DEDENT dp [ i ] = min ( dp [ i ] , dp [ j - 1 ] + ( k - n ) ** 2 ) NEW_LINE DEDENT DEDENT lastRowLen = len ( words [ - 1 ] ) NEW_LINE i = len ( words ) - 2 NEW_LINE while i > 0 and lastRowLen + len ( words [ i ] ) + 1 <= k : NEW_LINE INDENT lastRowLen += len ( words [ i ] ) + 1 NEW_LINE i -= 1 NEW_LINE DEDENT return min ( dp [ i + 1 : len ( words ) ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def kthDistinct ( self , arr : List [ str ] , k : int ) -> str : NEW_LINE INDENT count = Counter ( arr ) NEW_LINE for a in arr : NEW_LINE INDENT if count [ a ] == 1 : NEW_LINE INDENT k -= 1 NEW_LINE if k == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT DEDENT return ' ' NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxTwoEvents ( self , events : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE maxValue = 0 NEW_LINE evts = [ ] NEW_LINE for s , e , v in events : NEW_LINE INDENT evts . append ( ( s , 1 , v ) ) NEW_LINE evts . append ( ( e + 1 , 0 , v ) ) NEW_LINE DEDENT evts . sort ( ) NEW_LINE for _ , isStart , value in evts : NEW_LINE INDENT if isStart : NEW_LINE INDENT ans = max ( ans , value + maxValue ) NEW_LINE DEDENT else : NEW_LINE INDENT maxValue = max ( maxValue , value ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def platesBetweenCandles ( self , s : str , queries : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE A = [ i for i , c in enumerate ( s ) if c == ' | ' ] NEW_LINE for left , right in queries : NEW_LINE INDENT l = bisect_left ( A , left ) NEW_LINE r = bisect_right ( A , right ) - 1 NEW_LINE if l < r : NEW_LINE INDENT lengthBetweenCandles = A [ r ] - A [ l ] + 1 NEW_LINE numCandles = r - l + 1 NEW_LINE ans . append ( lengthBetweenCandles - numCandles ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countCombinations ( self , pieces : List [ str ] , positions : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( pieces ) NEW_LINE moves = { " rook " : [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] , " bishop " : [ ( 1 , 1 ) , ( 1 , - 1 ) , ( - 1 , 1 ) , ( - 1 , - 1 ) ] , " queen " : [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 1 ) , ( 1 , - 1 ) , ( - 1 , 1 ) , ( - 1 , - 1 ) ] } NEW_LINE ans = set ( ) NEW_LINE def hash ( board : List [ List [ int ] ] ) -> Tuple : NEW_LINE INDENT return tuple ( [ tuple ( pos ) for pos in board ] ) NEW_LINE DEDENT def dfs ( board : List [ List [ int ] ] , combMove : List [ Tuple [ int , int ] ] , activeMask : int ) -> None : NEW_LINE INDENT if activeMask == 0 : NEW_LINE INDENT return NEW_LINE DEDENT ans . add ( hash ( board ) ) NEW_LINE for nextActiveMask in range ( 1 , 1 << n ) : NEW_LINE INDENT if activeMask & nextActiveMask != nextActiveMask : NEW_LINE INDENT continue NEW_LINE DEDENT nextBoard = [ pos . copy ( ) for pos in board ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( nextActiveMask >> i ) & 1 : NEW_LINE INDENT nextBoard [ i ] [ 0 ] += combMove [ i ] [ 0 ] NEW_LINE nextBoard [ i ] [ 1 ] += combMove [ i ] [ 1 ] NEW_LINE DEDENT DEDENT if len ( set ( hash ( nextBoard ) ) ) < n : NEW_LINE INDENT continue NEW_LINE DEDENT if all ( 1 <= x <= 8 and 1 <= y <= 8 for x , y in nextBoard ) : NEW_LINE INDENT dfs ( nextBoard , combMove , nextActiveMask ) NEW_LINE DEDENT DEDENT DEDENT for combMove in product ( * ( moves [ piece ] for piece in pieces ) ) : NEW_LINE INDENT dfs ( positions , combMove , ( 1 << n ) - 1 ) NEW_LINE DEDENT return len ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestEqual ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT return next ( ( i for i , num in enumerate ( nums ) if i % 10 == num ) , - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nodesBetweenCriticalPoints ( self , head : Optional [ ListNode ] ) -> List [ int ] : NEW_LINE INDENT minDistance = math . inf NEW_LINE firstMaIndex = - 1 NEW_LINE prevMaIndex = - 1 NEW_LINE index = 1 NEW_LINE prev = head NEW_LINE curr = head . next NEW_LINE while curr . next : NEW_LINE INDENT if curr . val > prev . val and curr . val > curr . next . val or curr . val < prev . val and curr . val < curr . next . val : NEW_LINE INDENT if firstMaIndex == - 1 : NEW_LINE INDENT firstMaIndex = index NEW_LINE DEDENT if prevMaIndex != - 1 : NEW_LINE INDENT minDistance = min ( minDistance , index - prevMaIndex ) NEW_LINE DEDENT prevMaIndex = index NEW_LINE DEDENT prev = curr NEW_LINE curr = curr . next NEW_LINE index += 1 NEW_LINE DEDENT if minDistance == math . inf : NEW_LINE INDENT return [ - 1 , - 1 ] NEW_LINE DEDENT return [ minDistance , prevMaIndex - firstMaIndex ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumOperations ( self , nums : List [ int ] , start : int , goal : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE q = deque ( [ start ] ) NEW_LINE seen = { start } NEW_LINE while q : NEW_LINE INDENT ans += 1 NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT x = q . popleft ( ) NEW_LINE for num in nums : NEW_LINE INDENT for res in ( x + num , x - num , x ^ num ) : NEW_LINE INDENT if res == goal : NEW_LINE INDENT return ans NEW_LINE DEDENT if res < 0 or res > 1000 or res in seen : NEW_LINE INDENT continue NEW_LINE DEDENT seen . add ( res ) NEW_LINE q . append ( res ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reverseList ( self , head : Optional [ ListNode ] ) -> Optional [ ListNode ] : NEW_LINE INDENT if not head or not head . next : NEW_LINE INDENT return head NEW_LINE DEDENT newHead = self . reverseList ( head . next ) NEW_LINE head . next . next = head NEW_LINE head . next = None NEW_LINE return newHead NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def possiblyEquals ( self , s1 : str , s2 : str ) -> bool : NEW_LINE INDENT def getNums ( s : str ) -> Set [ int ] : NEW_LINE INDENT nums = { int ( s ) } NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT nums |= { x + y for x in getNums ( s [ : i ] ) for y in getNums ( s [ i : ] ) } NEW_LINE DEDENT return nums NEW_LINE DEDENT def getNextLetterIndex ( s : str , i : int ) -> int : NEW_LINE INDENT j = i NEW_LINE while j < len ( s ) and s [ j ] . isdigit ( ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT return j NEW_LINE DEDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int , j : int , paddingDiff : int ) -> bool : NEW_LINE INDENT if i == len ( s1 ) and j == len ( s2 ) : NEW_LINE INDENT return paddingDiff == 0 NEW_LINE DEDENT if i < len ( s1 ) and s1 [ i ] . isdigit ( ) : NEW_LINE INDENT nextLetterIndex = getNextLetterIndex ( s1 , i ) NEW_LINE for num in getNums ( s1 [ i : nextLetterIndex ] ) : NEW_LINE INDENT if dp ( nextLetterIndex , j , paddingDiff + num ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT elif j < len ( s2 ) and s2 [ j ] . isdigit ( ) : NEW_LINE INDENT nextLetterIndex = getNextLetterIndex ( s2 , j ) NEW_LINE for num in getNums ( s2 [ j : nextLetterIndex ] ) : NEW_LINE INDENT if dp ( i , nextLetterIndex , paddingDiff - num ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT elif paddingDiff > 0 : NEW_LINE INDENT if j < len ( s2 ) : NEW_LINE INDENT return dp ( i , j + 1 , paddingDiff - 1 ) NEW_LINE DEDENT DEDENT elif paddingDiff < 0 : NEW_LINE INDENT if i < len ( s1 ) : NEW_LINE INDENT return dp ( i + 1 , j , paddingDiff + 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if i < len ( s1 ) and j < len ( s2 ) and s1 [ i ] == s2 [ j ] : NEW_LINE INDENT return dp ( i + 1 , j + 1 , 0 ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT return dp ( 0 , 0 , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberOfCleanRooms ( self , room : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( room ) NEW_LINE n = len ( room [ 0 ] ) NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE ans = 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE state = 0 NEW_LINE seen = { ( i , j , state ) } NEW_LINE room [ i ] [ j ] = 2 NEW_LINE while True : NEW_LINE INDENT x = i + dirs [ state ] NEW_LINE y = j + dirs [ state + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n or room [ x ] [ y ] == 1 : NEW_LINE INDENT state = ( state + 1 ) % 4 NEW_LINE DEDENT else : NEW_LINE INDENT if room [ x ] [ y ] == 0 : NEW_LINE INDENT ans += 1 NEW_LINE room [ x ] [ y ] = 2 NEW_LINE DEDENT i = x NEW_LINE j = y NEW_LINE DEDENT if ( x , y , state ) in seen : NEW_LINE INDENT return ans NEW_LINE DEDENT seen . add ( ( x , y , state ) ) NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def countVowelSubstrings ( self , word : str ) -> int : NEW_LINE INDENT def countVowelSubstringsAtMost ( goal : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE k = goal NEW_LINE count = Counter ( ) NEW_LINE l = 0 NEW_LINE for r , c in enumerate ( word ) : NEW_LINE INDENT if c not in ' aeiou ' : NEW_LINE INDENT l = r + 1 NEW_LINE k = goal NEW_LINE count = Counter ( ) NEW_LINE continue NEW_LINE DEDENT count [ c ] += 1 NEW_LINE if count [ c ] == 1 : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT while k == - 1 : NEW_LINE INDENT count [ word [ l ] ] -= 1 NEW_LINE if count [ word [ l ] ] == 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT ans += r - l + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT return countVowelSubstringsAtMost ( 5 ) - countVowelSubstringsAtMost ( 4 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countVowels ( self , word : str ) -> int : NEW_LINE INDENT dp = [ 0 ] * ( len ( word ) + 1 ) NEW_LINE for i , c in enumerate ( word ) : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] + ( c in ' aeiou ' ) * ( i + 1 ) NEW_LINE DEDENT return sum ( dp ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimizedMaximum ( self , n : int , quantities : List [ int ] ) -> int : NEW_LINE INDENT l = 1 NEW_LINE r = max ( quantities ) NEW_LINE def numOfStores ( m : int ) -> int : NEW_LINE INDENT return sum ( ( q - 1 ) // m + 1 for q in quantities ) NEW_LINE DEDENT while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if numOfStores ( m ) <= n : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximalPathQuality ( self , values : List [ int ] , edges : List [ List [ int ] ] , maxTime : int ) -> int : NEW_LINE INDENT n = len ( values ) NEW_LINE ans = 0 NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE seen = [ 0 ] * n NEW_LINE seen [ 0 ] = 1 NEW_LINE for u , v , time in edges : NEW_LINE INDENT graph [ u ] . append ( ( v , time ) ) NEW_LINE graph [ v ] . append ( ( u , time ) ) NEW_LINE DEDENT def dfs ( u : int , quality : int , remainingTime : int ) : NEW_LINE INDENT nonlocal ans NEW_LINE if u == 0 : NEW_LINE INDENT ans = max ( ans , quality ) NEW_LINE DEDENT for v , time in graph [ u ] : NEW_LINE INDENT if time > remainingTime : NEW_LINE INDENT continue NEW_LINE DEDENT newQuality = quality + values [ v ] * ( seen [ v ] == 0 ) NEW_LINE seen [ v ] += 1 NEW_LINE dfs ( v , newQuality , remainingTime - time ) NEW_LINE seen [ v ] -= 1 NEW_LINE DEDENT DEDENT dfs ( 0 , values [ 0 ] , maxTime ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def equalCountSubstrings ( self , s : str , count : int ) -> int : NEW_LINE INDENT maxUnique = len ( set ( s ) ) NEW_LINE ans = 0 NEW_LINE for unique in range ( 1 , maxUnique + 1 ) : NEW_LINE INDENT windowSize = unique * count NEW_LINE lettersCount = Counter ( ) NEW_LINE uniqueCount = 0 NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT lettersCount [ c ] += 1 NEW_LINE if lettersCount [ c ] == count : NEW_LINE INDENT uniqueCount += 1 NEW_LINE DEDENT if i >= windowSize : NEW_LINE INDENT lettersCount [ s [ i - windowSize ] ] -= 1 NEW_LINE if lettersCount [ s [ i - windowSize ] ] == count - 1 : NEW_LINE INDENT uniqueCount -= 1 NEW_LINE DEDENT DEDENT ans += uniqueCount == unique NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Robot : NEW_LINE INDENT def __init__ ( self , width : int , height : int ) : NEW_LINE INDENT self . isOrigin = True NEW_LINE self . i = 0 NEW_LINE self . pos = [ ( ( 0 , 0 ) , ' South ' ) ] + [ ( ( i , 0 ) , ' East ' ) for i in range ( 1 , width ) ] + [ ( ( width - 1 , j ) , ' North ' ) for j in range ( 1 , height ) ] + [ ( ( i , height - 1 ) , ' West ' ) for i in range ( width - 2 , - 1 , - 1 ) ] + [ ( ( 0 , j ) , ' South ' ) for j in range ( height - 2 , 0 , - 1 ) ] NEW_LINE DEDENT def step ( self , num : int ) -> None : NEW_LINE INDENT self . isOrigin = False NEW_LINE self . i = ( self . i + num ) % len ( self . pos ) NEW_LINE DEDENT def getPos ( self ) -> List [ int ] : NEW_LINE INDENT return self . pos [ self . i ] [ 0 ] NEW_LINE DEDENT def getDir ( self ) -> str : NEW_LINE INDENT return ' East ' if self . isOrigin else self . pos [ self . i ] [ 1 ] NEW_LINE DEDENT DEDENT
from enum import Enum NEW_LINE class State ( Enum ) : NEW_LINE INDENT INIT = 0 NEW_LINE VISITING = 1 NEW_LINE VISITED = 2 NEW_LINE DEDENT class Solution : NEW_LINE INDENT def canFinish ( self , numCourses : int , prerequisites : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT graph = [ [ ] for _ in range ( numCourses ) ] NEW_LINE state = [ State . INIT ] * numCourses NEW_LINE for a , b in prerequisites : NEW_LINE INDENT graph [ b ] . append ( a ) NEW_LINE DEDENT def hasCycle ( u : int ) -> bool : NEW_LINE INDENT if state [ u ] == State . VISITING : NEW_LINE INDENT return True NEW_LINE DEDENT if state [ u ] == State . VISITED : NEW_LINE INDENT return False NEW_LINE DEDENT state [ u ] = State . VISITING NEW_LINE if any ( hasCycle ( v ) for v in graph [ u ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT state [ u ] = State . VISITED NEW_LINE return False NEW_LINE DEDENT return not any ( hasCycle ( i ) for i in range ( numCourses ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumBeauty ( self , items : List [ List [ int ] ] , queries : List [ int ] ) -> List [ int ] : NEW_LINE INDENT prices , beauties = zip ( * sorted ( items ) ) NEW_LINE maxBeautySoFar = [ 0 ] * ( len ( beauties ) + 1 ) NEW_LINE for i , beauty in enumerate ( beauties ) : NEW_LINE INDENT maxBeautySoFar [ i + 1 ] = max ( maxBeautySoFar [ i ] , beauty ) NEW_LINE DEDENT return [ maxBeautySoFar [ bisect_right ( prices , q ) ] for q in queries ] NEW_LINE DEDENT DEDENT
from sortedcontainers import SortedList NEW_LINE class Solution : NEW_LINE INDENT def maxTaskAssign ( self , tasks : List [ int ] , workers : List [ int ] , pills : int , strength : int ) -> int : NEW_LINE INDENT tasks . sort ( ) NEW_LINE workers . sort ( ) NEW_LINE def canComplete ( k : int , pillsLeft : int ) -> bool : NEW_LINE INDENT sortedWorkers = SortedList ( workers [ - k : ] ) NEW_LINE for i in reversed ( range ( k ) ) : NEW_LINE INDENT index = sortedWorkers . bisect_left ( tasks [ i ] ) NEW_LINE if index < len ( sortedWorkers ) : NEW_LINE INDENT sortedWorkers . pop ( index ) NEW_LINE DEDENT elif pillsLeft > 0 : NEW_LINE INDENT index = sortedWorkers . bisect_left ( tasks [ i ] - strength ) NEW_LINE if index < len ( sortedWorkers ) : NEW_LINE INDENT sortedWorkers . pop ( index ) NEW_LINE pillsLeft -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT ans = 0 NEW_LINE l = 0 NEW_LINE r = min ( len ( tasks ) , len ( workers ) ) NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if canComplete ( m , pills ) : NEW_LINE INDENT ans = m NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def timeRequiredToBuy ( self , tickets : List [ int ] , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for i , ticket in enumerate ( tickets ) : NEW_LINE INDENT if i <= k : NEW_LINE INDENT ans += min ( ticket , tickets [ k ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += min ( ticket , tickets [ k ] - 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reverseEvenLengthGroups ( self , head : Optional [ ListNode ] ) -> Optional [ ListNode ] : NEW_LINE INDENT dummy = ListNode ( 0 , head ) NEW_LINE prev = dummy NEW_LINE tail = head NEW_LINE next = head . next NEW_LINE groupLength = 1 NEW_LINE def getTailAndLength ( head : Optional [ ListNode ] , groupLength : int ) -> Tuple [ Optional [ ListNode ] , int ] : NEW_LINE INDENT length = 1 NEW_LINE tail = head NEW_LINE while length < groupLength and tail . next : NEW_LINE INDENT tail = tail . next NEW_LINE length += 1 NEW_LINE DEDENT return tail , length NEW_LINE DEDENT def reverse ( head : Optional [ ListNode ] ) -> Optional [ ListNode ] : NEW_LINE INDENT prev = None NEW_LINE while head : NEW_LINE INDENT next = head . next NEW_LINE head . next = prev NEW_LINE prev = head NEW_LINE head = next NEW_LINE DEDENT return prev NEW_LINE DEDENT while True : NEW_LINE INDENT if groupLength & 1 : NEW_LINE INDENT prev . next = head NEW_LINE prev = tail NEW_LINE DEDENT else : NEW_LINE INDENT tail . next = None NEW_LINE prev . next = reverse ( head ) NEW_LINE head . next = next NEW_LINE prev = head NEW_LINE DEDENT if not next : NEW_LINE INDENT break NEW_LINE DEDENT head = next NEW_LINE tail , length = getTailAndLength ( head , groupLength + 1 ) NEW_LINE next = tail . next NEW_LINE groupLength = length NEW_LINE DEDENT return dummy . next NEW_LINE DEDENT DEDENT
class UnionFind : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . id = list ( range ( n ) ) NEW_LINE DEDENT def union ( self , u : int , v : int ) -> None : NEW_LINE INDENT self . id [ u ] = v NEW_LINE DEDENT def find ( self , u : int ) -> int : NEW_LINE INDENT if self . id [ u ] != u : NEW_LINE INDENT self . id [ u ] = self . find ( self . id [ u ] ) NEW_LINE DEDENT return self . id [ u ] NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def friendRequests ( self , n : int , restrictions : List [ List [ int ] ] , requests : List [ List [ int ] ] ) -> List [ bool ] : NEW_LINE INDENT ans = [ ] NEW_LINE uf = UnionFind ( n ) NEW_LINE for u , v in requests : NEW_LINE INDENT pu = uf . find ( u ) NEW_LINE pv = uf . find ( v ) NEW_LINE isValid = True NEW_LINE if pu != pv : NEW_LINE INDENT for x , y in restrictions : NEW_LINE INDENT px = uf . find ( x ) NEW_LINE py = uf . find ( y ) NEW_LINE if ( pu , pv ) in [ ( px , py ) , ( py , px ) ] : NEW_LINE INDENT isValid = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT ans . append ( isValid ) NEW_LINE if isValid : NEW_LINE INDENT uf . union ( pu , pv ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class TrieNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . children : Dict [ str , TrieNode ] = defaultdict ( TrieNode ) NEW_LINE self . isWord = False NEW_LINE DEDENT DEDENT class Trie : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . root = TrieNode ( ) NEW_LINE DEDENT def insert ( self , word : str ) -> None : NEW_LINE INDENT node : TrieNode = self . root NEW_LINE for c in word : NEW_LINE INDENT if c not in node . children : NEW_LINE INDENT node . children [ c ] = TrieNode ( ) NEW_LINE DEDENT node = node . children [ c ] NEW_LINE DEDENT node . isWord = True NEW_LINE DEDENT def search ( self , word : str ) -> bool : NEW_LINE INDENT node : TrieNode = self . _find ( word ) NEW_LINE return node and node . isWord NEW_LINE DEDENT def startsWith ( self , prefix : str ) -> bool : NEW_LINE INDENT return self . _find ( prefix ) NEW_LINE DEDENT def _find ( self , prefix : str ) -> Optional [ TrieNode ] : NEW_LINE INDENT node : TrieNode = self . root NEW_LINE for c in prefix : NEW_LINE INDENT if c not in node . children : NEW_LINE INDENT return None NEW_LINE DEDENT node = node . children [ c ] NEW_LINE DEDENT return node NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberOfSubstrings ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = Counter ( ) NEW_LINE for c in s : NEW_LINE INDENT ans += count [ c ] + 1 NEW_LINE count [ c ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countWords ( self , words1 : List [ str ] , words2 : List [ str ] ) -> int : NEW_LINE INDENT count = Counter ( words1 ) NEW_LINE for word in words2 : NEW_LINE INDENT if word in count and count [ word ] < 2 : NEW_LINE INDENT count [ word ] -= 1 NEW_LINE DEDENT DEDENT return sum ( value == 0 for value in count . values ( ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumBuckets ( self , street : str ) -> int : NEW_LINE INDENT A = list ( street ) NEW_LINE for i , c in enumerate ( A ) : NEW_LINE INDENT if c == ' H ' : NEW_LINE INDENT if i > 0 and A [ i - 1 ] == ' B ' : NEW_LINE INDENT continue NEW_LINE DEDENT if i + 1 < len ( A ) and A [ i + 1 ] == ' . ' : NEW_LINE INDENT A [ i + 1 ] = ' B ' NEW_LINE DEDENT elif i > 0 and A [ i - 1 ] == ' . ' : NEW_LINE INDENT A [ i - 1 ] = ' B ' NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT return A . count ( ' B ' ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minCost ( self , startPos : List [ int ] , homePos : List [ int ] , rowCosts : List [ int ] , colCosts : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE i , j = startPos NEW_LINE x , y = homePos NEW_LINE while i != x : NEW_LINE INDENT i += 1 if i < x else - 1 NEW_LINE ans += rowCosts [ i ] NEW_LINE DEDENT while j != y : NEW_LINE INDENT j += 1 if j < y else - 1 NEW_LINE ans += colCosts [ j ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countPyramids ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT def count ( dp : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( dp ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , len ( dp [ 0 ] ) - 1 ) : NEW_LINE INDENT if dp [ i ] [ j ] == 1 : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ j - 1 ] , dp [ i + 1 ] [ j ] , dp [ i + 1 ] [ j + 1 ] ) + 1 NEW_LINE ans += dp [ i ] [ j ] - 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT return count ( deepcopy ( grid ) [ : : - 1 ] ) + count ( grid ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def targetIndices ( self , nums : List [ int ] , target : int ) -> List [ int ] : NEW_LINE INDENT count = nums . count ( target ) NEW_LINE lessThan = sum ( num < target for num in nums ) NEW_LINE return [ i for i in range ( lessThan , lessThan + count ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minSubArrayLen ( self , s : int , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = math . inf NEW_LINE summ = 0 NEW_LINE j = 0 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT summ += num NEW_LINE while summ >= s : NEW_LINE INDENT ans = min ( ans , i - j + 1 ) NEW_LINE summ -= nums [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ans if ans != math . inf else 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getAverages ( self , nums : List [ int ] , k : int ) -> List [ int ] : NEW_LINE INDENT n = len ( nums ) NEW_LINE size = 2 * k + 1 NEW_LINE ans = [ - 1 ] * n NEW_LINE if size > n : NEW_LINE INDENT return ans NEW_LINE DEDENT summ = sum ( nums [ : size ] ) NEW_LINE for i in range ( k , n - k ) : NEW_LINE INDENT ans [ i ] = summ // size NEW_LINE if i + k + 1 < n : NEW_LINE INDENT summ += nums [ i + k + 1 ] - nums [ i - k ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumDeletions ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE a = nums . index ( min ( nums ) ) NEW_LINE b = nums . index ( max ( nums ) ) NEW_LINE if a > b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT return min ( a + 1 + n - b , b + 1 , n - a ) NEW_LINE DEDENT DEDENT
class UnionFind : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . id = list ( range ( n ) ) NEW_LINE DEDENT def union ( self , u : int , v : int ) -> None : NEW_LINE INDENT self . id [ self . find ( u ) ] = self . find ( v ) NEW_LINE DEDENT def connected ( self , u : int , v : int ) -> bool : NEW_LINE INDENT return self . find ( self . id [ u ] ) == self . find ( self . id [ v ] ) NEW_LINE DEDENT def reset ( self , u : int ) : NEW_LINE INDENT self . id [ u ] = u NEW_LINE DEDENT def find ( self , u : int ) -> int : NEW_LINE INDENT if self . id [ u ] != u : NEW_LINE INDENT self . id [ u ] = self . find ( self . id [ u ] ) NEW_LINE DEDENT return self . id [ u ] NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def findAllPeople ( self , n : int , meetings : List [ List [ int ] ] , firstPerson : int ) -> List [ int ] : NEW_LINE INDENT uf = UnionFind ( n ) NEW_LINE timeToPairs = defaultdict ( list ) NEW_LINE uf . union ( 0 , firstPerson ) NEW_LINE for x , y , time in meetings : NEW_LINE INDENT timeToPairs [ time ] . append ( ( x , y ) ) NEW_LINE DEDENT for _ , pairs in sorted ( timeToPairs . items ( ) , key = lambda x : x [ 0 ] ) : NEW_LINE INDENT peopleUnioned = set ( ) NEW_LINE for x , y in pairs : NEW_LINE INDENT uf . union ( x , y ) NEW_LINE peopleUnioned . append ( x ) NEW_LINE peopleUnioned . append ( y ) NEW_LINE DEDENT for person in peopleUnioned : NEW_LINE INDENT if not uf . connected ( person , 0 ) : NEW_LINE INDENT uf . reset ( person ) NEW_LINE DEDENT DEDENT DEDENT return [ i for i in range ( n ) if uf . connected ( i , 0 ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumCost ( self , n : int , highways : List [ List [ int ] ] , discounts : int ) -> int : NEW_LINE INDENT graph = [ [ ] for _ in range ( n ) ] NEW_LINE minHeap = [ ( 0 , 0 , discounts ) ] NEW_LINE minDiscounts = { } NEW_LINE for city1 , city2 , toll in highways : NEW_LINE INDENT graph [ city1 ] . append ( ( city2 , toll ) ) NEW_LINE graph [ city2 ] . append ( ( city1 , toll ) ) NEW_LINE DEDENT while minHeap : NEW_LINE INDENT d , u , leftDiscounts = heapq . heappop ( minHeap ) NEW_LINE if u == n - 1 : NEW_LINE INDENT return d NEW_LINE DEDENT if u in minDiscounts and minDiscounts [ u ] >= leftDiscounts : NEW_LINE INDENT continue NEW_LINE DEDENT minDiscounts [ u ] = leftDiscounts NEW_LINE for v , w in graph [ u ] : NEW_LINE INDENT heapq . heappush ( minHeap , ( d + w , v , leftDiscounts ) ) NEW_LINE if leftDiscounts > 0 : NEW_LINE INDENT heapq . heappush ( minHeap , ( d + w // 2 , v , leftDiscounts - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findEvenNumbers ( self , digits : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE count = Counter ( digits ) NEW_LINE for a in range ( 1 , 10 ) : NEW_LINE INDENT for b in range ( 0 , 10 ) : NEW_LINE INDENT for c in range ( 0 , 9 , 2 ) : NEW_LINE INDENT if count [ a ] > 0 and count [ b ] > ( b == a ) and count [ c ] > ( c == a ) + ( c == b ) : NEW_LINE INDENT ans . append ( a * 100 + b * 10 + c ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def deleteMiddle ( self , head : Optional [ ListNode ] ) -> Optional [ ListNode ] : NEW_LINE INDENT dummy = ListNode ( 0 , head ) NEW_LINE slow = dummy NEW_LINE fast = dummy NEW_LINE while fast . next and fast . next . next : NEW_LINE INDENT slow = slow . next NEW_LINE fast = fast . next . next NEW_LINE DEDENT slow . next = slow . next . next NEW_LINE return dummy . next NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getDirections ( self , root : Optional [ TreeNode ] , startValue : int , destValue : int ) -> str : NEW_LINE INDENT def lca ( root : Optional [ TreeNode ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT if not root or root . val in ( startValue , destValue ) : NEW_LINE INDENT return root NEW_LINE DEDENT l = lca ( root . left ) NEW_LINE r = lca ( root . right ) NEW_LINE if l and r : NEW_LINE INDENT return root NEW_LINE DEDENT return l or r NEW_LINE DEDENT def dfs ( root : Optional [ TreeNode ] , path : List [ chr ] ) -> None : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT if root . val == startValue : NEW_LINE INDENT self . pathToStart = ' ' . join ( path ) NEW_LINE DEDENT if root . val == destValue : NEW_LINE INDENT self . pathToDest = ' ' . join ( path ) NEW_LINE DEDENT path . append ( ' L ' ) NEW_LINE dfs ( root . left , path ) NEW_LINE path . pop ( ) NEW_LINE path . append ( ' R ' ) NEW_LINE dfs ( root . right , path ) NEW_LINE path . pop ( ) NEW_LINE DEDENT dfs ( lca ( root ) , [ ] ) NEW_LINE return ' U ' * len ( self . pathToStart ) + ' ' . join ( self . pathToDest ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def validArrangement ( self , pairs : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE graph = defaultdict ( list ) NEW_LINE outDegree = Counter ( ) NEW_LINE inDegree = Counter ( ) NEW_LINE for start , end in pairs : NEW_LINE INDENT graph [ start ] . append ( end ) NEW_LINE outDegree [ start ] += 1 NEW_LINE inDegree [ end ] += 1 NEW_LINE DEDENT def getStartNode ( ) -> int : NEW_LINE INDENT for u in graph . keys ( ) : NEW_LINE INDENT if outDegree [ u ] - inDegree [ u ] == 1 : NEW_LINE INDENT return u NEW_LINE DEDENT DEDENT return pairs [ 0 ] [ 0 ] NEW_LINE DEDENT def euler ( u : int ) -> None : NEW_LINE INDENT stack = graph [ u ] NEW_LINE while stack : NEW_LINE INDENT v = stack . pop ( ) NEW_LINE euler ( v ) NEW_LINE ans . append ( [ u , v ] ) NEW_LINE DEDENT DEDENT euler ( getStartNode ( ) ) NEW_LINE return ans [ : : - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestEvenSum ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT nums . sort ( ) NEW_LINE summ = sum ( nums [ - k : ] ) NEW_LINE if summ % 2 == 0 : NEW_LINE INDENT return summ NEW_LINE DEDENT minOdd = - 1 NEW_LINE minEven = - 1 NEW_LINE maxOdd = - 1 NEW_LINE maxEven = - 1 NEW_LINE for i in range ( len ( nums ) - 1 , len ( nums ) - k - 1 , - 1 ) : NEW_LINE INDENT if nums [ i ] & 1 : NEW_LINE INDENT minOdd = nums [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT minEven = nums [ i ] NEW_LINE DEDENT DEDENT for i in range ( len ( nums ) - k ) : NEW_LINE INDENT if nums [ i ] & 1 : NEW_LINE INDENT maxOdd = nums [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT maxEven = nums [ i ] NEW_LINE DEDENT DEDENT ans = - 1 NEW_LINE if maxEven >= 0 and minOdd >= 0 : NEW_LINE INDENT ans = max ( ans , summ + maxEven - minOdd ) NEW_LINE DEDENT if maxOdd >= 0 and minEven >= 0 : NEW_LINE INDENT ans = max ( ans , summ + maxOdd - minEven ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxSubsequence ( self , nums : List [ int ] , k : int ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE threshold = sorted ( nums ) [ - k ] NEW_LINE larger = sum ( num > threshold for num in nums ) NEW_LINE equal = k - larger NEW_LINE for num in nums : NEW_LINE INDENT if num > threshold : NEW_LINE INDENT ans . append ( num ) NEW_LINE DEDENT elif num == threshold and equal : NEW_LINE INDENT ans . append ( num ) NEW_LINE equal -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mergeTwoLists ( self , list1 : Optional [ ListNode ] , list2 : Optional [ ListNode ] ) -> Optional [ ListNode ] : NEW_LINE INDENT if not list1 or not list2 : NEW_LINE INDENT return list1 if list1 else list2 NEW_LINE DEDENT if list1 . val > list2 . val : NEW_LINE INDENT list1 , list2 = list2 , list1 NEW_LINE DEDENT list1 . next = self . mergeTwoLists ( list1 . next , list2 ) NEW_LINE return list1 NEW_LINE DEDENT DEDENT
from enum import Enum NEW_LINE class State ( Enum ) : NEW_LINE INDENT INIT = 0 NEW_LINE VISITING = 1 NEW_LINE VISITED = 2 NEW_LINE DEDENT class Solution : NEW_LINE INDENT def findOrder ( self , numCourses : int , prerequisites : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE graph = [ [ ] for _ in range ( numCourses ) ] NEW_LINE state = [ State . INIT ] * numCourses NEW_LINE for v , u in prerequisites : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE DEDENT def hasCycle ( u : int ) -> bool : NEW_LINE INDENT if state [ u ] == State . VISITING : NEW_LINE INDENT return True NEW_LINE DEDENT if state [ u ] == State . VISITED : NEW_LINE INDENT return False NEW_LINE DEDENT state [ u ] = State . VISITING NEW_LINE if any ( hasCycle ( v ) for v in graph [ u ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT state [ u ] = State . VISITED NEW_LINE ans . append ( u ) NEW_LINE return False NEW_LINE DEDENT if any ( hasCycle ( i ) for i in range ( numCourses ) ) : NEW_LINE INDENT return [ ] NEW_LINE DEDENT return ans [ : : - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def goodDaysToRobBank ( self , security : List [ int ] , time : int ) -> List [ int ] : NEW_LINE INDENT n = len ( security ) NEW_LINE dec = [ 0 ] * n NEW_LINE inc = [ 0 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if security [ i - 1 ] >= security [ i ] : NEW_LINE INDENT dec [ i ] = dec [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if security [ i ] <= security [ i + 1 ] : NEW_LINE INDENT inc [ i ] = inc [ i + 1 ] + 1 NEW_LINE DEDENT DEDENT return [ i for i , ( a , b ) in enumerate ( zip ( dec , inc ) ) if a >= time and b >= time ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumDetonation ( self , bombs : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( bombs ) NEW_LINE ans = 0 NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE for i , ( xi , yi , ri ) in enumerate ( bombs ) : NEW_LINE INDENT for j , ( xj , yj , rj ) in enumerate ( bombs ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT if ri ** 2 >= ( xi - xj ) ** 2 + ( yi - yj ) ** 2 : NEW_LINE INDENT graph [ i ] . append ( j ) NEW_LINE DEDENT DEDENT DEDENT def dfs ( u : int , seen : Set [ int ] ) -> None : NEW_LINE INDENT for v in graph [ u ] : NEW_LINE INDENT if v in seen : NEW_LINE INDENT continue NEW_LINE DEDENT seen . add ( v ) NEW_LINE dfs ( v , seen ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT seen = set ( [ i ] ) NEW_LINE dfs ( i , seen ) NEW_LINE ans = max ( ans , len ( seen ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Location : NEW_LINE INDENT def __init__ ( self , name : str , score : int ) : NEW_LINE INDENT self . name = name NEW_LINE self . score = score NEW_LINE DEDENT def __lt__ ( self , location ) : NEW_LINE INDENT if self . score == location . score : NEW_LINE INDENT return self . name > location . name NEW_LINE DEDENT return self . score < location . score NEW_LINE DEDENT DEDENT class SORTracker : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . l = [ ] NEW_LINE self . r = [ ] NEW_LINE self . k = 0 NEW_LINE DEDENT def add ( self , name : str , score : int ) -> None : NEW_LINE INDENT heapq . heappush ( self . l , Location ( name , score ) ) NEW_LINE if len ( self . l ) > self . k + 1 : NEW_LINE INDENT location = heapq . heappop ( self . l ) NEW_LINE heapq . heappush ( self . r , ( - location . score , location . name ) ) NEW_LINE DEDENT DEDENT def get ( self ) -> str : NEW_LINE INDENT name = self . l [ 0 ] . name NEW_LINE if self . r : NEW_LINE INDENT topScore , topName = heapq . heappop ( self . r ) NEW_LINE heapq . heappush ( self . l , Location ( topName , - topScore ) ) NEW_LINE DEDENT self . k += 1 NEW_LINE return name NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countPoints ( self , rings : str ) -> int : NEW_LINE INDENT colors = [ 0 ] * 10 NEW_LINE for c , num in zip ( rings [ : : 2 ] , rings [ 1 : : 2 ] ) : NEW_LINE INDENT color = 1 if c == ' R ' else 2 if c == ' G ' else 4 NEW_LINE colors [ int ( num ) ] |= color NEW_LINE DEDENT return sum ( color == 7 for color in colors ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def subArrayRanges ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE def sumSubarray ( A : List [ int ] , op ) : NEW_LINE INDENT ans = 0 NEW_LINE prev = [ - 1 ] * n NEW_LINE next = [ n ] * n NEW_LINE stack = [ ] NEW_LINE for i , a in enumerate ( A ) : NEW_LINE INDENT while stack and op ( A [ stack [ - 1 ] ] , a ) : NEW_LINE INDENT index = stack . pop ( ) NEW_LINE next [ index ] = i NEW_LINE DEDENT if stack : NEW_LINE INDENT prev [ i ] = stack [ - 1 ] NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT for i , a in enumerate ( A ) : NEW_LINE INDENT ans += a * ( i - prev [ i ] ) * ( next [ i ] - i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT return sumSubarray ( nums , operator . lt ) - sumSubarray ( nums , operator . gt ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumRefill ( self , plants : List [ int ] , capacityA : int , capacityB : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE i = 0 NEW_LINE j = len ( plants ) - 1 NEW_LINE canA = capacityA NEW_LINE canB = capacityB NEW_LINE while i < j : NEW_LINE INDENT ans += ( canA < plants [ i ] ) + ( canB < plants [ j ] ) NEW_LINE if canA < plants [ i ] : NEW_LINE INDENT canA = capacityA NEW_LINE DEDENT if canB < plants [ j ] : NEW_LINE INDENT canB = capacityB NEW_LINE DEDENT canA -= plants [ i ] NEW_LINE canB -= plants [ j ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return ans + ( i == j and max ( canA , canB ) < plants [ i ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxTotalFruits ( self , fruits : List [ List [ int ] ] , startPos : int , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE maxRight = max ( startPos , fruits [ - 1 ] [ 0 ] ) NEW_LINE amounts = [ 0 ] * ( 1 + maxRight ) NEW_LINE for position , amount in fruits : NEW_LINE INDENT amounts [ position ] = amount NEW_LINE DEDENT prefix = [ 0 ] + list ( itertools . accumulate ( amounts ) ) NEW_LINE def getFruits ( leftSteps : int , rightSteps : int ) -> int : NEW_LINE INDENT l = max ( 0 , startPos - leftSteps ) NEW_LINE r = min ( maxRight , startPos + rightSteps ) NEW_LINE return prefix [ r + 1 ] - prefix [ l ] NEW_LINE DEDENT for rightSteps in range ( min ( maxRight - startPos , k ) + 1 ) : NEW_LINE INDENT leftSteps = max ( 0 , k - 2 * rightSteps ) NEW_LINE ans = max ( ans , getFruits ( leftSteps , rightSteps ) ) NEW_LINE DEDENT for leftSteps in range ( min ( startPos , k ) + 1 ) : NEW_LINE INDENT rightSteps = max ( 0 , k - 2 * leftSteps ) NEW_LINE ans = max ( ans , getFruits ( leftSteps , rightSteps ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def firstPalindrome ( self , words : List [ str ] ) -> str : NEW_LINE INDENT def isPalindrome ( s : str ) -> bool : NEW_LINE INDENT i = 0 NEW_LINE j = len ( s ) - 1 NEW_LINE while i < j : NEW_LINE INDENT if s [ i ] != s [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT return next ( ( word for word in words if isPalindrome ( word ) ) , ' ' ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def addSpaces ( self , s : str , spaces : List [ int ] ) -> str : NEW_LINE INDENT ans = [ ] NEW_LINE j = 0 NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT if j < len ( spaces ) and i == spaces [ j ] : NEW_LINE INDENT ans . append ( ' ▁ ' ) NEW_LINE j += 1 NEW_LINE DEDENT ans . append ( c ) NEW_LINE DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class TrieNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . children : Dict [ str , TrieNode ] = defaultdict ( TrieNode ) NEW_LINE self . isWord = False NEW_LINE DEDENT DEDENT class WordDictionary : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . root = TrieNode ( ) NEW_LINE DEDENT def addWord ( self , word : str ) -> None : NEW_LINE INDENT node : TrieNode = self . root NEW_LINE for c in word : NEW_LINE INDENT if c not in node . children : NEW_LINE INDENT node . children [ c ] = TrieNode ( ) NEW_LINE DEDENT node = node . children [ c ] NEW_LINE DEDENT node . isWord = True NEW_LINE DEDENT def search ( self , word : str ) -> bool : NEW_LINE INDENT return self . _dfs ( word , 0 , self . root ) NEW_LINE DEDENT def _dfs ( self , word : str , s : int , node : TrieNode ) -> bool : NEW_LINE INDENT if s == len ( word ) : NEW_LINE INDENT return node . isWord NEW_LINE DEDENT if word [ s ] != ' . ' : NEW_LINE INDENT next : TrieNode = node . children [ word [ s ] ] NEW_LINE return self . _dfs ( word , s + 1 , next ) if next else False NEW_LINE DEDENT for c in string . ascii_lowercase : NEW_LINE INDENT if c in node . children and self . _dfs ( word , s + 1 , node . children [ c ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getDescentPeriods ( self , prices : List [ int ] ) -> int : NEW_LINE INDENT ans = 1 NEW_LINE dp = 1 NEW_LINE for i in range ( 1 , len ( prices ) ) : NEW_LINE INDENT if prices [ i ] == prices [ i - 1 ] - 1 : NEW_LINE INDENT dp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp = 1 NEW_LINE DEDENT ans += dp NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def kIncreasing ( self , arr : List [ int ] , k : int ) -> int : NEW_LINE INDENT def numReplaced ( A : List [ int ] ) -> int : NEW_LINE INDENT tail = [ ] NEW_LINE for a in A : NEW_LINE INDENT if not tail or tail [ - 1 ] <= a : NEW_LINE INDENT tail . append ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT tail [ bisect_right ( tail , a ) ] = a NEW_LINE DEDENT DEDENT return len ( A ) - len ( tail ) NEW_LINE DEDENT return sum ( numReplaced ( arr [ i : : k ] ) for i in range ( k ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def elementInNums ( self , nums : List [ int ] , queries : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT n = len ( nums ) NEW_LINE def f ( time : int , index : int ) -> int : NEW_LINE INDENT if time < n : NEW_LINE INDENT index += time NEW_LINE return - 1 if index >= n else nums [ index ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 if index >= time - n else nums [ index ] NEW_LINE DEDENT DEDENT return [ f ( time % ( 2 * n ) , index ) for time , index in queries ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mostWordsFound ( self , sentences : List [ str ] ) -> int : NEW_LINE INDENT return max ( s . count ( ' ▁ ' ) for s in sentences ) + 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findAllRecipes ( self , recipes : List [ str ] , ingredients : List [ List [ str ] ] , supplies : List [ str ] ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE supplies = set ( supplies ) NEW_LINE graph = defaultdict ( list ) NEW_LINE inDegree = Counter ( ) NEW_LINE q = deque ( ) NEW_LINE for i , recipe in enumerate ( recipes ) : NEW_LINE INDENT for ingredient in ingredients [ i ] : NEW_LINE INDENT if ingredient not in supplies : NEW_LINE INDENT graph [ ingredient ] . append ( recipe ) NEW_LINE inDegree [ recipe ] += 1 NEW_LINE DEDENT DEDENT DEDENT for recipe in recipes : NEW_LINE INDENT if inDegree [ recipe ] == 0 : NEW_LINE INDENT q . append ( recipe ) NEW_LINE DEDENT DEDENT while q : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE ans . append ( u ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT inDegree [ v ] -= 1 NEW_LINE if inDegree [ v ] == 0 : NEW_LINE INDENT q . append ( v ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canBeValid ( self , s : str , locked : str ) -> bool : NEW_LINE INDENT if len ( s ) & 1 : NEW_LINE INDENT return False NEW_LINE DEDENT def check ( s : str , locked : str , isForward : bool ) -> bool : NEW_LINE INDENT changeable = 0 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE for c , lock in zip ( s , locked ) : NEW_LINE INDENT if lock == '0' : NEW_LINE INDENT changeable += 1 NEW_LINE DEDENT elif c == ' ( ' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT if isForward and changeable + l - r < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if not isForward and changeable + r - l < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT return check ( s , locked , True ) and check ( s [ : : - 1 ] , locked [ : : - 1 ] , False ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def abbreviateProduct ( self , left : int , right : int ) -> str : NEW_LINE INDENT prod = 1.0 NEW_LINE suf = 1 NEW_LINE countDigits = 0 NEW_LINE countZeros = 0 NEW_LINE for num in range ( left , right + 1 ) : NEW_LINE INDENT prod *= num NEW_LINE while prod >= 1.0 : NEW_LINE INDENT prod /= 10 NEW_LINE countDigits += 1 NEW_LINE DEDENT suf *= num NEW_LINE while suf % 10 == 0 : NEW_LINE INDENT suf //= 10 NEW_LINE countZeros += 1 NEW_LINE DEDENT if suf > 10 ** 8 : NEW_LINE INDENT suf %= 10 ** 8 NEW_LINE DEDENT DEDENT if countDigits - countZeros <= 10 : NEW_LINE INDENT tens = 10 ** ( countDigits - countZeros ) NEW_LINE return str ( int ( prod * tens + 0.5 ) ) + ' e ' + str ( countZeros ) NEW_LINE DEDENT pre = str ( int ( prod * 10 ** 5 ) ) NEW_LINE suf = str ( suf ) [ - 5 : ] NEW_LINE return pre + ' . . . ' + suf + ' e ' + str ( countZeros ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isSameAfterReversals ( self , num : int ) -> bool : NEW_LINE INDENT def getReversed ( num : int ) -> int : NEW_LINE INDENT reversed = 0 NEW_LINE while num > 0 : NEW_LINE INDENT reversed = reversed * 10 + num % 10 NEW_LINE num //= 10 NEW_LINE DEDENT return reversed NEW_LINE DEDENT reversed1 = getReversed ( num ) NEW_LINE reversed2 = getReversed ( reversed1 ) NEW_LINE return reversed2 == num NEW_LINE DEDENT DEDENT
class TrieNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . children : Dict [ str , TrieNode ] = defaultdict ( TrieNode ) NEW_LINE self . word : Optional [ str ] = None NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def findWords ( self , board : List [ List [ str ] ] , words : List [ str ] ) -> List [ str ] : NEW_LINE INDENT m = len ( board ) NEW_LINE n = len ( board [ 0 ] ) NEW_LINE ans = [ ] NEW_LINE root = TrieNode ( ) NEW_LINE def insert ( word : str ) -> None : NEW_LINE INDENT node = root NEW_LINE for c in word : NEW_LINE INDENT if c not in node . children : NEW_LINE INDENT node . children [ c ] = TrieNode ( ) NEW_LINE DEDENT node = node . children [ c ] NEW_LINE DEDENT node . word = word NEW_LINE DEDENT for word in words : NEW_LINE INDENT insert ( word ) NEW_LINE DEDENT def dfs ( i : int , j : int , node : TrieNode ) -> None : NEW_LINE INDENT if i < 0 or i == m or j < 0 or j == n : NEW_LINE INDENT return NEW_LINE DEDENT if board [ i ] [ j ] == ' * ' : NEW_LINE INDENT return NEW_LINE DEDENT c = board [ i ] [ j ] NEW_LINE if c not in node . children : NEW_LINE INDENT return NEW_LINE DEDENT child = node . children [ c ] NEW_LINE if child . word : NEW_LINE INDENT ans . append ( child . word ) NEW_LINE child . word = None NEW_LINE DEDENT board [ i ] [ j ] = ' * ' NEW_LINE dfs ( i + 1 , j , child ) NEW_LINE dfs ( i - 1 , j , child ) NEW_LINE dfs ( i , j + 1 , child ) NEW_LINE dfs ( i , j - 1 , child ) NEW_LINE board [ i ] [ j ] = c NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dfs ( i , j , root ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def executeInstructions ( self , n : int , startPos : List [ int ] , s : str ) -> List [ int ] : NEW_LINE INDENT moves = { ' L ' : ( 0 , - 1 ) , ' R ' : ( 0 , 1 ) , ' U ' : ( - 1 , 0 ) , ' D ' : ( 1 , 0 ) } NEW_LINE m = len ( s ) NEW_LINE uMost = startPos [ 0 ] + 1 NEW_LINE dMost = n - startPos [ 0 ] NEW_LINE lMost = startPos [ 1 ] + 1 NEW_LINE rMost = n - startPos [ 1 ] NEW_LINE ans = [ 0 ] * m NEW_LINE reach = { ( 0 , None ) : m , ( None , 0 ) : m } NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in reversed ( range ( m ) ) : NEW_LINE INDENT dx , dy = moves [ s [ i ] ] NEW_LINE x -= dx NEW_LINE y -= dy NEW_LINE reach [ ( x , None ) ] = i NEW_LINE reach [ ( None , y ) ] = i NEW_LINE out = min ( reach . get ( ( x - uMost , None ) , math . inf ) , reach . get ( ( x + dMost , None ) , math . inf ) , reach . get ( ( None , y - lMost ) , math . inf ) , reach . get ( ( None , y + rMost ) , math . inf ) ) NEW_LINE ans [ i ] = m - i if out == math . inf else out - i - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getDistances ( self , arr : List [ int ] ) -> List [ int ] : NEW_LINE INDENT prefix = [ 0 ] * len ( arr ) NEW_LINE suffix = [ 0 ] * len ( arr ) NEW_LINE numToIndices = defaultdict ( list ) NEW_LINE for i , a in enumerate ( arr ) : NEW_LINE INDENT numToIndices [ a ] . append ( i ) NEW_LINE DEDENT for indices in numToIndices . values ( ) : NEW_LINE INDENT for i in range ( 1 , len ( indices ) ) : NEW_LINE INDENT currIndex = indices [ i ] NEW_LINE prevIndex = indices [ i - 1 ] NEW_LINE prefix [ currIndex ] += prefix [ prevIndex ] + i * ( currIndex - prevIndex ) NEW_LINE DEDENT for i in range ( len ( indices ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT currIndex = indices [ i ] NEW_LINE prevIndex = indices [ i + 1 ] NEW_LINE suffix [ currIndex ] += suffix [ prevIndex ] + ( len ( indices ) - i - 1 ) * ( prevIndex - currIndex ) NEW_LINE DEDENT DEDENT return [ p + s for p , s in zip ( prefix , suffix ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def recoverArray ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT nums = sorted ( nums ) NEW_LINE def getArray ( x : int , count : collections . Counter ) -> List [ int ] : NEW_LINE INDENT A = [ ] NEW_LINE for num in nums : NEW_LINE INDENT if count [ num ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if count [ num + x ] == 0 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT count [ num ] -= 1 NEW_LINE count [ num + x ] -= 1 NEW_LINE A . append ( num + x // 2 ) NEW_LINE DEDENT return A NEW_LINE DEDENT count = Counter ( nums ) NEW_LINE for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT x = nums [ i ] - nums [ 0 ] NEW_LINE if x <= 0 or x & 1 : NEW_LINE INDENT continue NEW_LINE DEDENT A = getArray ( x , count . copy ( ) ) NEW_LINE if A : NEW_LINE INDENT return A NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumOperations ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE seen = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE match = [ [ - 1 ] * n for _ in range ( m ) ] NEW_LINE def dfs ( i : int , j : int , sessionId : int ) -> int : NEW_LINE INDENT for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT if grid [ x ] [ y ] == 0 or seen [ x ] [ y ] == sessionId : NEW_LINE INDENT continue NEW_LINE DEDENT seen [ x ] [ y ] = sessionId NEW_LINE if match [ x ] [ y ] == - 1 or dfs ( * divmod ( match [ x ] [ y ] , n ) , sessionId ) : NEW_LINE INDENT match [ x ] [ y ] = i * n + j NEW_LINE match [ i ] [ j ] = x * n + y NEW_LINE return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 and match [ i ] [ j ] == - 1 : NEW_LINE INDENT sessionId = i * n + j NEW_LINE seen [ i ] [ j ] = sessionId NEW_LINE ans += dfs ( i , j , sessionId ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkString ( self , s : str ) -> bool : NEW_LINE INDENT return ' ba ' not in s NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberOfBeams ( self , bank : List [ str ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prevOnes = 0 NEW_LINE for row in bank : NEW_LINE INDENT ones = row . count ( '1' ) NEW_LINE if ones : NEW_LINE INDENT ans += prevOnes * ones NEW_LINE prevOnes = ones NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def asteroidsDestroyed ( self , mass : int , asteroids : List [ int ] ) -> bool : NEW_LINE INDENT for asteroid in sorted ( asteroids ) : NEW_LINE INDENT if mass >= asteroid : NEW_LINE INDENT mass += asteroid NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
from enum import Enum NEW_LINE class State ( Enum ) : NEW_LINE INDENT INIT = 0 NEW_LINE VISITING = 1 NEW_LINE VISITED = 2 NEW_LINE DEDENT class Solution : NEW_LINE INDENT def maximumInvitations ( self , favorite : List [ int ] ) -> int : NEW_LINE INDENT n = len ( favorite ) NEW_LINE sumComponentsLength = 0 NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE inDegree = [ 0 ] * n NEW_LINE maxChainLength = [ 1 ] * n NEW_LINE for i , f in enumerate ( favorite ) : NEW_LINE INDENT graph [ i ] . append ( f ) NEW_LINE inDegree [ f ] += 1 NEW_LINE DEDENT q = deque ( [ i for i , d in enumerate ( inDegree ) if d == 0 ] ) NEW_LINE while q : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT inDegree [ v ] -= 1 NEW_LINE if inDegree [ v ] == 0 : NEW_LINE INDENT q . append ( v ) NEW_LINE DEDENT maxChainLength [ v ] = max ( maxChainLength [ v ] , 1 + maxChainLength [ u ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if favorite [ favorite [ i ] ] == i : NEW_LINE INDENT sumComponentsLength += maxChainLength [ i ] + maxChainLength [ favorite [ i ] ] NEW_LINE DEDENT DEDENT maxCycleLength = 0 NEW_LINE parent = [ - 1 ] * n NEW_LINE seen = set ( ) NEW_LINE state = [ State . INIT ] * n NEW_LINE def findCycle ( u : int ) -> None : NEW_LINE INDENT nonlocal maxCycleLength NEW_LINE seen . add ( u ) NEW_LINE state [ u ] = State . VISITING NEW_LINE for v in graph [ u ] : NEW_LINE INDENT if v not in seen : NEW_LINE INDENT parent [ v ] = u NEW_LINE findCycle ( v ) NEW_LINE DEDENT elif state [ v ] == State . VISITING : NEW_LINE INDENT curr = u NEW_LINE cycleLength = 1 NEW_LINE while curr != v : NEW_LINE INDENT curr = parent [ curr ] NEW_LINE cycleLength += 1 NEW_LINE DEDENT maxCycleLength = max ( maxCycleLength , cycleLength ) NEW_LINE DEDENT DEDENT state [ u ] = State . VISITED NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if i not in seen : NEW_LINE INDENT findCycle ( i ) NEW_LINE DEDENT DEDENT return max ( sumComponentsLength // 2 , maxCycleLength ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeOnes ( self , grid : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT revRow = [ a ^ 1 for a in grid [ 0 ] ] NEW_LINE return all ( row == grid [ 0 ] or row == revRow for row in grid ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def capitalizeTitle ( self , title : str ) -> str : NEW_LINE INDENT return ' ▁ ' . join ( s . lower ( ) if len ( s ) < 3 else s . capitalize ( ) for s in title . split ( ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rob ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT if not nums : NEW_LINE INDENT return 0 NEW_LINE DEDENT if len ( nums ) < 2 : NEW_LINE INDENT return nums [ 0 ] NEW_LINE DEDENT def rob ( l : int , r : int ) -> int : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT temp = dp1 NEW_LINE dp1 = max ( dp1 , dp2 + nums [ i ] ) NEW_LINE dp2 = temp NEW_LINE DEDENT return dp1 NEW_LINE DEDENT return max ( rob ( 0 , len ( nums ) - 2 ) , rob ( 1 , len ( nums ) - 1 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def pairSum ( self , head : Optional [ ListNode ] ) -> int : NEW_LINE INDENT def reverseList ( head : ListNode ) -> ListNode : NEW_LINE INDENT prev = None NEW_LINE while head : NEW_LINE INDENT next = head . next NEW_LINE head . next = prev NEW_LINE prev = head NEW_LINE head = next NEW_LINE DEDENT return prev NEW_LINE DEDENT ans = 0 NEW_LINE slow = head NEW_LINE fast = head NEW_LINE while fast and fast . next : NEW_LINE INDENT slow = slow . next NEW_LINE fast = fast . next . next NEW_LINE DEDENT tail = reverseList ( slow ) NEW_LINE while tail : NEW_LINE INDENT ans = max ( ans , head . val + tail . val ) NEW_LINE head = head . next NEW_LINE tail = tail . next NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestPalindrome ( self , words : List [ str ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = [ [ 0 ] * 26 for _ in range ( 26 ) ] NEW_LINE for a , b in words : NEW_LINE INDENT i = ord ( a ) - ord ( ' a ' ) NEW_LINE j = ord ( b ) - ord ( ' a ' ) NEW_LINE if count [ j ] [ i ] : NEW_LINE INDENT ans += 4 NEW_LINE count [ j ] [ i ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] [ j ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if count [ i ] [ i ] : NEW_LINE INDENT return ans + 2 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def possibleToStamp ( self , grid : List [ List [ int ] ] , stampHeight : int , stampWidth : int ) -> bool : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE A = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE B = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE fit = [ [ False ] * n for _ in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT A [ i + 1 ] [ j + 1 ] = A [ i + 1 ] [ j ] + A [ i ] [ j + 1 ] - A [ i ] [ j ] + grid [ i ] [ j ] NEW_LINE if i + 1 >= stampHeight and j + 1 >= stampWidth : NEW_LINE INDENT x = i - stampHeight + 1 NEW_LINE y = j - stampWidth + 1 NEW_LINE if A [ i + 1 ] [ j + 1 ] - A [ x ] [ j + 1 ] - A [ i + 1 ] [ y ] + A [ x ] [ y ] == 0 : NEW_LINE INDENT fit [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT B [ i + 1 ] [ j + 1 ] = B [ i + 1 ] [ j ] + B [ i ] [ j + 1 ] - B [ i ] [ j ] + fit [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if not grid [ i ] [ j ] : NEW_LINE INDENT x = min ( i + stampHeight , m ) NEW_LINE y = min ( j + stampWidth , n ) NEW_LINE if B [ x ] [ y ] - B [ i ] [ y ] - B [ x ] [ j ] + B [ i ] [ j ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkValid ( self , matrix : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT return all ( min ( len ( set ( row ) ) , len ( set ( col ) ) ) == len ( matrix ) for row , col in zip ( matrix , zip ( * matrix ) ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minSwaps ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE k = nums . count ( 1 ) NEW_LINE ones = 0 NEW_LINE maxOnes = 0 NEW_LINE for i in range ( n * 2 ) : NEW_LINE INDENT if i >= k and nums [ i % n - k ] : NEW_LINE INDENT ones -= 1 NEW_LINE DEDENT if nums [ i % n ] : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT maxOnes = max ( maxOnes , ones ) NEW_LINE DEDENT return k - maxOnes NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def wordCount ( self , startWords : List [ str ] , targetWords : List [ str ] ) -> int : NEW_LINE INDENT def getMask ( s : str ) -> int : NEW_LINE INDENT mask = 0 NEW_LINE for c in s : NEW_LINE INDENT mask ^= 1 << ord ( c ) - ord ( ' a ' ) NEW_LINE DEDENT return mask NEW_LINE DEDENT ans = 0 NEW_LINE seen = set ( getMask ( w ) for w in startWords ) NEW_LINE for targetWord in targetWords : NEW_LINE INDENT mask = getMask ( targetWord ) NEW_LINE for c in targetWord : NEW_LINE INDENT if mask ^ 1 << ord ( c ) - ord ( ' a ' ) in seen : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def earliestFullBloom ( self , plantTime : List [ int ] , growTime : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE time = 0 NEW_LINE for p , g in sorted ( [ ( p , g ) for ( p , g ) in zip ( plantTime , growTime ) ] , key = lambda x : - x [ 1 ] ) : NEW_LINE INDENT time += p NEW_LINE ans = max ( ans , time + g ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def equalizeWater ( self , buckets : List [ int ] , loss : int ) -> float : NEW_LINE INDENT kErr = 1e-5 NEW_LINE kPercentage = ( 100 - loss ) / 100 NEW_LINE l = 0.0 NEW_LINE r = max ( buckets ) NEW_LINE def canFill ( target : float ) -> bool : NEW_LINE INDENT extra = 0 NEW_LINE need = 0 NEW_LINE for bucket in buckets : NEW_LINE INDENT if bucket > target : NEW_LINE INDENT extra += bucket - target NEW_LINE DEDENT else : NEW_LINE INDENT need += target - bucket NEW_LINE DEDENT DEDENT return extra * kPercentage >= need NEW_LINE DEDENT while r - l > kErr : NEW_LINE INDENT m = ( l + r ) / 2 NEW_LINE if canFill ( m ) : NEW_LINE INDENT l = m NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def divideString ( self , s : str , k : int , fill : chr ) -> List [ str ] : NEW_LINE INDENT return [ s [ i : ] + fill * ( i + k - len ( s ) ) if i + k > len ( s ) else s [ i : i + k ] for i in range ( 0 , len ( s ) , k ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minMoves ( self , target : int , maxDoubles : int ) -> int : NEW_LINE INDENT steps = 0 NEW_LINE while target > 1 and maxDoubles : NEW_LINE INDENT if target & 1 : NEW_LINE INDENT target -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT target //= 2 NEW_LINE maxDoubles -= 1 NEW_LINE DEDENT steps += 1 NEW_LINE DEDENT return steps + target - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def shortestPalindrome ( self , s : str ) -> str : NEW_LINE INDENT t = s [ : : - 1 ] NEW_LINE for i in range ( len ( t ) ) : NEW_LINE INDENT if s . startswith ( t [ i : ] ) : NEW_LINE INDENT return t [ : i ] + s NEW_LINE DEDENT DEDENT return t + s NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mostPoints ( self , questions : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( questions ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE for i in reversed ( range ( n ) ) : NEW_LINE INDENT points , brainpower = questions [ i ] NEW_LINE nextIndex = i + brainpower + 1 NEW_LINE nextPoints = dp [ nextIndex ] if nextIndex < n else 0 NEW_LINE dp [ i ] = max ( points + nextPoints , dp [ i + 1 ] ) NEW_LINE DEDENT return dp [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxRunTime ( self , n : int , batteries : List [ int ] ) -> int : NEW_LINE INDENT summ = sum ( batteries ) NEW_LINE batteries . sort ( ) NEW_LINE while batteries [ - 1 ] > summ // n : NEW_LINE INDENT summ -= batteries . pop ( ) NEW_LINE n += 1 NEW_LINE DEDENT return summ // n NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countSubranges ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE ans = 0 NEW_LINE dp = Counter ( ) NEW_LINE for a , b in zip ( nums1 , nums2 ) : NEW_LINE INDENT newDp = Counter ( ) NEW_LINE newDp [ a ] += 1 NEW_LINE newDp [ - b ] += 1 NEW_LINE for prevSum , count in dp . items ( ) : NEW_LINE INDENT newDp [ prevSum + a ] += count NEW_LINE newDp [ prevSum + a ] %= kMod NEW_LINE newDp [ prevSum - b ] += count NEW_LINE newDp [ prevSum - b ] %= kMod NEW_LINE DEDENT dp = newDp NEW_LINE ans += dp [ 0 ] NEW_LINE ans %= kMod NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumCost ( self , cost : List [ int ] ) -> int : NEW_LINE INDENT return sum ( cost ) - sum ( sorted ( cost ) [ - 3 : : - 3 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberOfArrays ( self , differences : List [ int ] , lower : int , upper : int ) -> int : NEW_LINE INDENT prefix = [ 0 ] + list ( itertools . accumulate ( differences ) ) NEW_LINE return max ( 0 , ( upper - lower ) - ( max ( prefix ) - min ( prefix ) ) + 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def highestRankedKItems ( self , grid : List [ List [ int ] ] , pricing : List [ int ] , start : List [ int ] , k : int ) -> List [ List [ int ] ] : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE low , high = pricing NEW_LINE row , col = start NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE ans = [ ] NEW_LINE if low <= grid [ row ] [ col ] <= high : NEW_LINE INDENT ans . append ( [ row , col ] ) NEW_LINE if k == 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT q = deque ( [ ( row , col ) ] ) NEW_LINE seen = { ( row , col ) } NEW_LINE while q : NEW_LINE INDENT neighbors = [ ] NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE for t in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ t ] NEW_LINE y = j + dirs [ t + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT if not grid [ x ] [ y ] or ( x , y ) in seen : NEW_LINE INDENT continue NEW_LINE DEDENT if low <= grid [ x ] [ y ] <= high : NEW_LINE INDENT neighbors . append ( [ x , y ] ) NEW_LINE DEDENT q . append ( ( x , y ) ) NEW_LINE seen . add ( ( x , y ) ) NEW_LINE DEDENT DEDENT neighbors . sort ( key = lambda x : ( grid [ x [ 0 ] ] [ x [ 1 ] ] , x [ 0 ] , x [ 1 ] ) ) NEW_LINE for neighbor in neighbors : NEW_LINE INDENT if len ( ans ) < k : NEW_LINE INDENT ans . append ( neighbor ) NEW_LINE DEDENT if len ( ans ) == k : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberOfWays ( self , corridor : str ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE ans = 1 NEW_LINE prevSeat = - 1 NEW_LINE numSeats = 0 NEW_LINE for i , c in enumerate ( corridor ) : NEW_LINE INDENT if c == ' S ' : NEW_LINE INDENT numSeats += 1 NEW_LINE if numSeats > 2 and numSeats & 1 : NEW_LINE INDENT ans = ans * ( i - prevSeat ) % kMod NEW_LINE DEDENT prevSeat = i NEW_LINE DEDENT DEDENT return ans if numSeats > 1 and numSeats % 2 == 0 else 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countElements ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT mini = min ( nums ) NEW_LINE maxi = max ( nums ) NEW_LINE return sum ( mini < num < maxi for num in nums ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rearrangeArray ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE pos = [ ] NEW_LINE neg = [ ] NEW_LINE for num in nums : NEW_LINE INDENT ( pos if num > 0 else neg ) . append ( num ) NEW_LINE DEDENT for p , n in zip ( pos , neg ) : NEW_LINE INDENT ans += [ p , n ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findKthLargest ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT minHeap = [ ] NEW_LINE for num in nums : NEW_LINE INDENT heapq . heappush ( minHeap , num ) NEW_LINE if len ( minHeap ) > k : NEW_LINE INDENT heapq . heappop ( minHeap ) NEW_LINE DEDENT DEDENT return minHeap [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findLonely ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT count = Counter ( nums ) NEW_LINE return [ num for num , freq in count . items ( ) if freq == 1 and count [ num - 1 ] == 0 and count [ num + 1 ] == 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumGood ( self , statements : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( statements ) NEW_LINE ans = 0 NEW_LINE def isValid ( good : List [ int ] ) -> bool : NEW_LINE INDENT for i , g in enumerate ( good ) : NEW_LINE INDENT if not g : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if statements [ i ] [ j ] == 2 : NEW_LINE INDENT continue NEW_LINE DEDENT if statements [ i ] [ j ] != good [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def dfs ( good : List [ int ] , i : int , count : int ) -> None : NEW_LINE INDENT nonlocal ans NEW_LINE if i == n : NEW_LINE INDENT if isValid ( good ) : NEW_LINE INDENT ans = max ( ans , count ) NEW_LINE DEDENT return NEW_LINE DEDENT good . append ( 0 ) NEW_LINE dfs ( good , i + 1 , count ) NEW_LINE good [ - 1 ] = 1 NEW_LINE dfs ( good , i + 1 , count + 1 ) NEW_LINE good . pop ( ) NEW_LINE DEDENT dfs ( [ ] , 0 , 0 ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumLines ( self , points : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( points ) NEW_LINE allCovered = ( 1 << n ) - 1 NEW_LINE maxLines = n // 2 + ( n & 1 ) NEW_LINE def getSlope ( p : List [ int ] , q : List [ int ] ) -> Tuple [ int , int ] : NEW_LINE INDENT dx = p [ 0 ] - q [ 0 ] NEW_LINE dy = p [ 1 ] - q [ 1 ] NEW_LINE if dx == 0 : NEW_LINE INDENT return ( 0 , p [ 0 ] ) NEW_LINE DEDENT if dy == 0 : NEW_LINE INDENT return ( p [ 1 ] , 0 ) NEW_LINE DEDENT d = gcd ( dx , dy ) NEW_LINE x = dx // d NEW_LINE y = dy // d NEW_LINE return ( x , y ) if x > 0 else ( - x , - y ) NEW_LINE DEDENT @ functools . lru_cache ( None ) NEW_LINE def dfs ( covered : int ) -> int : NEW_LINE INDENT if covered == allCovered : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = maxLines NEW_LINE for i in range ( n ) : NEW_LINE INDENT if covered >> i & 1 : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT newCovered = covered | 1 << i | 1 << j NEW_LINE slope = getSlope ( points [ i ] , points [ j ] ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT if getSlope ( points [ i ] , points [ k ] ) == slope : NEW_LINE INDENT newCovered |= 1 << k NEW_LINE DEDENT DEDENT ans = min ( ans , 1 + dfs ( newCovered ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return dfs ( 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxScoreIndices ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT zeros = nums . count ( 0 ) NEW_LINE ones = len ( nums ) - zeros NEW_LINE ans = [ 0 ] NEW_LINE leftZeros = 0 NEW_LINE leftOnes = 0 NEW_LINE maxScore = ones NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT leftZeros += num == 0 NEW_LINE leftOnes += num == 1 NEW_LINE rightOnes = ones - leftOnes NEW_LINE score = leftZeros + rightOnes NEW_LINE if maxScore == score : NEW_LINE INDENT ans . append ( i + 1 ) NEW_LINE DEDENT elif maxScore < score : NEW_LINE INDENT maxScore = score NEW_LINE ans = [ i + 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def subStrHash ( self , s : str , power : int , modulo : int , k : int , hashValue : int ) -> str : NEW_LINE INDENT maxPower = pow ( power , k , modulo ) NEW_LINE hashed = 0 NEW_LINE def val ( c : chr ) -> int : NEW_LINE INDENT return ord ( c ) - ord ( ' a ' ) + 1 NEW_LINE DEDENT for i , c in reversed ( list ( enumerate ( s ) ) ) : NEW_LINE INDENT hashed = ( hashed * power + val ( c ) ) % modulo NEW_LINE if i + k < len ( s ) : NEW_LINE INDENT hashed = ( hashed - val ( s [ i + k ] ) * maxPower ) % modulo NEW_LINE DEDENT if hashed == hashValue : NEW_LINE INDENT bestLeft = i NEW_LINE DEDENT DEDENT return s [ bestLeft : bestLeft + k ] NEW_LINE DEDENT DEDENT
class UnionFind : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . count = n NEW_LINE self . id = list ( range ( n ) ) NEW_LINE self . size = [ 1 ] * n NEW_LINE self . rank = [ 0 ] * n NEW_LINE DEDENT def union ( self , u : int , v : int ) -> None : NEW_LINE INDENT i = self . find ( u ) NEW_LINE j = self . find ( v ) NEW_LINE if i == j : NEW_LINE INDENT return NEW_LINE DEDENT if self . rank [ i ] < self . rank [ j ] : NEW_LINE INDENT self . id [ i ] = self . id [ j ] NEW_LINE self . size [ j ] += self . size [ i ] NEW_LINE DEDENT elif self . rank [ j ] < self . rank [ i ] : NEW_LINE INDENT self . id [ j ] = self . id [ i ] NEW_LINE self . size [ i ] += self . size [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT self . id [ i ] = self . id [ j ] NEW_LINE self . size [ j ] += self . size [ i ] NEW_LINE self . rank [ j ] += 1 NEW_LINE DEDENT self . count -= 1 NEW_LINE DEDENT def find ( self , u : int ) -> int : NEW_LINE INDENT if self . id [ u ] != u : NEW_LINE INDENT self . id [ u ] = self . find ( self . id [ u ] ) NEW_LINE DEDENT return self . id [ u ] NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def groupStrings ( self , words : List [ str ] ) -> List [ int ] : NEW_LINE INDENT uf = UnionFind ( len ( words ) ) NEW_LINE def getMask ( s : str ) -> int : NEW_LINE INDENT mask = 0 NEW_LINE for c in s : NEW_LINE INDENT mask |= 1 << ord ( c ) - ord ( ' a ' ) NEW_LINE DEDENT return mask NEW_LINE DEDENT def getAddedMasks ( mask : int ) : NEW_LINE INDENT for i in range ( 26 ) : NEW_LINE INDENT if not ( mask >> i & 1 ) : NEW_LINE INDENT yield mask | 1 << i NEW_LINE DEDENT DEDENT DEDENT def getDeletedMasks ( mask : int ) : NEW_LINE INDENT for i in range ( 26 ) : NEW_LINE INDENT if mask >> i & 1 : NEW_LINE INDENT yield mask ^ 1 << i NEW_LINE DEDENT DEDENT DEDENT maskToIndex = { getMask ( word ) : i for i , word in enumerate ( words ) } NEW_LINE deletedMaskToIndex = { } NEW_LINE for i , word in enumerate ( words ) : NEW_LINE INDENT mask = getMask ( word ) NEW_LINE for m in getAddedMasks ( mask ) : NEW_LINE INDENT if m in maskToIndex : NEW_LINE INDENT uf . union ( i , maskToIndex [ m ] ) NEW_LINE DEDENT DEDENT for m in getDeletedMasks ( mask ) : NEW_LINE INDENT if m in maskToIndex : NEW_LINE INDENT uf . union ( i , maskToIndex [ m ] ) NEW_LINE DEDENT if m in deletedMaskToIndex : NEW_LINE INDENT uf . union ( i , deletedMaskToIndex [ m ] ) NEW_LINE DEDENT else : NEW_LINE INDENT deletedMaskToIndex [ m ] = i NEW_LINE DEDENT DEDENT DEDENT return [ uf . count , max ( uf . size ) ] NEW_LINE DEDENT DEDENT
from sortedcontainers import SortedList NEW_LINE class Solution : NEW_LINE INDENT def amountPainted ( self , paint : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT minDay = min ( s for s , e in paint ) NEW_LINE maxDay = max ( e for s , e in paint ) NEW_LINE ans = [ 0 ] * len ( paint ) NEW_LINE runningIndices = SortedList ( ) NEW_LINE events = [ ] NEW_LINE for i , ( start , end ) in enumerate ( paint ) : NEW_LINE INDENT events . append ( ( start , i , 1 ) ) NEW_LINE events . append ( ( end , i , - 1 ) ) NEW_LINE DEDENT events . sort ( ) NEW_LINE i = 0 NEW_LINE for day in range ( minDay , maxDay ) : NEW_LINE INDENT while i < len ( events ) and events [ i ] [ 0 ] == day : NEW_LINE INDENT day , index , type = events [ i ] NEW_LINE if type == 1 : NEW_LINE INDENT runningIndices . add ( index ) NEW_LINE DEDENT else : NEW_LINE INDENT runningIndices . remove ( index ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if runningIndices : NEW_LINE INDENT ans [ runningIndices [ 0 ] ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def combinationSum3 ( self , k : int , n : int ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( k : int , n : int , s : int , path : List [ int ] ) -> None : NEW_LINE INDENT if k == 0 and n == 0 : NEW_LINE INDENT ans . append ( path ) NEW_LINE return NEW_LINE DEDENT if k == 0 or n < 0 : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( s , 10 ) : NEW_LINE INDENT dfs ( k - 1 , n - i , i + 1 , path + [ i ] ) NEW_LINE DEDENT DEDENT dfs ( k , n , 1 , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumSum ( self , num : int ) -> int : NEW_LINE INDENT s = sorted ( str ( num ) ) NEW_LINE return int ( s [ 0 ] + s [ 2 ] ) + int ( s [ 1 ] + s [ 3 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def pivotArray ( self , nums : List [ int ] , pivot : int ) -> List [ int ] : NEW_LINE INDENT return [ num for num in nums if num < pivot ] + [ num for num in nums if num == pivot ] + [ num for num in nums if num > pivot ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minCostSetTime ( self , startAt : int , moveCost : int , pushCost : int , targetSeconds : int ) -> int : NEW_LINE INDENT ans = math . inf NEW_LINE mins = 99 if targetSeconds > 5999 else targetSeconds // 60 NEW_LINE secs = targetSeconds - mins * 60 NEW_LINE def getCost ( mins : int , secs : int ) -> int : NEW_LINE INDENT cost = 0 NEW_LINE curr = str ( startAt ) NEW_LINE for c in str ( mins * 100 + secs ) : NEW_LINE INDENT if c == curr : NEW_LINE INDENT cost += pushCost NEW_LINE DEDENT else : NEW_LINE INDENT cost += moveCost + pushCost NEW_LINE curr = c NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT while secs < 100 : NEW_LINE INDENT ans = min ( ans , getCost ( mins , secs ) ) NEW_LINE mins -= 1 NEW_LINE secs += 60 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumDifference ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT n = len ( nums ) // 3 NEW_LINE ans = math . inf NEW_LINE leftSum = 0 NEW_LINE rightSum = 0 NEW_LINE maxHeap = [ ] NEW_LINE minHeap = [ ] NEW_LINE minLeftSum = [ 0 ] * len ( nums ) NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT heapq . heappush ( maxHeap , - nums [ i ] ) NEW_LINE leftSum += nums [ i ] NEW_LINE if len ( maxHeap ) == n + 1 : NEW_LINE INDENT leftSum += heapq . heappop ( maxHeap ) NEW_LINE DEDENT if len ( maxHeap ) == n : NEW_LINE INDENT minLeftSum [ i ] = leftSum NEW_LINE DEDENT DEDENT for i in range ( len ( nums ) - 1 , n - 1 , - 1 ) : NEW_LINE INDENT heapq . heappush ( minHeap , nums [ i ] ) NEW_LINE rightSum += nums [ i ] NEW_LINE if len ( minHeap ) == n + 1 : NEW_LINE INDENT rightSum -= heapq . heappop ( minHeap ) NEW_LINE DEDENT if len ( minHeap ) == n : NEW_LINE INDENT ans = min ( ans , minLeftSum [ i - 1 ] - rightSum ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sortEvenOdd ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * len ( nums ) NEW_LINE evenCount = Counter ( nums [ : : 2 ] ) NEW_LINE oddCount = Counter ( nums [ 1 : : 2 ] ) NEW_LINE ansIndex = 0 NEW_LINE for i in range ( 1 , 101 ) : NEW_LINE INDENT while evenCount [ i ] > 0 : NEW_LINE INDENT ans [ ansIndex ] = i NEW_LINE ansIndex += 2 NEW_LINE evenCount [ i ] -= 1 NEW_LINE DEDENT DEDENT ansIndex = 1 NEW_LINE for i in range ( 100 , 0 , - 1 ) : NEW_LINE INDENT while oddCount [ i ] > 0 : NEW_LINE INDENT ans [ ansIndex ] = i NEW_LINE ansIndex += 2 NEW_LINE oddCount [ i ] -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestNumber ( self , num : int ) -> int : NEW_LINE INDENT s = sorted ( str ( abs ( num ) ) , reverse = num < 0 ) NEW_LINE firstNonZeroIndex = next ( ( i for i , c in enumerate ( s ) if c != '0' ) , 0 ) NEW_LINE s [ 0 ] , s [ firstNonZeroIndex ] = s [ firstNonZeroIndex ] , s [ 0 ] NEW_LINE return int ( ' ' . join ( s ) ) * ( - 1 if num < 0 else 1 ) NEW_LINE DEDENT DEDENT
class Bitset : NEW_LINE INDENT def __init__ ( self , size : int ) : NEW_LINE INDENT self . s = [ '0' ] * size NEW_LINE self . r = [ '1' ] * size NEW_LINE self . cnt = 0 NEW_LINE DEDENT def fix ( self , idx : int ) -> None : NEW_LINE INDENT if self . s [ idx ] == '0' : NEW_LINE INDENT self . cnt += 1 NEW_LINE DEDENT self . s [ idx ] = '1' NEW_LINE self . r [ idx ] = '0' NEW_LINE DEDENT def unfix ( self , idx : int ) -> None : NEW_LINE INDENT if self . s [ idx ] == '1' : NEW_LINE INDENT self . cnt -= 1 NEW_LINE DEDENT self . s [ idx ] = '0' NEW_LINE self . r [ idx ] = '1' NEW_LINE DEDENT def flip ( self ) -> None : NEW_LINE INDENT self . s , self . r = self . r , self . s NEW_LINE self . cnt = len ( self . s ) - self . cnt NEW_LINE DEDENT def all ( self ) -> bool : NEW_LINE INDENT return self . cnt == len ( self . s ) NEW_LINE DEDENT def one ( self ) -> bool : NEW_LINE INDENT return self . cnt NEW_LINE DEDENT def count ( self ) -> int : NEW_LINE INDENT return self . cnt NEW_LINE DEDENT def toString ( self ) -> str : NEW_LINE INDENT return ' ' . join ( self . s ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumTime ( self , s : str ) -> int : NEW_LINE INDENT n = len ( s ) NEW_LINE left = [ 0 ] * n NEW_LINE left [ 0 ] = ord ( s [ 0 ] ) - ord ( '0' ) NEW_LINE dp = [ n ] * n NEW_LINE dp [ 0 ] = left [ 0 ] + n - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT left [ i ] = min ( left [ i - 1 ] + ( ord ( s [ i ] ) - ord ( '0' ) ) * 2 , i + 1 ) NEW_LINE dp [ i ] = min ( dp [ i ] , left [ i ] + n - 1 - i ) NEW_LINE DEDENT return min ( dp ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def equalDigitFrequency ( self , s : str ) -> int : NEW_LINE INDENT power = 11 NEW_LINE kMod = 1_000_000_007 NEW_LINE seen = set ( ) NEW_LINE def isUnique ( s : str , i : int , j : int ) -> bool : NEW_LINE INDENT count = [ 0 ] * 10 NEW_LINE unique = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT count [ ord ( s [ k ] ) - ord ( '0' ) ] += 1 NEW_LINE if count [ ord ( s [ k ] ) - ord ( '0' ) ] == 1 : NEW_LINE INDENT unique += 1 NEW_LINE DEDENT DEDENT maxCount = max ( count ) NEW_LINE return maxCount * unique == j - i + 1 NEW_LINE DEDENT def getRollingHash ( s : str , i : int , j : int ) -> int : NEW_LINE INDENT hashed = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT hashed = ( hashed * power + val ( s [ k ] ) ) % kMod NEW_LINE DEDENT return hashed NEW_LINE DEDENT def val ( c : chr ) -> int : NEW_LINE INDENT return ord ( c ) - ord ( '0' ) + 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i , len ( s ) ) : NEW_LINE INDENT if isUnique ( s , i , j ) : NEW_LINE INDENT seen . add ( getRollingHash ( s , i , j ) ) NEW_LINE DEDENT DEDENT DEDENT return len ( seen ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countOperations ( self , num1 : int , num2 : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE while num1 and num2 : NEW_LINE INDENT if num1 < num2 : NEW_LINE INDENT num1 , num2 = num2 , num1 NEW_LINE DEDENT ans += num1 // num2 NEW_LINE num1 %= num2 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def containsDuplicate ( self , nums : List [ int ] ) -> bool : NEW_LINE INDENT return len ( nums ) != len ( set ( nums ) ) NEW_LINE DEDENT DEDENT
class T : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . count = Counter ( ) NEW_LINE self . max = 0 NEW_LINE self . secondMax = 0 NEW_LINE self . maxFreq = 0 NEW_LINE self . secondMaxFreq = 0 NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def minimumOperations ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ts = [ T ( ) for _ in range ( 2 ) ] NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT t = ts [ i & 1 ] NEW_LINE t . count [ num ] += 1 NEW_LINE freq = t . count [ num ] NEW_LINE if freq > t . maxFreq : NEW_LINE INDENT t . maxFreq = freq NEW_LINE t . max = num NEW_LINE DEDENT elif freq > t . secondMaxFreq : NEW_LINE INDENT t . secondMaxFreq = freq NEW_LINE t . secondMax = num NEW_LINE DEDENT DEDENT if ts [ 0 ] . max == ts [ 1 ] . max : NEW_LINE INDENT return len ( nums ) - max ( ts [ 0 ] . maxFreq + ts [ 1 ] . secondMaxFreq , ts [ 1 ] . maxFreq + ts [ 0 ] . secondMaxFreq ) NEW_LINE DEDENT return len ( nums ) - ( ts [ 0 ] . maxFreq + ts [ 1 ] . maxFreq ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumRemoval ( self , beans : List [ int ] ) -> int : NEW_LINE INDENT n = len ( beans ) NEW_LINE summ = sum ( beans ) NEW_LINE return min ( summ - ( n - i ) * bean for i , bean in enumerate ( sorted ( beans ) ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumANDSum ( self , nums : List [ int ] , numSlots : int ) -> int : NEW_LINE INDENT n = 2 * numSlots NEW_LINE nSelected = 1 << n NEW_LINE dp = [ 0 ] * nSelected NEW_LINE nums += [ 0 ] * ( n - len ( nums ) ) NEW_LINE for mask in range ( 1 , nSelected ) : NEW_LINE INDENT selected = mask . bit_count ( ) NEW_LINE slot = ( selected + 1 ) // 2 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT if mask >> i & 1 : NEW_LINE INDENT dp [ mask ] = max ( dp [ mask ] , dp [ mask ^ 1 << i ] + ( slot & num ) ) NEW_LINE DEDENT DEDENT DEDENT return dp [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeOnes ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( mask : int ) -> int : NEW_LINE INDENT if mask == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = math . inf NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if mask >> i * n + j & 1 : NEW_LINE INDENT nextMask = mask NEW_LINE for k in range ( n ) : NEW_LINE INDENT nextMask &= ~ ( 1 << i * n + k ) NEW_LINE DEDENT for k in range ( m ) : NEW_LINE INDENT nextMask &= ~ ( 1 << k * n + j ) NEW_LINE DEDENT ans = min ( ans , 1 + dp ( nextMask ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT return dp ( self . encode ( grid , m , n ) ) NEW_LINE DEDENT def encode ( self , grid : List [ List [ int ] ] , m : int , n : int ) -> int : NEW_LINE INDENT encoded = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] : NEW_LINE INDENT encoded |= 1 << i * n + j NEW_LINE DEDENT DEDENT DEDENT return encoded NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countPairs ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE numToIndices = defaultdict ( list ) NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT numToIndices [ num ] . append ( i ) NEW_LINE DEDENT for indices in numToIndices . values ( ) : NEW_LINE INDENT gcds = Counter ( ) NEW_LINE for i in indices : NEW_LINE INDENT gcd_i = math . gcd ( i , k ) NEW_LINE for gcd_j , count in gcds . items ( ) : NEW_LINE INDENT if gcd_i * gcd_j % k == 0 : NEW_LINE INDENT ans += count NEW_LINE DEDENT DEDENT gcds [ gcd_i ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sumOfThree ( self , num : int ) -> List [ int ] : NEW_LINE INDENT if num % 3 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT x = num // 3 NEW_LINE return [ x - 1 , x , x + 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumEvenSplit ( self , finalSum : int ) -> List [ int ] : NEW_LINE INDENT if finalSum & 1 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT ans = [ ] NEW_LINE needSum = finalSum NEW_LINE even = 2 NEW_LINE while needSum - even >= even + 2 : NEW_LINE INDENT ans . append ( even ) NEW_LINE needSum -= even NEW_LINE even += 2 NEW_LINE DEDENT return ans + [ needSum ] NEW_LINE DEDENT DEDENT
class FenwickTree : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . sums = [ 0 ] * ( n + 1 ) NEW_LINE DEDENT def update ( self , i : int , delta : int ) -> None : NEW_LINE INDENT while i < len ( self . sums ) : NEW_LINE INDENT self . sums [ i ] += delta NEW_LINE i += self . _lowbit ( i ) NEW_LINE DEDENT DEDENT def get ( self , i : int ) -> int : NEW_LINE INDENT summ = 0 NEW_LINE while i > 0 : NEW_LINE INDENT summ += self . sums [ i ] NEW_LINE i -= self . _lowbit ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT def _lowbit ( self , i ) -> int : NEW_LINE INDENT return i & - i NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def goodTriplets ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> int : NEW_LINE INDENT n = len ( nums1 ) NEW_LINE numToIndex = { num : i for i , num in enumerate ( nums1 ) } NEW_LINE A = [ numToIndex [ num ] for num in nums2 ] NEW_LINE leftSmaller = [ 0 ] * n NEW_LINE rightLarger = [ 0 ] * n NEW_LINE tree1 = FenwickTree ( n ) NEW_LINE tree2 = FenwickTree ( n ) NEW_LINE for i , a in enumerate ( A ) : NEW_LINE INDENT leftSmaller [ i ] = tree1 . get ( a ) NEW_LINE tree1 . update ( a + 1 , 1 ) NEW_LINE DEDENT for i , a in reversed ( list ( enumerate ( A ) ) ) : NEW_LINE INDENT rightLarger [ i ] = tree2 . get ( n ) - tree2 . get ( a ) NEW_LINE tree2 . update ( a + 1 , 1 ) NEW_LINE DEDENT return sum ( a * b for a , b in zip ( leftSmaller , rightLarger ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getSkyline ( self , buildings : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT n = len ( buildings ) NEW_LINE if n == 0 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT left , right , height = buildings [ 0 ] NEW_LINE return [ [ left , height ] , [ right , 0 ] ] NEW_LINE DEDENT left = self . getSkyline ( buildings [ : n // 2 ] ) NEW_LINE right = self . getSkyline ( buildings [ n // 2 : ] ) NEW_LINE return self . _merge ( left , right ) NEW_LINE DEDENT def _merge ( self , left : List [ List [ int ] ] , right : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE leftY = 0 NEW_LINE rightY = 0 NEW_LINE while i < len ( left ) and j < len ( right ) : NEW_LINE INDENT if left [ i ] [ 0 ] < right [ j ] [ 0 ] : NEW_LINE INDENT leftY = left [ i ] [ 1 ] NEW_LINE self . _addPoint ( ans , left [ i ] [ 0 ] , max ( left [ i ] [ 1 ] , rightY ) ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT rightY = right [ j ] [ 1 ] NEW_LINE self . _addPoint ( ans , right [ j ] [ 0 ] , max ( right [ j ] [ 1 ] , leftY ) ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while i < len ( left ) : NEW_LINE INDENT self . _addPoint ( ans , left [ i ] [ 0 ] , left [ i ] [ 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT while j < len ( right ) : NEW_LINE INDENT self . _addPoint ( ans , right [ j ] [ 0 ] , right [ j ] [ 1 ] ) NEW_LINE j += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def _addPoint ( self , ans : List [ List [ int ] ] , x : int , y : int ) -> None : NEW_LINE INDENT if ans and ans [ - 1 ] [ 0 ] == x : NEW_LINE INDENT ans [ - 1 ] [ 1 ] = y NEW_LINE return NEW_LINE DEDENT if ans and ans [ - 1 ] [ 1 ] == y : NEW_LINE INDENT return NEW_LINE DEDENT ans . append ( [ x , y ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countEven ( self , num : int ) -> int : NEW_LINE INDENT return ( num - self . sumOfDigit ( num ) % 2 ) // 2 NEW_LINE DEDENT def sumOfDigit ( self , num : int ) -> int : NEW_LINE INDENT summ = 0 NEW_LINE while num : NEW_LINE INDENT summ += num % 10 NEW_LINE num //= 10 NEW_LINE DEDENT return summ NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mergeNodes ( self , head : Optional [ ListNode ] ) -> Optional [ ListNode ] : NEW_LINE INDENT if not head : NEW_LINE INDENT return None NEW_LINE DEDENT if not head . next . val : NEW_LINE INDENT node = ListNode ( head . val ) NEW_LINE node . next = self . mergeNodes ( head . next . next ) NEW_LINE return node NEW_LINE DEDENT next = self . mergeNodes ( head . next ) NEW_LINE next . val += head . val NEW_LINE return next NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def repeatLimitedString ( self , s : str , repeatLimit : int ) -> str : NEW_LINE INDENT ans = ' ' NEW_LINE count = Counter ( s ) NEW_LINE while True : NEW_LINE INDENT addOne = ans and self . _shouldAddOne ( ans , count ) NEW_LINE c = self . _getLargestChar ( ans , count ) NEW_LINE if c == ' ▁ ' : NEW_LINE INDENT break NEW_LINE DEDENT repeats = 1 if addOne else min ( count [ c ] , repeatLimit ) NEW_LINE ans += c * repeats NEW_LINE count [ c ] -= repeats NEW_LINE DEDENT return ans NEW_LINE DEDENT def _shouldAddOne ( self , ans : str , count : collections . Counter ) -> bool : NEW_LINE INDENT for c in reversed ( string . ascii_lowercase ) : NEW_LINE INDENT if count [ c ] : NEW_LINE INDENT return ans [ - 1 ] == c NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def _getLargestChar ( self , ans : str , count : collections . Counter ) -> int : NEW_LINE INDENT for c in reversed ( string . ascii_lowercase ) : NEW_LINE INDENT if count [ c ] and ( not ans or ans [ - 1 ] != c ) : NEW_LINE INDENT return c NEW_LINE DEDENT DEDENT return ' ▁ ' NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countPairs ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE gcds = Counter ( ) NEW_LINE for num in nums : NEW_LINE INDENT gcd_i = math . gcd ( num , k ) NEW_LINE for gcd_j , count in gcds . items ( ) : NEW_LINE INDENT if gcd_i * gcd_j % k == 0 : NEW_LINE INDENT ans += count NEW_LINE DEDENT DEDENT gcds [ gcd_i ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def buildWall ( self , height : int , width : int , bricks : List [ int ] ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE rows = [ ] NEW_LINE self . _buildRows ( width , bricks , 0 , rows ) NEW_LINE n = len ( rows ) NEW_LINE dp = [ 1 ] * n NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE for i , a in enumerate ( rows ) : NEW_LINE INDENT for j , b in enumerate ( rows ) : NEW_LINE INDENT if not a & b : NEW_LINE INDENT graph [ i ] . append ( j ) NEW_LINE DEDENT DEDENT DEDENT for _ in range ( 2 , height + 1 ) : NEW_LINE INDENT newDp = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for v in graph [ i ] : NEW_LINE INDENT newDp [ i ] += dp [ v ] NEW_LINE newDp [ i ] %= kMod NEW_LINE DEDENT DEDENT dp = newDp NEW_LINE DEDENT return sum ( dp ) % kMod NEW_LINE DEDENT def _buildRows ( self , width : int , bricks : List [ int ] , path : int , rows : List [ int ] ) : NEW_LINE INDENT for brick in bricks : NEW_LINE INDENT if brick == width : NEW_LINE INDENT rows . append ( path ) NEW_LINE DEDENT elif brick < width : NEW_LINE INDENT newWidth = width - brick NEW_LINE self . _buildRows ( newWidth , bricks , path | 2 << newWidth , rows ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def prefixCount ( self , words : List [ str ] , pref : str ) -> int : NEW_LINE INDENT return sum ( word . startswith ( pref ) for word in words ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minSteps ( self , s : str , t : str ) -> int : NEW_LINE INDENT count = Counter ( s ) NEW_LINE count . subtract ( Counter ( t ) ) NEW_LINE return sum ( [ abs ( c ) for c in count . values ( ) ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumTime ( self , time : List [ int ] , totalTrips : int ) -> int : NEW_LINE INDENT l = 1 NEW_LINE r = min ( time ) * totalTrips NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if sum ( m // t for t in time ) >= totalTrips : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumFinishTime ( self , tires : List [ List [ int ] ] , changeTime : int , numLaps : int ) -> int : NEW_LINE INDENT singleTire = [ math . inf ] * ( numLaps + 1 ) NEW_LINE dp = [ math . inf ] * ( numLaps + 1 ) NEW_LINE for i , ( f , r ) in enumerate ( tires ) : NEW_LINE INDENT sumSecs = 0 NEW_LINE rPower = 1 NEW_LINE for j in range ( 1 , numLaps + 1 ) : NEW_LINE INDENT if f * rPower >= changeTime + f : NEW_LINE INDENT break NEW_LINE DEDENT sumSecs += f * rPower NEW_LINE rPower *= r NEW_LINE singleTire [ j ] = min ( singleTire [ j ] , sumSecs ) NEW_LINE DEDENT DEDENT dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , numLaps + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ i - j ] + changeTime + singleTire [ j ] ) NEW_LINE DEDENT DEDENT return dp [ numLaps ] - changeTime NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def containsNearbyDuplicate ( self , nums : List [ int ] , k : int ) -> bool : NEW_LINE INDENT seen = set ( ) NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT if i > k : NEW_LINE INDENT seen . remove ( nums [ i - k - 1 ] ) NEW_LINE DEDENT if num in seen : NEW_LINE INDENT return True NEW_LINE DEDENT seen . add ( num ) NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mostFrequent ( self , nums : List [ int ] , key : int ) -> int : NEW_LINE INDENT count = Counter ( ) NEW_LINE for a , b in zip ( nums , nums [ 1 : ] ) : NEW_LINE INDENT if a == key : NEW_LINE INDENT count [ b ] += 1 NEW_LINE DEDENT DEDENT return max ( count , key = lambda k : count [ k ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sortJumbled ( self , mapping : List [ int ] , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT def getMapped ( num : int ) -> int : NEW_LINE INDENT mapped = [ ] NEW_LINE for c in str ( num ) : NEW_LINE INDENT mapped . append ( str ( mapping [ ord ( c ) - ord ( '0' ) ] ) ) NEW_LINE DEDENT return int ( ' ' . join ( mapped ) ) NEW_LINE DEDENT A = [ ( getMapped ( num ) , i , num ) for i , num in enumerate ( nums ) ] NEW_LINE return [ num for _ , i , num in sorted ( A ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getAncestors ( self , n : int , edges : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ [ ] for _ in range ( n ) ] NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE for u , v in edges : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE DEDENT def dfs ( u : int , ancestor : int , seen : Set [ int ] ) -> None : NEW_LINE INDENT seen . add ( u ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT if v in seen : NEW_LINE INDENT continue NEW_LINE DEDENT ans [ v ] . append ( ancestor ) NEW_LINE dfs ( v , ancestor , seen ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT dfs ( i , i , set ( ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minMovesToMakePalindrome ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE A = list ( s ) NEW_LINE while len ( A ) > 1 : NEW_LINE INDENT i = A . index ( A [ - 1 ] ) NEW_LINE if i == len ( A ) - 1 : NEW_LINE INDENT ans += i // 2 NEW_LINE DEDENT else : NEW_LINE INDENT A . pop ( i ) NEW_LINE ans += i NEW_LINE DEDENT A . pop ( ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def cellsInRange ( self , s : str ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE startCol , startRow , _ , endCol , endRow = s NEW_LINE for j in range ( ord ( startCol ) , ord ( endCol ) + 1 ) : NEW_LINE INDENT for i in range ( int ( startRow ) , int ( endRow ) + 1 ) : NEW_LINE INDENT ans . append ( chr ( j ) + str ( i ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimalKSum ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE nums . append ( 0 ) NEW_LINE nums . sort ( ) NEW_LINE for a , b in zip ( nums , nums [ 1 : ] ) : NEW_LINE INDENT if a == b : NEW_LINE INDENT continue NEW_LINE DEDENT l = a + 1 NEW_LINE r = min ( a + k , b - 1 ) NEW_LINE ans += ( l + r ) * ( r - l + 1 ) // 2 NEW_LINE k -= r - l + 1 NEW_LINE if k == 0 : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT if k > 0 : NEW_LINE INDENT l = nums [ - 1 ] + 1 NEW_LINE r = nums [ - 1 ] + k NEW_LINE ans += ( l + r ) * ( r - l + 1 ) // 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def createBinaryTree ( self , descriptions : List [ List [ int ] ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT children = set ( ) NEW_LINE valToNode = { } NEW_LINE for p , c , isLeft in descriptions : NEW_LINE INDENT parent = valToNode . setdefault ( p , TreeNode ( p ) ) NEW_LINE child = valToNode . setdefault ( c , TreeNode ( c ) ) NEW_LINE if isLeft : NEW_LINE INDENT parent . left = child NEW_LINE DEDENT else : NEW_LINE INDENT parent . right = child NEW_LINE DEDENT children . add ( c ) NEW_LINE DEDENT root = ( set ( valToNode ) - set ( children ) ) . pop ( ) NEW_LINE return valToNode [ root ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def replaceNonCoprimes ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE for num in nums : NEW_LINE INDENT while ans and gcd ( ans [ - 1 ] , num ) > 1 : NEW_LINE INDENT num = lcm ( ans . pop ( ) , num ) NEW_LINE DEDENT ans . append ( num ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def singleDivisorTriplet ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = Counter ( nums ) NEW_LINE def divisible ( summ : int , num : int ) -> int : NEW_LINE INDENT return summ % num == 0 NEW_LINE DEDENT for a in range ( 1 , 101 ) : NEW_LINE INDENT if count [ a ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT for b in range ( a , 101 ) : NEW_LINE INDENT if count [ b ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT for c in range ( b , 101 ) : NEW_LINE INDENT if count [ c ] == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT summ = a + b + c NEW_LINE if divisible ( summ , a ) + divisible ( summ , b ) + divisible ( summ , c ) != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT if a == b : NEW_LINE INDENT ans += count [ a ] * ( count [ a ] - 1 ) // 2 * count [ c ] NEW_LINE DEDENT elif b == c : NEW_LINE INDENT ans += count [ b ] * ( count [ b ] - 1 ) // 2 * count [ a ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += count [ a ] * count [ b ] * count [ c ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans * 6 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def generateParenthesis ( self , n ) : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( l : int , r : int , s : str ) -> None : NEW_LINE INDENT if l == 0 and r == 0 : NEW_LINE INDENT ans . append ( s ) NEW_LINE DEDENT if l > 0 : NEW_LINE INDENT dfs ( l - 1 , r , s + ' ( ' ) NEW_LINE DEDENT if l < r : NEW_LINE INDENT dfs ( l , r - 1 , s + ' ) ' ) NEW_LINE DEDENT DEDENT dfs ( n , n , ' ' ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findKDistantIndices ( self , nums : List [ int ] , key : int , k : int ) -> List [ int ] : NEW_LINE INDENT n = len ( nums ) NEW_LINE ans = [ ] NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j < n and ( nums [ j ] != key or j < i - k ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if j == n : NEW_LINE INDENT break NEW_LINE DEDENT if abs ( i - j ) <= k : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def digArtifacts ( self , n : int , artifacts : List [ List [ int ] ] , dig : List [ List [ int ] ] ) -> int : NEW_LINE INDENT digged = set ( ( r , c ) for r , c in dig ) NEW_LINE def canExtract ( a : List [ int ] ) -> bool : NEW_LINE INDENT for i in range ( a [ 0 ] , a [ 2 ] + 1 ) : NEW_LINE INDENT for j in range ( a [ 1 ] , a [ 3 ] + 1 ) : NEW_LINE INDENT if ( i , j ) not in digged : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT return sum ( canExtract ( a ) for a in artifacts ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumTop ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE if k == 0 or k == 1 : NEW_LINE INDENT return - 1 if n == k else nums [ k ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return - 1 if k & 1 else nums [ 0 ] NEW_LINE DEDENT maxi = max ( nums [ : min ( n , k - 1 ) ] ) NEW_LINE if k >= n : NEW_LINE INDENT return maxi NEW_LINE DEDENT return max ( maxi , nums [ k ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumWeight ( self , n : int , edges : List [ List [ int ] ] , src1 : int , src2 : int , dest : int ) -> int : NEW_LINE INDENT graph1 = [ [ ] for _ in range ( n ) ] NEW_LINE graph2 = [ [ ] for _ in range ( n ) ] NEW_LINE for u , v , w in edges : NEW_LINE INDENT graph1 [ u ] . append ( ( v , w ) ) NEW_LINE graph2 [ v ] . append ( ( u , w ) ) NEW_LINE DEDENT def dijkstra ( graph : List [ List [ Tuple [ int , int ] ] ] , src : int ) -> List [ int ] : NEW_LINE INDENT minHeap = [ ( 0 , src ) ] NEW_LINE dist = [ math . inf ] * n NEW_LINE while minHeap : NEW_LINE INDENT d , u = heapq . heappop ( minHeap ) NEW_LINE if dist [ u ] != math . inf : NEW_LINE INDENT continue NEW_LINE DEDENT dist [ u ] = d NEW_LINE for v , w in graph [ u ] : NEW_LINE INDENT heapq . heappush ( minHeap , ( d + w , v ) ) NEW_LINE DEDENT DEDENT return dist NEW_LINE DEDENT fromSrc1 = dijkstra ( graph1 , src1 ) NEW_LINE fromSrc2 = dijkstra ( graph1 , src2 ) NEW_LINE fromDest = dijkstra ( graph2 , dest ) NEW_LINE minWeight = min ( a + b + c for a , b , c in zip ( fromSrc1 , fromSrc2 , fromDest ) ) NEW_LINE return - 1 if minWeight == math . inf else minWeight NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def distanceToCycle ( self , n : int , edges : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * n NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE for u , v in edges : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT NO_RANK = - 2 NEW_LINE def getRank ( u : int , currRank : int , rank : List [ int ] ) -> int : NEW_LINE INDENT if rank [ u ] != NO_RANK : NEW_LINE INDENT return rank [ u ] NEW_LINE DEDENT rank [ u ] = currRank NEW_LINE minRank = currRank NEW_LINE for v in graph [ u ] : NEW_LINE INDENT if rank [ v ] == len ( rank ) or rank [ v ] == currRank - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT nextRank = getRank ( v , currRank + 1 , rank ) NEW_LINE if nextRank <= currRank : NEW_LINE INDENT cycle . append ( v ) NEW_LINE DEDENT minRank = min ( minRank , nextRank ) NEW_LINE DEDENT rank [ u ] = len ( rank ) NEW_LINE return minRank NEW_LINE DEDENT cycle = [ ] NEW_LINE getRank ( 0 , 0 , [ NO_RANK ] * n ) NEW_LINE q = deque ( cycle ) NEW_LINE seen = set ( cycle ) NEW_LINE dist = 0 NEW_LINE while q : NEW_LINE INDENT dist += 1 NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT if v in seen : NEW_LINE INDENT continue NEW_LINE DEDENT q . append ( v ) NEW_LINE seen . add ( v ) NEW_LINE ans [ v ] = dist NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def divideArray ( self , nums : List [ int ] ) -> bool : NEW_LINE INDENT return all ( value % 2 == 0 for value in Counter ( nums ) . values ( ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumSubsequenceCount ( self , text : str , pattern : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count0 = 0 NEW_LINE count1 = 0 NEW_LINE for i , c in enumerate ( text ) : NEW_LINE INDENT if c == pattern [ 1 ] : NEW_LINE INDENT ans += count0 NEW_LINE count1 += 1 NEW_LINE DEDENT if c == pattern [ 0 ] : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT DEDENT return ans + max ( count0 , count1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def halveArray ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT halfSum = sum ( nums ) / 2 NEW_LINE ans = 0 NEW_LINE runningSum = 0.0 NEW_LINE maxHeap = [ - num for num in nums ] NEW_LINE heapq . heapify ( maxHeap ) NEW_LINE while runningSum < halfSum : NEW_LINE INDENT maxValue = - heapq . heappop ( maxHeap ) / 2 NEW_LINE runningSum += maxValue NEW_LINE heapq . heappush ( maxHeap , - maxValue ) NEW_LINE ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumWhiteTiles ( self , floor : str , numCarpets : int , carpetLen : int ) -> int : NEW_LINE INDENT kMax = 1000 NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int , j : int ) -> int : NEW_LINE INDENT if j < 0 : NEW_LINE INDENT return kMax NEW_LINE DEDENT if i >= len ( floor ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( dp ( i + carpetLen , j - 1 ) , dp ( i + 1 , j ) + int ( floor [ i ] ) ) NEW_LINE DEDENT return dp ( 0 , numCarpets ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximalSquare ( self , matrix : List [ List [ str ] ] ) -> int : NEW_LINE INDENT m = len ( matrix ) NEW_LINE n = len ( matrix [ 0 ] ) NEW_LINE dp = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE maxLength = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i == 0 or j == 0 or matrix [ i ] [ j ] == '0' : NEW_LINE INDENT dp [ i ] [ j ] = 1 if matrix [ i ] [ j ] == '1' else 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + 1 NEW_LINE DEDENT maxLength = max ( maxLength , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return maxLength * maxLength NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countHillValley ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE left = nums [ 0 ] NEW_LINE for i in range ( 1 , len ( nums ) - 1 ) : NEW_LINE INDENT if left < nums [ i ] and nums [ i ] > nums [ i + 1 ] or left > nums [ i ] and nums [ i ] < nums [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE left = nums [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countCollisions ( self , directions : str ) -> int : NEW_LINE INDENT l = 0 NEW_LINE r = len ( directions ) - 1 NEW_LINE while l < len ( directions ) and directions [ l ] == ' L ' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT while r >= 0 and directions [ r ] == ' R ' : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT return sum ( c != ' S ' for c in directions [ l : r + 1 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumBobPoints ( self , numArrows : int , aliceArrows : List [ int ] ) -> List [ int ] : NEW_LINE INDENT allMask = ( 1 << 12 ) - 1 NEW_LINE maxPoint = 0 NEW_LINE maxMask = 0 NEW_LINE def getShotableAndPoint ( mask : int , leftArrows : int ) -> Tuple [ bool , int ] : NEW_LINE INDENT point = 0 NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT if mask >> i & 1 : NEW_LINE INDENT leftArrows -= aliceArrows [ i ] + 1 NEW_LINE point += i NEW_LINE DEDENT DEDENT return leftArrows >= 0 , point NEW_LINE DEDENT for mask in range ( allMask ) : NEW_LINE INDENT shotable , point = getShotableAndPoint ( mask , numArrows ) NEW_LINE if shotable and point > maxPoint : NEW_LINE INDENT maxPoint = point NEW_LINE maxMask = mask NEW_LINE DEDENT DEDENT def getBobsArrows ( mask : int , leftArrows : int ) -> List [ int ] : NEW_LINE INDENT bobsArrows = [ 0 ] * 12 NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT if mask >> i & 1 : NEW_LINE INDENT bobsArrows [ i ] = aliceArrows [ i ] + 1 NEW_LINE leftArrows -= aliceArrows [ i ] + 1 NEW_LINE DEDENT DEDENT bobsArrows [ 0 ] = leftArrows NEW_LINE return bobsArrows NEW_LINE DEDENT return getBobsArrows ( maxMask , numArrows ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumHealth ( self , damage : List [ int ] , armor : int ) -> int : NEW_LINE INDENT return 1 + sum ( damage ) - min ( max ( damage ) , armor ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findDifference ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> List [ List [ int ] ] : NEW_LINE INDENT set1 = set ( nums1 ) NEW_LINE set2 = set ( nums2 ) NEW_LINE return [ set1 - set2 , set2 - set1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minDeletion ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT if nums [ i ] == nums [ i + 1 ] and ( i - ans ) % 2 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans + ( ( len ( nums ) - ans ) & 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def kthPalindrome ( self , queries : List [ int ] , intLength : int ) -> List [ int ] : NEW_LINE INDENT start = pow ( 10 , ( intLength + 1 ) // 2 - 1 ) NEW_LINE end = pow ( 10 , ( intLength + 1 ) // 2 ) NEW_LINE mul = pow ( 10 , intLength // 2 ) NEW_LINE def reverse ( num : int ) -> int : NEW_LINE INDENT res = 0 NEW_LINE while num : NEW_LINE INDENT res = res * 10 + num % 10 NEW_LINE num //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def getKthPalindrome ( q : int ) -> int : NEW_LINE INDENT prefix = start + q - 1 NEW_LINE return prefix * mul + reverse ( prefix // 10 if intLength & 1 else prefix ) NEW_LINE DEDENT return [ - 1 if start + q > end else getKthPalindrome ( q ) for q in queries ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxValueOfCoins ( self , piles : List [ List [ int ] ] , k : int ) -> int : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int , k : int ) -> int : NEW_LINE INDENT if i == len ( piles ) or k == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = dp ( i + 1 , k ) NEW_LINE val = 0 NEW_LINE for j in range ( min ( len ( piles [ i ] ) , k ) ) : NEW_LINE INDENT val += piles [ i ] [ j ] NEW_LINE ans = max ( ans , val + dp ( i + 1 , k - j - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT return dp ( 0 , k ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumSumScore ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = - math . inf NEW_LINE prefix = 0 NEW_LINE summ = sum ( nums ) NEW_LINE for num in nums : NEW_LINE INDENT prefix += num NEW_LINE ans = max ( ans , prefix , summ - prefix + num ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countNodes ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 + self . countNodes ( root . left ) + self . countNodes ( root . right ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minBitFlips ( self , start : int , goal : int ) -> int : NEW_LINE INDENT return bin ( start ^ goal ) . count ( '1' ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def triangularSum ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT for sz in range ( len ( nums ) , 0 , - 1 ) : NEW_LINE INDENT for i in range ( sz - 1 ) : NEW_LINE INDENT nums [ i ] = ( nums [ i ] + nums [ i + 1 ] ) % 10 NEW_LINE DEDENT DEDENT return nums [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberOfWays ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE before = [ 0 ] * 2 NEW_LINE after = [ 0 ] * 2 NEW_LINE after [ 0 ] = s . count ( '0' ) NEW_LINE after [ 1 ] = len ( s ) - after [ 0 ] NEW_LINE for c in s : NEW_LINE INDENT num = ord ( c ) - ord ( '0' ) NEW_LINE after [ num ] -= 1 NEW_LINE if num == 0 : NEW_LINE INDENT ans += before [ 1 ] * after [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += before [ 0 ] * after [ 0 ] NEW_LINE DEDENT before [ num ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sumScores ( self , s : str ) -> int : NEW_LINE INDENT n = len ( s ) NEW_LINE z = [ 0 ] * n NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if i <= r : NEW_LINE INDENT z [ i ] = min ( r - i + 1 , z [ i - l ] ) NEW_LINE DEDENT while i + z [ i ] < n and s [ z [ i ] ] == s [ i + z [ i ] ] : NEW_LINE INDENT z [ i ] += 1 NEW_LINE DEDENT if i + z [ i ] - 1 > r : NEW_LINE INDENT l = i NEW_LINE r = i + z [ i ] - 1 NEW_LINE DEDENT DEDENT return sum ( z ) + n NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def convertTime ( self , current : str , correct : str ) -> int : NEW_LINE INDENT ops = [ 60 , 15 , 5 , 1 ] NEW_LINE def getMinutes ( s : str ) -> int : NEW_LINE INDENT return int ( s [ : 2 ] ) * 60 + int ( s [ 3 : ] ) NEW_LINE DEDENT diff = getMinutes ( correct ) - getMinutes ( current ) NEW_LINE ans = 0 NEW_LINE for op in ops : NEW_LINE INDENT ans += diff // op NEW_LINE diff %= op NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findWinners ( self , matches : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ [ ] for _ in range ( 2 ) ] NEW_LINE lossesCount = Counter ( ) NEW_LINE for winner , loser in matches : NEW_LINE INDENT if winner not in lossesCount : NEW_LINE INDENT lossesCount [ winner ] = 0 NEW_LINE DEDENT lossesCount [ loser ] += 1 NEW_LINE DEDENT for player , nLosses in lossesCount . items ( ) : NEW_LINE INDENT if nLosses < 2 : NEW_LINE INDENT ans [ nLosses ] . append ( player ) NEW_LINE DEDENT DEDENT return [ sorted ( ans [ 0 ] ) , sorted ( ans [ 1 ] ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumCandies ( self , candies : List [ int ] , k : int ) -> int : NEW_LINE INDENT l = 1 NEW_LINE r = sum ( candies ) // k NEW_LINE def numChildren ( m : int ) -> bool : NEW_LINE INDENT return sum ( c // m for c in candies ) NEW_LINE DEDENT while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if numChildren ( m ) < k : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l if numChildren ( l ) >= k else l - 1 NEW_LINE DEDENT DEDENT
class TrieNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . children : Dict [ str , TrieNode ] = defaultdict ( TrieNode ) NEW_LINE self . isWord = False NEW_LINE DEDENT DEDENT class Encrypter : NEW_LINE INDENT def __init__ ( self , keys : List [ str ] , values : List [ str ] , dictionary : List [ str ] ) : NEW_LINE INDENT self . keyToValue = { k : v for k , v in zip ( keys , values ) } NEW_LINE self . valueToKeys = defaultdict ( list ) NEW_LINE self . root = TrieNode ( ) NEW_LINE for k , v in zip ( keys , values ) : NEW_LINE INDENT self . valueToKeys [ v ] . append ( k ) NEW_LINE DEDENT for word in dictionary : NEW_LINE INDENT self . _insert ( word ) NEW_LINE DEDENT DEDENT def encrypt ( self , word1 : str ) -> str : NEW_LINE INDENT return ' ' . join ( self . keyToValue [ c ] for c in word1 ) NEW_LINE DEDENT def decrypt ( self , word2 : str ) -> int : NEW_LINE INDENT return self . _find ( word2 , 0 , self . root ) NEW_LINE DEDENT def _insert ( self , word : str ) -> None : NEW_LINE INDENT node = self . root NEW_LINE for c in word : NEW_LINE INDENT if c not in node . children : NEW_LINE INDENT node . children [ c ] = TrieNode ( ) NEW_LINE DEDENT node = node . children [ c ] NEW_LINE DEDENT node . isWord = True NEW_LINE DEDENT def _find ( self , word : str , i : int , node : TrieNode ) -> int : NEW_LINE INDENT value = word [ i : i + 2 ] NEW_LINE if value not in self . valueToKeys : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE if i + 2 == len ( word ) : NEW_LINE INDENT for key in self . valueToKeys [ value ] : NEW_LINE INDENT ans += node . children [ key ] . isWord NEW_LINE DEDENT return ans NEW_LINE DEDENT for key in self . valueToKeys [ value ] : NEW_LINE INDENT if key not in node . children : NEW_LINE INDENT continue NEW_LINE DEDENT ans += self . _find ( word , i + 2 , node . children [ key ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isConsecutive ( self , nums : List [ int ] ) -> bool : NEW_LINE INDENT return max ( nums ) - min ( nums ) + 1 == len ( set ( nums ) ) == len ( nums ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def computeArea ( self , A : int , B : int , C : int , D : int , E : int , F : int , G : int , H : int ) -> int : NEW_LINE INDENT x = min ( C , G ) - max ( A , E ) if max ( A , E ) < min ( C , G ) else 0 NEW_LINE y = min ( D , H ) - max ( B , F ) if max ( B , F ) < min ( D , H ) else 0 NEW_LINE return ( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestInteger ( self , num : int ) -> int : NEW_LINE INDENT s = str ( num ) NEW_LINE ans = 0 NEW_LINE maxHeap = [ [ ] for _ in range ( 2 ) ] NEW_LINE for c in s : NEW_LINE INDENT digit = ord ( c ) - ord ( '0' ) NEW_LINE heapq . heappush ( maxHeap [ digit & 1 ] , - digit ) NEW_LINE DEDENT for c in s : NEW_LINE INDENT i = ord ( c ) - ord ( '0' ) & 1 NEW_LINE ans = ( ans * 10 - heapq . heappop ( maxHeap [ i ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimizeResult ( self , expression : str ) -> str : NEW_LINE INDENT plusIndex = expression . index ( ' + ' ) NEW_LINE left = expression [ : plusIndex ] NEW_LINE right = expression [ plusIndex + 1 : ] NEW_LINE ans = ' ' NEW_LINE mini = math . inf NEW_LINE for i in range ( len ( left ) ) : NEW_LINE INDENT for j in range ( len ( right ) ) : NEW_LINE INDENT a = 1 if i == 0 else int ( left [ : i ] ) NEW_LINE b = int ( left [ i : ] ) NEW_LINE c = int ( right [ 0 : j + 1 ] ) NEW_LINE d = 1 if j == len ( right ) - 1 else int ( right [ j + 1 : ] ) NEW_LINE val = a * ( b + c ) * d NEW_LINE if val < mini : NEW_LINE INDENT mini = val NEW_LINE ans = ( ' ' if i == 0 else str ( a ) ) + ' ( ' + str ( b ) + ' + ' + str ( c ) + ' ) ' + ( ' ' if j == len ( right ) - 1 else str ( d ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumProduct ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE ans = 1 NEW_LINE minHeap = nums . copy ( ) NEW_LINE heapq . heapify ( minHeap ) NEW_LINE for _ in range ( k ) : NEW_LINE INDENT minNum = heapq . heappop ( minHeap ) NEW_LINE heapq . heappush ( minHeap , minNum + 1 ) NEW_LINE DEDENT while minHeap : NEW_LINE INDENT ans *= heapq . heappop ( minHeap ) NEW_LINE ans %= kMod NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumBeauty ( self , flowers : List [ int ] , newFlowers : int , target : int , full : int , partial : int ) -> int : NEW_LINE INDENT n = len ( flowers ) NEW_LINE flowers = [ min ( flower , target ) for flower in flowers ] NEW_LINE flowers . sort ( ) NEW_LINE if flowers [ 0 ] == target : NEW_LINE INDENT return n * full NEW_LINE DEDENT if newFlowers >= n * target - sum ( flowers ) : NEW_LINE INDENT return max ( n * full , ( n - 1 ) * full + ( target - 1 ) * partial ) NEW_LINE DEDENT ans = 0 NEW_LINE leftFlowers = newFlowers NEW_LINE cost = [ 0 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT cost [ i ] = cost [ i - 1 ] + i * ( flowers [ i ] - flowers [ i - 1 ] ) NEW_LINE DEDENT i = n - 1 NEW_LINE while flowers [ i ] == target : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT while leftFlowers >= 0 : NEW_LINE INDENT j = min ( i + 1 , bisect_right ( cost , leftFlowers ) ) NEW_LINE minIncomplete = flowers [ j - 1 ] + ( leftFlowers - cost [ j - 1 ] ) // j NEW_LINE ans = max ( ans , ( n - 1 - i ) * full + minIncomplete * partial ) NEW_LINE leftFlowers -= max ( 0 , target - flowers [ i ] ) NEW_LINE i -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT sum = operator . add NEW_LINE DEDENT
class Solution : NEW_LINE INDENT def checkTree ( self , root : Optional [ TreeNode ] ) -> bool : NEW_LINE INDENT return root . val == root . left . val + root . right . val NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def meetRequirement ( self , n : int , lights : List [ List [ int ] ] , requirement : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE currBrightness = 0 NEW_LINE change = [ 0 ] * ( n + 1 ) NEW_LINE for position , rg in lights : NEW_LINE INDENT change [ max ( 0 , position - rg ) ] += 1 NEW_LINE change [ min ( n , position + rg + 1 ) ] -= 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT currBrightness += change [ i ] NEW_LINE if currBrightness >= requirement [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findClosestNumber ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT nums . sort ( key = lambda x : ( abs ( x ) , - x ) ) NEW_LINE return nums [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def calculate ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE num = 0 NEW_LINE sign = 1 NEW_LINE stack = [ sign ] NEW_LINE for c in s : NEW_LINE INDENT if c . isdigit ( ) : NEW_LINE INDENT num = num * 10 + ( ord ( c ) - ord ( '0' ) ) NEW_LINE DEDENT elif c == ' ( ' : NEW_LINE INDENT stack . append ( sign ) NEW_LINE DEDENT elif c == ' ) ' : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT elif c == ' + ' or c == ' - ' : NEW_LINE INDENT ans += sign * num NEW_LINE sign = ( 1 if c == ' + ' else - 1 ) * stack [ - 1 ] NEW_LINE num = 0 NEW_LINE DEDENT DEDENT return ans + sign * num NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def waysToBuyPensPencils ( self , total : int , cost1 : int , cost2 : int ) -> int : NEW_LINE INDENT maxPen = total // cost1 NEW_LINE return sum ( ( total - i * cost1 ) // cost2 for i in range ( maxPen + 1 ) ) + maxPen + 1 NEW_LINE DEDENT DEDENT
class ATM : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . banknotes = [ 20 , 50 , 100 , 200 , 500 ] NEW_LINE self . bank = [ 0 ] * 5 NEW_LINE DEDENT def deposit ( self , banknotesCount : List [ int ] ) -> None : NEW_LINE INDENT for i in range ( 5 ) : NEW_LINE INDENT self . bank [ i ] += banknotesCount [ i ] NEW_LINE DEDENT DEDENT def withdraw ( self , amount : int ) -> List [ int ] : NEW_LINE INDENT withdrew = [ 0 ] * 5 NEW_LINE for i in reversed ( range ( 5 ) ) : NEW_LINE INDENT withdrew [ i ] = min ( self . bank [ i ] , amount // self . banknotes [ i ] ) NEW_LINE amount -= withdrew [ i ] * self . banknotes [ i ] NEW_LINE DEDENT if amount : NEW_LINE INDENT return [ - 1 ] NEW_LINE DEDENT for i in range ( 5 ) : NEW_LINE INDENT self . bank [ i ] -= withdrew [ i ] NEW_LINE DEDENT return withdrew NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumScore ( self , scores : List [ int ] , edges : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( scores ) NEW_LINE ans = - 1 NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE for u , v in edges : NEW_LINE INDENT graph [ u ] . append ( ( scores [ v ] , v ) ) NEW_LINE graph [ v ] . append ( ( scores [ u ] , u ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT graph [ i ] = heapq . nlargest ( 3 , graph [ i ] ) NEW_LINE DEDENT for u , v in edges : NEW_LINE INDENT for scoreA , a in graph [ u ] : NEW_LINE INDENT for scoreB , b in graph [ v ] : NEW_LINE INDENT if a != b and a != v and b != u : NEW_LINE INDENT ans = max ( ans , scoreA + scores [ u ] + scores [ v ] + scoreB ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def digitSum ( self , s : str , k : int ) -> str : NEW_LINE INDENT while len ( s ) > k : NEW_LINE INDENT next = [ ] NEW_LINE for i in range ( 0 , len ( s ) , k ) : NEW_LINE INDENT summ = 0 NEW_LINE for j in range ( i , min ( len ( s ) , i + k ) ) : NEW_LINE INDENT summ += ord ( s [ j ] ) - ord ( '0' ) NEW_LINE DEDENT next . append ( str ( summ ) ) NEW_LINE DEDENT s = ' ' . join ( next ) NEW_LINE DEDENT return s NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumRounds ( self , tasks : List [ int ] ) -> int : NEW_LINE INDENT freqs = Counter ( tasks ) . values ( ) NEW_LINE return - 1 if 1 in freqs else sum ( ( f + 2 ) // 3 for f in freqs ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxTrailingZeros ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE leftPrefix2 = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE leftPrefix5 = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE topPrefix2 = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE topPrefix5 = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE def getCount ( num : int , factor : int ) -> int : NEW_LINE INDENT count = 0 NEW_LINE while num % factor == 0 : NEW_LINE INDENT num //= factor NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT leftPrefix2 [ i ] [ j ] = getCount ( grid [ i ] [ j ] , 2 ) NEW_LINE leftPrefix5 [ i ] [ j ] = getCount ( grid [ i ] [ j ] , 5 ) NEW_LINE if j : NEW_LINE INDENT leftPrefix2 [ i ] [ j ] += leftPrefix2 [ i ] [ j - 1 ] NEW_LINE leftPrefix5 [ i ] [ j ] += leftPrefix5 [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT topPrefix2 [ i ] [ j ] = getCount ( grid [ i ] [ j ] , 2 ) NEW_LINE topPrefix5 [ i ] [ j ] = getCount ( grid [ i ] [ j ] , 5 ) NEW_LINE if i : NEW_LINE INDENT topPrefix2 [ i ] [ j ] += topPrefix2 [ i - 1 ] [ j ] NEW_LINE topPrefix5 [ i ] [ j ] += topPrefix5 [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT curr2 = getCount ( grid [ i ] [ j ] , 2 ) NEW_LINE curr5 = getCount ( grid [ i ] [ j ] , 5 ) NEW_LINE l2 = leftPrefix2 [ i ] [ j ] NEW_LINE l5 = leftPrefix5 [ i ] [ j ] NEW_LINE r2 = leftPrefix2 [ i ] [ n - 1 ] - ( 0 if j == 0 else leftPrefix2 [ i ] [ j - 1 ] ) NEW_LINE r5 = leftPrefix5 [ i ] [ n - 1 ] - ( 0 if j == 0 else leftPrefix5 [ i ] [ j - 1 ] ) NEW_LINE t2 = topPrefix2 [ i ] [ j ] NEW_LINE t5 = topPrefix5 [ i ] [ j ] NEW_LINE d2 = topPrefix2 [ m - 1 ] [ j ] - ( 0 if i == 0 else topPrefix2 [ i - 1 ] [ j ] ) NEW_LINE d5 = topPrefix5 [ m - 1 ] [ j ] - ( 0 if i == 0 else topPrefix5 [ i - 1 ] [ j ] ) NEW_LINE ans = max ( ans , min ( l2 + t2 - curr2 , l5 + t5 - curr5 ) , min ( r2 + t2 - curr2 , r5 + t5 - curr5 ) , min ( l2 + d2 - curr2 , l5 + d5 - curr5 ) , min ( r2 + d2 - curr2 , r5 + d5 - curr5 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestPath ( self , parent : List [ int ] , s : str ) -> int : NEW_LINE INDENT n = len ( parent ) NEW_LINE ans = 0 NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT graph [ parent [ i ] ] . append ( i ) NEW_LINE DEDENT def longestPathDownFrom ( u : int ) -> int : NEW_LINE INDENT nonlocal ans NEW_LINE max1 = 0 NEW_LINE max2 = 0 NEW_LINE for v in graph [ u ] : NEW_LINE INDENT res = longestPathDownFrom ( v ) NEW_LINE if s [ u ] == s [ v ] : NEW_LINE INDENT continue NEW_LINE DEDENT if res > max1 : NEW_LINE INDENT max2 = max1 NEW_LINE max1 = res NEW_LINE DEDENT elif res > max2 : NEW_LINE INDENT max2 = res NEW_LINE DEDENT DEDENT ans = max ( ans , 1 + max1 + max2 ) NEW_LINE return 1 + max1 NEW_LINE DEDENT longestPathDownFrom ( 0 ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumCost ( self , n : int , highways : List [ List [ int ] ] , k : int ) -> int : NEW_LINE INDENT if k + 1 > n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT graph = [ [ ] for _ in range ( n ) ] NEW_LINE for u , v , w in highways : NEW_LINE INDENT graph [ u ] . append ( ( v , w ) ) NEW_LINE graph [ v ] . append ( ( u , w ) ) NEW_LINE DEDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( u : int , mask : int ) -> int : NEW_LINE INDENT if mask . bit_count ( ) == k + 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = - 1 NEW_LINE for v , w in graph [ u ] : NEW_LINE INDENT if mask >> v & 1 : NEW_LINE INDENT continue NEW_LINE DEDENT res = dp ( v , mask | 1 << v ) NEW_LINE if res != - 1 : NEW_LINE INDENT ans = max ( ans , w + res ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return max ( dp ( i , 1 << i ) for i in range ( n ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def intersection ( self , nums : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT count = [ 0 ] * 1001 NEW_LINE for A in nums : NEW_LINE INDENT for a in A : NEW_LINE INDENT count [ a ] += 1 NEW_LINE DEDENT DEDENT return [ i for i , c in enumerate ( count ) if c == len ( nums ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countLatticePoints ( self , circles : List [ List [ int ] ] ) -> int : NEW_LINE INDENT return sum ( any ( ( xc - x ) ** 2 + ( yc - y ) ** 2 <= r ** 2 for xc , yc , r in circles ) for x in range ( 201 ) for y in range ( 201 ) ) NEW_LINE DEDENT DEDENT
class MyStack : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . q = deque ( ) NEW_LINE DEDENT def push ( self , x : int ) -> None : NEW_LINE INDENT self . q . append ( x ) NEW_LINE for _ in range ( len ( self . q ) - 1 ) : NEW_LINE INDENT self . q . append ( self . q . popleft ( ) ) NEW_LINE DEDENT DEDENT def pop ( self ) -> int : NEW_LINE INDENT return self . q . popleft ( ) NEW_LINE DEDENT def top ( self ) -> int : NEW_LINE INDENT return self . q [ 0 ] NEW_LINE DEDENT def empty ( self ) -> bool : NEW_LINE INDENT return not self . q NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countRectangles ( self , rectangles : List [ List [ int ] ] , points : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE yToXs = [ [ ] for _ in range ( 101 ) ] NEW_LINE for l , h in rectangles : NEW_LINE INDENT yToXs [ h ] . append ( l ) NEW_LINE DEDENT for xs in yToXs : NEW_LINE INDENT xs . sort ( ) NEW_LINE DEDENT for xi , yi in points : NEW_LINE INDENT count = 0 NEW_LINE for y in range ( yi , 101 ) : NEW_LINE INDENT xs = yToXs [ y ] NEW_LINE count += len ( xs ) - bisect_left ( xs , xi ) NEW_LINE DEDENT ans . append ( count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def fullBloomFlowers ( self , flowers : List [ List [ int ] ] , persons : List [ int ] ) -> List [ int ] : NEW_LINE INDENT starts = sorted ( s for s , _ in flowers ) NEW_LINE ends = sorted ( e for _ , e in flowers ) NEW_LINE return [ bisect_right ( starts , p ) - bisect_left ( ends , p ) for p in persons ] NEW_LINE DEDENT DEDENT
class VideoSharingPlatform : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . currVideoId = 0 NEW_LINE self . usedIds = [ ] NEW_LINE self . videoIdToVideo = { } NEW_LINE self . videoIdToViews = Counter ( ) NEW_LINE self . videoIdToLikes = Counter ( ) NEW_LINE self . videoIdToDislikes = Counter ( ) NEW_LINE DEDENT def upload ( self , video : str ) -> int : NEW_LINE INDENT videoId = self . _getVideoId ( ) NEW_LINE self . videoIdToVideo [ videoId ] = video NEW_LINE return videoId NEW_LINE DEDENT def remove ( self , videoId : int ) -> None : NEW_LINE INDENT if videoId in self . videoIdToVideo : NEW_LINE INDENT heapq . heappush ( self . usedIds , videoId ) NEW_LINE del self . videoIdToVideo [ videoId ] NEW_LINE del self . videoIdToViews [ videoId ] NEW_LINE del self . videoIdToLikes [ videoId ] NEW_LINE del self . videoIdToDislikes [ videoId ] NEW_LINE DEDENT DEDENT def watch ( self , videoId : int , startMinute : int , endMinute : int ) -> str : NEW_LINE INDENT if videoId not in self . videoIdToVideo : NEW_LINE INDENT return ' - 1' NEW_LINE DEDENT self . videoIdToViews [ videoId ] += 1 NEW_LINE video = self . videoIdToVideo [ videoId ] NEW_LINE return video [ startMinute : min ( endMinute + 1 , len ( video ) ) ] NEW_LINE DEDENT def like ( self , videoId : int ) -> None : NEW_LINE INDENT if videoId in self . videoIdToVideo : NEW_LINE INDENT self . videoIdToLikes [ videoId ] += 1 NEW_LINE DEDENT DEDENT def dislike ( self , videoId : int ) -> None : NEW_LINE INDENT if videoId in self . videoIdToVideo : NEW_LINE INDENT self . videoIdToDislikes [ videoId ] += 1 NEW_LINE DEDENT DEDENT def getLikesAndDislikes ( self , videoId : int ) -> List [ int ] : NEW_LINE INDENT if videoId in self . videoIdToVideo : NEW_LINE INDENT return [ self . videoIdToLikes [ videoId ] , self . videoIdToDislikes [ videoId ] ] NEW_LINE DEDENT return [ - 1 ] NEW_LINE DEDENT def getViews ( self , videoId : int ) -> int : NEW_LINE INDENT if videoId in self . videoIdToVideo : NEW_LINE INDENT return self . videoIdToViews [ videoId ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def _getVideoId ( self ) -> int : NEW_LINE INDENT if not self . usedIds : NEW_LINE INDENT self . currVideoId += 1 NEW_LINE return self . currVideoId - 1 NEW_LINE DEDENT return heapq . heappop ( self . usedIds ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countPrefixes ( self , words : List [ str ] , s : str ) -> int : NEW_LINE INDENT return sum ( map ( s . startswith , words ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumAverageDifference ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE ans = 0 NEW_LINE minDiff = inf NEW_LINE prefix = 0 NEW_LINE suffix = sum ( nums ) NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT prefix += num NEW_LINE suffix -= num NEW_LINE prefixAvg = prefix // ( i + 1 ) NEW_LINE suffixAvg = 0 if i == n - 1 else suffix // ( n - i - 1 ) NEW_LINE diff = abs ( prefixAvg - suffixAvg ) NEW_LINE if diff < minDiff : NEW_LINE INDENT ans = i NEW_LINE minDiff = diff NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countUnguarded ( self , m : int , n : int , guards : List [ List [ int ] ] , walls : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE grid = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE left = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE right = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE up = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE down = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE for row , col in guards : NEW_LINE INDENT grid [ row ] [ col ] = ' G ' NEW_LINE DEDENT for row , col in walls : NEW_LINE INDENT grid [ row ] [ col ] = ' W ' NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT lastCell = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] == ' G ' or grid [ i ] [ j ] == ' W ' : NEW_LINE INDENT lastCell = grid [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] [ j ] = lastCell NEW_LINE DEDENT DEDENT lastCell = 0 NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if grid [ i ] [ j ] == ' G ' or grid [ i ] [ j ] == ' W ' : NEW_LINE INDENT lastCell = grid [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] [ j ] = lastCell NEW_LINE DEDENT DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT lastCell = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if grid [ i ] [ j ] == ' G ' or grid [ i ] [ j ] == ' W ' : NEW_LINE INDENT lastCell = grid [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT up [ i ] [ j ] = lastCell NEW_LINE DEDENT DEDENT lastCell = 0 NEW_LINE for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT if grid [ i ] [ j ] == ' G ' or grid [ i ] [ j ] == ' W ' : NEW_LINE INDENT lastCell = grid [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT down [ i ] [ j ] = lastCell NEW_LINE DEDENT DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] == 0 and left [ i ] [ j ] != ' G ' and right [ i ] [ j ] != ' G ' and up [ i ] [ j ] != ' G ' and down [ i ] [ j ] != ' G ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumMinutes ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE kMax = len ( grid ) * len ( grid [ 0 ] ) NEW_LINE fireGrid = [ [ - 1 ] * len ( grid [ 0 ] ) for _ in range ( len ( grid [ 0 ] ) ) ] NEW_LINE self . _buildFireGrid ( grid , fireGrid , dirs ) NEW_LINE ans = - 1 NEW_LINE l = 0 NEW_LINE r = kMax NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if self . _canStayFor ( grid , fireGrid , m , dirs ) : NEW_LINE INDENT ans = m NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return 1e9 if ans == kMax else ans NEW_LINE DEDENT def _buildFireGrid ( self , grid : List [ List [ int ] ] , fireMinute : List [ List [ int ] ] , dirs : List [ int ] ) -> None : NEW_LINE INDENT minuteFromFire = 0 NEW_LINE q = deque ( ) NEW_LINE for i in range ( len ( grid ) ) : NEW_LINE INDENT for j in range ( len ( grid [ 0 ] ) ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT q . append ( ( i , j ) ) NEW_LINE fireMinute [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT while q : NEW_LINE INDENT minuteFromFire += 1 NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == len ( grid ) or y < 0 or y == len ( grid [ 0 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if grid [ x ] [ y ] == 2 : NEW_LINE INDENT continue NEW_LINE DEDENT if fireMinute [ x ] [ y ] != - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT fireMinute [ x ] [ y ] = minuteFromFire NEW_LINE q . append ( ( x , y ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def _canStayFor ( self , grid : List [ List [ int ] ] , fireMinute : List [ List [ int ] ] , minute : int , dirs : List [ int ] ) -> bool : NEW_LINE INDENT q = deque ( [ ( 0 , 0 ) ] ) NEW_LINE seen = { ( 0 , 0 ) } NEW_LINE while q : NEW_LINE INDENT minute += 1 NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == len ( grid ) or y < 0 or y == len ( grid [ 0 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if grid [ x ] [ y ] == 2 : NEW_LINE INDENT continue NEW_LINE DEDENT if x == len ( grid ) - 1 and y == len ( grid [ 0 ] ) - 1 : NEW_LINE INDENT if fireMinute [ x ] [ y ] != - 1 and fireMinute [ x ] [ y ] < minute : NEW_LINE INDENT continue NEW_LINE DEDENT return True NEW_LINE DEDENT if fireMinute [ x ] [ y ] != - 1 and fireMinute [ x ] [ y ] <= minute : NEW_LINE INDENT continue NEW_LINE DEDENT if seen [ x ] [ y ] : NEW_LINE INDENT continue NEW_LINE DEDENT q . append ( ( x , y ) ) NEW_LINE seen . add ( ( x , y ) ) NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT DEDENT

class Solution : NEW_LINE INDENT def invertTree ( self , root : Optional [ TreeNode ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return None NEW_LINE DEDENT left = root . left NEW_LINE right = root . right NEW_LINE root . left = self . invertTree ( right ) NEW_LINE root . right = self . invertTree ( left ) NEW_LINE return root NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumCardPickup ( self , cards : List [ int ] ) -> int : NEW_LINE INDENT ans = math . inf NEW_LINE lastOccurrence = { } NEW_LINE for i , card in enumerate ( cards ) : NEW_LINE INDENT if card in lastOccurrence : NEW_LINE INDENT ans = min ( ans , i - lastOccurrence [ card ] + 1 ) NEW_LINE DEDENT lastOccurrence [ card ] = i NEW_LINE DEDENT return - 1 if ans == math . inf else ans NEW_LINE DEDENT DEDENT
class TrieNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . children : Dict [ int , TrieNode ] = { } NEW_LINE self . count = 0 NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def countDistinct ( self , nums : List [ int ] , k : int , p : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE root = TrieNode ( ) NEW_LINE def insert ( node : TrieNode , i : int , k : int ) : NEW_LINE INDENT nonlocal ans NEW_LINE if i == len ( nums ) or k - ( nums [ i ] % p == 0 ) < 0 : NEW_LINE INDENT return NEW_LINE DEDENT if nums [ i ] not in node . children : NEW_LINE INDENT node . children [ nums [ i ] ] = TrieNode ( ) NEW_LINE ans += 1 NEW_LINE DEDENT insert ( node . children [ nums [ i ] ] , i + 1 , k - ( nums [ i ] % p == 0 ) ) NEW_LINE DEDENT for i , num in enumerate ( nums ) : NEW_LINE INDENT insert ( root , i , k ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def appealSum ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE dp = 0 NEW_LINE lastOccurrence = [ - 1 ] * 26 NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT dp += i - lastOccurrence [ ord ( c ) - ord ( ' a ' ) ] NEW_LINE ans += dp NEW_LINE lastOccurrence [ ord ( c ) - ord ( ' a ' ) ] = i NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def convertArray ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT def cost ( nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE minHeap = [ ] NEW_LINE for num in nums : NEW_LINE INDENT if minHeap and minHeap [ 0 ] < num : NEW_LINE INDENT ans += num - heapq . heappushpop ( minHeap , num ) NEW_LINE DEDENT heapq . heappush ( minHeap , num ) NEW_LINE DEDENT return ans NEW_LINE DEDENT return min ( cost ( nums ) , cost ( [ - num for num in nums ] ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestGoodInteger ( self , num : str ) -> str : NEW_LINE INDENT return max ( num [ i - 2 : i + 1 ] if num [ i ] == num [ i - 1 ] == num [ i - 2 ] else ' ' for i in range ( 2 , len ( num ) ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def averageOfSubtree ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE def dfs ( root : Optional [ TreeNode ] ) -> Tuple [ int , int ] : NEW_LINE INDENT nonlocal ans NEW_LINE if not root : NEW_LINE INDENT return ( 0 , 0 ) NEW_LINE DEDENT leftSum , leftCount = dfs ( root . left ) NEW_LINE rightSum , rightCount = dfs ( root . right ) NEW_LINE summ = root . val + leftSum + rightSum NEW_LINE count = 1 + leftCount + rightCount NEW_LINE if summ // count == root . val : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ( summ , count ) NEW_LINE DEDENT dfs ( root ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countTexts ( self , pressedKeys : str ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE n = len ( pressedKeys ) NEW_LINE dp = [ 0 ] * n + [ 1 ] NEW_LINE def isSame ( s : str , i : int , k : int ) -> bool : NEW_LINE INDENT if i + k > len ( s ) : NEW_LINE INDENT return False NEW_LINE DEDENT for j in range ( i + 1 , i + k ) : NEW_LINE INDENT if s [ j ] != s [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT for i in reversed ( range ( n ) ) : NEW_LINE INDENT dp [ i ] = dp [ i + 1 ] NEW_LINE if isSame ( pressedKeys , i , 2 ) : NEW_LINE INDENT dp [ i ] += dp [ i + 2 ] NEW_LINE DEDENT if isSame ( pressedKeys , i , 3 ) : NEW_LINE INDENT dp [ i ] += dp [ i + 3 ] NEW_LINE DEDENT if ( pressedKeys [ i ] == '7' or pressedKeys [ i ] == '9' ) and isSame ( pressedKeys , i , 4 ) : NEW_LINE INDENT dp [ i ] += dp [ i + 4 ] NEW_LINE DEDENT dp [ i ] %= kMod NEW_LINE DEDENT return dp [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def hasValidPath ( self , grid : List [ List [ chr ] ] ) -> bool : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int , j : int , k : int ) -> int : NEW_LINE INDENT if i == len ( grid ) or j == len ( grid [ 0 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT k += 1 if grid [ i ] [ j ] == ' ( ' else - 1 NEW_LINE if k < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if i == len ( grid ) - 1 and j == len ( grid [ 0 ] ) - 1 : NEW_LINE INDENT return k == 0 NEW_LINE DEDENT return dp ( i + 1 , j , k ) | dp ( i , j + 1 , k ) NEW_LINE DEDENT return dp ( 0 , 0 , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumKeypresses ( self , s : str ) -> int : NEW_LINE INDENT return sum ( c * ( i // 9 + 1 ) for i , c in enumerate ( sorted ( Counter ( s ) . values ( ) , reverse = True ) ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def divisorSubstrings ( self , num : int , k : int ) -> int : NEW_LINE INDENT s = str ( num ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) - k + 1 ) : NEW_LINE INDENT x = int ( s [ i : i + k ] ) NEW_LINE if x != 0 and num % x == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def calculate ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prevNum = 0 NEW_LINE currNum = 0 NEW_LINE op = ' + ' NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT if c . isdigit ( ) : NEW_LINE INDENT currNum = currNum * 10 + int ( c ) NEW_LINE DEDENT if not c . isdigit ( ) and c != ' ▁ ' or i == len ( s ) - 1 : NEW_LINE INDENT if op == ' + ' or op == ' - ' : NEW_LINE INDENT ans += prevNum NEW_LINE prevNum = currNum if op == ' + ' else - currNum NEW_LINE DEDENT elif op == ' * ' : NEW_LINE INDENT prevNum = prevNum * currNum NEW_LINE DEDENT elif op == ' / ' : NEW_LINE INDENT if prevNum < 0 : NEW_LINE INDENT prevNum = ceil ( prevNum / currNum ) NEW_LINE DEDENT else : NEW_LINE INDENT prevNum = prevNum // currNum NEW_LINE DEDENT DEDENT op = c NEW_LINE currNum = 0 NEW_LINE DEDENT DEDENT return ans + prevNum NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def waysToSplitArray ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prefix = 0 NEW_LINE suffix = sum ( nums ) NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT prefix += nums [ i ] NEW_LINE suffix -= nums [ i ] NEW_LINE if prefix >= suffix : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumWhiteTiles ( self , tiles : List [ List [ int ] ] , carpetLen : int ) -> int : NEW_LINE INDENT if any ( tile [ 1 ] - tile [ 0 ] + 1 >= carpetLen for tile in tiles ) : NEW_LINE INDENT return carpetLen NEW_LINE DEDENT ans = 0 NEW_LINE prefix = [ 0 ] * ( len ( tiles ) + 1 ) NEW_LINE tiles . sort ( ) NEW_LINE starts = [ tile [ 0 ] for tile in tiles ] NEW_LINE for i , tile in enumerate ( tiles ) : NEW_LINE INDENT length = tile [ 1 ] - tile [ 0 ] + 1 NEW_LINE prefix [ i + 1 ] = prefix [ i ] + length NEW_LINE DEDENT for i , ( s , _ ) in enumerate ( tiles ) : NEW_LINE INDENT carpetEnd = s + carpetLen - 1 NEW_LINE endIndex = bisect_right ( starts , carpetEnd ) - 1 NEW_LINE notCover = max ( 0 , tiles [ endIndex ] [ 1 ] - carpetEnd ) NEW_LINE ans = max ( ans , prefix [ endIndex + 1 ] - prefix [ i ] - notCover ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestVariance ( self , s : str ) -> int : NEW_LINE INDENT def kadane ( a : str , b : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE countA = 0 NEW_LINE countB = 0 NEW_LINE canExtendPrevB = False NEW_LINE for c in s : NEW_LINE INDENT if c != a and c != b : NEW_LINE INDENT continue NEW_LINE DEDENT if c == a : NEW_LINE INDENT countA += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countB += 1 NEW_LINE DEDENT if countB > 0 : NEW_LINE INDENT ans = max ( ans , countA - countB ) NEW_LINE DEDENT elif countB == 0 and canExtendPrevB : NEW_LINE INDENT ans = max ( ans , countA - 1 ) NEW_LINE DEDENT if countB > countA : NEW_LINE INDENT countA = 0 NEW_LINE countB = 0 NEW_LINE canExtendPrevB = True NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return max ( kadane ( c1 , c2 ) for c1 in string . ascii_lowercase for c2 in string . ascii_lowercase if c1 != c2 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeAnagrams ( self , words : List [ str ] ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE def isAnagram ( a : str , b : str ) -> bool : NEW_LINE INDENT count = Counter ( a ) NEW_LINE count . subtract ( Counter ( b ) ) NEW_LINE return all ( value == 0 for value in count . values ( ) ) NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( words ) : NEW_LINE INDENT j = i + 1 NEW_LINE while j < len ( words ) and isAnagram ( words [ i ] , words [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans . append ( words [ i ] ) NEW_LINE i = j NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxConsecutive ( self , bottom : int , top : int , special : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE special . sort ( ) NEW_LINE for a , b in zip ( special , special [ 1 : ] ) : NEW_LINE INDENT ans = max ( ans , b - a - 1 ) NEW_LINE DEDENT return max ( ans , special [ 0 ] - bottom , top - special [ - 1 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestCombination ( self , candidates : List [ int ] ) -> int : NEW_LINE INDENT return max ( sum ( c >> i & 1 for c in candidates ) for i in range ( 24 ) ) NEW_LINE DEDENT DEDENT
import sortedcontainers NEW_LINE class CountIntervals : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . intervals = sortedcontainers . SortedDict ( ) NEW_LINE self . cnt = 0 NEW_LINE DEDENT def add ( self , left : int , right : int ) -> None : NEW_LINE INDENT while self . _isOverlapped ( left , right ) : NEW_LINE INDENT i = self . intervals . bisect_right ( right ) - 1 NEW_LINE l , r = self . intervals . popitem ( i ) NEW_LINE left = min ( left , l ) NEW_LINE right = max ( right , r ) NEW_LINE self . cnt -= r - l + 1 NEW_LINE DEDENT self . intervals [ left ] = right NEW_LINE self . cnt += right - left + 1 NEW_LINE DEDENT def count ( self ) -> int : NEW_LINE INDENT return self . cnt NEW_LINE DEDENT def _isOverlapped ( self , left : int , right : int ) -> bool : NEW_LINE INDENT i = self . intervals . bisect_right ( right ) NEW_LINE return i > 0 and self . intervals . peekitem ( i - 1 ) [ 1 ] >= left NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def closestNode ( self , n : int , edges : List [ List [ int ] ] , query : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE dist = [ [ - 1 ] * n for _ in range ( n ) ] NEW_LINE for u , v in edges : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT def fillDist ( start : int , u : int , d : int ) -> None : NEW_LINE INDENT dist [ start ] [ u ] = d NEW_LINE for v in graph [ u ] : NEW_LINE INDENT if dist [ start ] [ v ] == - 1 : NEW_LINE INDENT fillDist ( start , v , d + 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT fillDist ( i , i , 0 ) NEW_LINE DEDENT def findClosest ( u : int , end : int , node : int , ans : int ) -> int : NEW_LINE INDENT for v in graph [ u ] : NEW_LINE INDENT if dist [ v ] [ end ] < dist [ u ] [ end ] : NEW_LINE INDENT return findClosest ( v , end , node , ans if dist [ ans ] [ node ] < dist [ v ] [ node ] else v ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return [ findClosest ( start , end , node , start ) for start , end , node in query ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def percentageLetter ( self , s : str , letter : str ) -> int : NEW_LINE INDENT return 100 * s . count ( letter ) // len ( s ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumBags ( self , capacity : List [ int ] , rocks : List [ int ] , additionalRocks : int ) -> int : NEW_LINE INDENT for i , d in enumerate ( sorted ( [ c - r for c , r in zip ( capacity , rocks ) ] ) ) : NEW_LINE INDENT if d > additionalRocks : NEW_LINE INDENT return i NEW_LINE DEDENT additionalRocks -= d NEW_LINE DEDENT return len ( capacity ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def summaryRanges ( self , nums : List [ int ] ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE i = 0 NEW_LINE while i < len ( nums ) : NEW_LINE INDENT begin = nums [ i ] NEW_LINE while i < len ( nums ) - 1 and nums [ i ] == nums [ i + 1 ] - 1 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT end = nums [ i ] NEW_LINE if begin == end : NEW_LINE INDENT ans . append ( str ( begin ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( str ( begin ) + " - > " + str ( end ) ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumLines ( self , stockPrices : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE stockPrices . sort ( ) NEW_LINE def getSlope ( p : List [ int ] , q : List [ int ] ) -> Tuple [ int , int ] : NEW_LINE INDENT dx = p [ 0 ] - q [ 0 ] NEW_LINE dy = p [ 1 ] - q [ 1 ] NEW_LINE if dx == 0 : NEW_LINE INDENT return ( 0 , p [ 0 ] ) NEW_LINE DEDENT if dy == 0 : NEW_LINE INDENT return ( p [ 1 ] , 0 ) NEW_LINE DEDENT d = gcd ( dx , dy ) NEW_LINE return ( dx // d , dy // d ) NEW_LINE DEDENT for i in range ( 2 , len ( stockPrices ) ) : NEW_LINE INDENT a = getSlope ( stockPrices [ i - 2 ] , stockPrices [ i - 1 ] ) NEW_LINE b = getSlope ( stockPrices [ i - 1 ] , stockPrices [ i ] ) NEW_LINE if a != b : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans + ( len ( stockPrices ) > 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def totalStrength ( self , strength : List [ int ] ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE n = len ( strength ) NEW_LINE left = [ - 1 ] * n NEW_LINE stack = [ ] NEW_LINE for i in reversed ( range ( n ) ) : NEW_LINE INDENT while stack and strength [ stack [ - 1 ] ] >= strength [ i ] : NEW_LINE INDENT left [ stack . pop ( ) ] = i NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT right = [ n ] * n NEW_LINE stack = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT while stack and strength [ stack [ - 1 ] ] > strength [ i ] : NEW_LINE INDENT right [ stack . pop ( ) ] = i NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT ans = 0 NEW_LINE prefixOfPrefix = list ( itertools . accumulate ( itertools . accumulate ( strength ) , initial = 0 ) ) NEW_LINE for i , ( l , r ) in enumerate ( zip ( left , right ) ) : NEW_LINE INDENT leftSum = prefixOfPrefix [ i ] - prefixOfPrefix [ max ( 0 , l ) ] NEW_LINE rightSum = prefixOfPrefix [ r ] - prefixOfPrefix [ i ] NEW_LINE leftLen = i - l NEW_LINE rightLen = r - i NEW_LINE ans += strength [ i ] * ( rightSum * leftLen - leftSum * rightLen ) % kMod NEW_LINE DEDENT return ans % kMod NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def seePeople ( self , heights : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT m = len ( heights ) NEW_LINE n = len ( heights [ 0 ] ) NEW_LINE ans = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE for i , row in enumerate ( heights ) : NEW_LINE INDENT stack = [ ] NEW_LINE for j , height in enumerate ( row ) : NEW_LINE INDENT hasEqualHeight = False NEW_LINE while stack and row [ stack [ - 1 ] ] <= height : NEW_LINE INDENT if row [ stack [ - 1 ] ] == height : NEW_LINE INDENT hasEqualHeight = True NEW_LINE DEDENT ans [ i ] [ stack . pop ( ) ] += 1 NEW_LINE DEDENT if stack and not hasEqualHeight : NEW_LINE INDENT ans [ i ] [ stack [ - 1 ] ] += 1 NEW_LINE DEDENT stack . append ( j ) NEW_LINE DEDENT DEDENT for j , col in enumerate ( zip ( * heights ) ) : NEW_LINE INDENT stack = [ ] NEW_LINE for i , height in enumerate ( col ) : NEW_LINE INDENT hasEqualHeight = False NEW_LINE while stack and col [ stack [ - 1 ] ] <= height : NEW_LINE INDENT if col [ stack [ - 1 ] ] == height : NEW_LINE INDENT hasEqualHeight = True NEW_LINE DEDENT ans [ stack . pop ( ) ] [ j ] += 1 NEW_LINE DEDENT if stack and not hasEqualHeight : NEW_LINE INDENT ans [ stack [ - 1 ] ] [ j ] += 1 NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def digitCount ( self , num : str ) -> bool : NEW_LINE INDENT count = Counter ( num ) NEW_LINE return all ( count [ str ( i ) ] == int ( digit ) for i , digit in enumerate ( num ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestWordCount ( self , messages : List [ str ] , senders : List [ str ] ) -> str : NEW_LINE INDENT n = len ( messages ) NEW_LINE ans = ' ' NEW_LINE maxWordsSent = 0 NEW_LINE count = Counter ( ) NEW_LINE for message , sender in zip ( messages , senders ) : NEW_LINE INDENT wordsCount = message . count ( ' ▁ ' ) + 1 NEW_LINE count [ sender ] += wordsCount NEW_LINE numWordsSent = count [ sender ] NEW_LINE if numWordsSent > maxWordsSent : NEW_LINE INDENT ans = sender NEW_LINE maxWordsSent = numWordsSent NEW_LINE DEDENT elif numWordsSent == maxWordsSent and sender > ans : NEW_LINE INDENT ans = sender NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumImportance ( self , n : int , roads : List [ List [ int ] ] ) -> int : NEW_LINE INDENT count = [ 0 ] * n NEW_LINE for u , v in roads : NEW_LINE INDENT count [ u ] += 1 NEW_LINE count [ v ] += 1 NEW_LINE DEDENT count . sort ( ) NEW_LINE return sum ( ( i + 1 ) * c for i , c in enumerate ( count ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rearrangeCharacters ( self , s : str , target : str ) -> int : NEW_LINE INDENT countS = Counter ( s ) NEW_LINE countT = Counter ( target ) NEW_LINE return min ( countS [ c ] // countT [ c ] for c in target ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def discountPrices ( self , sentence : str , discount : int ) -> str : NEW_LINE INDENT kPrecision = 2 NEW_LINE ans = [ ] NEW_LINE for word in sentence . split ( ) : NEW_LINE INDENT if word [ 0 ] == ' $ ' and len ( word ) > 1 : NEW_LINE INDENT digits = word [ 1 : ] NEW_LINE if all ( digit . isdigit ( ) for digit in digits ) : NEW_LINE INDENT val = float ( digits ) * ( 100 - discount ) / 100 NEW_LINE s = f ' { val : .2f } ' NEW_LINE trimmed = s [ : s . index ( ' . ' ) + kPrecision + 1 ] NEW_LINE ans . append ( ' $ ' + trimmed ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( word ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans . append ( word ) NEW_LINE DEDENT DEDENT return ' ▁ ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def totalSteps ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT dp = [ 0 ] * len ( nums ) NEW_LINE stack = [ ] NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT step = 1 NEW_LINE while stack and nums [ stack [ - 1 ] ] <= num : NEW_LINE INDENT step = max ( step , dp [ stack . pop ( ) ] + 1 ) NEW_LINE DEDENT if stack : NEW_LINE INDENT dp [ i ] = step NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def majorityElement ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans1 = 0 NEW_LINE ans2 = 1 NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE for num in nums : NEW_LINE INDENT if num == ans1 : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT elif num == ans2 : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT elif count1 == 0 : NEW_LINE INDENT ans1 = num NEW_LINE count1 = 1 NEW_LINE DEDENT elif count2 == 0 : NEW_LINE INDENT ans2 = num NEW_LINE count2 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 -= 1 NEW_LINE count2 -= 1 NEW_LINE DEDENT DEDENT return [ ans for ans in ( ans1 , ans2 ) if nums . count ( ans ) > len ( nums ) // 3 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumObstacles ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE minHeap = [ ( grid [ 0 ] [ 0 ] , 0 , 0 ) ] NEW_LINE dist = [ [ math . inf ] * n for _ in range ( m ) ] NEW_LINE dist [ 0 ] [ 0 ] = grid [ 0 ] [ 0 ] NEW_LINE while minHeap : NEW_LINE INDENT d , i , j = heapq . heappop ( minHeap ) NEW_LINE if i == m - 1 and j == n - 1 : NEW_LINE INDENT return d NEW_LINE DEDENT for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT newDist = d + grid [ i ] [ j ] NEW_LINE if newDist < dist [ x ] [ y ] : NEW_LINE INDENT dist [ x ] [ y ] = newDist NEW_LINE heapq . heappush ( minHeap , ( newDist , x , y ) ) NEW_LINE DEDENT DEDENT DEDENT return dist [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumProfit ( self , present : List [ int ] , future : List [ int ] , budget : int ) -> int : NEW_LINE INDENT n = len ( present ) NEW_LINE dp = [ [ 0 ] * ( budget + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT profit = future [ i - 1 ] - present [ i - 1 ] NEW_LINE for j in range ( budget + 1 ) : NEW_LINE INDENT if j < present [ i - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , profit + dp [ i - 1 ] [ j - present [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ budget ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minMaxGame ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT if len ( nums ) == 1 : NEW_LINE INDENT return nums [ 0 ] NEW_LINE DEDENT nextNums = [ ] NEW_LINE for i in range ( len ( nums ) // 2 ) : NEW_LINE INDENT nextNums . append ( max ( nums [ 2 * i ] , nums [ 2 * i + 1 ] ) if i & 1 else min ( nums [ 2 * i ] , nums [ 2 * i + 1 ] ) ) NEW_LINE DEDENT return self . minMaxGame ( nextNums ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def partitionArray ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT nums . sort ( ) NEW_LINE ans = 1 NEW_LINE min = nums [ 0 ] NEW_LINE for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT if min + k < nums [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE min = nums [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def arrayChange ( self , nums : List [ int ] , operations : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT numToIndex = { num : i for i , num in enumerate ( nums ) } NEW_LINE for original , replaced in operations : NEW_LINE INDENT index = numToIndex [ original ] NEW_LINE nums [ index ] = replaced NEW_LINE del numToIndex [ original ] NEW_LINE numToIndex [ replaced ] = index NEW_LINE DEDENT return nums NEW_LINE DEDENT DEDENT
class TextEditor : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . s = [ ] NEW_LINE self . stack = [ ] NEW_LINE DEDENT def addText ( self , text : str ) -> None : NEW_LINE INDENT for c in text : NEW_LINE INDENT self . s . append ( c ) NEW_LINE DEDENT DEDENT def deleteText ( self , k : int ) -> int : NEW_LINE INDENT numDeleted = min ( k , len ( self . s ) ) NEW_LINE for _ in range ( numDeleted ) : NEW_LINE INDENT self . s . pop ( ) NEW_LINE DEDENT return numDeleted NEW_LINE DEDENT def cursorLeft ( self , k : int ) -> str : NEW_LINE INDENT while self . s and k > 0 : NEW_LINE INDENT self . stack . append ( self . s . pop ( ) ) NEW_LINE k -= 1 NEW_LINE DEDENT return self . _getString ( ) NEW_LINE DEDENT def cursorRight ( self , k : int ) -> str : NEW_LINE INDENT while self . stack and k > 0 : NEW_LINE INDENT self . s . append ( self . stack . pop ( ) ) NEW_LINE k -= 1 NEW_LINE DEDENT return self . _getString ( ) NEW_LINE DEDENT def _getString ( self ) -> str : NEW_LINE INDENT if len ( self . s ) < 10 : NEW_LINE INDENT return ' ' . join ( self . s ) NEW_LINE DEDENT return ' ' . join ( self . s [ - 10 : ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minCost ( self , nums : List [ int ] , costs : List [ int ] ) -> int : NEW_LINE INDENT dp = [ math . inf ] * len ( nums ) NEW_LINE maxStack = [ ] NEW_LINE minStack = [ ] NEW_LINE dp [ 0 ] = 0 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT while maxStack and num >= nums [ maxStack [ - 1 ] ] : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ maxStack . pop ( ) ] + costs [ i ] ) NEW_LINE DEDENT while minStack and num < nums [ minStack [ - 1 ] ] : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ minStack . pop ( ) ] + costs [ i ] ) NEW_LINE DEDENT maxStack . append ( i ) NEW_LINE minStack . append ( i ) NEW_LINE DEDENT return dp [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def strongPasswordCheckerII ( self , password : str ) -> bool : NEW_LINE INDENT if len ( password ) < 8 : NEW_LINE INDENT return False NEW_LINE DEDENT if not any ( c . islower ( ) for c in password ) : NEW_LINE INDENT return False NEW_LINE DEDENT if not any ( c . isupper ( ) for c in password ) : NEW_LINE INDENT return False NEW_LINE DEDENT if not any ( c . isdigit ( ) for c in password ) : NEW_LINE INDENT return False NEW_LINE DEDENT if not any ( " ! @ # $ % ^ & * ( ) - + " . find ( c ) != - 1 for c in password ) : NEW_LINE INDENT return False NEW_LINE DEDENT return all ( a != b for a , b in zip ( password , password [ 1 : ] ) ) NEW_LINE DEDENT DEDENT
from queue import PriorityQueue NEW_LINE class Solution : NEW_LINE INDENT def mergeKLists ( self , lists : List [ ListNode ] ) -> ListNode : NEW_LINE INDENT dummy = ListNode ( 0 ) NEW_LINE curr = dummy NEW_LINE pq = PriorityQueue ( ) NEW_LINE for i , lst in enumerate ( lists ) : NEW_LINE INDENT if lst : NEW_LINE INDENT pq . put ( ( lst . val , i , lst ) ) NEW_LINE DEDENT DEDENT while not pq . empty ( ) : NEW_LINE INDENT _ , i , minNode = pq . get ( ) NEW_LINE if minNode . next : NEW_LINE INDENT pq . put ( ( minNode . next . val , i , minNode . next ) ) NEW_LINE DEDENT curr . next = minNode NEW_LINE curr = curr . next NEW_LINE DEDENT return dummy . next NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def kthSmallest ( self , root : Optional [ TreeNode ] , k : int ) -> int : NEW_LINE INDENT def countNodes ( root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 + countNodes ( root . left ) + countNodes ( root . right ) NEW_LINE DEDENT leftCount = countNodes ( root . left ) NEW_LINE if leftCount == k - 1 : NEW_LINE INDENT return root . val NEW_LINE DEDENT if leftCount >= k : NEW_LINE INDENT return self . kthSmallest ( root . left , k ) NEW_LINE DEDENT return self . kthSmallest ( root . right , k - 1 - leftCount ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def successfulPairs ( self , spells : List [ int ] , potions : List [ int ] , success : int ) -> List [ int ] : NEW_LINE INDENT potions . sort ( ) NEW_LINE def firstIndexSuccess ( spell : int ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( potions ) NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if spell * potions [ m ] >= success : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT return [ len ( potions ) - firstIndexSuccess ( spell ) for spell in spells ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def matchReplacement ( self , s : str , sub : str , mappings : List [ List [ str ] ] ) -> bool : NEW_LINE INDENT isMapped = [ [ False ] * 128 for _ in range ( 128 ) ] NEW_LINE for old , new in mappings : NEW_LINE INDENT isMapped [ ord ( old ) ] [ ord ( new ) ] = True NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if self . _canTransform ( s , i , sub , isMapped ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def _canTransform ( self , s : str , start : int , sub : str , isMapped : List [ List [ bool ] ] ) -> bool : NEW_LINE INDENT if start + len ( sub ) > len ( s ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( len ( sub ) ) : NEW_LINE INDENT a = sub [ i ] NEW_LINE b = s [ start + i ] NEW_LINE if a != b and not isMapped [ ord ( a ) ] [ ord ( b ) ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countSubarrays ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE summ = 0 NEW_LINE l = 0 NEW_LINE for r , num in enumerate ( nums ) : NEW_LINE INDENT summ += num NEW_LINE while summ * ( r - l + 1 ) >= k : NEW_LINE INDENT summ -= nums [ l ] NEW_LINE l += 1 NEW_LINE DEDENT ans += r - l + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def calculateTax ( self , brackets : List [ List [ int ] ] , income : int ) -> float : NEW_LINE INDENT ans = 0 NEW_LINE prev = 0 NEW_LINE for upper , percent in brackets : NEW_LINE INDENT if income < upper : NEW_LINE INDENT return ans + ( income - prev ) * percent / 100.0 NEW_LINE DEDENT ans += ( upper - prev ) * percent / 100.0 NEW_LINE prev = upper NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minPathCost ( self , grid : List [ List [ int ] ] , moveCost : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE dp = [ [ math . inf ] * n for _ in range ( m ) ] NEW_LINE dp [ 0 ] = grid [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + moveCost [ grid [ i - 1 ] [ k ] ] [ j ] + grid [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return min ( dp [ - 1 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def distributeCookies ( self , cookies : List [ int ] , k : int ) -> int : NEW_LINE INDENT ans = math . inf NEW_LINE def dfs ( s : int , children : List [ int ] ) -> None : NEW_LINE INDENT nonlocal ans NEW_LINE if s == len ( cookies ) : NEW_LINE INDENT ans = min ( ans , max ( children ) ) NEW_LINE return NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT children [ i ] += cookies [ s ] NEW_LINE dfs ( s + 1 , children ) NEW_LINE children [ i ] -= cookies [ s ] NEW_LINE DEDENT DEDENT dfs ( 0 , [ 0 ] * k ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def distinctNames ( self , ideas : List [ str ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE suffixes = [ set ( ) for _ in range ( 26 ) ] NEW_LINE for idea in ideas : NEW_LINE INDENT suffixes [ ord ( idea [ 0 ] ) - ord ( ' a ' ) ] . add ( idea [ 1 : ] ) NEW_LINE DEDENT for i in range ( 25 ) : NEW_LINE INDENT for j in range ( i + 1 , 26 ) : NEW_LINE INDENT count = len ( suffixes [ i ] & suffixes [ j ] ) NEW_LINE ans += 2 * ( len ( suffixes [ i ] ) - count ) * ( len ( suffixes [ j ] ) - count ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkContradictions ( self , equations : List [ List [ str ] ] , values : List [ float ] ) -> bool : NEW_LINE INDENT strToInt = { } NEW_LINE for u , v in equations : NEW_LINE INDENT strToInt . setdefault ( u , len ( strToInt ) ) NEW_LINE strToInt . setdefault ( v , len ( strToInt ) ) NEW_LINE DEDENT graph = [ [ ] for _ in range ( len ( strToInt ) ) ] NEW_LINE seen = [ 0.0 ] * len ( graph ) NEW_LINE for i , ( ( A , B ) , value ) in enumerate ( zip ( equations , values ) ) : NEW_LINE INDENT u = strToInt [ A ] NEW_LINE v = strToInt [ B ] NEW_LINE graph [ u ] . append ( ( v , value ) ) NEW_LINE graph [ v ] . append ( ( u , 1 / value ) ) NEW_LINE DEDENT def dfs ( u : int , val : float ) -> bool : NEW_LINE INDENT if seen [ u ] : NEW_LINE INDENT return abs ( val / seen [ u ] - 1 ) > 1e-5 NEW_LINE DEDENT seen [ u ] = val NEW_LINE return any ( dfs ( v , val / w ) for v , w in graph [ u ] ) NEW_LINE DEDENT for i in range ( len ( graph ) ) : NEW_LINE INDENT if not seen [ i ] and dfs ( i , 1.0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def greatestLetter ( self , s : str ) -> str : NEW_LINE INDENT seen = set ( s ) NEW_LINE for i in range ( 25 , - 1 , - 1 ) : NEW_LINE INDENT if chr ( ord ( ' a ' ) + i ) in seen and chr ( ord ( ' A ' ) + i ) in seen : NEW_LINE INDENT return chr ( ord ( ' A ' ) + i ) NEW_LINE DEDENT DEDENT return ' ' NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isPowerOfTwo ( self , n : int ) -> bool : NEW_LINE INDENT return False if n < 0 else bin ( n ) . count ( '1' ) == 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumNumbers ( self , num : int , k : int ) -> int : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( 1 , 11 ) : NEW_LINE INDENT if i * k > num + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if i * k % 10 == num % 10 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestSubsequence ( self , s : str , k : int ) -> int : NEW_LINE INDENT oneCount = 0 NEW_LINE num = 0 NEW_LINE pow = 1 NEW_LINE for i in reversed ( range ( len ( s ) ) ) : NEW_LINE INDENT if num + pow > k : NEW_LINE INDENT break NEW_LINE DEDENT if s [ i ] == '1' : NEW_LINE INDENT oneCount += 1 NEW_LINE num += pow NEW_LINE DEDENT pow *= 2 NEW_LINE DEDENT return s . count ( '0' ) + oneCount NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sellingWood ( self , m : int , n : int , prices : List [ List [ int ] ] ) -> int : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for h , w , price in prices : NEW_LINE INDENT dp [ h ] [ w ] = price NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for h in range ( 1 , i // 2 + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ h ] [ j ] + dp [ i - h ] [ j ] ) NEW_LINE DEDENT for w in range ( 1 , j // 2 + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ w ] + dp [ i ] [ j - w ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countAsterisks ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE bars = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == ' | ' : NEW_LINE INDENT bars += 1 NEW_LINE DEDENT elif c == ' * ' and bars % 2 == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countPairs ( self , n : int , edges : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE graph = [ 0 ] * n NEW_LINE seen = [ 0 ] * n NEW_LINE unreached = n NEW_LINE for e in edges : NEW_LINE INDENT u = e [ 0 ] NEW_LINE v = e [ 1 ] NEW_LINE graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT reached = dfs ( graph , i , seen ) NEW_LINE unreached -= reached NEW_LINE ans += static_cast < long > ( unreached ) * reached NEW_LINE DEDENT return ans NEW_LINE DEDENT def dfs ( self , graph : List [ List [ int ] ] , u : int , seen : List [ bool ] ) -> int : NEW_LINE INDENT if seen [ u ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT seen [ u ] = True NEW_LINE return accumulate ( begin ( graph [ u ] ) , end ( graph [ u ] ) , 1 , [ & ] ( subtotal , v ) [ return subtotal + dfs ( graph , v , seen ) ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumXOR ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT return functools . reduce ( operator . ior , nums ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def distinctSequences ( self , n : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( n : int , prev : int , prevPrev : int ) -> int : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for dice in range ( 1 , 7 ) : NEW_LINE INDENT if dice != prev and dice != prevPrev and ( prev == 0 or math . gcd ( dice , prev ) == 1 ) : NEW_LINE INDENT ans += dp ( n - 1 , dice , prev ) NEW_LINE ans %= kMod NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return dp ( n , 0 , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkXMatrix ( self , grid : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT n = len ( grid ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i == j or i + j == n - 1 : NEW_LINE INDENT if grid [ i ] [ j ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif grid [ i ] [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class MyQueue : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . input = [ ] NEW_LINE self . output = [ ] NEW_LINE DEDENT def push ( self , x : int ) -> None : NEW_LINE INDENT self . input . append ( x ) NEW_LINE DEDENT def pop ( self ) -> int : NEW_LINE INDENT self . peek ( ) NEW_LINE return self . output . pop ( ) NEW_LINE DEDENT def peek ( self ) -> int : NEW_LINE INDENT if not self . output : NEW_LINE INDENT while self . input : NEW_LINE INDENT self . output . append ( self . input . pop ( ) ) NEW_LINE DEDENT DEDENT return self . output [ - 1 ] NEW_LINE DEDENT def empty ( self ) -> bool : NEW_LINE INDENT return not self . input and not self . output NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countHousePlacements ( self , n : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE house = 1 NEW_LINE space = 1 NEW_LINE total = house + space NEW_LINE for _ in range ( 2 , n + 1 ) : NEW_LINE INDENT house = space NEW_LINE space = total NEW_LINE total = ( house + space ) % kMod NEW_LINE DEDENT return total ** 2 % kMod NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumsSplicedArray ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> int : NEW_LINE INDENT def kadane ( nums1 : List [ int ] , nums2 : List [ int ] ) -> int : NEW_LINE INDENT gain = 0 NEW_LINE maxGain = 0 NEW_LINE for n1 , n2 in zip ( nums1 , nums2 ) : NEW_LINE INDENT gain = max ( 0 , gain + n2 - n1 ) NEW_LINE maxGain = max ( maxGain , gain ) NEW_LINE DEDENT return maxGain + sum ( nums1 ) NEW_LINE DEDENT return max ( kadane ( nums1 , nums2 ) , kadane ( nums2 , nums1 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumScore ( self , nums : List [ int ] , edges : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE xors = functools . reduce ( lambda x , y : x ^ y , nums ) NEW_LINE subXors = nums [ : ] NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE children = [ { i } for i in range ( n ) ] NEW_LINE for u , v in edges : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT def dfs ( u : int , parent : int ) -> Tuple [ int , Set [ int ] ] : NEW_LINE INDENT for v in graph [ u ] : NEW_LINE INDENT if v == parent : NEW_LINE INDENT continue NEW_LINE DEDENT vXor , vChildren = dfs ( v , u ) NEW_LINE subXors [ u ] ^= vXor NEW_LINE children [ u ] |= vChildren NEW_LINE DEDENT return subXors [ u ] , children [ u ] NEW_LINE DEDENT dfs ( 0 , - 1 ) NEW_LINE ans = math . inf NEW_LINE for i in range ( len ( edges ) ) : NEW_LINE INDENT a , b = edges [ i ] NEW_LINE if b in children [ a ] : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT c , d = edges [ j ] NEW_LINE if d in children [ c ] : NEW_LINE INDENT c , d = d , c NEW_LINE DEDENT if c in children [ a ] and a != c : NEW_LINE INDENT cands = [ subXors [ c ] , subXors [ a ] ^ subXors [ c ] , xors ^ subXors [ a ] ] NEW_LINE DEDENT elif a in children [ c ] and a != c : NEW_LINE INDENT cands = [ subXors [ a ] , subXors [ c ] ^ subXors [ a ] , xors ^ subXors [ c ] ] NEW_LINE DEDENT else : NEW_LINE INDENT cands = [ subXors [ a ] , subXors [ c ] , xors ^ subXors [ a ] ^ subXors [ c ] ] NEW_LINE DEDENT ans = min ( ans , max ( cands ) - min ( cands ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumTime ( self , jobs : List [ int ] , workers : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE jobs . sort ( ) NEW_LINE workers . sort ( ) NEW_LINE for job , worker in zip ( jobs , workers ) : NEW_LINE INDENT ans = max ( ans , ( job - 1 ) // worker + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def decodeMessage ( self , key : str , message : str ) -> str : NEW_LINE INDENT keyToActual = { ' ▁ ' : ' ▁ ' } NEW_LINE currChar = ' a ' NEW_LINE for c in key : NEW_LINE INDENT if c not in keyToActual : NEW_LINE INDENT keyToActual [ c ] = currChar NEW_LINE currChar = chr ( ord ( currChar ) + 1 ) NEW_LINE DEDENT DEDENT return ' ' . join ( keyToActual [ c ] for c in message ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def spiralMatrix ( self , m : int , n : int , head : Optional [ ListNode ] ) -> List [ List [ int ] ] : NEW_LINE INDENT dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE ans = [ [ - 1 ] * n for _ in range ( m ) ] NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE d = 0 NEW_LINE curr = head NEW_LINE while curr : NEW_LINE INDENT ans [ x ] [ y ] = curr . val NEW_LINE if x + dirs [ d ] < 0 or x + dirs [ d ] == m or y + dirs [ d + 1 ] < 0 or y + dirs [ d + 1 ] == n or ans [ x + dirs [ d ] ] [ y + dirs [ d + 1 ] ] != - 1 : NEW_LINE INDENT d = ( d + 1 ) % 4 NEW_LINE DEDENT x += dirs [ d ] NEW_LINE y += dirs [ d + 1 ] NEW_LINE curr = curr . next NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def peopleAwareOfSecret ( self , n : int , delay : int , forget : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE share = 0 NEW_LINE dp = [ 0 ] * n NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if i - delay >= 0 : NEW_LINE INDENT share += dp [ i - delay ] NEW_LINE DEDENT if i - forget >= 0 : NEW_LINE INDENT share -= dp [ i - forget ] NEW_LINE DEDENT share += kMod NEW_LINE share %= kMod NEW_LINE dp [ i ] = share NEW_LINE DEDENT return sum ( dp [ - forget : ] ) % kMod NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countPaths ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int , j : int ) -> int : NEW_LINE INDENT ans = 1 NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT if grid [ x ] [ y ] <= grid [ i ] [ j ] : NEW_LINE INDENT continue NEW_LINE DEDENT ans += dp ( x , y ) NEW_LINE ans %= kMod NEW_LINE DEDENT return ans NEW_LINE DEDENT return sum ( dp ( i , j ) for i in range ( m ) for j in range ( n ) ) % kMod NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countDigitOne ( self , n : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE pow10 = 1 NEW_LINE while pow10 <= n : NEW_LINE INDENT divisor = pow10 * 10 NEW_LINE quotient = n // divisor NEW_LINE remainder = n % divisor NEW_LINE if quotient > 0 : NEW_LINE INDENT ans += quotient * pow10 NEW_LINE DEDENT if remainder >= pow10 : NEW_LINE INDENT ans += min ( remainder - pow10 + 1 , pow10 ) NEW_LINE DEDENT pow10 *= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def makePalindrome ( self , s : str ) -> bool : NEW_LINE INDENT change = 0 NEW_LINE l = 0 NEW_LINE r = len ( s ) - 1 NEW_LINE while l < r : NEW_LINE INDENT if s [ l ] != s [ r ] : NEW_LINE INDENT change += 1 NEW_LINE if change > 2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def evaluateTree ( self , root : Optional [ TreeNode ] ) -> bool : NEW_LINE INDENT if root . val < 2 : NEW_LINE INDENT return root . val NEW_LINE DEDENT if root . val == 2 : NEW_LINE INDENT return self . evaluateTree ( root . left ) or self . evaluateTree ( root . right ) NEW_LINE DEDENT return self . evaluateTree ( root . left ) and self . evaluateTree ( root . right ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def latestTimeCatchTheBus ( self , buses : List [ int ] , passengers : List [ int ] , capacity : int ) -> int : NEW_LINE INDENT buses . sort ( ) NEW_LINE passengers . sort ( ) NEW_LINE if passengers [ 0 ] > buses [ - 1 ] : NEW_LINE INDENT return buses [ - 1 ] NEW_LINE DEDENT ans = passengers [ 0 ] - 1 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( buses ) : NEW_LINE INDENT arrived = 0 NEW_LINE while arrived < capacity and j < len ( passengers ) and passengers [ j ] <= buses [ i ] : NEW_LINE INDENT if j > 0 and passengers [ j ] != passengers [ j - 1 ] + 1 : NEW_LINE INDENT ans = passengers [ j ] - 1 NEW_LINE DEDENT j += 1 NEW_LINE arrived += 1 NEW_LINE DEDENT if arrived < capacity and j > 0 and passengers [ j - 1 ] != buses [ i ] : NEW_LINE INDENT ans = buses [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def validSubarraySize ( self , nums : List [ int ] , threshold : int ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE ans = 0 NEW_LINE prev = [ - 1 ] * n NEW_LINE next = [ n ] * n NEW_LINE stack = [ ] NEW_LINE for i , a in enumerate ( nums ) : NEW_LINE INDENT while stack and nums [ stack [ - 1 ] ] > a : NEW_LINE INDENT index = stack . pop ( ) NEW_LINE next [ index ] = i NEW_LINE DEDENT if stack : NEW_LINE INDENT prev [ i ] = stack [ - 1 ] NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT for i , ( num , prevIndex , nextIndex ) in enumerate ( zip ( nums , prev , next ) ) : NEW_LINE INDENT k = ( i - prevIndex ) + ( nextIndex - i ) - 1 NEW_LINE if num > threshold / k : NEW_LINE INDENT return k NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def fillCups ( self , amount : List [ int ] ) -> int : NEW_LINE INDENT return max ( max ( amount ) , ( sum ( amount ) + 1 ) // 2 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canChange ( self , start : str , target : str ) -> bool : NEW_LINE INDENT n = len ( start ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i <= n and j <= n : NEW_LINE INDENT while i < n and start [ i ] == ' _ ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT while j < n and target [ j ] == ' _ ' : NEW_LINE INDENT j += 1 NEW_LINE DEDENT if i == n or j == n : NEW_LINE INDENT return i == n and j == n NEW_LINE DEDENT if start [ i ] != target [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT if start [ i ] == ' R ' and i > j : NEW_LINE INDENT return False NEW_LINE DEDENT if start [ i ] == ' L ' and i < j : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isPalindrome ( self , head : ListNode ) -> bool : NEW_LINE INDENT def reverseList ( head : ListNode ) -> ListNode : NEW_LINE INDENT prev = None NEW_LINE curr = head NEW_LINE while curr : NEW_LINE INDENT next = curr . next NEW_LINE curr . next = prev NEW_LINE prev = curr NEW_LINE curr = next NEW_LINE DEDENT return prev NEW_LINE DEDENT slow = head NEW_LINE fast = head NEW_LINE while fast and fast . next : NEW_LINE INDENT slow = slow . next NEW_LINE fast = fast . next . next NEW_LINE DEDENT if fast : NEW_LINE INDENT slow = slow . next NEW_LINE DEDENT slow = reverseList ( slow ) NEW_LINE while slow : NEW_LINE INDENT if slow . val != head . val : NEW_LINE INDENT return False NEW_LINE DEDENT slow = slow . next NEW_LINE head = head . next NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumSwaps ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT minIndex = self . _getLeftmostMinIndex ( nums ) NEW_LINE maxIndex = self . _getRightmostMaxIndex ( nums ) NEW_LINE swaps = minIndex + ( len ( nums ) - 1 - maxIndex ) NEW_LINE return swaps if minIndex <= maxIndex else swaps - 1 NEW_LINE DEDENT def _getLeftmostMinIndex ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT min = nums [ 0 ] NEW_LINE minIndex = 0 NEW_LINE for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT if nums [ i ] < min : NEW_LINE INDENT min = nums [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT return minIndex NEW_LINE DEDENT def _getRightmostMaxIndex ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT max = nums [ - 1 ] NEW_LINE maxIndex = len ( nums ) - 1 NEW_LINE for i in range ( len ( nums ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT if nums [ i ] > max : NEW_LINE INDENT max = nums [ i ] NEW_LINE maxIndex = i NEW_LINE DEDENT DEDENT return maxIndex NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberOfPairs ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * 2 NEW_LINE count = Counter ( nums ) NEW_LINE for i in range ( 101 ) : NEW_LINE INDENT ans [ 0 ] += count [ i ] // 2 NEW_LINE ans [ 1 ] += count [ i ] & 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumSum ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT kMax = 9 * 9 NEW_LINE ans = - 1 NEW_LINE count = [ [ ] for _ in range ( kMax + 1 ) ] NEW_LINE def getSum ( num : int ) -> int : NEW_LINE INDENT summ = 0 NEW_LINE while num : NEW_LINE INDENT summ += num % 10 NEW_LINE num //= 10 NEW_LINE DEDENT return summ NEW_LINE DEDENT for num in nums : NEW_LINE INDENT count [ getSum ( num ) ] . append ( num ) NEW_LINE DEDENT for groupNums in count : NEW_LINE INDENT if len ( groupNums ) < 2 : NEW_LINE INDENT continue NEW_LINE DEDENT groupNums . sort ( reverse = True ) NEW_LINE ans = max ( ans , groupNums [ 0 ] + groupNums [ 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minOperations ( self , nums : List [ int ] , numsDivide : List [ int ] ) -> int : NEW_LINE INDENT gcd = functools . reduce ( math . gcd , numsDivide ) NEW_LINE for i , num in enumerate ( sorted ( nums ) ) : NEW_LINE INDENT if gcd % num == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def visibleMountains ( self , peaks : List [ List [ int ] ] ) -> int : NEW_LINE INDENT count = Counter ( ( x , y ) for x , y in peaks ) NEW_LINE peaks = sorted ( [ k for k , v in count . items ( ) if v == 1 ] ) NEW_LINE stack = [ ] NEW_LINE def isHidden ( peak1 : List [ int ] , peak2 : List [ int ] ) -> bool : NEW_LINE INDENT x1 , y1 = peak1 NEW_LINE x2 , y2 = peak2 NEW_LINE return x1 - y1 >= x2 - y2 and x1 + y1 <= x2 + y2 NEW_LINE DEDENT for i , peak in enumerate ( peaks ) : NEW_LINE INDENT while stack and isHidden ( peaks [ stack [ - 1 ] ] , peak ) : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT if stack and isHidden ( peak , peaks [ stack [ - 1 ] ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT return len ( stack ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def bestHand ( self , ranks : List [ int ] , suits : List [ str ] ) -> str : NEW_LINE INDENT if all ( suit == suits [ 0 ] for suit in suits ) : NEW_LINE INDENT return ' Flush ' NEW_LINE DEDENT match max ( Counter ( ranks ) . values ( ) ) : NEW_LINE INDENT case 5 | 4 | 3 : NEW_LINE INDENT return ' Three ▁ of ▁ a ▁ Kind ' NEW_LINE DEDENT case 2 : NEW_LINE INDENT return ' Pair ' NEW_LINE DEDENT case _ : NEW_LINE INDENT return ' High ▁ Card ' NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def zeroFilledSubarray ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE indexBeforeZero = - 1 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT if num : NEW_LINE INDENT indexBeforeZero = i NEW_LINE DEDENT else : NEW_LINE INDENT ans += i - indexBeforeZero NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
from sortedcontainers import SortedSet NEW_LINE class NumberContainers : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . numberToIndices = defaultdict ( SortedSet ) NEW_LINE self . indexToNumber = { } NEW_LINE DEDENT def change ( self , index : int , number : int ) -> None : NEW_LINE INDENT if index in self . indexToNumber : NEW_LINE INDENT originalNumber = self . indexToNumber [ index ] NEW_LINE self . numberToIndices [ originalNumber ] . remove ( index ) NEW_LINE if len ( self . numberToIndices [ originalNumber ] ) == 0 : NEW_LINE INDENT del self . numberToIndices [ originalNumber ] NEW_LINE DEDENT DEDENT self . indexToNumber [ index ] = number NEW_LINE self . numberToIndices [ number ] . add ( index ) NEW_LINE DEDENT def find ( self , number : int ) -> int : NEW_LINE INDENT if number in self . numberToIndices : NEW_LINE INDENT return self . numberToIndices [ number ] [ 0 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def lowestCommonAncestor ( self , root : ' TreeNode ' , p : ' TreeNode ' , q : ' TreeNode ' ) -> ' TreeNode ' : NEW_LINE INDENT if root . val > max ( p . val , q . val ) : NEW_LINE INDENT return self . lowestCommonAncestor ( root . left , p , q ) NEW_LINE DEDENT if root . val < min ( p . val , q . val ) : NEW_LINE INDENT return self . lowestCommonAncestor ( root . right , p , q ) NEW_LINE DEDENT return root NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def shortestSequence ( self , rolls : List [ int ] , k : int ) -> int : NEW_LINE INDENT ans = 1 NEW_LINE seen = set ( ) NEW_LINE for roll in rolls : NEW_LINE INDENT seen . add ( roll ) NEW_LINE if len ( seen ) == k : NEW_LINE INDENT ans += 1 NEW_LINE seen . clear ( ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def repeatedCharacter ( self , s : str ) -> str : NEW_LINE INDENT seen = [ False ] * 26 NEW_LINE for c in s : NEW_LINE INDENT if seen [ ord ( c ) - ord ( ' a ' ) ] : NEW_LINE INDENT return c NEW_LINE DEDENT seen [ ord ( c ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def equalPairs ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( grid ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT k = 0 NEW_LINE while k < n : NEW_LINE INDENT if grid [ i ] [ k ] != grid [ k ] [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT k += 1 NEW_LINE DEDENT if k == n : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
from sortedcontainers import SortedSet NEW_LINE class FoodRatings : NEW_LINE INDENT def __init__ ( self , foods : List [ str ] , cuisines : List [ str ] , ratings : List [ int ] ) : NEW_LINE INDENT self . cuisineToRatingAndFoods = defaultdict ( lambda : SortedSet ( key = lambda x : ( - x [ 0 ] , x [ 1 ] ) ) ) NEW_LINE self . foodToCuisine = { } NEW_LINE self . foodToRating = { } NEW_LINE for food , cuisine , rating in zip ( foods , cuisines , ratings ) : NEW_LINE INDENT self . cuisineToRatingAndFoods [ cuisine ] . add ( ( rating , food ) ) NEW_LINE self . foodToCuisine [ food ] = cuisine NEW_LINE self . foodToRating [ food ] = rating NEW_LINE DEDENT DEDENT def changeRating ( self , food : str , newRating : int ) -> None : NEW_LINE INDENT cuisine = self . foodToCuisine [ food ] NEW_LINE oldRating = self . foodToRating [ food ] NEW_LINE ratingAndFoods = self . cuisineToRatingAndFoods [ cuisine ] NEW_LINE ratingAndFoods . remove ( ( oldRating , food ) ) NEW_LINE ratingAndFoods . add ( ( newRating , food ) ) NEW_LINE self . foodToRating [ food ] = newRating NEW_LINE DEDENT def highestRated ( self , cuisine : str ) -> str : NEW_LINE INDENT return self . cuisineToRatingAndFoods [ cuisine ] [ 0 ] [ 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countExcellentPairs ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT count = Counter ( map ( int . bit_count , set ( nums ) ) ) NEW_LINE return sum ( count [ i ] * count [ j ] for i in count for j in count if i + j >= k ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumBooks ( self , books : List [ int ] ) -> int : NEW_LINE INDENT dp = [ 0 ] * len ( books ) NEW_LINE stack = [ ] NEW_LINE for i , book in enumerate ( books ) : NEW_LINE INDENT while stack and books [ stack [ - 1 ] ] >= book - ( i - stack [ - 1 ] ) : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT j = stack [ - 1 ] if stack else - 1 NEW_LINE lastPicked = book - ( i - j ) + 1 NEW_LINE if lastPicked > 1 : NEW_LINE INDENT dp [ i ] = ( book + lastPicked ) * ( i - j ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = book * ( book + 1 ) // 2 NEW_LINE DEDENT if j >= 0 : NEW_LINE INDENT dp [ i ] += dp [ j ] NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumOperations ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT return len ( set ( nums ) - { 0 } ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumGroups ( self , grades : List [ int ] ) -> int : NEW_LINE INDENT return int ( math . sqrt ( len ( grades ) * 2 + 0.25 ) - 0.5 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def closestMeetingNode ( self , edges : List [ int ] , node1 : int , node2 : int ) -> int : NEW_LINE INDENT kMax = 10000 NEW_LINE dist1 = self . _getDist ( edges , node1 ) NEW_LINE dist2 = self . _getDist ( edges , node2 ) NEW_LINE minDist = kMax NEW_LINE ans = - 1 NEW_LINE for i , ( d1 , d2 ) in enumerate ( zip ( dist1 , dist2 ) ) : NEW_LINE INDENT if min ( d1 , d2 ) >= 0 : NEW_LINE INDENT maxDist = max ( d1 , d2 ) NEW_LINE if maxDist < minDist : NEW_LINE INDENT minDist = maxDist NEW_LINE ans = i NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def _getDist ( self , edges : List [ int ] , u : int ) -> List [ int ] : NEW_LINE INDENT dist = [ - 1 ] * len ( edges ) NEW_LINE d = 0 NEW_LINE while u != - 1 and dist [ u ] == - 1 : NEW_LINE INDENT dist [ u ] = d NEW_LINE d += 1 NEW_LINE u = edges [ u ] NEW_LINE DEDENT return dist NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def lowestCommonAncestor ( self , root : ' TreeNode ' , p : ' TreeNode ' , q : ' TreeNode ' ) -> ' TreeNode ' : NEW_LINE INDENT if not root or root == p or root == q : NEW_LINE INDENT return root NEW_LINE DEDENT l = self . lowestCommonAncestor ( root . left , p , q ) NEW_LINE r = self . lowestCommonAncestor ( root . right , p , q ) NEW_LINE if l and r : NEW_LINE INDENT return root NEW_LINE DEDENT return l or r NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestCycle ( self , edges : List [ int ] ) -> int : NEW_LINE INDENT ans = - 1 NEW_LINE time = 1 NEW_LINE timeVisited = [ 0 ] * len ( edges ) NEW_LINE for i , edge in enumerate ( edges ) : NEW_LINE INDENT if timeVisited [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT startTime = time NEW_LINE u = i NEW_LINE while u != - 1 and not timeVisited [ u ] : NEW_LINE INDENT timeVisited [ u ] = time NEW_LINE time += 1 NEW_LINE u = edges [ u ] NEW_LINE DEDENT if u != - 1 and timeVisited [ u ] >= startTime : NEW_LINE INDENT ans = max ( ans , time - timeVisited [ u ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumCosts ( self , regular : List [ int ] , express : List [ int ] , expressCost : int ) -> List [ int ] : NEW_LINE INDENT n = len ( regular ) NEW_LINE ans = [ 0 ] * n NEW_LINE dpReg = 0 NEW_LINE dpExp = expressCost NEW_LINE for i in range ( n ) : NEW_LINE INDENT prevReg = dpReg NEW_LINE prevExp = dpExp NEW_LINE dpReg = min ( prevReg + regular [ i ] , prevExp + 0 + regular [ i ] ) NEW_LINE dpExp = min ( prevReg + expressCost + express [ i ] , prevExp + express [ i ] ) NEW_LINE ans [ i ] = min ( dpReg , dpExp ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mergeSimilarItems ( self , items1 : List [ List [ int ] ] , items2 : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT return sorted ( ( Counter ( dict ( items1 ) ) + Counter ( dict ( items2 ) ) ) . items ( ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countBadPairs ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = Counter ( ) NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT ans += i - count [ num - i ] NEW_LINE count [ num - i ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def taskSchedulerII ( self , tasks : List [ int ] , space : int ) -> int : NEW_LINE INDENT taskToNextAvailable = defaultdict ( int ) NEW_LINE ans = 0 NEW_LINE for task in tasks : NEW_LINE INDENT ans = max ( ans + 1 , taskToNextAvailable [ task ] ) NEW_LINE taskToNextAvailable [ task ] = ans + space + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumReplacement ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE max = nums [ - 1 ] NEW_LINE for i in range ( len ( nums ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT ops = ( nums [ i ] - 1 ) // max NEW_LINE ans += ops NEW_LINE max = nums [ i ] // ( ops + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def arithmeticTriplets ( self , nums : List [ int ] , diff : int ) -> int : NEW_LINE INDENT kMax = 200 NEW_LINE ans = 0 NEW_LINE count = [ False ] * ( kMax + 1 ) NEW_LINE for num in nums : NEW_LINE INDENT if num >= 2 * diff and count [ num - diff ] and count [ num - 2 * diff ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT count [ num ] = True NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reachableNodes ( self , n : int , edges : List [ List [ int ] ] , restricted : List [ int ] ) -> int : NEW_LINE INDENT graph = [ [ ] for _ in range ( n ) ] NEW_LINE seen = set ( restricted ) NEW_LINE for u , v in edges : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT def dfs ( u : int ) -> int : NEW_LINE INDENT if u in seen : NEW_LINE INDENT return 0 NEW_LINE DEDENT seen . add ( u ) NEW_LINE return 1 + sum ( dfs ( v ) for v in graph [ u ] ) NEW_LINE DEDENT return dfs ( 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def validPartition ( self , nums : List [ int ] ) -> bool : NEW_LINE INDENT n = len ( nums ) NEW_LINE dp = [ False ] * ( n + 1 ) NEW_LINE dp [ 0 ] = True NEW_LINE dp [ 2 ] = nums [ 0 ] == nums [ 1 ] NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 2 ] and nums [ i - 2 ] == nums [ i - 1 ] ) or ( dp [ i - 3 ] and ( ( nums [ i - 3 ] == nums [ i - 2 ] and nums [ i - 2 ] == nums [ i - 1 ] ) or ( nums [ i - 3 ] + 1 == nums [ i - 2 ] and nums [ i - 2 ] + 1 == nums [ i - 1 ] ) ) ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def deleteNode ( self , node ) : NEW_LINE INDENT node . val = node . next . val NEW_LINE node . next = node . next . next NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestIdealString ( self , s : str , k : int ) -> int : NEW_LINE INDENT dp = [ 0 ] * 26 NEW_LINE for c in s : NEW_LINE INDENT i = ord ( c ) - ord ( ' a ' ) NEW_LINE dp [ i ] = 1 + self . _getMaxReachable ( dp , i , k ) NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT def _getMaxReachable ( self , dp : List [ int ] , i : int , k : int ) -> int : NEW_LINE INDENT first = max ( 0 , i - k ) NEW_LINE last = min ( 25 , i + k ) NEW_LINE maxReachable = 0 NEW_LINE for j in range ( first , last + 1 ) : NEW_LINE INDENT maxReachable = max ( maxReachable , dp [ j ] ) NEW_LINE DEDENT return maxReachable NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minScore ( self , grid : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE ans = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE valAndIndices = [ ] NEW_LINE rows = [ 0 ] * m NEW_LINE cols = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT valAndIndices . append ( ( grid [ i ] [ j ] , i , j ) ) NEW_LINE DEDENT DEDENT valAndIndices . sort ( ) NEW_LINE for _ , i , j in valAndIndices : NEW_LINE INDENT nextAvailable = max ( rows [ i ] , cols [ j ] ) + 1 NEW_LINE ans [ i ] [ j ] = nextAvailable NEW_LINE rows [ i ] = nextAvailable NEW_LINE cols [ j ] = nextAvailable NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestLocal ( self , grid : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT n = len ( grid ) NEW_LINE ans = [ [ 0 ] * ( n - 2 ) for _ in range ( n - 2 ) ] NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( n - 2 ) : NEW_LINE INDENT for x in range ( i , i + 3 ) : NEW_LINE INDENT for y in range ( j , j + 3 ) : NEW_LINE INDENT ans [ i ] [ j ] = max ( ans [ i ] [ j ] , grid [ x ] [ y ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def edgeScore ( self , edges : List [ int ] ) -> int : NEW_LINE INDENT scores = [ 0 ] * len ( edges ) NEW_LINE for i , edge in enumerate ( edges ) : NEW_LINE INDENT scores [ edge ] += i NEW_LINE DEDENT return scores . index ( max ( scores ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestNumber ( self , pattern : str ) -> str : NEW_LINE INDENT ans = [ ] NEW_LINE stack = [ '1' ] NEW_LINE for c in pattern : NEW_LINE INDENT maxSorFar = stack [ - 1 ] NEW_LINE if c == ' I ' : NEW_LINE INDENT while stack : NEW_LINE INDENT maxSorFar = max ( maxSorFar , stack [ - 1 ] ) NEW_LINE ans . append ( stack . pop ( ) ) NEW_LINE DEDENT DEDENT stack . append ( chr ( ord ( maxSorFar ) + 1 ) ) NEW_LINE DEDENT while stack : NEW_LINE INDENT ans . append ( stack . pop ( ) ) NEW_LINE DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countSpecialNumbers ( self , n : int ) -> int : NEW_LINE INDENT s = str ( n ) NEW_LINE digitSize = int ( log10 ( n ) ) + 1 NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( digitSize : int , usedMask : int , isTight : bool ) -> int : NEW_LINE INDENT if digitSize == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE maxDigit = ord ( s [ len ( s ) - digitSize ] ) - ord ( '0' ) if isTight else 9 NEW_LINE for digit in range ( maxDigit + 1 ) : NEW_LINE INDENT if usedMask >> digit & 1 : NEW_LINE INDENT continue NEW_LINE DEDENT nextIsTight = isTight and ( digit == maxDigit ) NEW_LINE if usedMask == 0 and digit == 0 : NEW_LINE INDENT ans += dp ( digitSize - 1 , usedMask , nextIsTight ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += dp ( digitSize - 1 , usedMask | 1 << digit , nextIsTight ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return dp ( digitSize , 0 , True ) - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxScore ( self , edges : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( edges ) NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE for i , ( parent , weight ) in enumerate ( edges ) : NEW_LINE INDENT if parent != - 1 : NEW_LINE INDENT graph [ parent ] . append ( ( i , weight ) ) NEW_LINE DEDENT DEDENT takeRoot , notTakeRoot = self . _dfs ( graph , 0 ) NEW_LINE return max ( takeRoot , notTakeRoot ) NEW_LINE DEDENT def _dfs ( self , graph : List [ List [ int ] ] , u : int ) -> Tuple [ int , int ] : NEW_LINE INDENT bestEdge = 0 NEW_LINE notTakeU = 0 NEW_LINE for v , w in graph [ u ] : NEW_LINE INDENT takeV , notTakeV = self . _dfs ( graph , v ) NEW_LINE bestEdge = max ( bestEdge , w + notTakeV - takeV ) NEW_LINE notTakeU += takeV NEW_LINE DEDENT return ( bestEdge + notTakeU , notTakeU ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumRecolors ( self , blocks : str , k : int ) -> int : NEW_LINE INDENT countB = 0 NEW_LINE maxCountB = 0 NEW_LINE for i , block in enumerate ( blocks ) : NEW_LINE INDENT if block == ' B ' : NEW_LINE INDENT countB += 1 NEW_LINE DEDENT if i >= k and blocks [ i - k ] == ' B ' : NEW_LINE INDENT countB -= 1 NEW_LINE DEDENT maxCountB = max ( maxCountB , countB ) NEW_LINE DEDENT return k - maxCountB NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def productExceptSelf ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT n = len ( nums ) NEW_LINE prefix = [ 1 ] * n NEW_LINE suffix = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] * nums [ i - 1 ] NEW_LINE DEDENT for i in reversed ( range ( n - 1 ) ) : NEW_LINE INDENT suffix [ i ] = suffix [ i + 1 ] * nums [ i + 1 ] NEW_LINE DEDENT return [ prefix [ i ] * suffix [ i ] for i in range ( n ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def secondsToRemoveOccurrences ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE zeros = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == '0' : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT elif zeros > 0 : NEW_LINE INDENT ans = max ( ans + 1 , zeros ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def shiftingLetters ( self , s : str , shifts : List [ List [ int ] ] ) -> str : NEW_LINE INDENT ans = [ ] NEW_LINE currShift = 0 NEW_LINE timeline = [ 0 ] * ( len ( s ) + 1 ) NEW_LINE for start , end , direction in shifts : NEW_LINE INDENT diff = 1 if direction else - 1 NEW_LINE timeline [ start ] += diff NEW_LINE timeline [ end + 1 ] -= diff NEW_LINE DEDENT for i , c in enumerate ( s ) : NEW_LINE INDENT currShift = ( currShift + timeline [ i ] ) % 26 NEW_LINE num = ( ord ( s [ i ] ) - ord ( ' a ' ) + currShift + 26 ) % 26 NEW_LINE ans . append ( chr ( ord ( ' a ' ) + num ) ) NEW_LINE DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumSegmentSum ( self , nums : List [ int ] , removeQueries : List [ int ] ) -> List [ int ] : NEW_LINE INDENT n = len ( nums ) NEW_LINE maxSum = 0 NEW_LINE ans = [ 0 ] * n NEW_LINE summ = [ 0 ] * n NEW_LINE count = [ 0 ] * n NEW_LINE for i in reversed ( range ( n ) ) : NEW_LINE INDENT ans [ i ] = maxSum NEW_LINE j = removeQueries [ i ] NEW_LINE leftSum = summ [ j - 1 ] if j > 0 else 0 NEW_LINE rightSum = summ [ j + 1 ] if j + 1 < n else 0 NEW_LINE segmentSum = nums [ j ] + leftSum + rightSum NEW_LINE leftCount = count [ j - 1 ] if j > 0 else 0 NEW_LINE rightCount = count [ j + 1 ] if j + 1 < n else 0 NEW_LINE segmentCount = 1 + leftCount + rightCount NEW_LINE l = j - leftCount NEW_LINE r = j + rightCount NEW_LINE summ [ l ] = segmentSum NEW_LINE summ [ r ] = segmentSum NEW_LINE count [ l ] = segmentCount NEW_LINE count [ r ] = segmentCount NEW_LINE maxSum = max ( maxSum , segmentSum ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minNumberOfHours ( self , initialEnergy : int , initialExperience : int , energy : List [ int ] , experience : List [ int ] ) -> int : NEW_LINE INDENT return self . _getRequiredEnergy ( initialEnergy , energy ) + self . _getRequiredExperience ( initialExperience , experience ) NEW_LINE DEDENT def _getRequiredEnergy ( self , initialEnergy : int , energy : List [ int ] ) -> int : NEW_LINE INDENT return max ( 0 , sum ( energy ) + 1 - initialEnergy ) NEW_LINE DEDENT def _getRequiredExperience ( self , currentExperience : int , experience : List [ int ] ) -> int : NEW_LINE INDENT requiredExperience = 0 NEW_LINE for e in experience : NEW_LINE INDENT if e >= currentExperience : NEW_LINE INDENT requiredExperience += e + 1 - currentExperience NEW_LINE currentExperience += e + 1 - currentExperience NEW_LINE DEDENT currentExperience += e NEW_LINE DEDENT return requiredExperience NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestPalindromic ( self , num : str ) -> str : NEW_LINE INDENT count = Counter ( num ) NEW_LINE firstHalf = ' ' . join ( count [ i ] // 2 * i for i in '9876543210' ) . lstrip ( '0' ) NEW_LINE mid = self . _getMid ( count ) NEW_LINE return ( firstHalf + mid + firstHalf [ : : - 1 ] ) or '0' NEW_LINE DEDENT def _getMid ( self , count : Dict [ str , int ] ) -> str : NEW_LINE INDENT for c in '9876543210' : NEW_LINE INDENT if count [ c ] & 1 : NEW_LINE INDENT return c NEW_LINE DEDENT DEDENT return ' ' NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def amountOfTime ( self , root : Optional [ TreeNode ] , start : int ) -> int : NEW_LINE INDENT ans = - 1 NEW_LINE graph = self . _getGraph ( root ) NEW_LINE q = deque ( [ start ] ) NEW_LINE seen = { start } NEW_LINE while q : NEW_LINE INDENT ans += 1 NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE if u not in graph : NEW_LINE INDENT continue NEW_LINE DEDENT for v in graph [ u ] : NEW_LINE INDENT if v in seen : NEW_LINE INDENT continue NEW_LINE DEDENT q . append ( v ) NEW_LINE seen . add ( v ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def _getGraph ( self , root : Optional [ TreeNode ] ) -> Dict [ int , List [ int ] ] : NEW_LINE INDENT graph = defaultdict ( list ) NEW_LINE q = deque ( [ ( root , - 1 ) ] ) NEW_LINE while q : NEW_LINE INDENT node , parent = q . popleft ( ) NEW_LINE if parent != - 1 : NEW_LINE INDENT graph [ parent ] . append ( node . val ) NEW_LINE graph [ node . val ] . append ( parent ) NEW_LINE DEDENT if node . left : NEW_LINE INDENT q . append ( ( node . left , node . val ) ) NEW_LINE DEDENT if node . right : NEW_LINE INDENT q . append ( ( node . right , node . val ) ) NEW_LINE DEDENT DEDENT return graph NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def kSum ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT maxSum = sum ( num for num in nums if num > 0 ) NEW_LINE absNums = sorted ( abs ( num ) for num in nums ) NEW_LINE maxHeap = [ ( - ( maxSum - absNums [ 0 ] ) , 0 ) ] NEW_LINE nextMaxSum = maxSum NEW_LINE for _ in range ( k - 1 ) : NEW_LINE INDENT nextMaxSum , i = heapq . heappop ( maxHeap ) NEW_LINE nextMaxSum *= - 1 NEW_LINE if i + 1 < len ( absNums ) : NEW_LINE INDENT heapq . heappush ( maxHeap , ( - ( nextMaxSum - absNums [ i + 1 ] ) , i + 1 ) ) NEW_LINE heapq . heappush ( maxHeap , ( - ( nextMaxSum - absNums [ i + 1 ] + absNums [ i ] ) , i + 1 ) ) NEW_LINE DEDENT DEDENT return nextMaxSum NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def matrixMedian ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT noGreaterThanMedianCount = len ( grid ) * len ( grid [ 0 ] ) // 2 + 1 NEW_LINE l = 1 NEW_LINE r = int ( 1e6 ) NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if sum ( bisect_right ( row , m ) for row in grid ) >= noGreaterThanMedianCount : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def answerQueries ( self , nums : List [ int ] , queries : List [ int ] ) -> List [ int ] : NEW_LINE INDENT nums . sort ( ) NEW_LINE def numOfElementsLessThan ( q : int ) -> int : NEW_LINE INDENT summ = 0 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT summ += nums [ i ] NEW_LINE if summ > q : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return len ( nums ) NEW_LINE DEDENT return [ numOfElementsLessThan ( q ) for q in queries ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxSlidingWindow ( self , nums : List [ int ] , k : int ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE q = deque ( ) NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT while q and q [ - 1 ] < num : NEW_LINE INDENT q . pop ( ) NEW_LINE DEDENT q . append ( num ) NEW_LINE if i >= k and nums [ i - k ] == q [ 0 ] : NEW_LINE INDENT q . popleft ( ) NEW_LINE DEDENT if i >= k - 1 : NEW_LINE INDENT ans . append ( q [ 0 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeStars ( self , s : str ) -> str : NEW_LINE INDENT ans = [ ] NEW_LINE for c in s : NEW_LINE INDENT if c == ' * ' : NEW_LINE INDENT ans . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( c ) NEW_LINE DEDENT DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def garbageCollection ( self , garbage : List [ str ] , travel : List [ int ] ) -> int : NEW_LINE INDENT prefix = list ( itertools . accumulate ( travel ) ) NEW_LINE def getTime ( c : str ) -> int : NEW_LINE INDENT characterCount = 0 NEW_LINE lastIndex = - 1 NEW_LINE for i , s in enumerate ( garbage ) : NEW_LINE INDENT if any ( g == c for g in s ) : NEW_LINE INDENT lastIndex = i NEW_LINE DEDENT characterCount += s . count ( c ) NEW_LINE DEDENT return characterCount + ( 0 if lastIndex <= 0 else prefix [ lastIndex - 1 ] ) NEW_LINE DEDENT return getTime ( ' M ' ) + getTime ( ' P ' ) + getTime ( ' G ' ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def buildMatrix ( self , k : int , rowConditions : List [ List [ int ] ] , colConditions : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT rowOrder = self . _topologicalSort ( rowConditions , k ) NEW_LINE if not rowOrder : NEW_LINE INDENT return [ ] NEW_LINE DEDENT colOrder = self . _topologicalSort ( colConditions , k ) NEW_LINE if not colOrder : NEW_LINE INDENT return [ ] NEW_LINE DEDENT ans = [ [ 0 ] * k for _ in range ( k ) ] NEW_LINE nodeToRowIndex = [ 0 ] * ( k + 1 ) NEW_LINE for i , node in enumerate ( rowOrder ) : NEW_LINE INDENT nodeToRowIndex [ node ] = i NEW_LINE DEDENT for j , node in enumerate ( colOrder ) : NEW_LINE INDENT i = nodeToRowIndex [ node ] NEW_LINE ans [ i ] [ j ] = node NEW_LINE DEDENT return ans NEW_LINE DEDENT def _topologicalSort ( self , conditions : List [ List [ int ] ] , n : int ) -> List [ int ] : NEW_LINE INDENT order = [ ] NEW_LINE graph = [ [ ] for _ in range ( n + 1 ) ] NEW_LINE inDegree = [ 0 ] * ( n + 1 ) NEW_LINE for u , v in conditions : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE inDegree [ v ] += 1 NEW_LINE DEDENT q = deque ( [ i for i in range ( 1 , n + 1 ) if inDegree [ i ] == 0 ] ) NEW_LINE while q : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE order . append ( u ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT inDegree [ v ] -= 1 NEW_LINE if inDegree [ v ] == 0 : NEW_LINE INDENT q . append ( v ) NEW_LINE DEDENT DEDENT DEDENT return order if len ( order ) == n else [ ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countSubarrays ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE j = - 1 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT if i > 0 and num <= nums [ i - 1 ] : NEW_LINE INDENT j = i - 1 NEW_LINE DEDENT ans += i - j NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findSubarrays ( self , nums : List [ int ] ) -> bool : NEW_LINE INDENT seen = set ( ) NEW_LINE for a , b in zip ( nums , nums [ 1 : ] ) : NEW_LINE INDENT summ = a + b NEW_LINE if summ in seen : NEW_LINE INDENT return True NEW_LINE DEDENT seen . add ( summ ) NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isStrictlyPalindromic ( self , n : int ) -> bool : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumRows ( self , matrix : List [ List [ int ] ] , numSelect : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE def dfs ( colIndex : int , leftColsCount : int , mask : int ) : NEW_LINE INDENT nonlocal ans NEW_LINE if leftColsCount == 0 : NEW_LINE INDENT ans = max ( ans , self . _getAllZerosRowCount ( matrix , mask ) ) NEW_LINE return NEW_LINE DEDENT if colIndex == len ( matrix [ 0 ] ) : NEW_LINE INDENT return NEW_LINE DEDENT dfs ( colIndex + 1 , leftColsCount - 1 , mask | 1 << colIndex ) NEW_LINE dfs ( colIndex + 1 , leftColsCount , mask ) NEW_LINE DEDENT dfs ( 0 , numSelect , 0 ) NEW_LINE return ans NEW_LINE DEDENT def _getAllZerosRowCount ( self , matrix : List [ List [ int ] ] , mask : int ) -> int : NEW_LINE INDENT count = 0 NEW_LINE for row in matrix : NEW_LINE INDENT isAllZeros = True NEW_LINE for i , cell in enumerate ( row ) : NEW_LINE INDENT if cell == 1 and ( mask >> i & 1 ) == 0 : NEW_LINE INDENT isAllZeros = False NEW_LINE break NEW_LINE DEDENT DEDENT if isAllZeros : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumRobots ( self , chargeTimes : List [ int ] , runningCosts : List [ int ] , budget : int ) -> int : NEW_LINE INDENT cost = 0 NEW_LINE q = deque ( ) NEW_LINE j = 0 NEW_LINE for i , ( chargeTime , runningCost ) in enumerate ( zip ( chargeTimes , runningCosts ) ) : NEW_LINE INDENT cost += runningCost NEW_LINE while q and q [ - 1 ] < chargeTime : NEW_LINE INDENT q . pop ( ) NEW_LINE DEDENT q . append ( chargeTime ) NEW_LINE if q [ 0 ] + ( i - j + 1 ) * cost > budget : NEW_LINE INDENT if q [ 0 ] == chargeTimes [ j ] : NEW_LINE INDENT q . popleft ( ) NEW_LINE DEDENT cost -= runningCosts [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return len ( chargeTimes ) - j NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkDistances ( self , s : str , distance : List [ int ] ) -> bool : NEW_LINE INDENT firstSeenIndex = [ - 1 ] * 26 NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT j = ord ( c ) - ord ( ' a ' ) NEW_LINE prevIndex = firstSeenIndex [ j ] NEW_LINE if prevIndex != - 1 and i - prevIndex - 1 != distance [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT firstSeenIndex [ j ] = i NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def swapPairs ( self , head : ListNode ) -> ListNode : NEW_LINE INDENT def getLength ( head : ListNode ) -> int : NEW_LINE INDENT length = 0 NEW_LINE while head : NEW_LINE INDENT length += 1 NEW_LINE head = head . next NEW_LINE DEDENT return length NEW_LINE DEDENT length = getLength ( head ) NEW_LINE dummy = ListNode ( 0 , head ) NEW_LINE prev = dummy NEW_LINE curr = head NEW_LINE for _ in range ( length // 2 ) : NEW_LINE INDENT next = curr . next NEW_LINE curr . next = next . next NEW_LINE next . next = prev . next NEW_LINE prev . next = next NEW_LINE prev = curr NEW_LINE curr = curr . next NEW_LINE DEDENT return dummy . next NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def searchMatrix ( self , matrix : List [ List [ int ] ] , target : int ) -> bool : NEW_LINE INDENT r = 0 NEW_LINE c = len ( matrix [ 0 ] ) - 1 NEW_LINE while r < len ( matrix ) and c >= 0 : NEW_LINE INDENT if matrix [ r ] [ c ] == target : NEW_LINE INDENT return True NEW_LINE DEDENT if target < matrix [ r ] [ c ] : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberOfWays ( self , startPos : int , endPos : int , k : int ) -> int : NEW_LINE INDENT val = k + endPos - startPos NEW_LINE if val < 0 or val & 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT rightStep = val // 2 NEW_LINE leftStep = k - rightStep NEW_LINE if leftStep < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return self . _nChooseK ( leftStep + rightStep , min ( leftStep , rightStep ) ) NEW_LINE DEDENT def _nChooseK ( self , n : int , k : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE dp = [ 1 ] + [ 0 ] * k NEW_LINE for _ in range ( n ) : NEW_LINE INDENT for j in range ( k , 0 , - 1 ) : NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] NEW_LINE dp [ j ] %= kMod NEW_LINE DEDENT DEDENT return dp [ k ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestNiceSubarray ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE usedBits = 0 NEW_LINE l = 0 NEW_LINE for r , num in enumerate ( nums ) : NEW_LINE INDENT while usedBits & num : NEW_LINE INDENT usedBits ^= nums [ l ] NEW_LINE l += 1 NEW_LINE DEDENT usedBits |= num NEW_LINE ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mostBooked ( self , n : int , meetings : List [ List [ int ] ] ) -> int : NEW_LINE INDENT count = [ 0 ] * n NEW_LINE meetings . sort ( ) NEW_LINE occupied = [ ] NEW_LINE availableRoomIds = [ i for i in range ( n ) ] NEW_LINE heapq . heapify ( availableRoomIds ) NEW_LINE for start , end in meetings : NEW_LINE INDENT while occupied and occupied [ 0 ] [ 0 ] <= start : NEW_LINE INDENT heapq . heappush ( availableRoomIds , heapq . heappop ( occupied ) [ 1 ] ) NEW_LINE DEDENT if availableRoomIds : NEW_LINE INDENT roomId = heapq . heappop ( availableRoomIds ) NEW_LINE count [ roomId ] += 1 NEW_LINE heapq . heappush ( occupied , ( end , roomId ) ) NEW_LINE DEDENT else : NEW_LINE INDENT newStart , roomId = heapq . heappop ( occupied ) NEW_LINE count [ roomId ] += 1 NEW_LINE heapq . heappush ( occupied , ( newStart + ( end - start ) , roomId ) ) NEW_LINE DEDENT DEDENT return count . index ( max ( count ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumTime ( self , power : List [ int ] ) -> int : NEW_LINE INDENT n = len ( power ) NEW_LINE maxMask = 1 << n NEW_LINE dp = [ math . inf ] * maxMask NEW_LINE dp [ 0 ] = 0 NEW_LINE for mask in range ( 1 , maxMask ) : NEW_LINE INDENT currentGain = mask . bit_count ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mask >> i & 1 : NEW_LINE INDENT dp [ mask ] = min ( dp [ mask ] , dp [ mask & ~ ( 1 << i ) ] + int ( math . ceil ( power [ i ] / currentGain ) ) ) NEW_LINE DEDENT DEDENT DEDENT return dp [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mostFrequentEven ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = - 1 NEW_LINE count = Counter ( ) NEW_LINE for num in nums : NEW_LINE INDENT if num & 1 : NEW_LINE INDENT continue NEW_LINE DEDENT count [ num ] += 1 NEW_LINE newCount = count [ num ] NEW_LINE maxCount = count [ ans ] NEW_LINE if newCount > maxCount or newCount == maxCount and num < ans : NEW_LINE INDENT ans = num NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def partitionString ( self , s : str ) -> int : NEW_LINE INDENT ans = 1 NEW_LINE usedMask = 0 NEW_LINE for c in s : NEW_LINE INDENT i = ord ( c ) - ord ( ' a ' ) NEW_LINE if usedMask >> i & 1 : NEW_LINE INDENT usedMask = 1 << i NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT usedMask |= 1 << i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minGroups ( self , intervals : List [ List [ int ] ] ) -> int : NEW_LINE INDENT minHeap = [ ] NEW_LINE for left , right in sorted ( intervals ) : NEW_LINE INDENT if minHeap and left > minHeap [ 0 ] : NEW_LINE INDENT heapq . heappop ( minHeap ) NEW_LINE DEDENT heapq . heappush ( minHeap , right ) NEW_LINE DEDENT return len ( minHeap ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countDaysTogether ( self , arriveAlice : str , leaveAlice : str , arriveBob : str , leaveBob : str ) -> int : NEW_LINE INDENT days = [ 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE def toDays ( s : str ) -> int : NEW_LINE INDENT month = int ( s [ : 2 ] ) NEW_LINE day = int ( s [ 3 : ] ) NEW_LINE prevDays = 0 NEW_LINE for m in range ( 1 , month ) : NEW_LINE INDENT prevDays += days [ m ] NEW_LINE DEDENT return prevDays + day NEW_LINE DEDENT arriveA = toDays ( arriveAlice ) NEW_LINE leaveA = toDays ( leaveAlice ) NEW_LINE arriveB = toDays ( arriveBob ) NEW_LINE leaveB = toDays ( leaveBob ) NEW_LINE ans = 0 NEW_LINE for day in range ( 1 , 366 ) : NEW_LINE INDENT if arriveA <= day and day <= leaveA and arriveB <= day and day <= leaveB : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def diffWaysToCompute ( self , expression : str ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE for i , c in enumerate ( expression ) : NEW_LINE INDENT if c in ' + - * ' : NEW_LINE INDENT for a in self . diffWaysToCompute ( expression [ : i ] ) : NEW_LINE INDENT for b in self . diffWaysToCompute ( expression [ i + 1 : ] ) : NEW_LINE INDENT ans . append ( eval ( str ( a ) + c + str ( b ) ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans or [ int ( expression ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def matchPlayersAndTrainers ( self , players : List [ int ] , trainers : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE players . sort ( ) NEW_LINE trainers . sort ( ) NEW_LINE for i , trainer in enumerate ( trainers ) : NEW_LINE INDENT if players [ ans ] <= trainers [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE if ans == len ( players ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestSubarrays ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT kMaxDigit = 30 NEW_LINE ans = [ 1 ] * len ( nums ) NEW_LINE closest = [ 0 ] * kMaxDigit NEW_LINE for i in reversed ( range ( len ( nums ) ) ) : NEW_LINE INDENT for j in range ( kMaxDigit ) : NEW_LINE INDENT if nums [ i ] >> j & 1 : NEW_LINE INDENT closest [ j ] = i NEW_LINE DEDENT ans [ i ] = max ( ans [ i ] , closest [ j ] - i + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumMoney ( self , transactions : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE losses = 0 NEW_LINE for cost , cashback in transactions : NEW_LINE INDENT losses += max ( 0 , cost - cashback ) NEW_LINE DEDENT for cost , cashback in transactions : NEW_LINE INDENT if cost > cashback : NEW_LINE INDENT ans = max ( ans , losses + cashback ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , losses + cost ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestEvenMultiple ( self , n : int ) -> int : NEW_LINE INDENT return n * ( n % 2 + 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestContinuousSubstring ( self , s : str ) -> int : NEW_LINE INDENT ans = 1 NEW_LINE runningLen = 1 NEW_LINE for a , b in zip ( s , s [ 1 : ] ) : NEW_LINE INDENT if ord ( a ) + 1 == ord ( b ) : NEW_LINE INDENT runningLen += 1 NEW_LINE ans = max ( ans , runningLen ) NEW_LINE DEDENT else : NEW_LINE INDENT runningLen = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reverseOddLevels ( self , root : Optional [ TreeNode ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT def dfs ( left : Optional [ TreeNode ] , right : Optional [ TreeNode ] , isOddLevel : bool ) -> None : NEW_LINE INDENT if not left : NEW_LINE INDENT return NEW_LINE DEDENT if isOddLevel : NEW_LINE INDENT left . val , right . val = right . val , left . val NEW_LINE DEDENT dfs ( left . left , right . right , not isOddLevel ) NEW_LINE dfs ( left . right , right . left , not isOddLevel ) NEW_LINE DEDENT dfs ( root . left , root . right , True ) NEW_LINE return root NEW_LINE DEDENT DEDENT
class TrieNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . children : Dict [ str , TrieNode ] = defaultdict ( TrieNode ) NEW_LINE self . count = 0 NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def sumPrefixScores ( self , words : List [ str ] ) -> List [ int ] : NEW_LINE INDENT root = TrieNode ( ) NEW_LINE def insert ( word : str ) -> None : NEW_LINE INDENT node : TrieNode = root NEW_LINE for c in word : NEW_LINE INDENT if c not in node . children : NEW_LINE INDENT node . children [ c ] = TrieNode ( ) NEW_LINE DEDENT node = node . children [ c ] NEW_LINE node . count += 1 NEW_LINE DEDENT DEDENT for word in words : NEW_LINE INDENT insert ( word ) NEW_LINE DEDENT def getScore ( word : str ) -> int : NEW_LINE INDENT node : TrieNode = root NEW_LINE score = 0 NEW_LINE for c in word : NEW_LINE INDENT node = node . children [ c ] NEW_LINE score += node . count NEW_LINE DEDENT return score NEW_LINE DEDENT return [ getScore ( word ) for word in words ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def closestFair ( self , n : int ) -> int : NEW_LINE INDENT digitsCount = len ( str ( n ) ) NEW_LINE return self . _getOddDigits ( digitsCount ) if digitsCount & 1 else self . _getEvenDigits ( n ) NEW_LINE DEDENT def _getOddDigits ( self , digitsCount : int ) -> int : NEW_LINE INDENT zerosCount = ( digitsCount + 1 ) // 2 NEW_LINE onesCount = ( digitsCount - 1 ) // 2 NEW_LINE return '1' + '0' * zerosCount + '1' * onesCount NEW_LINE DEDENT def _getEvenDigits ( self , n : int ) -> int : NEW_LINE INDENT digitsCount = len ( str ( n ) ) NEW_LINE maxNum = int ( '1' + '0' * digitsCount ) NEW_LINE for num in range ( n , maxNum ) : NEW_LINE INDENT if self . _isValidNum ( num ) : NEW_LINE INDENT return num NEW_LINE DEDENT DEDENT return self . _getOddDigits ( digitsCount + 1 ) NEW_LINE DEDENT def _isValidNum ( self , num : int ) -> bool : NEW_LINE INDENT count = 0 NEW_LINE s = str ( num ) NEW_LINE for c in s : NEW_LINE INDENT count += - 1 if ord ( c ) - ord ( '0' ) & 1 else 1 NEW_LINE DEDENT return count == 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sortPeople ( self , names : List [ str ] , heights : List [ int ] ) -> List [ str ] : NEW_LINE INDENT return [ height for _ , height in sorted ( [ ( height , name ) for name , height in zip ( names , heights ) ] , reverse = True ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestSubarray ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE maxIndex = 0 NEW_LINE sameNumLength = 0 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT if nums [ i ] == nums [ maxIndex ] : NEW_LINE INDENT sameNumLength += 1 NEW_LINE ans = max ( ans , sameNumLength ) NEW_LINE DEDENT elif nums [ i ] > nums [ maxIndex ] : NEW_LINE INDENT maxIndex = i NEW_LINE sameNumLength = 1 NEW_LINE ans = 1 NEW_LINE DEDENT else : NEW_LINE INDENT sameNumLength = 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isAnagram ( self , s : str , t : str ) -> bool : NEW_LINE INDENT if len ( s ) != len ( t ) : NEW_LINE INDENT return False NEW_LINE DEDENT dict = Counter ( s ) NEW_LINE for c in t : NEW_LINE INDENT dict [ c ] -= 1 NEW_LINE if dict [ c ] < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def goodIndices ( self , nums : List [ int ] , k : int ) -> List [ int ] : NEW_LINE INDENT n = len ( nums ) NEW_LINE dec = [ 1 ] * n NEW_LINE inc = [ 1 ] * n NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if nums [ i - 1 ] >= nums [ i ] : NEW_LINE INDENT dec [ i ] = dec [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if nums [ i ] <= nums [ i + 1 ] : NEW_LINE INDENT inc [ i ] = inc [ i + 1 ] + 1 NEW_LINE DEDENT DEDENT return [ i for i in range ( k , n - k ) if dec [ i - 1 ] >= k and inc [ i + 1 ] >= k ] NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumOperations ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE l = 0 NEW_LINE r = len ( nums ) - 1 NEW_LINE leftSum = nums [ 0 ] NEW_LINE rightSum = nums [ - 1 ] NEW_LINE while l < r : NEW_LINE INDENT if leftSum < rightSum : NEW_LINE INDENT l += 1 NEW_LINE leftSum += nums [ l ] NEW_LINE ans += 1 NEW_LINE DEDENT elif leftSum > rightSum : NEW_LINE INDENT r -= 1 NEW_LINE rightSum += nums [ r ] NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE r -= 1 NEW_LINE leftSum = nums [ l ] NEW_LINE rightSum = nums [ r ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def equalFrequency ( self , word : str ) -> bool : NEW_LINE INDENT count = Counter ( word ) NEW_LINE for c in word : NEW_LINE INDENT count [ c ] -= 1 NEW_LINE if self . _equalCount ( count ) : NEW_LINE INDENT return True NEW_LINE DEDENT count [ c ] += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT def _equalCount ( self , count : Dict [ int , int ] ) -> bool : NEW_LINE INDENT freq = - 1 NEW_LINE for c in count . values ( ) : NEW_LINE INDENT if c == 0 or c == freq : NEW_LINE INDENT continue NEW_LINE DEDENT if freq == - 1 : NEW_LINE INDENT freq = c NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class LUPrefix : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . seen = set ( ) NEW_LINE self . longestPrefix = 0 NEW_LINE DEDENT def upload ( self , video : int ) -> None : NEW_LINE INDENT self . seen . add ( video ) NEW_LINE while self . longestPrefix + 1 in self . seen : NEW_LINE INDENT self . longestPrefix += 1 NEW_LINE DEDENT DEDENT def longest ( self ) -> int : NEW_LINE INDENT return self . longestPrefix NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def xorAllNums ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> int : NEW_LINE INDENT xors1 = functools . reduce ( operator . xor , nums1 ) NEW_LINE xors2 = functools . reduce ( operator . xor , nums2 ) NEW_LINE return ( len ( nums1 ) % 2 * xors2 ) ^ ( len ( nums2 ) % 2 * xors1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def commonFactors ( self , a : int , b : int ) -> int : NEW_LINE INDENT gcd = math . gcd ( a , b ) NEW_LINE return sum ( a % i == 0 and b % i == 0 for i in range ( 1 , gcd + 1 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxSum ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT return max ( grid [ i - 1 ] [ j - 1 ] + grid [ i - 1 ] [ j ] + grid [ i - 1 ] [ j + 1 ] + grid [ i ] [ j ] + grid [ i + 1 ] [ j - 1 ] + grid [ i + 1 ] [ j ] + grid [ i + 1 ] [ j + 1 ] for i in range ( 1 , len ( grid ) - 1 ) for j in range ( 1 , len ( grid [ 0 ] ) - 1 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimizeXor ( self , num1 : int , num2 : int ) -> int : NEW_LINE INDENT kMaxDigit = 30 NEW_LINE bits = num2 . bit_count ( ) NEW_LINE if num1 . bit_count ( ) == bits : NEW_LINE INDENT return num1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in reversed ( range ( kMaxDigit ) ) : NEW_LINE INDENT if num1 >> i & 1 : NEW_LINE INDENT ans |= 1 << i NEW_LINE bits -= 1 NEW_LINE if bits == 0 : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT DEDENT for i in range ( kMaxDigit ) : NEW_LINE INDENT if ( num1 >> i & 1 ) == 0 : NEW_LINE INDENT ans |= 1 << i NEW_LINE bits -= 1 NEW_LINE if bits == 0 : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def shortestDistance ( self , wordsDict : List [ str ] , word1 : str , word2 : str ) -> int : NEW_LINE INDENT ans = len ( wordsDict ) NEW_LINE index1 = - 1 NEW_LINE index2 = - 1 NEW_LINE for i , word in enumerate ( wordsDict ) : NEW_LINE INDENT if word == word1 : NEW_LINE INDENT index1 = i NEW_LINE if index2 != - 1 : NEW_LINE INDENT ans = min ( ans , index1 - index2 ) NEW_LINE DEDENT DEDENT if word == word2 : NEW_LINE INDENT index2 = i NEW_LINE if index1 != - 1 : NEW_LINE INDENT ans = min ( ans , index2 - index1 ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def deleteString ( self , s : str ) -> int : NEW_LINE INDENT n = len ( s ) NEW_LINE lcs = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] NEW_LINE dp = [ 1 ] * n NEW_LINE for i in reversed ( range ( n ) ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if s [ i ] == s [ j ] : NEW_LINE INDENT lcs [ i ] [ j ] = lcs [ i + 1 ] [ j + 1 ] + 1 NEW_LINE DEDENT if lcs [ i ] [ j ] >= j - i : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxTastiness ( self , price : List [ int ] , tastiness : List [ int ] , maxAmount : int , maxCoupons : int ) -> int : NEW_LINE INDENT n = len ( price ) NEW_LINE dp = [ [ [ 0 ] * ( maxCoupons + 1 ) for j in range ( maxAmount + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT currPrice = price [ i - 1 ] NEW_LINE currTastiness = tastiness [ i - 1 ] NEW_LINE for amount in range ( maxAmount + 1 ) : NEW_LINE INDENT for coupon in range ( maxCoupons + 1 ) : NEW_LINE INDENT dp [ i ] [ amount ] [ coupon ] = dp [ i - 1 ] [ amount ] [ coupon ] NEW_LINE if amount >= currPrice : NEW_LINE INDENT dp [ i ] [ amount ] [ coupon ] = max ( dp [ i ] [ amount ] [ coupon ] , dp [ i - 1 ] [ amount - currPrice ] [ coupon ] + currTastiness ) NEW_LINE DEDENT if coupon > 0 and amount >= currPrice // 2 : NEW_LINE INDENT dp [ i ] [ amount ] [ coupon ] = max ( dp [ i ] [ amount ] [ coupon ] , dp [ i - 1 ] [ amount - currPrice // 2 ] [ coupon - 1 ] + currTastiness ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n ] [ maxAmount ] [ maxCoupons ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def hardestWorker ( self , n : int , logs : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = logs [ 0 ] [ 0 ] NEW_LINE maxWorkingTime = logs [ 0 ] [ 1 ] NEW_LINE for ( _ , prevLeaveTime ) , ( id , leaveTime ) in zip ( logs , logs [ 1 : ] ) : NEW_LINE INDENT workingTime = leaveTime - prevLeaveTime NEW_LINE if workingTime > maxWorkingTime : NEW_LINE INDENT ans = id NEW_LINE maxWorkingTime = workingTime NEW_LINE DEDENT elif workingTime == maxWorkingTime : NEW_LINE INDENT ans = min ( ans , id ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findArray ( self , pref : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * len ( pref ) NEW_LINE ans [ 0 ] = pref [ 0 ] NEW_LINE for i in range ( 1 , len ( ans ) ) : NEW_LINE INDENT ans [ i ] = pref [ i ] ^ pref [ i - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def robotWithString ( self , s : str ) -> str : NEW_LINE INDENT ans = [ ] NEW_LINE count = Counter ( s ) NEW_LINE stack = [ ] NEW_LINE for c in s : NEW_LINE INDENT stack . append ( c ) NEW_LINE count [ c ] -= 1 NEW_LINE minChar = self . _getMinChar ( count ) NEW_LINE while stack and stack [ - 1 ] <= minChar : NEW_LINE INDENT ans . append ( stack . pop ( ) ) NEW_LINE DEDENT DEDENT return ' ' . join ( ans + stack [ : : - 1 ] ) NEW_LINE DEDENT def _getMinChar ( self , count : List [ int ] ) -> str : NEW_LINE INDENT for c in string . ascii_lowercase : NEW_LINE INDENT if count [ c ] : NEW_LINE INDENT return c NEW_LINE DEDENT DEDENT return ' a ' NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberOfPaths ( self , grid : List [ List [ int ] ] , k : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int , j : int , summ : int ) -> int : NEW_LINE INDENT if i == m or j == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if i == m - 1 and j == n - 1 : NEW_LINE INDENT return 1 if ( summ + grid [ i ] [ j ] ) % k == 0 else 0 NEW_LINE DEDENT newSum = ( summ + grid [ i ] [ j ] ) % k NEW_LINE return ( dp ( i + 1 , j , newSum ) + dp ( i , j + 1 , newSum ) ) % kMod NEW_LINE DEDENT return dp ( 0 , 0 , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimumSplits ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 1 NEW_LINE gcd = nums [ 0 ] NEW_LINE for num in nums : NEW_LINE INDENT newGcd = math . gcd ( gcd , num ) NEW_LINE if newGcd > 1 : NEW_LINE INDENT gcd = newGcd NEW_LINE DEDENT else : NEW_LINE INDENT gcd = num NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countTime ( self , time : str ) -> int : NEW_LINE INDENT ans = 1 NEW_LINE if time [ 3 ] == ' ? ' : NEW_LINE INDENT ans *= 6 NEW_LINE DEDENT if time [ 4 ] == ' ? ' : NEW_LINE INDENT ans *= 10 NEW_LINE DEDENT if time [ 0 ] == ' ? ' and time [ 1 ] == ' ? ' : NEW_LINE INDENT return ans * 24 NEW_LINE DEDENT if time [ 0 ] == ' ? ' : NEW_LINE INDENT return ans * 3 if time [ 1 ] < '4' else ans * 2 NEW_LINE DEDENT if time [ 1 ] == ' ? ' : NEW_LINE INDENT return ans * 4 if time [ 0 ] == '2' else ans * 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def productQueries ( self , n : int , queries : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE kMaxDigit = 30 NEW_LINE ans = [ ] NEW_LINE powers = [ 1 << i for i in range ( kMaxDigit ) if n >> i & 1 ] NEW_LINE for left , right in queries : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT prod *= powers [ i ] NEW_LINE prod %= kMod NEW_LINE DEDENT ans . append ( prod ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minimizeArrayValue ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prefix = 0 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT prefix += num NEW_LINE prefixAvg = math . ceil ( prefix / ( i + 1 ) ) NEW_LINE ans = max ( ans , prefixAvg ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class WordDistance : NEW_LINE INDENT def __init__ ( self , wordsDict : List [ str ] ) : NEW_LINE INDENT self . wordToIndices = defaultdict ( list ) NEW_LINE for i , word in enumerate ( wordsDict ) : NEW_LINE INDENT self . wordToIndices [ word ] . append ( i ) NEW_LINE DEDENT DEDENT def shortest ( self , word1 : str , word2 : str ) -> int : NEW_LINE INDENT indices1 = self . wordToIndices [ word1 ] NEW_LINE indices2 = self . wordToIndices [ word2 ] NEW_LINE ans = math . inf NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( indices1 ) and j < len ( indices2 ) : NEW_LINE INDENT ans = min ( ans , abs ( indices1 [ i ] - indices2 [ j ] ) ) NEW_LINE if indices1 [ i ] < indices2 [ j ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def componentValue ( self , nums : List [ int ] , edges : List [ List [ int ] ] ) -> int : NEW_LINE INDENT kMax = 1_000_000_000 NEW_LINE n = len ( nums ) NEW_LINE summ = sum ( nums ) NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE for u , v in edges : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT def dfs ( u : int , target : int , seen : Set [ bool ] ) -> int : NEW_LINE INDENT summ = nums [ u ] NEW_LINE seen . add ( u ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT if v in seen : NEW_LINE INDENT continue NEW_LINE DEDENT summ += dfs ( v , target , seen ) NEW_LINE if summ > target : NEW_LINE INDENT return kMax NEW_LINE DEDENT DEDENT if summ == target : NEW_LINE INDENT return 0 NEW_LINE DEDENT return summ NEW_LINE DEDENT for i in range ( n , 1 , - 1 ) : NEW_LINE INDENT if summ % i == 0 and dfs ( 0 , summ // i , set ( ) ) == 0 : NEW_LINE INDENT return i - 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMaxK ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = - 1 NEW_LINE seen = set ( ) NEW_LINE for num in nums : NEW_LINE INDENT if - num in seen : NEW_LINE INDENT ans = max ( ans , abs ( num ) ) NEW_LINE DEDENT else : NEW_LINE INDENT seen . add ( num ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countSubarrays ( self , nums : List [ int ] , minK : int , maxK : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE j = - 1 NEW_LINE prevMinKIndex = - 1 NEW_LINE prevMaxKIndex = - 1 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT if num < minK or num > maxK : NEW_LINE INDENT j = i NEW_LINE DEDENT if num == minK : NEW_LINE INDENT prevMinKIndex = i NEW_LINE DEDENT if num == maxK : NEW_LINE INDENT prevMaxKIndex = i NEW_LINE DEDENT ans += max ( 0 , min ( prevMinKIndex , prevMaxKIndex ) - j ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def shortestWordDistance ( self , wordsDict : List [ str ] , word1 : str , word2 : str ) -> int : NEW_LINE INDENT isSame = word1 == word2 NEW_LINE ans = math . inf NEW_LINE index1 = len ( wordsDict ) NEW_LINE index2 = - len ( wordsDict ) NEW_LINE for i , word in enumerate ( wordsDict ) : NEW_LINE INDENT if word == word1 : NEW_LINE INDENT if isSame : NEW_LINE INDENT index2 = index1 NEW_LINE DEDENT index1 = i NEW_LINE DEDENT elif word == word2 : NEW_LINE INDENT index2 = i NEW_LINE DEDENT ans = min ( ans , abs ( index1 - index2 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isStrobogrammatic ( self , num : str ) -> bool : NEW_LINE INDENT rotated = [ '0' , '1' , ' x ' , ' x ' , ' x ' , ' x ' , '9' , ' x ' , '8' , '6' ] NEW_LINE l = 0 NEW_LINE r = len ( num ) - 1 NEW_LINE while l <= r : NEW_LINE INDENT if num [ l ] != rotated [ ord ( num [ r ] ) - ord ( '0' ) ] : NEW_LINE INDENT return False NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findStrobogrammatic ( self , n : int ) -> List [ str ] : NEW_LINE INDENT def helper ( n : int , k : int ) -> List [ str ] : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return [ ' ' ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return [ '0' , '1' , '8' ] NEW_LINE DEDENT ans = [ ] NEW_LINE for inner in helper ( n - 2 , k ) : NEW_LINE INDENT if n < k : NEW_LINE INDENT ans . append ( '0' + inner + '0' ) NEW_LINE DEDENT ans . append ( '1' + inner + '1' ) NEW_LINE ans . append ( '6' + inner + '9' ) NEW_LINE ans . append ( '8' + inner + '8' ) NEW_LINE ans . append ( '9' + inner + '6' ) NEW_LINE DEDENT return ans NEW_LINE DEDENT return helper ( n , n ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def strobogrammaticInRange ( self , low : str , high : str ) -> int : NEW_LINE INDENT pairs = [ [ '0' , '0' ] , [ '1' , '1' ] , [ '6' , '9' ] , [ '8' , '8' ] , [ '9' , '6' ] ] NEW_LINE ans = 0 NEW_LINE def dfs ( s : List [ chr ] , l : int , r : int ) -> None : NEW_LINE INDENT nonlocal ans NEW_LINE if l > r : NEW_LINE INDENT if len ( s ) == len ( low ) and ' ' . join ( s ) < low : NEW_LINE INDENT return NEW_LINE DEDENT if len ( s ) == len ( high ) and ' ' . join ( s ) > high : NEW_LINE INDENT return NEW_LINE DEDENT ans += 1 NEW_LINE return NEW_LINE DEDENT for leftDigit , rightDigit in pairs : NEW_LINE INDENT if l == r and leftDigit != rightDigit : NEW_LINE INDENT continue NEW_LINE DEDENT s [ l ] = leftDigit NEW_LINE s [ r ] = rightDigit NEW_LINE if len ( s ) > 1 and s [ 0 ] == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( s , l + 1 , r - 1 ) NEW_LINE DEDENT DEDENT for n in range ( len ( low ) , len ( high ) + 1 ) : NEW_LINE INDENT dfs ( [ ' ▁ ' ] * n , 0 , n - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def groupStrings ( self , strings : List [ str ] ) -> List [ List [ str ] ] : NEW_LINE INDENT keyToStrings = defaultdict ( list ) NEW_LINE def getKey ( s : str ) -> str : NEW_LINE INDENT key = ' ' NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT diff = ( ord ( s [ i ] ) - ord ( s [ i - 1 ] ) + 26 ) % 26 NEW_LINE key += str ( diff ) + ' , ' NEW_LINE DEDENT return key NEW_LINE DEDENT for s in strings : NEW_LINE INDENT keyToStrings [ getKey ( s ) ] . append ( s ) NEW_LINE DEDENT return keyToStrings . values ( ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reverseKGroup ( self , head : Optional [ ListNode ] , k : int ) -> Optional [ ListNode ] : NEW_LINE INDENT if not head : NEW_LINE INDENT return None NEW_LINE DEDENT tail = head NEW_LINE for _ in range ( k ) : NEW_LINE INDENT if not tail : NEW_LINE INDENT return head NEW_LINE DEDENT tail = tail . next NEW_LINE DEDENT newHead = self . _reverse ( head , tail ) NEW_LINE head . next = self . reverseKGroup ( tail , k ) NEW_LINE return newHead NEW_LINE DEDENT def _reverse ( self , head : Optional [ ListNode ] , tail : Optional [ ListNode ] ) -> Optional [ ListNode ] : NEW_LINE INDENT prev = None NEW_LINE curr = head NEW_LINE while curr != tail : NEW_LINE INDENT next = curr . next NEW_LINE curr . next = prev NEW_LINE prev = curr NEW_LINE curr = next NEW_LINE DEDENT return prev NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countUnivalSubtrees ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE def isUnival ( root : Optional [ TreeNode ] , val : int ) -> bool : NEW_LINE INDENT nonlocal ans NEW_LINE if not root : NEW_LINE INDENT return True NEW_LINE DEDENT if isUnival ( root . left , root . val ) & isUnival ( root . right , root . val ) : NEW_LINE INDENT ans += 1 NEW_LINE return root . val == val NEW_LINE DEDENT return False NEW_LINE DEDENT isUnival ( root , math . inf ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Vector2D : NEW_LINE INDENT def __init__ ( self , vec : List [ List [ int ] ] ) : NEW_LINE INDENT self . vec = [ ] NEW_LINE self . i = 0 NEW_LINE for A in vec : NEW_LINE INDENT self . vec += A NEW_LINE DEDENT DEDENT def next ( self ) -> int : NEW_LINE INDENT ans = self . vec [ self . i ] NEW_LINE self . i += 1 NEW_LINE return ans NEW_LINE DEDENT def hasNext ( self ) -> bool : NEW_LINE INDENT return self . i < len ( self . vec ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canAttendMeetings ( self , intervals : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT intervals . sort ( ) NEW_LINE for i in range ( 1 , len ( intervals ) ) : NEW_LINE INDENT if intervals [ i - 1 ] [ 1 ] > intervals [ i ] [ 0 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minMeetingRooms ( self , intervals : List [ List [ int ] ] ) -> int : NEW_LINE INDENT minHeap = [ ] NEW_LINE for start , end in sorted ( intervals ) : NEW_LINE INDENT if minHeap and start >= minHeap [ 0 ] : NEW_LINE INDENT heapq . heappop ( minHeap ) NEW_LINE DEDENT heapq . heappush ( minHeap , end ) NEW_LINE DEDENT return len ( minHeap ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getFactors ( self , n : int ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( n : int , s : int , path : List [ int ] ) -> None : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT if len ( path ) > 1 : NEW_LINE INDENT ans . append ( path . copy ( ) ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( s , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT path . append ( i ) NEW_LINE dfs ( n // i , i , path ) NEW_LINE path . pop ( ) NEW_LINE DEDENT DEDENT DEDENT dfs ( n , 2 , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def verifyPreorder ( self , preorder : List [ int ] ) -> bool : NEW_LINE INDENT i = 0 NEW_LINE def dfs ( min : int , max : int ) -> None : NEW_LINE INDENT nonlocal i NEW_LINE if i == len ( preorder ) : NEW_LINE INDENT return NEW_LINE DEDENT if preorder [ i ] < min or preorder [ i ] > max : NEW_LINE INDENT return NEW_LINE DEDENT val = preorder [ i ] NEW_LINE i += 1 NEW_LINE dfs ( min , val ) NEW_LINE dfs ( val , max ) NEW_LINE DEDENT dfs ( - math . inf , math . inf ) NEW_LINE return i == len ( preorder ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minCost ( self , costs : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT for i in range ( 1 , len ( costs ) ) : NEW_LINE INDENT costs [ i ] [ 0 ] += min ( costs [ i - 1 ] [ 1 ] , costs [ i - 1 ] [ 2 ] ) NEW_LINE costs [ i ] [ 1 ] += min ( costs [ i - 1 ] [ 0 ] , costs [ i - 1 ] [ 2 ] ) NEW_LINE costs [ i ] [ 2 ] += min ( costs [ i - 1 ] [ 0 ] , costs [ i - 1 ] [ 1 ] ) NEW_LINE DEDENT return min ( costs [ - 1 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def binaryTreePaths ( self , root : Optional [ TreeNode ] ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( root : Optional [ TreeNode ] , path : List [ str ] ) -> None : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT if not root . left and not root . right : NEW_LINE INDENT ans . append ( ' ' . join ( path ) + str ( root . val ) ) NEW_LINE return NEW_LINE DEDENT path . append ( str ( root . val ) + ' - > ' ) NEW_LINE dfs ( root . left , path ) NEW_LINE dfs ( root . right , path ) NEW_LINE path . pop ( ) NEW_LINE DEDENT dfs ( root , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def addDigits ( self , num : int ) -> int : NEW_LINE INDENT return 0 if num == 0 else 1 + ( num - 1 ) % 9 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def threeSumSmaller ( self , nums : List [ int ] , target : int ) -> int : NEW_LINE INDENT if len ( nums ) < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE nums . sort ( ) NEW_LINE for i in range ( len ( nums ) - 2 ) : NEW_LINE INDENT l = i + 1 NEW_LINE r = len ( nums ) - 1 NEW_LINE while l < r : NEW_LINE INDENT if nums [ i ] + nums [ l ] + nums [ r ] < target : NEW_LINE INDENT ans += r - l NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeDuplicates ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT i = 0 NEW_LINE for num in nums : NEW_LINE INDENT if i < 1 or num > nums [ i - 1 ] : NEW_LINE INDENT nums [ i ] = num NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def singleNumber ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT xors = functools . reduce ( operator . xor , nums ) NEW_LINE lowbit = xors & - xors NEW_LINE ans = [ 0 , 0 ] NEW_LINE for num in nums : NEW_LINE INDENT if num & lowbit : NEW_LINE INDENT ans [ 0 ] ^= num NEW_LINE DEDENT else : NEW_LINE INDENT ans [ 1 ] ^= num NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def validTree ( self , n : int , edges : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT if n == 0 or len ( edges ) != n - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT graph = [ [ ] for _ in range ( n ) ] NEW_LINE q = deque ( [ 0 ] ) NEW_LINE seen = { 0 } NEW_LINE for u , v in edges : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT while q : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT if v not in seen : NEW_LINE INDENT q . append ( v ) NEW_LINE seen . add ( v ) NEW_LINE DEDENT DEDENT DEDENT return len ( seen ) == n NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isUgly ( self , n : int ) -> bool : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for prime in 2 , 3 , 5 : NEW_LINE INDENT while n % prime == 0 : NEW_LINE INDENT n //= prime NEW_LINE DEDENT DEDENT return n == 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nthUglyNumber ( self , n : int ) -> int : NEW_LINE INDENT nums = [ 1 ] NEW_LINE i2 = 0 NEW_LINE i3 = 0 NEW_LINE i5 = 0 NEW_LINE while len ( nums ) < n : NEW_LINE INDENT next2 = nums [ i2 ] * 2 NEW_LINE next3 = nums [ i3 ] * 3 NEW_LINE next5 = nums [ i5 ] * 5 NEW_LINE next = min ( next2 , next3 , next5 ) NEW_LINE if next == next2 : NEW_LINE INDENT i2 += 1 NEW_LINE DEDENT if next == next3 : NEW_LINE INDENT i3 += 1 NEW_LINE DEDENT if next == next5 : NEW_LINE INDENT i5 += 1 NEW_LINE DEDENT nums . append ( next ) NEW_LINE DEDENT return nums [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minCostII ( self , costs : List [ List [ int ] ] ) -> int : NEW_LINE INDENT prevIndex = - 1 NEW_LINE prevMin1 = 0 NEW_LINE prevMin2 = 0 NEW_LINE for cost in costs : NEW_LINE INDENT index = - 1 NEW_LINE min1 = math . inf NEW_LINE min2 = math . inf NEW_LINE for i , cst in enumerate ( cost ) : NEW_LINE INDENT theCost = cst + ( prevMin2 if i == prevIndex else prevMin1 ) NEW_LINE if theCost < min1 : NEW_LINE INDENT index = i NEW_LINE min2 = min1 NEW_LINE min1 = theCost NEW_LINE DEDENT elif theCost < min2 : NEW_LINE INDENT min2 = theCost NEW_LINE DEDENT DEDENT prevIndex = index NEW_LINE prevMin1 = min1 NEW_LINE prevMin2 = min2 NEW_LINE DEDENT return prevMin1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canPermutePalindrome ( self , s : str ) -> bool : NEW_LINE INDENT seen = set ( ) NEW_LINE for c in s : NEW_LINE INDENT if c in seen : NEW_LINE INDENT seen . remove ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT seen . add ( c ) NEW_LINE DEDENT DEDENT return len ( seen ) <= 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def generatePalindromes ( self , s : str ) -> List [ str ] : NEW_LINE INDENT count = Counter ( s ) NEW_LINE odd = sum ( value & 1 for value in count . values ( ) ) NEW_LINE if odd > 1 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT ans = [ ] NEW_LINE candidates = [ ] NEW_LINE mid = ' ' NEW_LINE for key , value in count . items ( ) : NEW_LINE INDENT if value & 1 : NEW_LINE INDENT mid += key NEW_LINE DEDENT for _ in range ( value // 2 ) : NEW_LINE INDENT candidates . append ( key ) NEW_LINE DEDENT DEDENT def dfs ( used : List [ bool ] , path : List [ chr ] ) -> None : NEW_LINE INDENT if len ( path ) == len ( candidates ) : NEW_LINE INDENT ans . append ( ' ' . join ( path ) + mid + ' ' . join ( path [ : : - 1 ] ) ) NEW_LINE return NEW_LINE DEDENT for i , candidate in enumerate ( candidates ) : NEW_LINE INDENT if used [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT if i > 0 and candidate == candidates [ i - 1 ] and not used [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT used [ i ] = True NEW_LINE path . append ( candidate ) NEW_LINE dfs ( used , path ) NEW_LINE path . pop ( ) NEW_LINE used [ i ] = False NEW_LINE DEDENT DEDENT dfs ( [ False ] * len ( candidates ) , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def missingNumber ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = len ( nums ) NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT ans ^= i ^ num NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def alienOrder ( self , words : List [ str ] ) -> str : NEW_LINE INDENT graph = { } NEW_LINE inDegree = [ 0 ] * 26 NEW_LINE self . _buildGraph ( graph , words , inDegree ) NEW_LINE return self . _topology ( graph , inDegree ) NEW_LINE DEDENT def _buildGraph ( self , graph : Dict [ chr , Set [ chr ] ] , words : List [ str ] , inDegree : List [ int ] ) -> None : NEW_LINE INDENT for word in words : NEW_LINE INDENT for c in word : NEW_LINE INDENT if c not in graph : NEW_LINE INDENT graph [ c ] = set ( ) NEW_LINE DEDENT DEDENT DEDENT for first , second in zip ( words , words [ 1 : ] ) : NEW_LINE INDENT length = min ( len ( first ) , len ( second ) ) NEW_LINE for j in range ( length ) : NEW_LINE INDENT u = first [ j ] NEW_LINE v = second [ j ] NEW_LINE if u != v : NEW_LINE INDENT if v not in graph [ u ] : NEW_LINE INDENT graph [ u ] . add ( v ) NEW_LINE inDegree [ ord ( v ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT break NEW_LINE DEDENT if j == length - 1 and len ( first ) > len ( second ) : NEW_LINE INDENT graph . clear ( ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT DEDENT def _topology ( self , graph : Dict [ chr , Set [ chr ] ] , inDegree : List [ int ] ) -> str : NEW_LINE INDENT s = ' ' NEW_LINE q = deque ( ) NEW_LINE for c in graph : NEW_LINE INDENT if inDegree [ ord ( c ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT q . append ( c ) NEW_LINE DEDENT DEDENT while q : NEW_LINE INDENT u = q . pop ( ) NEW_LINE s += u NEW_LINE for v in graph [ u ] : NEW_LINE INDENT inDegree [ ord ( v ) - ord ( ' a ' ) ] -= 1 NEW_LINE if inDegree [ ord ( v ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT q . append ( v ) NEW_LINE DEDENT DEDENT DEDENT return s if len ( s ) == len ( graph ) else ' ' NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeElement ( self , nums : List [ int ] , val : int ) -> int : NEW_LINE INDENT i = 0 NEW_LINE for num in nums : NEW_LINE INDENT if num != val : NEW_LINE INDENT nums [ i ] = num NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def closestValue ( self , root : Optional [ TreeNode ] , target : float ) -> int : NEW_LINE INDENT if target < root . val and root . left : NEW_LINE INDENT left = self . closestValue ( root . left , target ) NEW_LINE if abs ( left - target ) < abs ( root . val - target ) : NEW_LINE INDENT return left NEW_LINE DEDENT DEDENT if target > root . val and root . right : NEW_LINE INDENT right = self . closestValue ( root . right , target ) NEW_LINE if abs ( right - target ) < abs ( root . val - target ) : NEW_LINE INDENT return right NEW_LINE DEDENT DEDENT return root . val NEW_LINE DEDENT DEDENT
class Codec : NEW_LINE INDENT def encode ( self , strs : List [ str ] ) -> str : NEW_LINE INDENT return ' ' . join ( str ( len ( s ) ) + ' / ' + s for s in strs ) NEW_LINE DEDENT def decode ( self , s : str ) -> List [ str ] : NEW_LINE INDENT decoded = [ ] NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT slash = s . find ( ' / ' , i ) NEW_LINE length = int ( s [ i : slash ] ) NEW_LINE i = slash + length + 1 NEW_LINE decoded . append ( s [ slash + 1 : i ] ) NEW_LINE DEDENT return decoded NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def closestKValues ( self , root : Optional [ TreeNode ] , target : float , k : int ) -> List [ int ] : NEW_LINE INDENT q = deque ( ) NEW_LINE def inorder ( root : Optional [ TreeNode ] ) -> None : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( root . left ) NEW_LINE q . append ( root . val ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT inorder ( root ) NEW_LINE while len ( q ) > k : NEW_LINE INDENT if abs ( q [ 0 ] - target ) > abs ( q [ - 1 ] - target ) : NEW_LINE INDENT q . popleft ( ) NEW_LINE DEDENT else : NEW_LINE INDENT q . pop ( ) NEW_LINE DEDENT DEDENT return list ( q ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberToWords ( self , num : int ) -> str : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT return " Zero " NEW_LINE DEDENT belowTwenty = [ " " , " One " , " Two " , " Three " , " Four " , " Five " , " Six " , " Seven " , " Eight " , " Nine " , " Ten " , " Eleven " , " Twelve " , " Thirteen " , " Fourteen " , " Fifteen " , " Sixteen " , " Seventeen " , " Eighteen " , " Nineteen " ] NEW_LINE tens = [ " " , " Ten " , " Twenty " , " Thirty " , " Forty " , " Fifty " , " Sixty " , " Seventy " , " Eighty " , " Ninety " ] NEW_LINE def helper ( num : int ) -> str : NEW_LINE INDENT if num < 20 : NEW_LINE INDENT s = belowTwenty [ num ] NEW_LINE DEDENT elif num < 100 : NEW_LINE INDENT s = tens [ num // 10 ] + " ▁ " + belowTwenty [ num % 10 ] NEW_LINE DEDENT elif num < 1000 : NEW_LINE INDENT s = helper ( num // 100 ) + " ▁ Hundred ▁ " + helper ( num % 100 ) NEW_LINE DEDENT elif num < 1000000 : NEW_LINE INDENT s = helper ( num // 1000 ) + " ▁ Thousand ▁ " + helper ( num % 1000 ) NEW_LINE DEDENT elif num < 1000000000 : NEW_LINE INDENT s = helper ( num // 1000000 ) + " ▁ Million ▁ " + helper ( num % 1000000 ) NEW_LINE DEDENT else : NEW_LINE INDENT s = helper ( num // 1000000000 ) + " ▁ Billion ▁ " + helper ( num % 1000000000 ) NEW_LINE DEDENT return s . strip ( ) NEW_LINE DEDENT return helper ( num ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def hIndex ( self , citations : List [ int ] ) -> int : NEW_LINE INDENT n = len ( citations ) NEW_LINE accumulate = 0 NEW_LINE count = [ 0 ] * ( n + 1 ) NEW_LINE for citation in citations : NEW_LINE INDENT count [ min ( citation , n ) ] += 1 NEW_LINE DEDENT for i , c in reversed ( list ( enumerate ( count ) ) ) : NEW_LINE INDENT accumulate += c NEW_LINE if accumulate >= i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def hIndex ( self , citations : List [ int ] ) -> int : NEW_LINE INDENT l = 0 NEW_LINE r = len ( citations ) NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if citations [ m ] >= len ( citations ) - m : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return len ( citations ) - l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numWays ( self , n : int , k : int ) -> int : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return k NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return k * k NEW_LINE DEDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = k NEW_LINE dp [ 2 ] = k * k NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) * ( k - 1 ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findCelebrity ( self , n : int ) -> int : NEW_LINE INDENT candidate = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if knows ( candidate , i ) : NEW_LINE INDENT candidate = i NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if i < candidate and knows ( candidate , i ) or not knows ( i , candidate ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if i > candidate and not knows ( i , candidate ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return candidate NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def firstBadVersion ( self , n : int ) -> int : NEW_LINE INDENT l = 1 NEW_LINE r = n NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) >> 1 NEW_LINE if isBadVersion ( m ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numSquares ( self , n : int ) -> int : NEW_LINE INDENT dp = [ n ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while j * j <= i : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ i - j * j ] + 1 ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def strStr ( self , haystack : str , needle : str ) -> int : NEW_LINE INDENT m = len ( haystack ) NEW_LINE n = len ( needle ) NEW_LINE for i in range ( m - n + 1 ) : NEW_LINE INDENT if haystack [ i : i + n ] == needle : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def wiggleSort ( self , nums : List [ int ] ) -> None : NEW_LINE INDENT for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT if not ( i & 1 ) and nums [ i ] > nums [ i - 1 ] or ( i & 1 ) and nums [ i ] < nums [ i - 1 ] : NEW_LINE INDENT nums [ i ] , nums [ i - 1 ] = nums [ i - 1 ] , nums [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
class ZigzagIterator : NEW_LINE INDENT def __init__ ( self , v1 : List [ int ] , v2 : List [ int ] ) : NEW_LINE INDENT def vals ( ) : NEW_LINE INDENT for i in itertools . count ( ) : NEW_LINE INDENT for v in v1 , v2 : NEW_LINE INDENT if i < len ( v ) : NEW_LINE INDENT yield v [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT self . vals = vals ( ) NEW_LINE self . n = len ( v1 ) + len ( v2 ) NEW_LINE DEDENT def next ( self ) : NEW_LINE INDENT self . n -= 1 NEW_LINE return next ( self . vals ) NEW_LINE DEDENT def hasNext ( self ) : NEW_LINE INDENT return self . n > 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def addOperators ( self , num : str , target : int ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( start : int , prev : int , eval : int , path : List [ str ] ) -> None : NEW_LINE INDENT if start == len ( num ) : NEW_LINE INDENT if eval == target : NEW_LINE INDENT ans . append ( ' ' . join ( path ) ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( start , len ( num ) ) : NEW_LINE INDENT if i > start and num [ start ] == '0' : NEW_LINE INDENT return NEW_LINE DEDENT s = num [ start : i + 1 ] NEW_LINE curr = int ( s ) NEW_LINE if start == 0 : NEW_LINE INDENT path . append ( s ) NEW_LINE dfs ( i + 1 , curr , curr , path ) NEW_LINE path . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT for op in [ ' + ' , ' - ' , ' * ' ] : NEW_LINE INDENT path . append ( op + s ) NEW_LINE if op == ' + ' : NEW_LINE INDENT dfs ( i + 1 , curr , eval + curr , path ) NEW_LINE DEDENT elif op == ' - ' : NEW_LINE INDENT dfs ( i + 1 , - curr , eval - curr , path ) NEW_LINE DEDENT else : NEW_LINE INDENT dfs ( i + 1 , prev * curr , eval - prev + prev * curr , path ) NEW_LINE DEDENT path . pop ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT dfs ( 0 , 0 , 0 , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def moveZeroes ( self , nums : List [ int ] ) -> None : NEW_LINE INDENT j = 0 NEW_LINE for num in nums : NEW_LINE INDENT if num != 0 : NEW_LINE INDENT nums [ j ] = num NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( j , len ( nums ) ) : NEW_LINE INDENT nums [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT
class PeekingIterator : NEW_LINE INDENT def __init__ ( self , iterator : Iterator ) : NEW_LINE INDENT self . iterator = iterator NEW_LINE self . buffer = self . iterator . next ( ) if self . iterator . hasNext ( ) else None NEW_LINE DEDENT def peek ( self ) -> int : NEW_LINE INDENT return self . buffer NEW_LINE DEDENT def next ( self ) -> int : NEW_LINE INDENT next = self . buffer NEW_LINE self . buffer = self . iterator . next ( ) if self . iterator . hasNext ( ) else None NEW_LINE return next NEW_LINE DEDENT def hasNext ( self ) -> bool : NEW_LINE INDENT return self . buffer is not None NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def inorderSuccessor ( self , root : Optional [ TreeNode ] , p : Optional [ TreeNode ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return None NEW_LINE DEDENT if root . val <= p . val : NEW_LINE INDENT return self . inorderSuccessor ( root . right , p ) NEW_LINE DEDENT return self . inorderSuccessor ( root . left , p ) or root NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def wallsAndGates ( self , rooms : List [ List [ int ] ] ) -> None : NEW_LINE INDENT kInf = 2 ** 31 - 1 NEW_LINE m = len ( rooms ) NEW_LINE n = len ( rooms [ 0 ] ) NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE q = deque ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if rooms [ i ] [ j ] == 0 : NEW_LINE INDENT q . append ( ( i , j ) ) NEW_LINE DEDENT DEDENT DEDENT while q : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT if rooms [ x ] [ y ] != kInf : NEW_LINE INDENT continue NEW_LINE DEDENT rooms [ x ] [ y ] = rooms [ i ] [ j ] + 1 NEW_LINE q . append ( ( x , y ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def findDuplicate ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT slow = nums [ nums [ 0 ] ] NEW_LINE fast = nums [ nums [ nums [ 0 ] ] ] NEW_LINE while slow != fast : NEW_LINE INDENT slow = nums [ slow ] NEW_LINE fast = nums [ nums [ fast ] ] NEW_LINE DEDENT slow = nums [ 0 ] NEW_LINE while slow != fast : NEW_LINE INDENT slow = nums [ slow ] NEW_LINE fast = nums [ fast ] NEW_LINE DEDENT return slow NEW_LINE DEDENT DEDENT
class ValidWordAbbr : NEW_LINE INDENT def __init__ ( self , dictionary : List [ str ] ) : NEW_LINE INDENT self . dict = set ( dictionary ) NEW_LINE self . abbrUnique = { } NEW_LINE for word in self . dict : NEW_LINE INDENT abbr = self . _getAbbr ( word ) NEW_LINE self . abbrUnique [ abbr ] = abbr not in self . abbrUnique NEW_LINE DEDENT DEDENT def isUnique ( self , word : str ) -> bool : NEW_LINE INDENT abbr = self . _getAbbr ( word ) NEW_LINE return abbr not in self . abbrUnique or self . abbrUnique [ abbr ] and word in self . dict NEW_LINE DEDENT def _getAbbr ( self , s : str ) -> str : NEW_LINE INDENT n = len ( s ) NEW_LINE if n <= 2 : NEW_LINE INDENT return s NEW_LINE DEDENT return s [ 0 ] + str ( n - 2 ) + s [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def gameOfLife ( self , board : List [ List [ int ] ] ) -> None : NEW_LINE INDENT m = len ( board ) NEW_LINE n = len ( board [ 0 ] ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT ones = 0 NEW_LINE for x in range ( max ( 0 , i - 1 ) , min ( m , i + 2 ) ) : NEW_LINE INDENT for y in range ( max ( 0 , j - 1 ) , min ( n , j + 2 ) ) : NEW_LINE INDENT ones += board [ x ] [ y ] & 1 NEW_LINE DEDENT DEDENT if board [ i ] [ j ] == 1 and ( ones == 3 or ones == 4 ) : NEW_LINE INDENT board [ i ] [ j ] |= 0b10 NEW_LINE DEDENT if board [ i ] [ j ] == 0 and ones == 3 : NEW_LINE INDENT board [ i ] [ j ] |= 0b10 NEW_LINE DEDENT DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT board [ i ] [ j ] >>= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def divide ( self , dividend : int , divisor : int ) -> int : NEW_LINE INDENT if dividend == - 2 ** 31 and divisor == - 1 : NEW_LINE INDENT return 2 ** 31 - 1 NEW_LINE DEDENT sign = - 1 if ( dividend > 0 ) ^ ( divisor > 0 ) else 1 NEW_LINE ans = 0 NEW_LINE dvd = abs ( dividend ) NEW_LINE dvs = abs ( divisor ) NEW_LINE while dvd >= dvs : NEW_LINE INDENT k = 1 NEW_LINE while k * 2 * dvs <= dvd : NEW_LINE INDENT k <<= 1 NEW_LINE DEDENT dvd -= k * dvs NEW_LINE ans += k NEW_LINE DEDENT return sign * ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def wordPattern ( self , pattern : str , str : str ) -> bool : NEW_LINE INDENT t = str . split ( ) NEW_LINE return [ * map ( pattern . index , pattern ) ] == [ * map ( t . index , t ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def wordPatternMatch ( self , pattern : str , s : str ) -> bool : NEW_LINE INDENT def isMatch ( i : int , j : int , charToString : Dict [ chr , str ] , seen : Set [ str ] ) -> bool : NEW_LINE INDENT if i == len ( pattern ) and j == len ( s ) : NEW_LINE INDENT return True NEW_LINE DEDENT if i == len ( pattern ) or j == len ( s ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = pattern [ i ] NEW_LINE if c in charToString : NEW_LINE INDENT t = charToString [ c ] NEW_LINE if t not in s [ j : ] : NEW_LINE INDENT return False NEW_LINE DEDENT return isMatch ( i + 1 , j + len ( t ) , charToString , seen ) NEW_LINE DEDENT for k in range ( j , len ( s ) ) : NEW_LINE INDENT t = s [ j : k + 1 ] NEW_LINE if t in seen : NEW_LINE INDENT continue NEW_LINE DEDENT charToString [ c ] = t NEW_LINE seen . add ( t ) NEW_LINE if isMatch ( i + 1 , k + 1 , charToString , seen ) : NEW_LINE INDENT return True NEW_LINE DEDENT del charToString [ c ] NEW_LINE seen . remove ( t ) NEW_LINE DEDENT return False NEW_LINE DEDENT return isMatch ( 0 , 0 , { } , set ( ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canWinNim ( self , n : int ) -> bool : NEW_LINE INDENT return n % 4 != 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def generatePossibleNextMoves ( self , currentState : str ) -> List [ str ] : NEW_LINE INDENT return [ currentState [ : i ] + ' - - ' + currentState [ i + 2 : ] for i , ( a , b ) in enumerate ( zip ( currentState , currentState [ 1 : ] ) ) if a == ' + ' and b == ' + ' ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def canWin ( self , currentState : str ) -> bool : NEW_LINE INDENT return any ( True for i , ( a , b ) in enumerate ( zip ( currentState , currentState [ 1 : ] ) ) if a == ' + ' and b == ' + ' and not self . canWin ( currentState [ : i ] + ' - ' + currentState [ i + 2 : ] ) ) NEW_LINE DEDENT DEDENT
class MedianFinder : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . maxHeap = [ ] NEW_LINE self . minHeap = [ ] NEW_LINE DEDENT def addNum ( self , num : int ) -> None : NEW_LINE INDENT if not self . maxHeap or num <= - self . maxHeap [ 0 ] : NEW_LINE INDENT heapq . heappush ( self . maxHeap , - num ) NEW_LINE DEDENT else : NEW_LINE INDENT heapq . heappush ( self . minHeap , num ) NEW_LINE DEDENT if len ( self . maxHeap ) < len ( self . minHeap ) : NEW_LINE INDENT heapq . heappush ( self . maxHeap , - heapq . heappop ( self . minHeap ) ) NEW_LINE DEDENT elif len ( self . maxHeap ) - len ( self . minHeap ) > 1 : NEW_LINE INDENT heapq . heappush ( self . minHeap , - heapq . heappop ( self . maxHeap ) ) NEW_LINE DEDENT DEDENT def findMedian ( self ) -> float : NEW_LINE INDENT if len ( self . maxHeap ) == len ( self . minHeap ) : NEW_LINE INDENT return ( - self . maxHeap [ 0 ] + self . minHeap [ 0 ] ) / 2.0 NEW_LINE DEDENT return - self . maxHeap [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minTotalDistance ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE I = [ i for i in range ( m ) for j in range ( n ) if grid [ i ] [ j ] ] NEW_LINE J = [ j for j in range ( n ) for i in range ( m ) if grid [ i ] [ j ] ] NEW_LINE def minTotalDistance ( grid : List [ int ] ) -> int : NEW_LINE INDENT summ = 0 NEW_LINE i = 0 NEW_LINE j = len ( grid ) - 1 NEW_LINE while i < j : NEW_LINE INDENT summ += grid [ j ] - grid [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return summ NEW_LINE DEDENT return minTotalDistance ( I ) + minTotalDistance ( J ) NEW_LINE DEDENT DEDENT
class Codec : NEW_LINE INDENT def serialize ( self , root : ' TreeNode ' ) -> str : NEW_LINE INDENT if not root : NEW_LINE INDENT return ' ' NEW_LINE DEDENT s = ' ' NEW_LINE q = deque ( [ root ] ) NEW_LINE while q : NEW_LINE INDENT node = q . popleft ( ) NEW_LINE if node : NEW_LINE INDENT s += str ( node . val ) + ' ▁ ' NEW_LINE q . append ( node . left ) NEW_LINE q . append ( node . right ) NEW_LINE DEDENT else : NEW_LINE INDENT s += ' n ▁ ' NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT def deserialize ( self , data : str ) -> ' TreeNode ' : NEW_LINE INDENT if not data : NEW_LINE INDENT return None NEW_LINE DEDENT vals = data . split ( ) NEW_LINE root = TreeNode ( vals [ 0 ] ) NEW_LINE q = deque ( [ root ] ) NEW_LINE for i in range ( 1 , len ( vals ) , 2 ) : NEW_LINE INDENT node = q . popleft ( ) NEW_LINE if vals [ i ] != ' n ' : NEW_LINE INDENT node . left = TreeNode ( vals [ i ] ) NEW_LINE q . append ( node . left ) NEW_LINE DEDENT if vals [ i + 1 ] != ' n ' : NEW_LINE INDENT node . right = TreeNode ( vals [ i + 1 ] ) NEW_LINE q . append ( node . right ) NEW_LINE DEDENT DEDENT return root NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestConsecutive ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT def dfs ( root : Optional [ TreeNode ] , target : int , length : int , maxLength : int ) -> int : NEW_LINE INDENT if not root : NEW_LINE INDENT return maxLength NEW_LINE DEDENT if root . val == target : NEW_LINE INDENT length += 1 NEW_LINE maxLength = max ( maxLength , length ) NEW_LINE DEDENT else : NEW_LINE INDENT length = 1 NEW_LINE DEDENT return max ( dfs ( root . left , root . val + 1 , length , maxLength ) , dfs ( root . right , root . val + 1 , length , maxLength ) ) NEW_LINE DEDENT return dfs ( root , root . val , 0 , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getHint ( self , secret : str , guess : str ) -> str : NEW_LINE INDENT bulls = sum ( map ( operator . eq , secret , guess ) ) NEW_LINE bovine = sum ( min ( secret . count ( x ) , guess . count ( x ) ) for x in set ( guess ) ) NEW_LINE return ' % dA % dB ' % ( bulls , bovine - bulls ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def lengthOfLongestSubstring ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = Counter ( ) NEW_LINE l = 0 NEW_LINE for r , c in enumerate ( s ) : NEW_LINE INDENT count [ c ] += 1 NEW_LINE while count [ c ] > 1 : NEW_LINE INDENT count [ s [ l ] ] -= 1 NEW_LINE l += 1 NEW_LINE DEDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findSubstring ( self , s : str , words : List [ str ] ) -> List [ int ] : NEW_LINE INDENT if len ( s ) == 0 or words == [ ] : NEW_LINE INDENT return [ ] NEW_LINE DEDENT k = len ( words ) NEW_LINE n = len ( words [ 0 ] ) NEW_LINE ans = [ ] NEW_LINE count = Counter ( words ) NEW_LINE for i in range ( len ( s ) - k * n + 1 ) : NEW_LINE INDENT seen = defaultdict ( int ) NEW_LINE j = 0 NEW_LINE while j < k : NEW_LINE INDENT word = s [ i + j * n : i + j * n + n ] NEW_LINE seen [ word ] += 1 NEW_LINE if seen [ word ] > count [ word ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == k : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def lengthOfLIS ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT if not nums : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ 1 ] * len ( nums ) NEW_LINE for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if nums [ j ] < nums [ i ] : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max ( dp ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeInvalidParentheses ( self , s : str ) -> List [ str ] : NEW_LINE INDENT def getLeftAndRightCounts ( s : str ) -> tuple : NEW_LINE INDENT l = 0 NEW_LINE r = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == ' ( ' : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif c == ' ) ' : NEW_LINE INDENT if l == 0 : NEW_LINE INDENT r += 1 NEW_LINE DEDENT else : NEW_LINE INDENT l -= 1 NEW_LINE DEDENT DEDENT DEDENT return l , r NEW_LINE DEDENT def isValid ( s : str ) : NEW_LINE INDENT count = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == ' ( ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif c == ' ) ' : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if count < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT ans = [ ] NEW_LINE def dfs ( s : str , start : int , l : int , r : int ) -> None : NEW_LINE INDENT if l == 0 and r == 0 and isValid ( s ) : NEW_LINE INDENT ans . append ( s ) NEW_LINE return NEW_LINE DEDENT for i in range ( start , len ( s ) ) : NEW_LINE INDENT if i > start and s [ i ] == s [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT if r > 0 and s [ i ] == ' ) ' : NEW_LINE INDENT dfs ( s [ : i ] + s [ i + 1 : ] , i , l , r - 1 ) NEW_LINE DEDENT elif l > 0 and s [ i ] == ' ( ' : NEW_LINE INDENT dfs ( s [ : i ] + s [ i + 1 : ] , i , l - 1 , r ) NEW_LINE DEDENT DEDENT DEDENT l , r = getLeftAndRightCounts ( s ) NEW_LINE dfs ( s , 0 , l , r ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minArea ( self , image : List [ List [ str ] ] , x : int , y : int ) -> int : NEW_LINE INDENT m = len ( image ) NEW_LINE n = len ( image [ 0 ] ) NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE topLeft = [ x , y ] NEW_LINE bottomRight = [ x , y ] NEW_LINE q = deque ( [ ( x , y ) ] ) NEW_LINE image [ x ] [ y ] = '2' NEW_LINE while q : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT r = i + dirs [ k ] NEW_LINE c = j + dirs [ k + 1 ] NEW_LINE if r < 0 or r == m or c < 0 or c == n : NEW_LINE INDENT continue NEW_LINE DEDENT if image [ r ] [ c ] != '1' : NEW_LINE INDENT continue NEW_LINE DEDENT topLeft [ 0 ] = min ( topLeft [ 0 ] , r ) NEW_LINE topLeft [ 1 ] = min ( topLeft [ 1 ] , c ) NEW_LINE bottomRight [ 0 ] = max ( bottomRight [ 0 ] , r ) NEW_LINE bottomRight [ 1 ] = max ( bottomRight [ 1 ] , c ) NEW_LINE q . append ( ( r , c ) ) NEW_LINE image [ r ] [ c ] = '2' NEW_LINE DEDENT DEDENT width = bottomRight [ 1 ] - topLeft [ 1 ] + 1 NEW_LINE height = bottomRight [ 0 ] - topLeft [ 0 ] + 1 NEW_LINE return width * height NEW_LINE DEDENT DEDENT
class NumArray : NEW_LINE INDENT def __init__ ( self , nums : List [ int ] ) : NEW_LINE INDENT self . prefix = [ 0 ] + list ( itertools . accumulate ( nums ) ) NEW_LINE DEDENT def sumRange ( self , left : int , right : int ) -> int : NEW_LINE INDENT return self . prefix [ right + 1 ] - self . prefix [ left ] NEW_LINE DEDENT DEDENT
class NumMatrix : NEW_LINE INDENT def __init__ ( self , matrix : List [ List [ int ] ] ) : NEW_LINE INDENT if not matrix : NEW_LINE INDENT return NEW_LINE DEDENT m = len ( matrix ) NEW_LINE n = len ( matrix [ 0 ] ) NEW_LINE self . prefix = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT self . prefix [ i + 1 ] [ j + 1 ] = matrix [ i ] [ j ] + self . prefix [ i ] [ j + 1 ] + self . prefix [ i + 1 ] [ j ] - self . prefix [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def sumRegion ( self , row1 : int , col1 : int , row2 : int , col2 : int ) -> int : NEW_LINE INDENT return self . prefix [ row2 + 1 ] [ col2 + 1 ] - self . prefix [ row1 ] [ col2 + 1 ] - self . prefix [ row2 + 1 ] [ col1 ] + self . prefix [ row1 ] [ col1 ] NEW_LINE DEDENT DEDENT
class UnionFind : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . id = [ - 1 ] * n NEW_LINE DEDENT def union ( self , u : int , v : int ) -> None : NEW_LINE INDENT self . id [ u ] = v NEW_LINE DEDENT def find ( self , u : int ) -> int : NEW_LINE INDENT if self . id [ u ] != u : NEW_LINE INDENT self . id [ u ] = self . find ( self . id [ u ] ) NEW_LINE DEDENT return self . id [ u ] NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def numIslands2 ( self , m : int , n : int , positions : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE ans = [ ] NEW_LINE seen = [ [ False ] * n for _ in range ( m ) ] NEW_LINE uf = UnionFind ( m * n ) NEW_LINE count = 0 NEW_LINE def getId ( i : int , j : int , n : int ) -> int : NEW_LINE INDENT return i * n + j NEW_LINE DEDENT for i , j in positions : NEW_LINE INDENT if seen [ i ] [ j ] : NEW_LINE INDENT ans . append ( count ) NEW_LINE continue NEW_LINE DEDENT seen [ i ] [ j ] = True NEW_LINE id = getId ( i , j , n ) NEW_LINE uf . id [ id ] = id NEW_LINE count += 1 NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT neighborId = getId ( x , y , n ) NEW_LINE if uf . id [ neighborId ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT currentParent = uf . find ( id ) NEW_LINE neighborParent = uf . find ( neighborId ) NEW_LINE if currentParent != neighborParent : NEW_LINE INDENT uf . union ( currentParent , neighborParent ) NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT ans . append ( count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isAdditiveNumber ( self , num : str ) -> bool : NEW_LINE INDENT n = len ( num ) NEW_LINE def dfs ( firstNum : int , secondNum : int , s : int ) -> bool : NEW_LINE INDENT if s == len ( num ) : NEW_LINE INDENT return True NEW_LINE DEDENT thirdNum = firstNum + secondNum NEW_LINE thirdNumStr = str ( thirdNum ) NEW_LINE return num . find ( thirdNumStr , s ) == s and dfs ( secondNum , thirdNum , s + len ( thirdNumStr ) ) NEW_LINE DEDENT for i in range ( n // 2 ) : NEW_LINE INDENT if i > 0 and num [ 0 ] == '0' : NEW_LINE INDENT return False NEW_LINE DEDENT firstNum = int ( num [ : i + 1 ] ) NEW_LINE j = i + 1 NEW_LINE while max ( i , j - i ) < n - j : NEW_LINE INDENT if j > i + 1 and num [ i + 1 ] == '0' : NEW_LINE INDENT break NEW_LINE DEDENT secondNum = int ( num [ i + 1 : j + 1 ] ) NEW_LINE if dfs ( firstNum , secondNum , j + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class FenwickTree : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . sums = [ 0 ] * ( n + 1 ) NEW_LINE DEDENT def update ( self , i : int , delta : int ) -> None : NEW_LINE INDENT while i < len ( self . sums ) : NEW_LINE INDENT self . sums [ i ] += delta NEW_LINE i += self . _lowbit ( i ) NEW_LINE DEDENT DEDENT def get ( self , i : int ) -> int : NEW_LINE INDENT summ = 0 NEW_LINE while i > 0 : NEW_LINE INDENT summ += self . sums [ i ] NEW_LINE i -= self . _lowbit ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT def _lowbit ( self , i ) -> int : NEW_LINE INDENT return i & - i NEW_LINE DEDENT DEDENT class NumArray : NEW_LINE INDENT def __init__ ( self , nums : List [ int ] ) : NEW_LINE INDENT self . nums = nums NEW_LINE self . tree = FenwickTree ( len ( nums ) ) NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT self . tree . update ( i + 1 , num ) NEW_LINE DEDENT DEDENT def update ( self , index : int , val : int ) -> None : NEW_LINE INDENT self . tree . update ( index + 1 , val - self . nums [ index ] ) NEW_LINE self . nums [ index ] = val NEW_LINE DEDENT def sumRange ( self , left : int , right : int ) -> int : NEW_LINE INDENT return self . tree . get ( right + 1 ) - self . tree . get ( left ) NEW_LINE DEDENT DEDENT
class FenwickTree : NEW_LINE INDENT def __init__ ( self , m : int , n : int ) : NEW_LINE INDENT self . sums = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE DEDENT def update ( self , row : int , col : int , delta : int ) -> None : NEW_LINE INDENT i = row NEW_LINE while i < len ( self . sums ) : NEW_LINE INDENT j = col NEW_LINE while j < len ( self . sums [ 0 ] ) : NEW_LINE INDENT self . sums [ i ] [ j ] += delta NEW_LINE j += j & - j NEW_LINE DEDENT i += i & - i NEW_LINE DEDENT DEDENT def get ( self , row : int , col : int ) -> int : NEW_LINE INDENT summ = 0 NEW_LINE i = row NEW_LINE while i > 0 : NEW_LINE INDENT j = col NEW_LINE while j > 0 : NEW_LINE INDENT summ += self . sums [ i ] [ j ] NEW_LINE j -= j & - j NEW_LINE DEDENT i -= i & - i NEW_LINE DEDENT return summ NEW_LINE DEDENT DEDENT class NumMatrix : NEW_LINE INDENT def __init__ ( self , matrix : List [ List [ int ] ] ) : NEW_LINE INDENT self . matrix = matrix NEW_LINE self . tree = FenwickTree ( len ( matrix ) , len ( matrix [ 0 ] ) ) NEW_LINE for i in range ( len ( matrix ) ) : NEW_LINE INDENT for j , val in enumerate ( matrix [ i ] ) : NEW_LINE INDENT self . tree . update ( i + 1 , j + 1 , val ) NEW_LINE DEDENT DEDENT DEDENT def update ( self , row : int , col : int , val : int ) -> None : NEW_LINE INDENT self . tree . update ( row + 1 , col + 1 , val - self . matrix [ row ] [ col ] ) NEW_LINE self . matrix [ row ] [ col ] = val NEW_LINE DEDENT def sumRegion ( self , row1 : int , col1 : int , row2 : int , col2 : int ) -> int : NEW_LINE INDENT return self . tree . get ( row2 + 1 , col2 + 1 ) - self . tree . get ( row1 , col2 + 1 ) - self . tree . get ( row2 + 1 , col1 ) + self . tree . get ( row1 , col1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxProfit ( self , prices : List [ int ] ) -> int : NEW_LINE INDENT sell = 0 NEW_LINE hold = - math . inf NEW_LINE prev = 0 NEW_LINE for price in prices : NEW_LINE INDENT cache = sell NEW_LINE sell = max ( sell , hold + price ) NEW_LINE hold = max ( hold , prev - price ) NEW_LINE prev = cache NEW_LINE DEDENT return sell NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nextPermutation ( self , nums : List [ int ] ) -> None : NEW_LINE INDENT n = len ( nums ) NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if nums [ i ] < nums [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if i >= 0 : NEW_LINE INDENT for j in range ( n - 1 , i , - 1 ) : NEW_LINE INDENT if nums [ j ] > nums [ i ] : NEW_LINE INDENT nums [ i ] , nums [ j ] = nums [ j ] , nums [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT def reverse ( nums : List [ int ] , l : int , r : int ) -> None : NEW_LINE INDENT while l < r : NEW_LINE INDENT nums [ l ] , nums [ r ] = nums [ r ] , nums [ l ] NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT reverse ( nums , i + 1 , len ( nums ) - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMinHeightTrees ( self , n : int , edges : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT if n == 1 or not edges : NEW_LINE INDENT return [ 0 ] NEW_LINE DEDENT ans = [ ] NEW_LINE graph = defaultdict ( set ) NEW_LINE for u , v in edges : NEW_LINE INDENT graph [ u ] . add ( v ) NEW_LINE graph [ v ] . add ( u ) NEW_LINE DEDENT for label , children in graph . items ( ) : NEW_LINE INDENT if len ( children ) == 1 : NEW_LINE INDENT ans . append ( label ) NEW_LINE DEDENT DEDENT while n > 2 : NEW_LINE INDENT n -= len ( ans ) NEW_LINE nextLeaves = [ ] NEW_LINE for leaf in ans : NEW_LINE INDENT u = next ( iter ( graph [ leaf ] ) ) NEW_LINE graph [ u ] . remove ( leaf ) NEW_LINE if len ( graph [ u ] ) == 1 : NEW_LINE INDENT nextLeaves . append ( u ) NEW_LINE DEDENT DEDENT ans = nextLeaves NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def multiply ( self , mat1 : List [ List [ int ] ] , mat2 : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT m = len ( mat1 ) NEW_LINE n = len ( mat2 ) NEW_LINE l = len ( mat2 [ 0 ] ) NEW_LINE ans = [ [ 0 ] * l for _ in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE INDENT ans [ i ] [ j ] += mat1 [ i ] [ k ] * mat2 [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxCoins ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT A = [ 1 ] + nums + [ 1 ] NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int , j : int ) -> int : NEW_LINE INDENT if i > j : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( dp ( i , k - 1 ) + dp ( k + 1 , j ) + A [ i - 1 ] * A [ k ] * A [ j + 1 ] for k in range ( i , j + 1 ) ) NEW_LINE DEDENT return dp ( 1 , len ( nums ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nthSuperUglyNumber ( self , n : int , primes : List [ int ] ) -> int : NEW_LINE INDENT k = len ( primes ) NEW_LINE nums = [ 1 ] NEW_LINE indices = [ 0 ] * k NEW_LINE while len ( nums ) < n : NEW_LINE INDENT nexts = [ 0 ] * k NEW_LINE for i in range ( k ) : NEW_LINE INDENT nexts [ i ] = nums [ indices [ i ] ] * primes [ i ] NEW_LINE DEDENT next = min ( nexts ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if next == nexts [ i ] : NEW_LINE INDENT indices [ i ] += 1 NEW_LINE DEDENT DEDENT nums . append ( next ) NEW_LINE DEDENT return nums [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def verticalOrder ( self , root : Optional [ TreeNode ] ) -> List [ List [ int ] ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return [ ] NEW_LINE DEDENT range_ = [ 0 ] * 2 NEW_LINE def getRange ( root : Optional [ TreeNode ] , x : int ) -> None : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT range_ [ 0 ] = min ( range_ [ 0 ] , x ) NEW_LINE range_ [ 1 ] = max ( range_ [ 1 ] , x ) NEW_LINE getRange ( root . left , x - 1 ) NEW_LINE getRange ( root . right , x + 1 ) NEW_LINE DEDENT getRange ( root , 0 ) NEW_LINE ans = [ [ ] for _ in range ( range_ [ 1 ] - range_ [ 0 ] + 1 ) ] NEW_LINE q = deque ( [ ( root , - range_ [ 0 ] ) ] ) NEW_LINE while q : NEW_LINE INDENT node , x = q . popleft ( ) NEW_LINE ans [ x ] . append ( node . val ) NEW_LINE if node . left : NEW_LINE INDENT q . append ( ( node . left , x - 1 ) ) NEW_LINE DEDENT if node . right : NEW_LINE INDENT q . append ( ( node . right , x + 1 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class FenwickTree : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . sums = [ 0 ] * ( n + 1 ) NEW_LINE DEDENT def update ( self , i : int , delta : int ) -> None : NEW_LINE INDENT while i < len ( self . sums ) : NEW_LINE INDENT self . sums [ i ] += delta NEW_LINE i += self . _lowbit ( i ) NEW_LINE DEDENT DEDENT def get ( self , i : int ) -> int : NEW_LINE INDENT summ = 0 NEW_LINE while i > 0 : NEW_LINE INDENT summ += self . sums [ i ] NEW_LINE i -= self . _lowbit ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT def _lowbit ( self , i ) -> int : NEW_LINE INDENT return i & - i NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def countSmaller ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE ranks = Counter ( ) NEW_LINE self . _getRanks ( nums , ranks ) NEW_LINE tree = FenwickTree ( len ( ranks ) ) NEW_LINE for num in reversed ( nums ) : NEW_LINE INDENT ans . append ( tree . get ( ranks [ num ] - 1 ) ) NEW_LINE tree . update ( ranks [ num ] , 1 ) NEW_LINE DEDENT return ans [ : : - 1 ] NEW_LINE DEDENT def _getRanks ( self , nums : List [ int ] , ranks : Dict [ int , int ] ) -> None : NEW_LINE INDENT rank = 0 NEW_LINE for num in sorted ( set ( nums ) ) : NEW_LINE INDENT rank += 1 NEW_LINE ranks [ num ] = rank NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeDuplicateLetters ( self , s : str ) -> str : NEW_LINE INDENT ans = [ ] NEW_LINE count = Counter ( s ) NEW_LINE used = [ False ] * 26 NEW_LINE for c in s : NEW_LINE INDENT count [ c ] -= 1 NEW_LINE if used [ ord ( c ) - ord ( ' a ' ) ] : NEW_LINE INDENT continue NEW_LINE DEDENT while ans and ans [ - 1 ] > c and count [ ans [ - 1 ] ] > 0 : NEW_LINE INDENT used [ ord ( ans [ - 1 ] ) - ord ( ' a ' ) ] = False NEW_LINE ans . pop ( ) NEW_LINE DEDENT ans . append ( c ) NEW_LINE used [ ord ( ans [ - 1 ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def shortestDistance ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE nBuildings = sum ( a == 1 for row in grid for a in row ) NEW_LINE ans = math . inf NEW_LINE dist = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE reachCount = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE def bfs ( row : int , col : int ) -> bool : NEW_LINE INDENT q = deque ( [ ( row , col ) ] ) NEW_LINE seen = { ( row , col ) } NEW_LINE depth = 0 NEW_LINE seenBuildings = 1 NEW_LINE while q : NEW_LINE INDENT depth += 1 NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT if ( x , y ) in seen : NEW_LINE INDENT continue NEW_LINE DEDENT seen . add ( ( x , y ) ) NEW_LINE if not grid [ x ] [ y ] : NEW_LINE INDENT dist [ x ] [ y ] += depth NEW_LINE reachCount [ x ] [ y ] += 1 NEW_LINE q . append ( ( x , y ) ) NEW_LINE DEDENT elif grid [ x ] [ y ] == 1 : NEW_LINE INDENT seenBuildings += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return seenBuildings == nBuildings NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT if not bfs ( i , j ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if reachCount [ i ] [ j ] == nBuildings : NEW_LINE INDENT ans = min ( ans , dist [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return - 1 if ans == math . inf else ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxProduct ( self , words : List [ str ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE def getMask ( word : str ) -> int : NEW_LINE INDENT mask = 0 NEW_LINE for c in word : NEW_LINE INDENT mask |= 1 << ord ( c ) - ord ( ' a ' ) NEW_LINE DEDENT return mask NEW_LINE DEDENT masks = [ getMask ( word ) for word in words ] NEW_LINE for i in range ( len ( words ) ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if not ( masks [ i ] & masks [ j ] ) : NEW_LINE INDENT ans = max ( ans , len ( words [ i ] ) * len ( words [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def bulbSwitch ( self , n : int ) -> int : NEW_LINE INDENT return int ( sqrt ( n ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestValidParentheses ( self , s : str ) -> int : NEW_LINE INDENT s2 = ' ) ' + s NEW_LINE dp = [ 0 ] * len ( s2 ) NEW_LINE for i in range ( 1 , len ( s2 ) ) : NEW_LINE INDENT if s2 [ i ] == ' ) ' and s2 [ i - dp [ i - 1 ] - 1 ] == ' ( ' : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - dp [ i - 1 ] - 2 ] + 2 NEW_LINE DEDENT DEDENT return max ( dp ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def generateAbbreviations ( self , word : str ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE def getCountString ( count : int ) -> str : NEW_LINE INDENT return str ( count ) if count > 0 else ' ' NEW_LINE DEDENT def dfs ( i : int , count : int , path : List [ str ] ) -> None : NEW_LINE INDENT if i == len ( word ) : NEW_LINE INDENT ans . append ( ' ' . join ( path ) + getCountString ( count ) ) NEW_LINE return NEW_LINE DEDENT dfs ( i + 1 , count + 1 , path ) NEW_LINE path . append ( getCountString ( count ) + word [ i ] ) NEW_LINE dfs ( i + 1 , 0 , path ) NEW_LINE path . pop ( ) NEW_LINE DEDENT dfs ( 0 , 0 , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def coinChange ( self , coins : List [ int ] , amount : int ) -> int : NEW_LINE INDENT dp = [ 0 ] + [ amount + 1 ] * amount NEW_LINE for coin in coins : NEW_LINE INDENT for i in range ( coin , amount + 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ i - coin ] + 1 ) NEW_LINE DEDENT DEDENT return - 1 if dp [ amount ] == amount + 1 else dp [ amount ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countComponents ( self , n : int , edges : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE seen = set ( ) NEW_LINE for u , v in edges : NEW_LINE INDENT graph [ u ] . append ( v ) NEW_LINE graph [ v ] . append ( u ) NEW_LINE DEDENT def bfs ( node : int , seen : Set [ int ] ) -> None : NEW_LINE INDENT q = deque ( [ node ] ) NEW_LINE seen . add ( node ) NEW_LINE while q : NEW_LINE INDENT u = q . pop ( ) NEW_LINE for v in graph [ u ] : NEW_LINE INDENT if v not in seen : NEW_LINE INDENT q . append ( v ) NEW_LINE seen . add ( v ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if i not in seen : NEW_LINE INDENT bfs ( i , seen ) NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxSubArrayLen ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prefix = 0 NEW_LINE prefixToIndex = { 0 : - 1 } NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT prefix += num NEW_LINE target = prefix - k NEW_LINE if target in prefixToIndex : NEW_LINE INDENT ans = max ( ans , i - prefixToIndex [ target ] ) NEW_LINE DEDENT if prefix not in prefixToIndex : NEW_LINE INDENT prefixToIndex [ prefix ] = i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isPowerOfThree ( self , n : int ) -> bool : NEW_LINE INDENT return n > 0 and 3 ** 19 % n == 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countRangeSum ( self , nums : List [ int ] , lower : int , upper : int ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE self . ans = 0 NEW_LINE prefix = [ 0 ] + list ( itertools . accumulate ( nums ) ) NEW_LINE self . _mergeSort ( prefix , 0 , n , lower , upper ) NEW_LINE return self . ans NEW_LINE DEDENT def _mergeSort ( self , prefix : List [ int ] , l : int , r : int , lower : int , upper : int ) -> None : NEW_LINE INDENT if l >= r : NEW_LINE INDENT return NEW_LINE DEDENT m = ( l + r ) // 2 NEW_LINE self . _mergeSort ( prefix , l , m , lower , upper ) NEW_LINE self . _mergeSort ( prefix , m + 1 , r , lower , upper ) NEW_LINE self . _merge ( prefix , l , m , r , lower , upper ) NEW_LINE DEDENT def _merge ( self , prefix : List [ int ] , l : int , m : int , r : int , lower : int , upper : int ) -> None : NEW_LINE INDENT lo = m + 1 NEW_LINE hi = m + 1 NEW_LINE for i in range ( l , m + 1 ) : NEW_LINE INDENT while lo <= r and prefix [ lo ] - prefix [ i ] < lower : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT while hi <= r and prefix [ hi ] - prefix [ i ] <= upper : NEW_LINE INDENT hi += 1 NEW_LINE DEDENT self . ans += hi - lo NEW_LINE DEDENT sorted = [ 0 ] * ( r - l + 1 ) NEW_LINE k = 0 NEW_LINE i = l NEW_LINE j = m + 1 NEW_LINE while i <= m and j <= r : NEW_LINE INDENT if prefix [ i ] < prefix [ j ] : NEW_LINE INDENT sorted [ k ] = prefix [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sorted [ k ] = prefix [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while i <= m : NEW_LINE INDENT sorted [ k ] = prefix [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT while j <= r : NEW_LINE INDENT sorted [ k ] = prefix [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT prefix [ l : l + len ( sorted ) ] = sorted NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def oddEvenList ( self , head : ListNode ) -> ListNode : NEW_LINE INDENT oddHead = ListNode ( 0 ) NEW_LINE evenHead = ListNode ( 0 ) NEW_LINE odd = oddHead NEW_LINE even = evenHead NEW_LINE isOdd = True NEW_LINE while head : NEW_LINE INDENT if isOdd : NEW_LINE INDENT odd . next = head NEW_LINE odd = head NEW_LINE DEDENT else : NEW_LINE INDENT even . next = head NEW_LINE even = head NEW_LINE DEDENT head = head . next NEW_LINE isOdd = not isOdd NEW_LINE DEDENT even . next = None NEW_LINE odd . next = evenHead . next NEW_LINE return oddHead . next NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestIncreasingPath ( self , matrix : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( matrix ) NEW_LINE n = len ( matrix [ 0 ] ) NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dfs ( i : int , j : int , prev : int ) -> int : NEW_LINE INDENT if i < 0 or i == m or j < 0 or j == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if matrix [ i ] [ j ] <= prev : NEW_LINE INDENT return 0 NEW_LINE DEDENT curr = matrix [ i ] [ j ] NEW_LINE return 1 + max ( dfs ( i + 1 , j , curr ) , dfs ( i - 1 , j , curr ) , dfs ( i , j + 1 , curr ) , dfs ( i , j - 1 , curr ) ) NEW_LINE DEDENT return max ( dfs ( i , j , - math . inf ) for i in range ( m ) for j in range ( n ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def search ( self , nums : List [ int ] , target : int ) -> int : NEW_LINE INDENT l = 0 NEW_LINE r = len ( nums ) - 1 NEW_LINE while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if nums [ m ] == target : NEW_LINE INDENT return m NEW_LINE DEDENT if nums [ l ] <= nums [ m ] : NEW_LINE INDENT if nums [ l ] <= target < nums [ m ] : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if nums [ m ] < target <= nums [ r ] : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minPatches ( self , nums : List [ int ] , n : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE i = 0 NEW_LINE miss = 1 NEW_LINE while miss <= n : NEW_LINE INDENT if i < len ( nums ) and nums [ i ] <= miss : NEW_LINE INDENT miss += nums [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT miss += miss NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isValidSerialization ( self , preorder : str ) -> bool : NEW_LINE INDENT degree = 1 NEW_LINE for node in preorder . split ( ' , ' ) : NEW_LINE INDENT degree -= 1 NEW_LINE if degree < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if node != ' # ' : NEW_LINE INDENT degree += 2 NEW_LINE DEDENT DEDENT return degree == 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findItinerary ( self , tickets : List [ List [ str ] ] ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE graph = defaultdict ( list ) NEW_LINE for a , b in reversed ( sorted ( tickets ) ) : NEW_LINE INDENT graph [ a ] . append ( b ) NEW_LINE DEDENT def dfs ( u : str ) -> None : NEW_LINE INDENT while u in graph and graph [ u ] : NEW_LINE INDENT dfs ( graph [ u ] . pop ( ) ) NEW_LINE DEDENT ans . append ( u ) NEW_LINE DEDENT dfs ( ' JFK ' ) NEW_LINE return ans [ : : - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def increasingTriplet ( self , nums : List [ int ] ) -> bool : NEW_LINE INDENT first = math . inf NEW_LINE second = math . inf NEW_LINE for num in nums : NEW_LINE INDENT if num <= first : NEW_LINE INDENT first = num NEW_LINE DEDENT elif num <= second : NEW_LINE INDENT second = num NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isSelfCrossing ( self , x : List [ int ] ) -> bool : NEW_LINE INDENT if len ( x ) <= 3 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , len ( x ) ) : NEW_LINE INDENT if x [ i - 2 ] <= x [ i ] and x [ i - 1 ] <= x [ i - 3 ] : NEW_LINE INDENT return True NEW_LINE DEDENT if i >= 4 and x [ i - 1 ] == x [ i - 3 ] and x [ i - 2 ] <= x [ i ] + x [ i - 4 ] : NEW_LINE INDENT return True NEW_LINE DEDENT if i >= 5 and x [ i - 4 ] <= x [ i - 2 ] and x [ i - 2 ] <= x [ i ] + x [ i - 4 ] and x [ i - 1 ] <= x [ i - 3 ] and x [ i - 3 ] <= x [ i - 1 ] + x [ i - 5 ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def palindromePairs ( self , words : List [ str ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE dict = { word [ : : - 1 ] : i for i , word in enumerate ( words ) } NEW_LINE for i , word in enumerate ( words ) : NEW_LINE INDENT if " " in dict and dict [ " " ] != i and word == word [ : : - 1 ] : NEW_LINE INDENT ans . append ( [ i , dict [ " " ] ] ) NEW_LINE DEDENT for j in range ( 1 , len ( word ) + 1 ) : NEW_LINE INDENT l = word [ : j ] NEW_LINE r = word [ j : ] NEW_LINE if l in dict and dict [ l ] != i and r == r [ : : - 1 ] : NEW_LINE INDENT ans . append ( [ i , dict [ l ] ] ) NEW_LINE DEDENT if r in dict and dict [ r ] != i and l == l [ : : - 1 ] : NEW_LINE INDENT ans . append ( [ dict [ r ] , i ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rob ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT def robOrNot ( root : Optional [ TreeNode ] ) -> tuple : NEW_LINE INDENT if not root : NEW_LINE INDENT return ( 0 , 0 ) NEW_LINE DEDENT robLeft , notRobLeft = robOrNot ( root . left ) NEW_LINE robRight , notRobRight = robOrNot ( root . right ) NEW_LINE return ( root . val + notRobLeft + notRobRight , max ( robLeft , notRobLeft ) + max ( robRight , notRobRight ) ) NEW_LINE DEDENT return max ( robOrNot ( root ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countBits ( self , n : int ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans [ i ] = ans [ i // 2 ] + ( i & 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def depthSum ( self , nestedList : List [ NestedInteger ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE depth = 0 NEW_LINE q = deque ( ) NEW_LINE def addIntegers ( nestedList : List [ NestedInteger ] ) -> None : NEW_LINE INDENT for ni in nestedList : NEW_LINE INDENT q . append ( ni ) NEW_LINE DEDENT DEDENT addIntegers ( nestedList ) NEW_LINE while q : NEW_LINE INDENT depth += 1 NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT ni = q . popleft ( ) NEW_LINE if ni . isInteger ( ) : NEW_LINE INDENT ans += ni . getInteger ( ) * depth NEW_LINE DEDENT else : NEW_LINE INDENT addIntegers ( ni . getList ( ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def searchRange ( self , nums : List [ int ] , target : int ) -> List [ int ] : NEW_LINE INDENT l = bisect_left ( nums , target ) NEW_LINE if l == len ( nums ) or nums [ l ] != target : NEW_LINE INDENT return - 1 , - 1 NEW_LINE DEDENT r = bisect_right ( nums , target ) - 1 NEW_LINE return l , r NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def lengthOfLongestSubstringKDistinct ( self , s : str , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE distinct = 0 NEW_LINE count = Counter ( ) NEW_LINE l = 0 NEW_LINE for r , c in enumerate ( s ) : NEW_LINE INDENT count [ c ] += 1 NEW_LINE if count [ c ] == 1 : NEW_LINE INDENT distinct += 1 NEW_LINE DEDENT while distinct == k + 1 : NEW_LINE INDENT count [ s [ l ] ] -= 1 NEW_LINE if count [ s [ l ] ] == 0 : NEW_LINE INDENT distinct -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class NestedIterator : NEW_LINE INDENT def __init__ ( self , nestedList : List [ NestedInteger ] ) : NEW_LINE INDENT self . q = deque ( ) NEW_LINE self . addInteger ( nestedList ) NEW_LINE DEDENT def next ( self ) -> int : NEW_LINE INDENT return self . q . popleft ( ) NEW_LINE DEDENT def hasNext ( self ) -> bool : NEW_LINE INDENT return self . q NEW_LINE DEDENT def addInteger ( self , nestedList : List [ NestedInteger ] ) -> None : NEW_LINE INDENT for ni in nestedList : NEW_LINE INDENT if ni . isInteger ( ) : NEW_LINE INDENT self . q . append ( ni . getInteger ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT self . addInteger ( ni . getList ( ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def isPowerOfFour ( self , n : int ) -> bool : NEW_LINE INDENT return n > 0 and bin ( n ) . count ( '1' ) == 1 and ( n - 1 ) % 3 == 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def integerBreak ( self , n : int ) -> int : NEW_LINE INDENT if n == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 3 : NEW_LINE INDENT return 2 NEW_LINE DEDENT ans = 1 NEW_LINE while n > 4 : NEW_LINE INDENT n -= 3 NEW_LINE ans *= 3 NEW_LINE DEDENT ans *= n NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reverseString ( self , s : List [ str ] ) -> None : NEW_LINE INDENT l = 0 NEW_LINE r = len ( s ) - 1 NEW_LINE while l < r : NEW_LINE INDENT s [ l ] , s [ r ] = s [ r ] , s [ l ] NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def reverseVowels ( self , s : str ) -> str : NEW_LINE INDENT charList = list ( s ) NEW_LINE vowels = { ' a ' , ' e ' , ' i ' , ' o ' , ' u ' , ' A ' , ' E ' , ' I ' , ' O ' , ' U ' } NEW_LINE l = 0 NEW_LINE r = len ( s ) - 1 NEW_LINE while l < r : NEW_LINE INDENT while l < r and charList [ l ] not in vowels : NEW_LINE INDENT l += 1 NEW_LINE DEDENT while l < r and charList [ r ] not in vowels : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT charList [ l ] , charList [ r ] = charList [ r ] , charList [ l ] NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return ' ' . join ( charList ) NEW_LINE DEDENT DEDENT
class MovingAverage : NEW_LINE INDENT def __init__ ( self , size : int ) : NEW_LINE INDENT self . size = size NEW_LINE self . sum = 0 NEW_LINE self . q = deque ( ) NEW_LINE DEDENT def next ( self , val : int ) -> float : NEW_LINE INDENT if len ( self . q ) == self . size : NEW_LINE INDENT self . sum -= self . q . popleft ( ) NEW_LINE DEDENT self . sum += val NEW_LINE self . q . append ( val ) NEW_LINE return self . sum / len ( self . q ) NEW_LINE DEDENT DEDENT
class TicTacToe : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . n = n NEW_LINE self . rows = [ 0 ] * n NEW_LINE self . cols = [ 0 ] * n NEW_LINE self . diag = 0 NEW_LINE self . antiDiag = 0 NEW_LINE DEDENT def move ( self , row : int , col : int , player : int ) -> int : NEW_LINE INDENT toAdd = 1 if player == 1 else - 1 NEW_LINE target = self . n if player == 1 else - self . n NEW_LINE if row == col : NEW_LINE INDENT self . diag += toAdd NEW_LINE if self . diag == target : NEW_LINE INDENT return player NEW_LINE DEDENT DEDENT if row + col == self . n - 1 : NEW_LINE INDENT self . antiDiag += toAdd NEW_LINE if self . antiDiag == target : NEW_LINE INDENT return player NEW_LINE DEDENT DEDENT self . rows [ row ] += toAdd NEW_LINE if self . rows [ row ] == target : NEW_LINE INDENT return player NEW_LINE DEDENT self . cols [ col ] += toAdd NEW_LINE if self . cols [ col ] == target : NEW_LINE INDENT return player NEW_LINE DEDENT return 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def intersection ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE nums1 = set ( nums1 ) NEW_LINE for num in nums2 : NEW_LINE INDENT if num in nums1 : NEW_LINE INDENT ans . append ( num ) NEW_LINE nums1 . remove ( num ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def searchInsert ( self , nums : List [ int ] , target : int ) -> int : NEW_LINE INDENT l = 0 NEW_LINE r = len ( nums ) NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if nums [ m ] == target : NEW_LINE INDENT return m NEW_LINE DEDENT if nums [ m ] < target : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def intersect ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> List [ int ] : NEW_LINE INDENT if len ( nums1 ) > len ( nums2 ) : NEW_LINE INDENT return self . intersect ( nums2 , nums1 ) NEW_LINE DEDENT ans = [ ] NEW_LINE count = Counter ( nums1 ) NEW_LINE for num in nums2 : NEW_LINE INDENT if count [ num ] > 0 : NEW_LINE INDENT ans . append ( num ) NEW_LINE count [ num ] -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberOfPatterns ( self , m : int , n : int ) -> int : NEW_LINE INDENT seen = set ( ) NEW_LINE accross = [ [ 0 ] * 10 for _ in range ( 10 ) ] NEW_LINE accross [ 1 ] [ 3 ] = accross [ 3 ] [ 1 ] = 2 NEW_LINE accross [ 1 ] [ 7 ] = accross [ 7 ] [ 1 ] = 4 NEW_LINE accross [ 3 ] [ 9 ] = accross [ 9 ] [ 3 ] = 6 NEW_LINE accross [ 7 ] [ 9 ] = accross [ 9 ] [ 7 ] = 8 NEW_LINE accross [ 1 ] [ 9 ] = accross [ 9 ] [ 1 ] = accross [ 2 ] [ 8 ] = accross [ 8 ] [ 2 ] = accross [ 3 ] [ 7 ] = accross [ 7 ] [ 3 ] = accross [ 4 ] [ 6 ] = accross [ 6 ] [ 4 ] = 5 NEW_LINE def dfs ( u : int , depth : int ) -> int : NEW_LINE INDENT if depth > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT seen . add ( u ) NEW_LINE ans = 1 if depth >= m else 0 NEW_LINE for v in range ( 1 , 10 ) : NEW_LINE INDENT if v == u or v in seen : NEW_LINE INDENT continue NEW_LINE DEDENT accrossed = accross [ u ] [ v ] NEW_LINE if not accrossed or accrossed in seen : NEW_LINE INDENT ans += dfs ( v , depth + 1 ) NEW_LINE DEDENT DEDENT seen . remove ( u ) NEW_LINE return ans NEW_LINE DEDENT return dfs ( 1 , 1 ) * 4 + dfs ( 2 , 1 ) * 4 + dfs ( 5 , 1 ) NEW_LINE DEDENT DEDENT
class SnakeGame : NEW_LINE INDENT def __init__ ( self , width : int , height : int , food : List [ List [ int ] ] ) : NEW_LINE INDENT self . width = width NEW_LINE self . height = height NEW_LINE self . food = food NEW_LINE self . score = 0 NEW_LINE self . k = 0 NEW_LINE self . lookup = set ( [ self . getId ( 0 , 0 ) ] ) NEW_LINE self . body = deque ( [ self . getId ( 0 , 0 ) ] ) NEW_LINE DEDENT def move ( self , direction : str ) -> int : NEW_LINE INDENT i = self . body [ 0 ] // self . width NEW_LINE j = self . body [ 0 ] % self . width NEW_LINE if direction == " U " : NEW_LINE INDENT i -= 1 NEW_LINE if i < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if direction == " L " : NEW_LINE INDENT j -= 1 NEW_LINE if j < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if direction == " R " : NEW_LINE INDENT j += 1 NEW_LINE if j == self . width : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if direction == " D " : NEW_LINE INDENT i += 1 NEW_LINE if i == self . height : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT newHead = self . getId ( i , j ) NEW_LINE if self . k < len ( self . food ) and i == self . food [ self . k ] [ 0 ] and j == self . food [ self . k ] [ 1 ] : NEW_LINE INDENT self . lookup . add ( newHead ) NEW_LINE self . body . appendleft ( newHead ) NEW_LINE self . k += 1 NEW_LINE self . score += 1 NEW_LINE return self . score NEW_LINE DEDENT if newHead != self . body [ - 1 ] and newHead in self . lookup : NEW_LINE INDENT return - 1 NEW_LINE DEDENT self . lookup . remove ( self . body [ - 1 ] ) NEW_LINE self . lookup . add ( newHead ) NEW_LINE self . body . pop ( ) NEW_LINE self . body . appendleft ( newHead ) NEW_LINE return self . score NEW_LINE DEDENT def getId ( self , i : int , j : int ) -> int : NEW_LINE INDENT return i * self . width + j NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxEnvelopes ( self , envelopes : List [ List [ int ] ] ) -> int : NEW_LINE INDENT envelopes . sort ( key = lambda x : ( x [ 0 ] , - x [ 1 ] ) ) NEW_LINE ans = 0 NEW_LINE dp = [ 0 ] * len ( envelopes ) NEW_LINE for _ , h in envelopes : NEW_LINE INDENT l = 0 NEW_LINE r = ans NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if dp [ m ] >= h : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT dp [ l ] = h NEW_LINE if l == ans : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Twitter : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . timer = itertools . count ( step = - 1 ) NEW_LINE self . tweets = defaultdict ( deque ) NEW_LINE self . followees = defaultdict ( set ) NEW_LINE DEDENT def postTweet ( self , userId : int , tweetId : int ) -> None : NEW_LINE INDENT self . tweets [ userId ] . appendleft ( ( next ( self . timer ) , tweetId ) ) NEW_LINE if len ( self . tweets [ userId ] ) > 10 : NEW_LINE INDENT self . tweets [ userId ] . pop ( ) NEW_LINE DEDENT DEDENT def getNewsFeed ( self , userId : int ) -> List [ int ] : NEW_LINE INDENT tweets = list ( heapq . merge ( * ( self . tweets [ followee ] for followee in self . followees [ userId ] | { userId } ) ) ) NEW_LINE return [ tweetId for _ , tweetId in tweets [ : 10 ] ] NEW_LINE DEDENT def follow ( self , followerId : int , followeeId : int ) -> None : NEW_LINE INDENT self . followees [ followerId ] . add ( followeeId ) NEW_LINE DEDENT def unfollow ( self , followerId : int , followeeId : int ) -> None : NEW_LINE INDENT self . followees [ followerId ] . discard ( followeeId ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isReflected ( self , points : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT minX = math . inf NEW_LINE maxX = - math . inf NEW_LINE seen = set ( ) NEW_LINE for x , y in points : NEW_LINE INDENT minX = min ( minX , x ) NEW_LINE maxX = max ( maxX , x ) NEW_LINE seen . add ( ( x , y ) ) NEW_LINE DEDENT summ = minX + maxX NEW_LINE return all ( ( summ - x , y ) in seen for x , y in points ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countNumbersWithUniqueDigits ( self , n : int ) -> int : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 10 NEW_LINE uniqueDigits = 9 NEW_LINE availableNum = 9 NEW_LINE while n > 1 and availableNum > 0 : NEW_LINE INDENT uniqueDigits *= availableNum NEW_LINE ans += uniqueDigits NEW_LINE n -= 1 NEW_LINE availableNum -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rearrangeString ( self , s : str , k : int ) -> str : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = [ ] NEW_LINE count = Counter ( s ) NEW_LINE valid = Counter ( ) NEW_LINE def getBestLetter ( index : int ) -> chr : NEW_LINE INDENT maxCount = - 1 NEW_LINE bestLetter = ' * ' NEW_LINE for c in string . ascii_lowercase : NEW_LINE INDENT if count [ c ] > 0 and count [ c ] > maxCount and index >= valid [ c ] : NEW_LINE INDENT bestLetter = c NEW_LINE maxCount = count [ c ] NEW_LINE DEDENT DEDENT return bestLetter NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT c = getBestLetter ( i ) NEW_LINE if c == ' * ' : NEW_LINE INDENT return ' ' NEW_LINE DEDENT ans . append ( c ) NEW_LINE count [ c ] -= 1 NEW_LINE valid [ c ] = i + k NEW_LINE DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Logger : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . messageQueue = deque ( ) NEW_LINE self . messageSet = set ( ) NEW_LINE DEDENT def shouldPrintMessage ( self , timestamp : int , message : str ) -> bool : NEW_LINE INDENT while self . messageQueue : NEW_LINE INDENT headTimestamp , headMessage = self . messageQueue [ 0 ] NEW_LINE if timestamp < headTimestamp + 10 : NEW_LINE INDENT break NEW_LINE DEDENT self . messageQueue . popleft ( ) NEW_LINE self . messageSet . remove ( headMessage ) NEW_LINE DEDENT if message in self . messageSet : NEW_LINE INDENT return False NEW_LINE DEDENT self . messageQueue . append ( ( timestamp , message ) ) NEW_LINE self . messageSet . add ( message ) NEW_LINE return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isValidSudoku ( self , board : List [ List [ str ] ] ) -> bool : NEW_LINE INDENT seen = set ( ) NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT for j in range ( 9 ) : NEW_LINE INDENT c = board [ i ] [ j ] NEW_LINE if c == ' . ' : NEW_LINE INDENT continue NEW_LINE DEDENT if c + ' @ row ▁ ' + str ( i ) in seen or c + ' @ col ▁ ' + str ( j ) in seen or c + ' @ box ▁ ' + str ( i // 3 ) + str ( j // 3 ) in seen : NEW_LINE INDENT return False NEW_LINE DEDENT seen . add ( c + ' @ row ▁ ' + str ( i ) ) NEW_LINE seen . add ( c + ' @ col ▁ ' + str ( j ) ) NEW_LINE seen . add ( c + ' @ box ▁ ' + str ( i // 3 ) + str ( j // 3 ) ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sortTransformedArray ( self , nums : List [ int ] , a : int , b : int , c : int ) -> List [ int ] : NEW_LINE INDENT n = len ( nums ) NEW_LINE upward = a > 0 NEW_LINE ans = [ 0 ] * n NEW_LINE def f ( x : int , a : int , b : int , c : int ) -> int : NEW_LINE INDENT return ( a * x + b ) * x + c NEW_LINE DEDENT quad = [ f ( num , a , b , c ) for num in nums ] NEW_LINE i = n - 1 if upward else 0 NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while l <= r : NEW_LINE INDENT if upward : NEW_LINE INDENT if quad [ l ] > quad [ r ] : NEW_LINE INDENT ans [ i ] = quad [ l ] NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = quad [ r ] NEW_LINE r -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if quad [ l ] < quad [ r ] : NEW_LINE INDENT ans [ i ] = quad [ l ] NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans [ i ] = quad [ r ] NEW_LINE r -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxKilledEnemies ( self , grid : List [ List [ chr ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE enemyCount = 0 NEW_LINE dp = [ [ 0 ] * n for _ in range ( m ) ] NEW_LINE def update ( i : int , j : int ) -> None : NEW_LINE INDENT nonlocal enemyCount NEW_LINE if grid [ i ] [ j ] == '0' : NEW_LINE INDENT dp [ i ] [ j ] += enemyCount NEW_LINE DEDENT elif grid [ i ] [ j ] == ' E ' : NEW_LINE INDENT enemyCount += 1 NEW_LINE DEDENT else : NEW_LINE INDENT enemyCount = 0 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT enemyCount = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT update ( i , j ) NEW_LINE DEDENT enemyCount = 0 NEW_LINE for j in reversed ( range ( n ) ) : NEW_LINE INDENT update ( i , j ) NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT enemyCount = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT update ( i , j ) NEW_LINE DEDENT enemyCount = 0 NEW_LINE for i in reversed ( range ( m ) ) : NEW_LINE INDENT update ( i , j ) NEW_LINE DEDENT DEDENT return max ( map ( max , dp ) ) NEW_LINE DEDENT DEDENT
class HitCounter : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . timestamps = [ 0 ] * 300 NEW_LINE self . hits = [ 0 ] * 300 NEW_LINE DEDENT def hit ( self , timestamp : int ) -> None : NEW_LINE INDENT i = timestamp % 300 NEW_LINE if self . timestamps [ i ] == timestamp : NEW_LINE INDENT self . hits [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . timestamps [ i ] = timestamp NEW_LINE self . hits [ i ] = 1 NEW_LINE DEDENT DEDENT def getHits ( self , timestamp : int ) -> int : NEW_LINE INDENT return sum ( h for t , h in zip ( self . timestamps , self . hits ) if timestamp - t < 300 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canMeasureWater ( self , jug1Capacity : int , jug2Capacity : int , targetCapacity : int ) -> bool : NEW_LINE INDENT return targetCapacity == 0 or jug1Capacity + jug2Capacity >= targetCapacity and targetCapacity % gcd ( jug1Capacity , jug2Capacity ) == 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isPerfectSquare ( self , num : int ) -> bool : NEW_LINE INDENT l = 1 NEW_LINE r = num NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if m >= num / m : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l * l == num NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestDivisibleSubset ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT n = len ( nums ) NEW_LINE ans = [ ] NEW_LINE count = [ 1 ] * n NEW_LINE prevIndex = [ - 1 ] * n NEW_LINE maxCount = 0 NEW_LINE index = - 1 NEW_LINE nums . sort ( ) NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT for j in reversed ( range ( i ) ) : NEW_LINE INDENT if num % nums [ j ] == 0 and count [ i ] < count [ j ] + 1 : NEW_LINE INDENT count [ i ] = count [ j ] + 1 NEW_LINE prevIndex [ i ] = j NEW_LINE DEDENT DEDENT if count [ i ] > maxCount : NEW_LINE INDENT maxCount = count [ i ] NEW_LINE index = i NEW_LINE DEDENT DEDENT while index != - 1 : NEW_LINE INDENT ans . append ( nums [ index ] ) NEW_LINE index = prevIndex [ index ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def solveSudoku ( self , board : List [ List [ str ] ] ) -> None : NEW_LINE INDENT def isValid ( row : int , col : int , c : chr ) -> bool : NEW_LINE INDENT for i in range ( 9 ) : NEW_LINE INDENT if board [ i ] [ col ] == c or board [ row ] [ i ] == c or board [ 3 * ( row // 3 ) + i // 3 ] [ 3 * ( col // 3 ) + i % 3 ] == c : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def solve ( s : int ) -> bool : NEW_LINE INDENT if s == 81 : NEW_LINE INDENT return True NEW_LINE DEDENT i = s // 9 NEW_LINE j = s % 9 NEW_LINE if board [ i ] [ j ] != ' . ' : NEW_LINE INDENT return solve ( s + 1 ) NEW_LINE DEDENT for c in string . digits [ 1 : ] : NEW_LINE INDENT if isValid ( i , j , c ) : NEW_LINE INDENT board [ i ] [ j ] = c NEW_LINE if solve ( s + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT board [ i ] [ j ] = ' . ' NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT solve ( 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getSum ( self , a : int , b : int ) -> int : NEW_LINE INDENT mask = 0xFFFFFFFF NEW_LINE kMax = 2000 NEW_LINE while b : NEW_LINE INDENT a , b = ( a ^ b ) & mask , ( ( a & b ) << 1 ) & mask NEW_LINE DEDENT return a if a < kMax else ~ ( a ^ mask ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def superPow ( self , a : int , b : List [ int ] ) -> int : NEW_LINE INDENT def powMod ( x : int , y : int ) -> int : NEW_LINE INDENT pow = 1 NEW_LINE for _ in range ( y ) : NEW_LINE INDENT pow = ( pow * x ) % k NEW_LINE DEDENT return pow NEW_LINE DEDENT k = 1337 NEW_LINE ans = 1 NEW_LINE for i in b : NEW_LINE INDENT ans = powMod ( ans , 10 ) * powMod ( a , i ) % k NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getMoneyAmount ( self , n : int ) -> int : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int , j : int ) -> int : NEW_LINE INDENT if i >= j : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = math . inf NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT ans = min ( ans , max ( dp ( i , k - 1 ) , dp ( k + 1 , j ) ) + k ) NEW_LINE DEDENT return ans NEW_LINE DEDENT return dp ( 1 , n ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def combinationSum4 ( self , nums : List [ int ] , target : int ) -> int : NEW_LINE INDENT dp = [ 1 ] + [ - 1 ] * target NEW_LINE def dfs ( target : int ) -> int : NEW_LINE INDENT if target < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ target ] != - 1 : NEW_LINE INDENT return dp [ target ] NEW_LINE DEDENT dp [ target ] = sum ( dfs ( target - num ) for num in nums ) NEW_LINE return dp [ target ] NEW_LINE DEDENT return dfs ( target ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def kthSmallest ( self , matrix : List [ List [ int ] ] , k : int ) -> int : NEW_LINE INDENT minHeap = [ ] NEW_LINE i = 0 NEW_LINE while i < k and i < len ( matrix ) : NEW_LINE INDENT heapq . heappush ( minHeap , ( matrix [ i ] [ 0 ] , i , 0 ) ) NEW_LINE i += 1 NEW_LINE DEDENT while k > 1 : NEW_LINE INDENT k -= 1 NEW_LINE _ , i , j = heapq . heappop ( minHeap ) NEW_LINE if j + 1 < len ( matrix [ 0 ] ) : NEW_LINE INDENT heapq . heappush ( minHeap , ( matrix [ i ] [ j + 1 ] , i , j + 1 ) ) NEW_LINE DEDENT DEDENT return minHeap [ 0 ] [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countAndSay ( self , n : int ) -> str : NEW_LINE INDENT ans = '1' NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT nxt = ' ' NEW_LINE i = 0 NEW_LINE while i < len ( ans ) : NEW_LINE INDENT count = 1 NEW_LINE while i + 1 < len ( ans ) and ans [ i ] == ans [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT nxt += str ( count ) + ans [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ans = nxt NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class RandomizedSet : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . vals = [ ] NEW_LINE self . valToIndex = defaultdict ( int ) NEW_LINE DEDENT def insert ( self , val : int ) -> bool : NEW_LINE INDENT if val in self . valToIndex : NEW_LINE INDENT return False NEW_LINE DEDENT self . valToIndex [ val ] = len ( self . vals ) NEW_LINE self . vals . append ( val ) NEW_LINE return True NEW_LINE DEDENT def remove ( self , val : int ) -> bool : NEW_LINE INDENT if val not in self . valToIndex : NEW_LINE INDENT return False NEW_LINE DEDENT index = self . valToIndex [ val ] NEW_LINE self . valToIndex [ self . vals [ - 1 ] ] = index NEW_LINE del self . valToIndex [ val ] NEW_LINE self . vals [ index ] = self . vals [ - 1 ] NEW_LINE self . vals . pop ( ) NEW_LINE return True NEW_LINE DEDENT def getRandom ( self ) -> int : NEW_LINE INDENT index = randint ( 0 , len ( self . vals ) - 1 ) NEW_LINE return self . vals [ index ] NEW_LINE DEDENT DEDENT
class RandomizedCollection : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . vals = [ ] NEW_LINE self . valToIndices = defaultdict ( list ) NEW_LINE DEDENT def insert ( self , val : int ) -> bool : NEW_LINE INDENT self . valToIndices [ val ] . append ( len ( self . vals ) ) NEW_LINE self . vals . append ( [ val , len ( self . valToIndices [ val ] ) - 1 ] ) NEW_LINE return len ( self . valToIndices [ val ] ) == 1 NEW_LINE DEDENT def remove ( self , val : int ) -> bool : NEW_LINE INDENT if val not in self . valToIndices or self . valToIndices [ val ] == [ ] : NEW_LINE INDENT return False NEW_LINE DEDENT index = self . valToIndices [ val ] [ - 1 ] NEW_LINE self . valToIndices [ self . vals [ - 1 ] [ 0 ] ] [ self . vals [ - 1 ] [ 1 ] ] = index NEW_LINE self . valToIndices [ val ] . pop ( ) NEW_LINE self . vals [ index ] = self . vals [ - 1 ] NEW_LINE self . vals . pop ( ) NEW_LINE return True NEW_LINE DEDENT def getRandom ( self ) -> int : NEW_LINE INDENT index = randint ( 0 , len ( self . vals ) - 1 ) NEW_LINE return self . vals [ index ] [ 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canConstruct ( self , ransomNote : str , magazine : str ) -> bool : NEW_LINE INDENT count1 = Counter ( ransomNote ) NEW_LINE count2 = Counter ( magazine ) NEW_LINE return all ( count1 [ c ] <= count2 [ c ] for c in string . ascii_lowercase ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def __init__ ( self , nums : List [ int ] ) : NEW_LINE INDENT self . nums = nums NEW_LINE DEDENT def reset ( self ) -> List [ int ] : NEW_LINE INDENT return self . nums NEW_LINE DEDENT def shuffle ( self ) -> List [ int ] : NEW_LINE INDENT A = self . nums . copy ( ) NEW_LINE for i in range ( len ( A ) - 1 , 0 , - 1 ) : NEW_LINE INDENT j = randint ( 0 , i ) NEW_LINE A [ i ] , A [ j ] = A [ j ] , A [ i ] NEW_LINE DEDENT return A NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def deserialize ( self , s : str ) -> NestedInteger : NEW_LINE INDENT if s [ 0 ] != ' [ ' : NEW_LINE INDENT return NestedInteger ( int ( s ) ) NEW_LINE DEDENT stack = [ ] NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT if c == ' [ ' : NEW_LINE INDENT stack . append ( NestedInteger ( ) ) NEW_LINE start = i + 1 NEW_LINE DEDENT elif c == ' , ' : NEW_LINE INDENT if i > start : NEW_LINE INDENT num = int ( s [ start : i ] ) NEW_LINE stack [ - 1 ] . add ( NestedInteger ( num ) ) NEW_LINE DEDENT start = i + 1 NEW_LINE DEDENT elif c == ' ] ' : NEW_LINE INDENT popped = stack . pop ( ) NEW_LINE if i > start : NEW_LINE INDENT num = int ( s [ start : i ] ) NEW_LINE popped . add ( NestedInteger ( num ) ) NEW_LINE DEDENT if stack : NEW_LINE INDENT stack [ - 1 ] . add ( popped ) NEW_LINE DEDENT else : NEW_LINE INDENT return popped NEW_LINE DEDENT start = i + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def firstUniqChar ( self , s : str ) -> int : NEW_LINE INDENT count = Counter ( s ) NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT if count [ c ] == 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findTheDifference ( self , s : str , t : str ) -> str : NEW_LINE INDENT count = Counter ( s ) NEW_LINE for i , c in enumerate ( t ) : NEW_LINE INDENT count [ c ] -= 1 NEW_LINE if count [ c ] == - 1 : NEW_LINE INDENT return c NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def combinationSum ( self , candidates : List [ int ] , target : int ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( s : int , target : int , path : List [ int ] ) -> None : NEW_LINE INDENT if target < 0 : NEW_LINE INDENT return NEW_LINE DEDENT if target == 0 : NEW_LINE INDENT ans . append ( path . clone ( ) ) NEW_LINE return NEW_LINE DEDENT for i in range ( s , len ( candidates ) ) : NEW_LINE INDENT path . append ( candidates [ i ] ) NEW_LINE dfs ( i , target - candidates [ i ] , path ) NEW_LINE path . pop ( ) NEW_LINE DEDENT DEDENT candidates . sort ( ) NEW_LINE dfs ( 0 , target , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def decodeString ( self , s : str ) -> str : NEW_LINE INDENT stack = [ ] NEW_LINE currStr = ' ' NEW_LINE currNum = 0 NEW_LINE for c in s : NEW_LINE INDENT if c . isdigit ( ) : NEW_LINE INDENT currNum = currNum * 10 + int ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT if c == ' [ ' : NEW_LINE INDENT stack . append ( ( currStr , currNum ) ) NEW_LINE currStr = ' ' NEW_LINE currNum = 0 NEW_LINE DEDENT elif c == ' ] ' : NEW_LINE INDENT prevStr , num = stack . pop ( ) NEW_LINE currStr = prevStr + num * currStr NEW_LINE DEDENT else : NEW_LINE INDENT currStr += c NEW_LINE DEDENT DEDENT DEDENT return currStr NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxRotateFunction ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT f = sum ( i * num for i , num in enumerate ( nums ) ) NEW_LINE ans = f NEW_LINE summ = sum ( nums ) NEW_LINE for a in reversed ( nums ) : NEW_LINE INDENT f += summ - len ( nums ) * a NEW_LINE ans = max ( ans , f ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def integerReplacement ( self , n : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE while n > 1 : NEW_LINE INDENT if ( n & 1 ) == 0 : NEW_LINE INDENT n >>= 1 NEW_LINE DEDENT elif n == 3 or ( ( n >> 1 ) & 1 ) == 0 : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT n += 1 NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def calcEquation ( self , equations : List [ List [ str ] ] , values : List [ float ] , queries : List [ List [ str ] ] ) -> List [ float ] : NEW_LINE INDENT ans = [ ] NEW_LINE graph = defaultdict ( dict ) NEW_LINE for ( A , B ) , value in zip ( equations , values ) : NEW_LINE INDENT graph [ A ] [ B ] = value NEW_LINE graph [ B ] [ A ] = 1 / value NEW_LINE DEDENT def devide ( A : str , C : str , seen : Set [ str ] ) -> float : NEW_LINE INDENT if A == C : NEW_LINE INDENT return 1.0 NEW_LINE DEDENT seen . add ( A ) NEW_LINE for B , value in graph [ A ] . items ( ) : NEW_LINE INDENT if B in seen : NEW_LINE INDENT continue NEW_LINE DEDENT res = devide ( B , C , seen ) NEW_LINE if res > 0 : NEW_LINE INDENT return value * res NEW_LINE DEDENT DEDENT return - 1.0 NEW_LINE DEDENT for A , C in queries : NEW_LINE INDENT if A not in graph and C not in graph : NEW_LINE INDENT ans . append ( - 1.0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( devide ( A , C , set ( ) ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMedianSortedArrays ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> float : NEW_LINE INDENT n1 = len ( nums1 ) NEW_LINE n2 = len ( nums2 ) NEW_LINE if n1 > n2 : NEW_LINE INDENT return self . findMedianSortedArrays ( nums2 , nums1 ) NEW_LINE DEDENT l = 0 NEW_LINE r = n1 NEW_LINE while l <= r : NEW_LINE INDENT partition1 = ( l + r ) // 2 NEW_LINE partition2 = ( n1 + n2 + 1 ) // 2 - partition1 NEW_LINE maxLeft1 = - 2 ** 31 if partition1 == 0 else nums1 [ partition1 - 1 ] NEW_LINE maxLeft2 = - 2 ** 31 if partition2 == 0 else nums2 [ partition2 - 1 ] NEW_LINE minRight1 = 2 ** 31 - 1 if partition1 == n1 else nums1 [ partition1 ] NEW_LINE minRight2 = 2 ** 31 - 1 if partition2 == n2 else nums2 [ partition2 ] NEW_LINE if maxLeft1 <= minRight2 and maxLeft2 <= minRight1 : NEW_LINE INDENT return ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 ) ) * 0.5 if ( n1 + n2 ) % 2 == 0 else max ( maxLeft1 , maxLeft2 ) NEW_LINE DEDENT elif maxLeft1 > minRight2 : NEW_LINE INDENT r = partition1 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = partition1 + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def combinationSum2 ( self , candidates : List [ int ] , target : int ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( s : int , target : int , path : List [ int ] ) -> None : NEW_LINE INDENT if target < 0 : NEW_LINE INDENT return NEW_LINE DEDENT if target == 0 : NEW_LINE INDENT ans . append ( path . copy ( ) ) NEW_LINE return NEW_LINE DEDENT for i in range ( s , len ( candidates ) ) : NEW_LINE INDENT if i > s and candidates [ i ] == candidates [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT path . append ( candidates [ i ] ) NEW_LINE dfs ( i + 1 , target - candidates [ i ] , path ) NEW_LINE path . pop ( ) NEW_LINE DEDENT DEDENT candidates . sort ( ) NEW_LINE dfs ( 0 , target , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findNthDigit ( self , n : int ) -> int : NEW_LINE INDENT def getDigit ( num : int , pos : int , digitSize : int ) : NEW_LINE INDENT if pos == 0 : NEW_LINE INDENT return num % 10 NEW_LINE DEDENT for _ in range ( digitSize - pos ) : NEW_LINE INDENT num //= 10 NEW_LINE DEDENT return num % 10 NEW_LINE DEDENT digitSize = 1 NEW_LINE startNum = 1 NEW_LINE count = 9 NEW_LINE while digitSize * count < n : NEW_LINE INDENT n -= digitSize * count NEW_LINE digitSize += 1 NEW_LINE startNum *= 10 NEW_LINE count *= 10 NEW_LINE DEDENT targetNum = startNum + ( n - 1 ) // digitSize NEW_LINE pos = n % digitSize NEW_LINE return getDigit ( targetNum , pos , digitSize ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canCross ( self , stones : List [ int ] ) -> bool : NEW_LINE INDENT n = len ( stones ) NEW_LINE dp = [ [ False ] * ( n + 1 ) for _ in range ( n ) ] NEW_LINE dp [ 0 ] [ 0 ] = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT k = stones [ i ] - stones [ j ] NEW_LINE if k > n : NEW_LINE INDENT continue NEW_LINE DEDENT for x in ( k - 1 , k , k + 1 ) : NEW_LINE INDENT if 0 <= x <= n : NEW_LINE INDENT dp [ i ] [ k ] |= dp [ j ] [ x ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return any ( dp [ - 1 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestPalindrome ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = Counter ( s ) NEW_LINE for c in count . values ( ) : NEW_LINE INDENT ans += c if c % 2 == 0 else c - 1 NEW_LINE DEDENT hasOddCount = any ( c % 2 == 1 for c in count . values ( ) ) NEW_LINE return ans + hasOddCount NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def firstMissingPositive ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while nums [ i ] > 0 and nums [ i ] <= n and nums [ nums [ i ] - 1 ] != nums [ i ] : NEW_LINE INDENT nums [ nums [ i ] - 1 ] , nums [ i ] = nums [ i ] , nums [ nums [ i ] - 1 ] NEW_LINE DEDENT DEDENT for i , num in enumerate ( nums ) : NEW_LINE INDENT if num != i + 1 : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return n + 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def splitArray ( self , nums : List [ int ] , m : int ) -> int : NEW_LINE INDENT n = len ( nums ) NEW_LINE prefix = [ 0 ] + list ( itertools . accumulate ( nums ) ) NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int , k : int ) -> int : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return prefix [ i ] NEW_LINE DEDENT ans = math . inf NEW_LINE for j in range ( k - 1 , i ) : NEW_LINE INDENT ans = min ( ans , max ( dp ( j , k - 1 ) , prefix [ i ] - prefix [ j ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT return dp ( n , m ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minAbbreviation ( self , target : str , dictionary : List [ str ] ) -> str : NEW_LINE INDENT m = len ( target ) NEW_LINE def getMask ( word : str ) -> int : NEW_LINE INDENT mask = 0 NEW_LINE for i , c in enumerate ( word ) : NEW_LINE INDENT if c != target [ i ] : NEW_LINE INDENT mask |= 1 << m - 1 - i NEW_LINE DEDENT DEDENT return mask NEW_LINE DEDENT masks = [ getMask ( word ) for word in dictionary if len ( word ) == m ] NEW_LINE if not masks : NEW_LINE INDENT return str ( m ) NEW_LINE DEDENT abbrs = [ ] NEW_LINE def getAbbr ( cand : int ) -> str : NEW_LINE INDENT abbr = ' ' NEW_LINE replacedCount = 0 NEW_LINE for i , c in enumerate ( target ) : NEW_LINE INDENT if cand >> m - 1 - i & 1 : NEW_LINE INDENT if replacedCount : NEW_LINE INDENT abbr += str ( replacedCount ) NEW_LINE DEDENT abbr += c NEW_LINE replacedCount = 0 NEW_LINE DEDENT else : NEW_LINE INDENT replacedCount += 1 NEW_LINE DEDENT DEDENT if replacedCount : NEW_LINE INDENT abbr += str ( replacedCount ) NEW_LINE DEDENT return abbr NEW_LINE DEDENT for cand in range ( 2 ** m ) : NEW_LINE INDENT if all ( cand & mask for mask in masks ) : NEW_LINE INDENT abbr = getAbbr ( cand ) NEW_LINE abbrs . append ( abbr ) NEW_LINE DEDENT DEDENT def getAbbrLen ( abbr : str ) -> int : NEW_LINE INDENT abbrLen = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( abbr ) : NEW_LINE INDENT if abbr [ j ] . isalpha ( ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT while j < len ( abbr ) and abbr [ j ] . isdigit ( ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT abbrLen += 1 NEW_LINE i = j NEW_LINE DEDENT return abbrLen NEW_LINE DEDENT return min ( abbrs , key = lambda x : getAbbrLen ( x ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def fizzBuzz ( self , n : int ) -> List [ str ] : NEW_LINE INDENT d = { 3 : ' Fizz ' , 5 : ' Buzz ' } NEW_LINE return [ ' ' . join ( [ d [ k ] for k in d if i % k == 0 ] ) or str ( i ) for i in range ( 1 , n + 1 ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def addStrings ( self , num1 : str , num2 : str ) -> str : NEW_LINE INDENT ans = [ ] NEW_LINE carry = 0 NEW_LINE i = len ( num1 ) - 1 NEW_LINE j = len ( num2 ) - 1 NEW_LINE while i >= 0 or j >= 0 or carry : NEW_LINE INDENT if i >= 0 : NEW_LINE INDENT carry += int ( num1 [ i ] ) NEW_LINE DEDENT if j >= 0 : NEW_LINE INDENT carry += int ( num2 [ j ] ) NEW_LINE DEDENT ans . append ( str ( carry % 10 ) ) NEW_LINE carry //= 10 NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT return ' ' . join ( reversed ( ans ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canPartition ( self , nums : List [ int ] ) -> bool : NEW_LINE INDENT summ = sum ( nums ) NEW_LINE if summ & 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return self . knapsack_ ( nums , summ // 2 ) NEW_LINE DEDENT def knapsack_ ( self , nums : List [ int ] , subsetSum : int ) -> bool : NEW_LINE INDENT n = len ( nums ) NEW_LINE dp = [ [ False ] * ( subsetSum + 1 ) for _ in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = True NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = nums [ i - 1 ] NEW_LINE for j in range ( subsetSum + 1 ) : NEW_LINE INDENT if j < num : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] or dp [ i - 1 ] [ j - num ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ subsetSum ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def pacificAtlantic ( self , heights : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT m = len ( heights ) NEW_LINE n = len ( heights [ 0 ] ) NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE qP = deque ( ) NEW_LINE qA = deque ( ) NEW_LINE seenP = [ [ False ] * n for _ in range ( m ) ] NEW_LINE seenA = [ [ False ] * n for _ in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT qP . append ( ( i , 0 ) ) NEW_LINE qA . append ( ( i , n - 1 ) ) NEW_LINE seenP [ i ] [ 0 ] = True NEW_LINE seenA [ i ] [ n - 1 ] = True NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT qP . append ( ( 0 , j ) ) NEW_LINE qA . append ( ( m - 1 , j ) ) NEW_LINE seenP [ 0 ] [ j ] = True NEW_LINE seenA [ m - 1 ] [ j ] = True NEW_LINE DEDENT def bfs ( q : deque , seen : List [ List [ bool ] ] ) : NEW_LINE INDENT while q : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE h = heights [ i ] [ j ] NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT if seen [ x ] [ y ] or heights [ x ] [ y ] < h : NEW_LINE INDENT continue NEW_LINE DEDENT q . append ( ( x , y ) ) NEW_LINE seen [ x ] [ y ] = True NEW_LINE DEDENT DEDENT DEDENT bfs ( qP , seenP ) NEW_LINE bfs ( qA , seenA ) NEW_LINE return [ [ i , j ] for i in range ( m ) for j in range ( n ) if seenP [ i ] [ j ] and seenA [ i ] [ j ] ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def wordsTyping ( self , sentence : List [ str ] , rows : int , cols : int ) -> int : NEW_LINE INDENT combined = ' ▁ ' . join ( sentence ) + ' ▁ ' NEW_LINE n = len ( combined ) NEW_LINE i = 0 NEW_LINE for _ in range ( rows ) : NEW_LINE INDENT i += cols NEW_LINE if combined [ i % n ] == ' ▁ ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT while i > 0 and combined [ ( i - 1 ) % n ] != ' ▁ ' : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT DEDENT DEDENT return i // n NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def trap ( self , height : List [ int ] ) -> int : NEW_LINE INDENT n = len ( height ) NEW_LINE l = [ 0 ] * n NEW_LINE r = [ 0 ] * n NEW_LINE for i , h in enumerate ( height ) : NEW_LINE INDENT l [ i ] = h if i == 0 else max ( h , l [ i - 1 ] ) NEW_LINE DEDENT for i , h in reversed ( list ( enumerate ( height ) ) ) : NEW_LINE INDENT r [ i ] = h if i == n - 1 else max ( h , r [ i + 1 ] ) NEW_LINE DEDENT return sum ( min ( l [ i ] , r [ i ] ) - h for i , h in enumerate ( height ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def originalDigits ( self , s : str ) -> str : NEW_LINE INDENT count = [ 0 ] * 10 NEW_LINE for c in s : NEW_LINE INDENT if c == ' z ' : NEW_LINE INDENT count [ 0 ] += 1 NEW_LINE DEDENT if c == ' o ' : NEW_LINE INDENT count [ 1 ] += 1 NEW_LINE DEDENT if c == ' w ' : NEW_LINE INDENT count [ 2 ] += 1 NEW_LINE DEDENT if c == ' h ' : NEW_LINE INDENT count [ 3 ] += 1 NEW_LINE DEDENT if c == ' u ' : NEW_LINE INDENT count [ 4 ] += 1 NEW_LINE DEDENT if c == ' f ' : NEW_LINE INDENT count [ 5 ] += 1 NEW_LINE DEDENT if c == ' x ' : NEW_LINE INDENT count [ 6 ] += 1 NEW_LINE DEDENT if c == ' s ' : NEW_LINE INDENT count [ 7 ] += 1 NEW_LINE DEDENT if c == ' g ' : NEW_LINE INDENT count [ 8 ] += 1 NEW_LINE DEDENT if c == ' i ' : NEW_LINE INDENT count [ 9 ] += 1 NEW_LINE DEDENT DEDENT count [ 1 ] -= count [ 0 ] + count [ 2 ] + count [ 4 ] NEW_LINE count [ 3 ] -= count [ 8 ] NEW_LINE count [ 5 ] -= count [ 4 ] NEW_LINE count [ 7 ] -= count [ 6 ] NEW_LINE count [ 9 ] -= count [ 5 ] + count [ 6 ] + count [ 8 ] NEW_LINE return ' ' . join ( chr ( i + ord ( '0' ) ) for i , c in enumerate ( count ) for j in range ( c ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def characterReplacement ( self , s : str , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE maxCount = 0 NEW_LINE count = Counter ( ) NEW_LINE l = 0 NEW_LINE for r , c in enumerate ( s ) : NEW_LINE INDENT count [ c ] += 1 NEW_LINE maxCount = max ( maxCount , count [ c ] ) NEW_LINE while maxCount + k < r - l + 1 : NEW_LINE INDENT count [ s [ l ] ] -= 1 NEW_LINE l += 1 NEW_LINE DEDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def multiply ( self , num1 : str , num2 : str ) -> str : NEW_LINE INDENT s = [ 0 ] * ( len ( num1 ) + len ( num2 ) ) NEW_LINE for i in reversed ( range ( len ( num1 ) ) ) : NEW_LINE INDENT for j in reversed ( range ( len ( num2 ) ) ) : NEW_LINE INDENT mult = int ( num1 [ i ] ) * int ( num2 [ j ] ) NEW_LINE summ = mult + s [ i + j + 1 ] NEW_LINE s [ i + j ] += summ // 10 NEW_LINE s [ i + j + 1 ] = summ % 10 NEW_LINE DEDENT DEDENT for i , c in enumerate ( s ) : NEW_LINE INDENT if c != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ' ' . join ( map ( str , s [ i : ] ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def flatten ( self , head : ' Node ' ) -> ' Node ' : NEW_LINE INDENT def flatten ( head : ' Node ' , rest : ' Node ' ) -> ' Node ' : NEW_LINE INDENT if not head : NEW_LINE INDENT return rest NEW_LINE DEDENT head . next = flatten ( head . child , flatten ( head . next , rest ) ) NEW_LINE if head . next : NEW_LINE INDENT head . next . prev = head NEW_LINE DEDENT head . child = None NEW_LINE return head NEW_LINE DEDENT return flatten ( head , None ) NEW_LINE DEDENT DEDENT
class Codec : NEW_LINE INDENT def encode ( self , root : ' Node ' ) -> Optional [ TreeNode ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return None NEW_LINE DEDENT rootTreeNode = TreeNode ( root . val ) NEW_LINE q = deque ( [ ( root , rootTreeNode ) ] ) NEW_LINE while q : NEW_LINE INDENT parentNode , parentTreeNode = q . popleft ( ) NEW_LINE prevTreeNode = None NEW_LINE headTreeNode = None NEW_LINE for child in parentNode . children : NEW_LINE INDENT currTreeNode = TreeNode ( child . val ) NEW_LINE if prevTreeNode : NEW_LINE INDENT prevTreeNode . right = currTreeNode NEW_LINE DEDENT else : NEW_LINE INDENT headTreeNode = currTreeNode NEW_LINE DEDENT prevTreeNode = currTreeNode NEW_LINE q . append ( ( child , currTreeNode ) ) NEW_LINE DEDENT parentTreeNode . left = headTreeNode NEW_LINE DEDENT return rootTreeNode NEW_LINE DEDENT def decode ( self , root : Optional [ TreeNode ] ) -> ' Node ' : NEW_LINE INDENT if not root : NEW_LINE INDENT return None NEW_LINE DEDENT rootNode = Node ( root . val , [ ] ) NEW_LINE q = deque ( [ ( rootNode , root ) ] ) NEW_LINE while q : NEW_LINE INDENT parentNode , parentTreeNode = q . popleft ( ) NEW_LINE sibling = parentTreeNode . left NEW_LINE while sibling : NEW_LINE INDENT currNode = Node ( sibling . val , [ ] ) NEW_LINE parentNode . children . append ( currNode ) NEW_LINE q . append ( ( currNode , sibling ) ) NEW_LINE sibling = sibling . right NEW_LINE DEDENT DEDENT return rootNode NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countSegments ( self , s : str ) -> int : NEW_LINE INDENT return len ( s . split ( ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def eraseOverlapIntervals ( self , intervals : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE currentEnd = - math . inf NEW_LINE for interval in sorted ( intervals , key = lambda x : x [ 1 ] ) : NEW_LINE INDENT if interval [ 0 ] >= currentEnd : NEW_LINE INDENT currentEnd = interval [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def pathSum ( self , root : TreeNode , summ : int ) -> int : NEW_LINE INDENT if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT def dfs ( root : TreeNode , summ : int ) -> int : NEW_LINE INDENT if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( summ == root . val ) + dfs ( root . left , summ - root . val ) + dfs ( root . right , summ - root . val ) NEW_LINE DEDENT return dfs ( root , summ ) + self . pathSum ( root . left , summ ) + self . pathSum ( root . right , summ ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findAnagrams ( self , s : str , p : str ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE count = Counter ( p ) NEW_LINE required = len ( p ) NEW_LINE for r , c in enumerate ( s ) : NEW_LINE INDENT count [ c ] -= 1 NEW_LINE if count [ c ] >= 0 : NEW_LINE INDENT required -= 1 NEW_LINE DEDENT if r >= len ( p ) : NEW_LINE INDENT count [ s [ r - len ( p ) ] ] += 1 NEW_LINE if count [ s [ r - len ( p ) ] ] > 0 : NEW_LINE INDENT required += 1 NEW_LINE DEDENT DEDENT if required == 0 : NEW_LINE INDENT ans . append ( r - len ( p ) + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def parseTernary ( self , expression : str ) -> str : NEW_LINE INDENT c = expression [ self . i ] NEW_LINE if self . i + 1 == len ( expression ) or expression [ self . i + 1 ] == ' : ' : NEW_LINE INDENT self . i += 2 NEW_LINE return str ( c ) NEW_LINE DEDENT self . i += 2 NEW_LINE first = self . parseTernary ( expression ) NEW_LINE second = self . parseTernary ( expression ) NEW_LINE return first if c == ' T ' else second NEW_LINE DEDENT i = 0 NEW_LINE DEDENT
class Solution : NEW_LINE INDENT def isMatch ( self , s : str , p : str ) -> bool : NEW_LINE INDENT m = len ( s ) NEW_LINE n = len ( p ) NEW_LINE dp = [ [ False ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = True NEW_LINE def isMatch ( i : int , j : int ) -> bool : NEW_LINE INDENT return i >= 0 and p [ j ] == ' ? ' or s [ i ] == p [ j ] NEW_LINE DEDENT for j , c in enumerate ( p ) : NEW_LINE INDENT if c == ' * ' : NEW_LINE INDENT dp [ 0 ] [ j + 1 ] = dp [ 0 ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if p [ j ] == ' * ' : NEW_LINE INDENT matchEmpty = dp [ i + 1 ] [ j ] NEW_LINE matchSome = dp [ i ] [ j + 1 ] NEW_LINE dp [ i + 1 ] [ j + 1 ] = matchEmpty or matchSome NEW_LINE DEDENT elif isMatch ( i , j ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def arrangeCoins ( self , n : int ) -> int : NEW_LINE INDENT return int ( ( - 1 + sqrt ( 8 * n + 1 ) ) // 2 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findDuplicates ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE for num in nums : NEW_LINE INDENT nums [ abs ( num ) - 1 ] *= - 1 NEW_LINE if nums [ abs ( num ) - 1 ] > 0 : NEW_LINE INDENT ans . append ( abs ( num ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def compress ( self , chars : List [ str ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE i = 0 NEW_LINE while i < len ( chars ) : NEW_LINE INDENT letter = chars [ i ] NEW_LINE count = 0 NEW_LINE while i < len ( chars ) and chars [ i ] == letter : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT chars [ ans ] = letter NEW_LINE ans += 1 NEW_LINE if count > 1 : NEW_LINE INDENT for c in str ( count ) : NEW_LINE INDENT chars [ ans ] = c NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sequenceReconstruction ( self , org : List [ int ] , seqs : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT if not seqs : NEW_LINE INDENT return False NEW_LINE DEDENT n = len ( org ) NEW_LINE graph = [ [ ] for _ in range ( n ) ] NEW_LINE inDegree = [ 0 ] * n NEW_LINE for seq in seqs : NEW_LINE INDENT if len ( seq ) == 1 and seq [ 0 ] < 1 or seq [ 0 ] > n : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for u , v in zip ( seq , seq [ 1 : ] ) : NEW_LINE INDENT if u < 1 or u > n or v < 1 or v > n : NEW_LINE INDENT return False NEW_LINE DEDENT graph [ u - 1 ] . append ( v - 1 ) NEW_LINE inDegree [ v - 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT q = deque ( [ i for i , d in enumerate ( inDegree ) if d == 0 ] ) NEW_LINE i = 0 NEW_LINE while q : NEW_LINE INDENT if len ( q ) > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT u = q . popleft ( ) NEW_LINE if u != org [ i ] - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE for v in graph [ u ] : NEW_LINE INDENT inDegree [ v ] -= 1 NEW_LINE if inDegree [ v ] == 0 : NEW_LINE INDENT q . append ( v ) NEW_LINE DEDENT DEDENT DEDENT return i == n NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : NEW_LINE INDENT stack1 = [ ] NEW_LINE stack2 = [ ] NEW_LINE while l1 : NEW_LINE INDENT stack1 . append ( l1 ) NEW_LINE l1 = l1 . next NEW_LINE DEDENT while l2 : NEW_LINE INDENT stack2 . append ( l2 ) NEW_LINE l2 = l2 . next NEW_LINE DEDENT head = None NEW_LINE carry = 0 NEW_LINE while carry or stack1 or stack2 : NEW_LINE INDENT if stack1 : NEW_LINE INDENT carry += stack1 . pop ( ) . val NEW_LINE DEDENT if stack2 : NEW_LINE INDENT carry += stack2 . pop ( ) . val NEW_LINE DEDENT node = ListNode ( carry % 10 ) NEW_LINE node . next = head NEW_LINE head = node NEW_LINE carry //= 10 NEW_LINE DEDENT return head NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numberOfBoomerangs ( self , points : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for x1 , y1 in points : NEW_LINE INDENT count = defaultdict ( int ) NEW_LINE for x2 , y2 in points : NEW_LINE INDENT ans += 2 * count [ ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ] NEW_LINE count [ ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ] += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findDisappearedNumbers ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT for num in nums : NEW_LINE INDENT index = abs ( num ) - 1 NEW_LINE nums [ index ] = - abs ( nums [ index ] ) NEW_LINE DEDENT return [ i + 1 for i , num in enumerate ( nums ) if num > 0 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def jump ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE end = 0 NEW_LINE farthest = 0 NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT farthest = max ( farthest , i + nums [ i ] ) NEW_LINE if farthest >= len ( nums ) - 1 : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT if i == end : NEW_LINE INDENT ans += 1 NEW_LINE end = farthest NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def deleteNode ( self , root : Optional [ TreeNode ] , key : int ) -> Optional [ TreeNode ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return None NEW_LINE DEDENT if root . val == key : NEW_LINE INDENT if not root . left : NEW_LINE INDENT return root . right NEW_LINE DEDENT if not root . right : NEW_LINE INDENT return root . left NEW_LINE DEDENT minNode = self . _getMin ( root . right ) NEW_LINE root . right = self . deleteNode ( root . right , minNode . val ) NEW_LINE minNode . left = root . left NEW_LINE minNode . right = root . right NEW_LINE root = minNode NEW_LINE DEDENT elif root . val < key : NEW_LINE INDENT root . right = self . deleteNode ( root . right , key ) NEW_LINE DEDENT else : NEW_LINE INDENT root . left = self . deleteNode ( root . left , key ) NEW_LINE DEDENT return root NEW_LINE DEDENT def _getMin ( self , node : Optional [ TreeNode ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT while node . left : NEW_LINE INDENT node = node . left NEW_LINE DEDENT return node NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def frequencySort ( self , s : str ) -> str : NEW_LINE INDENT ans = [ ] NEW_LINE bucket = [ [ ] for _ in range ( len ( s ) + 1 ) ] NEW_LINE for c , freq in Counter ( s ) . items ( ) : NEW_LINE INDENT bucket [ freq ] . append ( c ) NEW_LINE DEDENT for freq in reversed ( range ( len ( bucket ) ) ) : NEW_LINE INDENT for c in bucket [ freq ] : NEW_LINE INDENT ans . append ( c * freq ) NEW_LINE DEDENT DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMinArrowShots ( self , points : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE arrowX = - math . inf NEW_LINE for point in sorted ( points , key = lambda x : x [ 1 ] ) : NEW_LINE INDENT if point [ 0 ] > arrowX : NEW_LINE INDENT ans += 1 NEW_LINE arrowX = point [ 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minMoves ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT mini = min ( nums ) NEW_LINE return sum ( num - mini for num in nums ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def fourSumCount ( self , A : List [ int ] , B : List [ int ] , C : List [ int ] , D : List [ int ] ) -> int : NEW_LINE INDENT count = Counter ( a + b for a in A for b in B ) NEW_LINE return sum ( count [ - c - d ] for c in C for d in D ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def circularArrayLoop ( self , nums : List [ int ] ) -> bool : NEW_LINE INDENT def advance ( i : int ) -> int : NEW_LINE INDENT return ( i + nums [ i ] ) % len ( nums ) NEW_LINE DEDENT if len ( nums ) < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT for i , num in enumerate ( nums ) : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT slow = i NEW_LINE fast = advance ( slow ) NEW_LINE while num * nums [ fast ] > 0 and num * nums [ advance ( fast ) ] > 0 : NEW_LINE INDENT if slow == fast : NEW_LINE INDENT if slow == advance ( slow ) : NEW_LINE INDENT break NEW_LINE DEDENT return True NEW_LINE DEDENT slow = advance ( slow ) NEW_LINE fast = advance ( advance ( fast ) ) NEW_LINE DEDENT slow = i NEW_LINE sign = num NEW_LINE while sign * nums [ slow ] > 0 : NEW_LINE INDENT next = advance ( slow ) NEW_LINE nums [ slow ] = 0 NEW_LINE slow = next NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def poorPigs ( self , buckets : int , minutesToDie : int , minutesToTest : int ) -> int : NEW_LINE INDENT return ceil ( log ( buckets ) / log ( minutesToTest // minutesToDie + 1 ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def repeatedSubstringPattern ( self , s : str ) -> bool : NEW_LINE INDENT return s in ( s + s ) [ 1 : - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def permute ( self , nums : List [ int ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE used = [ False ] * len ( nums ) NEW_LINE def dfs ( path : List [ int ] ) -> None : NEW_LINE INDENT if len ( path ) == len ( nums ) : NEW_LINE INDENT ans . append ( path . copy ( ) ) NEW_LINE return NEW_LINE DEDENT for i , num in enumerate ( nums ) : NEW_LINE INDENT if used [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT used [ i ] = True NEW_LINE path . append ( num ) NEW_LINE dfs ( path ) NEW_LINE path . pop ( ) NEW_LINE used [ i ] = False NEW_LINE DEDENT DEDENT dfs ( [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
import statistics NEW_LINE class Solution : NEW_LINE INDENT def minMoves2 ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT median = int ( statistics . median ( nums ) ) NEW_LINE return sum ( abs ( num - median ) for num in nums ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def islandPerimeter ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE islands = 0 NEW_LINE neighbors = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT islands += 1 NEW_LINE if i + 1 < m and grid [ i + 1 ] [ j ] == 1 : NEW_LINE INDENT neighbors += 1 NEW_LINE DEDENT if j + 1 < n and grid [ i ] [ j + 1 ] == 1 : NEW_LINE INDENT neighbors += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return islands * 4 - neighbors * 2 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minTransfers ( self , transactions : List [ List [ int ] ] ) -> int : NEW_LINE INDENT balance = [ 0 ] * 21 NEW_LINE for u , v , amount in transactions : NEW_LINE INDENT balance [ u ] -= amount NEW_LINE balance [ v ] += amount NEW_LINE DEDENT debt = [ b for b in balance if b ] NEW_LINE def dfs ( s : int ) -> int : NEW_LINE INDENT while s < len ( debt ) and not debt [ s ] : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if s == len ( debt ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = math . inf NEW_LINE for i in range ( s + 1 , len ( debt ) ) : NEW_LINE INDENT if debt [ i ] * debt [ s ] < 0 : NEW_LINE INDENT debt [ i ] += debt [ s ] NEW_LINE ans = min ( ans , 1 + dfs ( s + 1 ) ) NEW_LINE debt [ i ] -= debt [ s ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return dfs ( 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isConvex ( self , points : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT def getCross ( p : List [ int ] , q : List [ int ] , r : List [ int ] ) : NEW_LINE INDENT return ( q [ 0 ] - p [ 0 ] ) * ( r [ 1 ] - p [ 1 ] ) - ( q [ 1 ] - p [ 1 ] ) * ( r [ 0 ] - p [ 0 ] ) NEW_LINE DEDENT sign = 0 NEW_LINE for i in range ( len ( points ) ) : NEW_LINE INDENT cross = getCross ( points [ i - 2 ] , points [ i - 1 ] , points [ i ] ) NEW_LINE if cross == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if sign == 0 : NEW_LINE INDENT sign = cross NEW_LINE DEDENT elif cross * sign < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def permuteUnique ( self , nums : List [ int ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE used = [ False ] * len ( nums ) NEW_LINE def dfs ( path : List [ int ] ) -> None : NEW_LINE INDENT if len ( path ) == len ( nums ) : NEW_LINE INDENT ans . append ( path . copy ( ) ) NEW_LINE return NEW_LINE DEDENT for i , num in enumerate ( nums ) : NEW_LINE INDENT if used [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT if i > 0 and nums [ i ] == nums [ i - 1 ] and not used [ i - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT used [ i ] = True NEW_LINE path . append ( num ) NEW_LINE dfs ( path ) NEW_LINE path . pop ( ) NEW_LINE used [ i ] = False NEW_LINE DEDENT DEDENT nums . sort ( ) NEW_LINE dfs ( [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findAllConcatenatedWordsInADict ( self , words : List [ str ] ) -> List [ str ] : NEW_LINE INDENT wordSet = set ( words ) NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def isConcat ( word : str ) -> bool : NEW_LINE INDENT for i in range ( 1 , len ( word ) ) : NEW_LINE INDENT prefix = word [ : i ] NEW_LINE suffix = word [ i : ] NEW_LINE if prefix in wordSet and ( suffix in wordSet or isConcat ( suffix ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT return [ word for word in words if isConcat ( word ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def makesquare ( self , matchsticks : List [ int ] ) -> bool : NEW_LINE INDENT if len ( matchsticks ) < 4 : NEW_LINE INDENT return False NEW_LINE DEDENT perimeter = sum ( matchsticks ) NEW_LINE if perimeter % 4 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT A = sorted ( matchsticks ) [ : : - 1 ] NEW_LINE def dfs ( selected : int , edges : List [ int ] ) -> bool : NEW_LINE INDENT if selected == len ( A ) : NEW_LINE INDENT return all ( edge == edges [ 0 ] for edge in edges ) NEW_LINE DEDENT for i , edge in enumerate ( edges ) : NEW_LINE INDENT if A [ selected ] > edge : NEW_LINE INDENT continue NEW_LINE DEDENT edges [ i ] -= A [ selected ] NEW_LINE if dfs ( selected + 1 , edges ) : NEW_LINE INDENT return True NEW_LINE DEDENT edges [ i ] += A [ selected ] NEW_LINE DEDENT return False NEW_LINE DEDENT return dfs ( 0 , [ perimeter // 4 ] * 4 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMaxForm ( self , strs : List [ str ] , m : int , n : int ) -> int : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for s in strs : NEW_LINE INDENT count0 = s . count ( '0' ) NEW_LINE count1 = len ( s ) - count0 NEW_LINE for i in range ( m , count0 - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n , count1 - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - count0 ] [ j - count1 ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def __init__ ( self , radius : float , x_center : float , y_center : float ) : NEW_LINE INDENT self . radius = radius NEW_LINE self . x_center = x_center NEW_LINE self . y_center = y_center NEW_LINE DEDENT def randPoint ( self ) -> List [ float ] : NEW_LINE INDENT length = sqrt ( random . uniform ( 0 , 1 ) ) * self . radius NEW_LINE degree = random . uniform ( 0 , 1 ) * 2 * math . pi NEW_LINE x = self . x_center + length * math . cos ( degree ) NEW_LINE y = self . y_center + length * math . sin ( degree ) NEW_LINE return [ x , y ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestPalindrome ( self , n : int ) -> int : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 9 NEW_LINE DEDENT kMod = 1337 NEW_LINE upper = pow ( 10 , n ) - 1 NEW_LINE lower = pow ( 10 , n - 1 ) - 1 NEW_LINE for i in range ( upper , lower , - 1 ) : NEW_LINE INDENT cand = int ( str ( i ) + str ( i ) [ : : - 1 ] ) NEW_LINE j = upper NEW_LINE while j * j >= cand : NEW_LINE INDENT if cand % j == 0 : NEW_LINE INDENT return cand % kMod NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def rotate ( self , matrix : List [ List [ int ] ] ) -> None : NEW_LINE INDENT matrix . reverse ( ) NEW_LINE for i in range ( len ( matrix ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( matrix ) ) : NEW_LINE INDENT matrix [ i ] [ j ] , matrix [ j ] [ i ] = matrix [ j ] [ i ] , matrix [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestGoodBase ( self , n : str ) -> str : NEW_LINE INDENT n = int ( n ) NEW_LINE for m in range ( int ( math . log ( n , 2 ) ) , 1 , - 1 ) : NEW_LINE INDENT k = int ( n ** m ** - 1 ) NEW_LINE if ( k ** ( m + 1 ) - 1 ) // ( k - 1 ) == n : NEW_LINE INDENT return str ( k ) NEW_LINE DEDENT DEDENT return str ( n - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findPermutation ( self , s : str ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE stack = [ ] NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT stack . append ( i + 1 ) NEW_LINE if c == ' I ' : NEW_LINE INDENT while stack : NEW_LINE INDENT ans . append ( stack . pop ( ) ) NEW_LINE DEDENT DEDENT DEDENT stack . append ( len ( s ) + 1 ) NEW_LINE while stack : NEW_LINE INDENT ans . append ( stack . pop ( ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMaxConsecutiveOnes ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE summ = 0 NEW_LINE for num in nums : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT summ = 0 NEW_LINE DEDENT else : NEW_LINE INDENT summ += num NEW_LINE ans = max ( ans , summ ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMaxConsecutiveOnes ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE zeros = 0 NEW_LINE l = 0 NEW_LINE for r , num in enumerate ( nums ) : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT while zeros == 2 : NEW_LINE INDENT if nums [ l ] == 0 : NEW_LINE INDENT zeros -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMinStep ( self , board : str , hand : str ) -> int : NEW_LINE INDENT def deDup ( board ) : NEW_LINE INDENT start = 0 NEW_LINE for i , c in enumerate ( board ) : NEW_LINE INDENT if c != board [ start ] : NEW_LINE INDENT if i - start >= 3 : NEW_LINE INDENT return deDup ( board [ : start ] + board [ i : ] ) NEW_LINE DEDENT start = i NEW_LINE DEDENT DEDENT return board NEW_LINE DEDENT @ functools . lru_cache ( None ) NEW_LINE def dfs ( board : str , hand : str ) : NEW_LINE INDENT board = deDup ( board ) NEW_LINE if board == ' # ' : NEW_LINE INDENT return 0 NEW_LINE DEDENT boardSet = set ( board ) NEW_LINE hand = ' ' . join ( h for h in hand if h in boardSet ) NEW_LINE if not hand : NEW_LINE INDENT return math . inf NEW_LINE DEDENT ans = math . inf NEW_LINE for i in range ( len ( board ) ) : NEW_LINE INDENT for j , h in enumerate ( hand ) : NEW_LINE INDENT newHand = hand [ : j ] + hand [ j + 1 : ] NEW_LINE newBoard = board [ : i ] + h + board [ i : ] NEW_LINE ans = min ( ans , 1 + dfs ( newBoard , newHand ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT ans = dfs ( board + ' # ' , hand ) NEW_LINE return - 1 if ans == math . inf else ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def groupAnagrams ( self , strs : List [ str ] ) -> List [ List [ str ] ] : NEW_LINE INDENT dict = defaultdict ( list ) NEW_LINE for str in strs : NEW_LINE INDENT key = ' ' . join ( sorted ( str ) ) NEW_LINE dict [ key ] . append ( str ) NEW_LINE DEDENT return dict . values ( ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def hasPath ( self , maze : List [ List [ int ] ] , start : List [ int ] , destination : List [ int ] ) -> bool : NEW_LINE INDENT m = len ( maze ) NEW_LINE n = len ( maze [ 0 ] ) NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE q = deque ( [ ( start [ 0 ] , start [ 1 ] ) ] ) NEW_LINE seen = { ( start [ 0 ] , start [ 1 ] ) } NEW_LINE def isValid ( x : int , y : int ) -> bool : NEW_LINE INDENT return 0 <= x < m and 0 <= y < n and maze [ x ] [ y ] == 0 NEW_LINE DEDENT while q : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i NEW_LINE y = j NEW_LINE while isValid ( x + dirs [ k ] , y + dirs [ k + 1 ] ) : NEW_LINE INDENT x += dirs [ k ] NEW_LINE y += dirs [ k + 1 ] NEW_LINE DEDENT if [ x , y ] == destination : NEW_LINE INDENT return True NEW_LINE DEDENT if ( x , y ) in seen : NEW_LINE INDENT continue NEW_LINE DEDENT q . append ( ( x , y ) ) NEW_LINE seen . add ( ( x , y ) ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findSubsequences ( self , nums : List [ int ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE def dfs ( s : int , path : List [ int ] ) -> None : NEW_LINE INDENT if len ( path ) > 1 : NEW_LINE INDENT ans . append ( path ) NEW_LINE DEDENT used = set ( ) NEW_LINE for i in range ( s , len ( nums ) ) : NEW_LINE INDENT if nums [ i ] in used : NEW_LINE INDENT continue NEW_LINE DEDENT if not path or nums [ i ] >= path [ - 1 ] : NEW_LINE INDENT used . add ( nums [ i ] ) NEW_LINE dfs ( i + 1 , path + [ nums [ i ] ] ) NEW_LINE DEDENT DEDENT DEDENT dfs ( 0 , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findTargetSumWays ( self , nums : List [ int ] , target : int ) -> int : NEW_LINE INDENT summ = sum ( nums ) NEW_LINE if summ < abs ( target ) or ( summ + target ) & 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT def knapsack ( target : int ) -> int : NEW_LINE INDENT dp = [ 1 ] + [ 0 ] * summ NEW_LINE for num in nums : NEW_LINE INDENT for j in range ( summ , num - 1 , - 1 ) : NEW_LINE INDENT dp [ j ] += dp [ j - num ] NEW_LINE DEDENT DEDENT return dp [ target ] NEW_LINE DEDENT return knapsack ( ( summ + target ) // 2 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findPoisonedDuration ( self , timeSeries : List [ int ] , duration : int ) -> int : NEW_LINE INDENT if duration == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , len ( timeSeries ) - 1 ) : NEW_LINE INDENT ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ] , duration ) NEW_LINE DEDENT return ans + duration NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nextGreaterElement ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> List [ int ] : NEW_LINE INDENT numToNextGreater = { } NEW_LINE stack = [ ] NEW_LINE for num in nums2 : NEW_LINE INDENT while stack and stack [ - 1 ] < num : NEW_LINE INDENT numToNextGreater [ stack . pop ( ) ] = num NEW_LINE DEDENT stack . append ( num ) NEW_LINE DEDENT return [ numToNextGreater . get ( num , - 1 ) for num in nums1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def __init__ ( self , rects : List [ List [ int ] ] ) : NEW_LINE INDENT self . rects = rects NEW_LINE self . areas = list ( itertools . accumulate ( [ ( x2 - x1 + 1 ) * ( y2 - y1 + 1 ) for x1 , y1 , x2 , y2 in rects ] ) ) NEW_LINE DEDENT def pick ( self ) -> List [ int ] : NEW_LINE INDENT index = bisect_right ( self . areas , randint ( 0 , self . areas [ - 1 ] - 1 ) ) NEW_LINE x1 , y1 , x2 , y2 = self . rects [ index ] NEW_LINE return [ randint ( x1 , x2 ) , randint ( y1 , y2 ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findShortestWay ( self , maze : List [ List [ int ] ] , ball : List [ int ] , hole : List [ int ] ) -> str : NEW_LINE INDENT ans = " impossible " NEW_LINE minSteps = math . inf NEW_LINE def dfs ( i : int , j : int , dx : int , dy : int , steps : int , path : str ) : NEW_LINE INDENT nonlocal ans NEW_LINE nonlocal minSteps NEW_LINE if steps >= minSteps : NEW_LINE INDENT return NEW_LINE DEDENT if dx != 0 or dy != 0 : NEW_LINE INDENT while 0 <= i + dx < len ( maze ) and 0 <= j + dy < len ( maze [ 0 ] ) and maze [ i + dx ] [ j + dy ] != 1 : NEW_LINE INDENT i += dx NEW_LINE j += dy NEW_LINE steps += 1 NEW_LINE if i == hole [ 0 ] and j == hole [ 1 ] and steps < minSteps : NEW_LINE INDENT minSteps = steps NEW_LINE ans = path NEW_LINE DEDENT DEDENT DEDENT if maze [ i ] [ j ] == 0 or steps + 2 < maze [ i ] [ j ] : NEW_LINE INDENT maze [ i ] [ j ] = steps + 2 NEW_LINE if dx == 0 : NEW_LINE INDENT dfs ( i , j , 1 , 0 , steps , path + ' d ' ) NEW_LINE DEDENT if dy == 0 : NEW_LINE INDENT dfs ( i , j , 0 , - 1 , steps , path + ' l ' ) NEW_LINE DEDENT if dy == 0 : NEW_LINE INDENT dfs ( i , j , 0 , 1 , steps , path + ' r ' ) NEW_LINE DEDENT if dx == 0 : NEW_LINE INDENT dfs ( i , j , - 1 , 0 , steps , path + ' u ' ) NEW_LINE DEDENT DEDENT DEDENT dfs ( ball [ 0 ] , ball [ 1 ] , 0 , 0 , 0 , ' ' ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestPalindrome ( self , s : str ) -> str : NEW_LINE INDENT if not s : NEW_LINE INDENT return ' ' NEW_LINE DEDENT indices = [ 0 , 0 ] NEW_LINE def extend ( s : str , i : int , j : int ) -> Tuple [ int , int ] : NEW_LINE INDENT while i >= 0 and j < len ( s ) : NEW_LINE INDENT if s [ i ] != s [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE j += 1 NEW_LINE DEDENT return i + 1 , j - 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT l1 , r1 = extend ( s , i , i ) NEW_LINE if r1 - l1 > indices [ 1 ] - indices [ 0 ] : NEW_LINE INDENT indices = l1 , r1 NEW_LINE DEDENT if i + 1 < len ( s ) and s [ i ] == s [ i + 1 ] : NEW_LINE INDENT l2 , r2 = extend ( s , i , i + 1 ) NEW_LINE if r2 - l2 > indices [ 1 ] - indices [ 0 ] : NEW_LINE INDENT indices = l2 , r2 NEW_LINE DEDENT DEDENT DEDENT return s [ indices [ 0 ] : indices [ 1 ] + 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def myPow ( self , x : float , n : int ) -> float : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n < 0 : NEW_LINE INDENT return 1 / self . myPow ( x , - n ) NEW_LINE DEDENT if n % 2 : NEW_LINE INDENT return x * self . myPow ( x , n - 1 ) NEW_LINE DEDENT return self . myPow ( x * x , n / 2 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findWords ( self , words : List [ str ] ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE rows = [ set ( ' qwertyuiop ' ) , set ( ' asdfghjkl ' ) , set ( ' zxcvbnm ' ) ] NEW_LINE for word in words : NEW_LINE INDENT lowerWord = set ( word . lower ( ) ) NEW_LINE if any ( lowerWord <= row for row in rows ) : NEW_LINE INDENT ans . append ( word ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMode ( self , root : Optional [ TreeNode ] ) -> List [ int ] : NEW_LINE INDENT self . ans = [ ] NEW_LINE self . pred = None NEW_LINE self . count = 0 NEW_LINE self . maxCount = 0 NEW_LINE def updateCount ( root : Optional [ TreeNode ] ) -> None : NEW_LINE INDENT if self . pred and self . pred . val == root . val : NEW_LINE INDENT self . count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT self . count = 1 NEW_LINE DEDENT if self . count > self . maxCount : NEW_LINE INDENT self . maxCount = self . count NEW_LINE self . ans = [ root . val ] NEW_LINE DEDENT elif self . count == self . maxCount : NEW_LINE INDENT self . ans . append ( root . val ) NEW_LINE DEDENT self . pred = root NEW_LINE DEDENT def inorder ( root : Optional [ TreeNode ] ) -> None : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( root . left ) NEW_LINE updateCount ( root ) NEW_LINE inorder ( root . right ) NEW_LINE DEDENT inorder ( root ) NEW_LINE return self . ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nextGreaterElements ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT n = len ( nums ) NEW_LINE ans = [ - 1 ] * n NEW_LINE stack = [ ] NEW_LINE for i in range ( n * 2 ) : NEW_LINE INDENT num = nums [ i % n ] NEW_LINE while stack and nums [ stack [ - 1 ] ] < num : NEW_LINE INDENT ans [ stack . pop ( ) ] = num NEW_LINE DEDENT if i < n : NEW_LINE INDENT stack . append ( i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkPerfectNumber ( self , num : int ) -> bool : NEW_LINE INDENT return num in { 6 , 28 , 496 , 8128 , 33550336 } NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findFrequentTreeSum ( self , root : Optional [ TreeNode ] ) -> List [ int ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return [ ] NEW_LINE DEDENT count = Counter ( ) NEW_LINE def dfs ( root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT summ = root . val + dfs ( root . left ) + dfs ( root . right ) NEW_LINE count [ summ ] += 1 NEW_LINE return summ NEW_LINE DEDENT dfs ( root ) NEW_LINE maxFreq = max ( count . values ( ) ) NEW_LINE return [ summ for summ in count if count [ summ ] == maxFreq ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def fib ( self , N : int ) -> int : NEW_LINE INDENT if N < 2 : NEW_LINE INDENT return N NEW_LINE DEDENT dp = [ 0 , 0 , 1 ] NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ 0 ] = dp [ 1 ] NEW_LINE dp [ 1 ] = dp [ 2 ] NEW_LINE dp [ 2 ] = dp [ 0 ] + dp [ 1 ] NEW_LINE DEDENT return dp [ 2 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def solveNQueens ( self , n : int ) -> List [ List [ str ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE cols = [ False ] * n NEW_LINE diag1 = [ False ] * ( 2 * n - 1 ) NEW_LINE diag2 = [ False ] * ( 2 * n - 1 ) NEW_LINE def dfs ( i : int , board : List [ int ] ) -> None : NEW_LINE INDENT if i == n : NEW_LINE INDENT ans . append ( board ) NEW_LINE return NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if cols [ j ] or diag1 [ i + j ] or diag2 [ j - i + n - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = True NEW_LINE dfs ( i + 1 , board + [ ' . ' * j + ' Q ' + ' . ' * ( n - j - 1 ) ] ) NEW_LINE cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = False NEW_LINE DEDENT DEDENT dfs ( 0 , [ ] ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findBottomLeftValue ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT q = deque ( [ root ] ) NEW_LINE while q : NEW_LINE INDENT root = q . popleft ( ) NEW_LINE if root . right : NEW_LINE INDENT q . append ( root . right ) NEW_LINE DEDENT if root . left : NEW_LINE INDENT q . append ( root . left ) NEW_LINE DEDENT DEDENT return root . val NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findRotateSteps ( self , ring : str , key : str ) -> int : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def dfs ( ring : str , index : int ) -> int : NEW_LINE INDENT if index == len ( key ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = math . inf NEW_LINE for i , r in enumerate ( ring ) : NEW_LINE INDENT if r == key [ index ] : NEW_LINE INDENT minRotates = min ( i , len ( ring ) - i ) NEW_LINE newRing = ring [ i : ] + ring [ : i ] NEW_LINE remainingRotates = dfs ( newRing , index + 1 ) NEW_LINE ans = min ( ans , minRotates + remainingRotates ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return dfs ( ring , 0 ) + len ( key ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def largestValues ( self , root : Optional [ TreeNode ] ) -> List [ int ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return [ ] NEW_LINE DEDENT ans = [ ] NEW_LINE q = deque ( [ root ] ) NEW_LINE while q : NEW_LINE INDENT maxi = - math . inf NEW_LINE for _ in range ( len ( q ) ) : NEW_LINE INDENT root = q . popleft ( ) NEW_LINE maxi = max ( maxi , root . val ) NEW_LINE if root . left : NEW_LINE INDENT q . append ( root . left ) NEW_LINE DEDENT if root . right : NEW_LINE INDENT q . append ( root . right ) NEW_LINE DEDENT DEDENT ans . append ( maxi ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestPalindromeSubseq ( self , s : str ) -> int : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int , j : int ) -> int : NEW_LINE INDENT if i > j : NEW_LINE INDENT return 0 NEW_LINE DEDENT if i == j : NEW_LINE INDENT return 1 NEW_LINE DEDENT if s [ i ] == s [ j ] : NEW_LINE INDENT return 2 + dp ( i + 1 , j - 1 ) NEW_LINE DEDENT return max ( dp ( i + 1 , j ) , dp ( i , j - 1 ) ) NEW_LINE DEDENT return dp ( 0 , len ( s ) - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMinMoves ( self , machines : List [ int ] ) -> int : NEW_LINE INDENT dresses = sum ( machines ) NEW_LINE if dresses % len ( machines ) != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = 0 NEW_LINE average = dresses // len ( machines ) NEW_LINE inout = 0 NEW_LINE for dress in machines : NEW_LINE INDENT inout += dress - average NEW_LINE ans = max ( ans , abs ( inout ) , dress - average ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def change ( self , amount : int , coins : List [ int ] ) -> int : NEW_LINE INDENT dp = [ 1 ] + [ 0 ] * amount NEW_LINE for coin in coins : NEW_LINE INDENT for i in range ( coin , amount + 1 ) : NEW_LINE INDENT dp [ i ] += dp [ i - coin ] NEW_LINE DEDENT DEDENT return dp [ amount ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def totalNQueens ( self , n : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE cols = [ False ] * n NEW_LINE diag1 = [ False ] * ( 2 * n - 1 ) NEW_LINE diag2 = [ False ] * ( 2 * n - 1 ) NEW_LINE def dfs ( i : int ) -> None : NEW_LINE INDENT nonlocal ans NEW_LINE if i == n : NEW_LINE INDENT ans += 1 NEW_LINE return NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if cols [ j ] or diag1 [ i + j ] or diag2 [ j - i + n - 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = True NEW_LINE dfs ( i + 1 ) NEW_LINE cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = False NEW_LINE DEDENT DEDENT dfs ( 0 ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def detectCapitalUse ( self , word : str ) -> bool : NEW_LINE INDENT return word . isupper ( ) or word . islower ( ) or word . istitle ( ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findLUSlength ( self , a : str , b : str ) -> int : NEW_LINE INDENT return - 1 if a == b else max ( len ( a ) , len ( b ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findLUSlength ( self , strs : List [ str ] ) -> int : NEW_LINE INDENT def isSubsequence ( a : str , b : str ) -> bool : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( a ) and j < len ( b ) : NEW_LINE INDENT if a [ i ] == b [ j ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT return i == len ( a ) NEW_LINE DEDENT seen = set ( ) NEW_LINE duplicates = set ( ) NEW_LINE for s in strs : NEW_LINE INDENT if s in seen : NEW_LINE INDENT duplicates . add ( s ) NEW_LINE DEDENT seen . add ( s ) NEW_LINE DEDENT strs . sort ( key = lambda s : - len ( s ) ) NEW_LINE for i in range ( len ( strs ) ) : NEW_LINE INDENT if strs [ i ] in duplicates : NEW_LINE INDENT continue NEW_LINE DEDENT isASubsequence = False NEW_LINE for j in range ( i ) : NEW_LINE INDENT isASubsequence |= isSubsequence ( strs [ i ] , strs [ j ] ) NEW_LINE DEDENT if not isASubsequence : NEW_LINE INDENT return len ( strs [ i ] ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkSubarraySum ( self , nums : List [ int ] , k : int ) -> bool : NEW_LINE INDENT prefix = 0 NEW_LINE prefixToIndex = { 0 : - 1 } NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT prefix += num NEW_LINE if k != 0 : NEW_LINE INDENT prefix %= k NEW_LINE DEDENT if prefix in prefixToIndex : NEW_LINE INDENT if i - prefixToIndex [ prefix ] > 1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT prefixToIndex [ prefix ] = i NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findLongestWord ( self , s : str , d : List [ str ] ) -> str : NEW_LINE INDENT ans = ' ' NEW_LINE for word in d : NEW_LINE INDENT i = 0 NEW_LINE for c in s : NEW_LINE INDENT if i < len ( word ) and c == word [ i ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if i == len ( word ) : NEW_LINE INDENT if len ( word ) > len ( ans ) or len ( word ) == len ( ans ) and word < ans : NEW_LINE INDENT ans = word NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMaxLength ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prefix = 0 NEW_LINE prefixToIndex = { 0 : - 1 } NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT prefix += 1 if num else - 1 NEW_LINE if prefix in prefixToIndex : NEW_LINE INDENT ans = max ( ans , i - prefixToIndex [ prefix ] ) NEW_LINE DEDENT else : NEW_LINE INDENT prefixToIndex [ prefix ] = i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def wordsAbbreviation ( self , words : List [ str ] ) -> List [ str ] : NEW_LINE INDENT n = len ( words ) NEW_LINE def getAbbrev ( s : str , prefixIndex : int ) -> str : NEW_LINE INDENT n = len ( s ) NEW_LINE num = n - ( prefixIndex + 1 ) - 1 NEW_LINE numLength = 1 if num < 10 else ( 2 if num < 100 else 3 ) NEW_LINE abbrevLength = ( prefixIndex + 1 ) + numLength + 1 NEW_LINE if abbrevLength >= n : NEW_LINE INDENT return s NEW_LINE DEDENT return s [ : prefixIndex + 1 ] + str ( num ) + s [ - 1 ] NEW_LINE DEDENT ans = [ getAbbrev ( word , 0 ) for word in words ] NEW_LINE prefix = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT while True : NEW_LINE INDENT dupeIndices = [ ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ans [ i ] == ans [ j ] : NEW_LINE INDENT dupeIndices . append ( j ) NEW_LINE DEDENT DEDENT if not dupeIndices : NEW_LINE INDENT break NEW_LINE DEDENT dupeIndices . append ( i ) NEW_LINE for index in dupeIndices : NEW_LINE INDENT prefix [ index ] += 1 NEW_LINE ans [ index ] = getAbbrev ( words [ index ] , prefix [ index ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def __init__ ( self , w : List [ int ] ) : NEW_LINE INDENT self . prefix = list ( itertools . accumulate ( w ) ) NEW_LINE DEDENT def pickIndex ( self ) -> int : NEW_LINE INDENT target = randint ( 0 , self . prefix [ - 1 ] - 1 ) NEW_LINE l = 0 NEW_LINE r = len ( self . prefix ) NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if self . prefix [ m ] > target : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def updateBoard ( self , board : List [ List [ str ] ] , click : List [ int ] ) -> List [ List [ str ] ] : NEW_LINE INDENT if board [ click [ 0 ] ] [ click [ 1 ] ] == ' M ' : NEW_LINE INDENT board [ click [ 0 ] ] [ click [ 1 ] ] = ' X ' NEW_LINE return board NEW_LINE DEDENT dirs = [ ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , - 1 ) , ( 0 , 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) ] NEW_LINE def getMinesCount ( i : int , j : int ) -> int : NEW_LINE INDENT minesCount = 0 NEW_LINE for dx , dy in dirs : NEW_LINE INDENT x = i + dx NEW_LINE y = j + dy NEW_LINE if x < 0 or x == len ( board ) or y < 0 or y == len ( board [ 0 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT if board [ x ] [ y ] == ' M ' : NEW_LINE INDENT minesCount += 1 NEW_LINE DEDENT DEDENT return minesCount NEW_LINE DEDENT def dfs ( i : int , j : int ) -> None : NEW_LINE INDENT if i < 0 or i == len ( board ) or j < 0 or j == len ( board [ 0 ] ) : NEW_LINE INDENT return NEW_LINE DEDENT if board [ i ] [ j ] != ' E ' : NEW_LINE INDENT return NEW_LINE DEDENT minesCount = getMinesCount ( i , j ) NEW_LINE board [ i ] [ j ] = ' B ' if minesCount == 0 else str ( minesCount ) NEW_LINE if minesCount == 0 : NEW_LINE INDENT for dx , dy in dirs : NEW_LINE INDENT dfs ( i + dx , j + dy ) NEW_LINE DEDENT DEDENT DEDENT dfs ( click [ 0 ] , click [ 1 ] ) NEW_LINE return board NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxSubArray ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = - math . inf NEW_LINE summ = 0 NEW_LINE for num in nums : NEW_LINE INDENT summ += num NEW_LINE ans = max ( ans , summ ) NEW_LINE summ = max ( summ , 0 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findLonelyPixel ( self , picture : List [ List [ str ] ] ) -> int : NEW_LINE INDENT m = len ( picture ) NEW_LINE n = len ( picture [ 0 ] ) NEW_LINE ans = 0 NEW_LINE rows = [ 0 ] * m NEW_LINE cols = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if picture [ i ] [ j ] == ' B ' : NEW_LINE INDENT rows [ i ] += 1 NEW_LINE cols [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if rows [ i ] == 1 : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if picture [ i ] [ j ] == ' B ' : NEW_LINE INDENT if cols [ j ] == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findPairs ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE numToIndex = { num : i for i , num in enumerate ( nums ) } NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT target = num + k NEW_LINE if target in numToIndex and numToIndex [ target ] != i : NEW_LINE INDENT ans += 1 NEW_LINE del numToIndex [ target ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findBlackPixel ( self , picture : List [ List [ str ] ] , target : int ) -> int : NEW_LINE INDENT m = len ( picture ) NEW_LINE n = len ( picture [ 0 ] ) NEW_LINE ans = 0 NEW_LINE rows = [ row . count ( ' B ' ) for row in picture ] NEW_LINE cols = [ col . count ( ' B ' ) for col in zip ( * picture ) ] NEW_LINE rowStrings = [ ' ' . join ( row ) for row in picture ] NEW_LINE countRowStrings = Counter ( rowStrings ) NEW_LINE for i , ( row , stringRow ) in enumerate ( zip ( rows , rowStrings ) ) : NEW_LINE INDENT if row == target and countRowStrings [ stringRow ] == target : NEW_LINE INDENT for j , col in enumerate ( cols ) : NEW_LINE INDENT if picture [ i ] [ j ] == ' B ' and col == target : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Codec : NEW_LINE INDENT alphabets = string . ascii_letters + '0123456789' NEW_LINE urlToCode = { } NEW_LINE codeToUrl = { } NEW_LINE def encode ( self , longUrl : str ) -> str : NEW_LINE INDENT while longUrl not in self . urlToCode : NEW_LINE INDENT code = ' ' . join ( random . choice ( self . alphabets ) for _ in range ( 6 ) ) NEW_LINE if code not in self . codeToUrl : NEW_LINE INDENT self . codeToUrl [ code ] = longUrl NEW_LINE self . urlToCode [ longUrl ] = code NEW_LINE DEDENT DEDENT return ' http : / / tinyurl . com / ' + self . urlToCode [ longUrl ] NEW_LINE DEDENT def decode ( self , shortUrl : str ) -> str : NEW_LINE INDENT return self . codeToUrl [ shortUrl [ - 6 : ] ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def complexNumberMultiply ( self , a : str , b : str ) -> str : NEW_LINE INDENT def getRealAndImag ( s : str ) -> tuple : NEW_LINE INDENT return int ( s [ : s . index ( ' + ' ) ] ) , int ( s [ s . index ( ' + ' ) + 1 : - 1 ] ) NEW_LINE DEDENT A , B = getRealAndImag ( a ) NEW_LINE C , D = getRealAndImag ( b ) NEW_LINE return str ( A * C - B * D ) + ' + ' + str ( A * D + B * C ) + ' i ' NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def convertBST ( self , root : Optional [ TreeNode ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT prefix = 0 NEW_LINE def reversedInorder ( root : Optional [ TreeNode ] ) -> None : NEW_LINE INDENT nonlocal prefix NEW_LINE if not root : NEW_LINE INDENT return NEW_LINE DEDENT reversedInorder ( root . right ) NEW_LINE prefix += root . val NEW_LINE root . val = prefix NEW_LINE reversedInorder ( root . left ) NEW_LINE DEDENT reversedInorder ( root ) NEW_LINE return root NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMinDifference ( self , timePoints : List [ str ] ) -> int : NEW_LINE INDENT ans = 24 * 60 NEW_LINE nums = sorted ( [ int ( timePoint [ : 2 ] ) * 60 + int ( timePoint [ 3 : ] ) for timePoint in timePoints ] ) NEW_LINE for a , b in zip ( nums , nums [ 1 : ] ) : NEW_LINE INDENT ans = min ( ans , b - a ) NEW_LINE DEDENT return min ( ans , 24 * 60 - nums [ - 1 ] + nums [ 0 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def spiralOrder ( self , matrix : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT if not matrix : NEW_LINE INDENT return [ ] NEW_LINE DEDENT m = len ( matrix ) NEW_LINE n = len ( matrix [ 0 ] ) NEW_LINE ans = [ ] NEW_LINE r1 = 0 NEW_LINE c1 = 0 NEW_LINE r2 = m - 1 NEW_LINE c2 = n - 1 NEW_LINE while len ( ans ) < m * n : NEW_LINE INDENT j = c1 NEW_LINE while j <= c2 and len ( ans ) < m * n : NEW_LINE INDENT ans . append ( matrix [ r1 ] [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT i = r1 + 1 NEW_LINE while i <= r2 - 1 and len ( ans ) < m * n : NEW_LINE INDENT ans . append ( matrix [ i ] [ c2 ] ) NEW_LINE i += 1 NEW_LINE DEDENT j = c2 NEW_LINE while j >= c1 and len ( ans ) < m * n : NEW_LINE INDENT ans . append ( matrix [ r2 ] [ j ] ) NEW_LINE j -= 1 NEW_LINE DEDENT i = r2 - 1 NEW_LINE while i >= r1 + 1 and len ( ans ) < m * n : NEW_LINE INDENT ans . append ( matrix [ i ] [ c1 ] ) NEW_LINE i -= 1 NEW_LINE DEDENT r1 += 1 NEW_LINE c1 += 1 NEW_LINE r2 -= 1 NEW_LINE c2 -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def singleNonDuplicate ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT l = 0 NEW_LINE r = len ( nums ) - 1 NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if m % 2 == 1 : NEW_LINE INDENT m -= 1 NEW_LINE DEDENT if nums [ m ] == nums [ m + 1 ] : NEW_LINE INDENT l = m + 2 NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return nums [ l ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reverseStr ( self , s : str , k : int ) -> str : NEW_LINE INDENT return s [ : k ] [ : : - 1 ] + s [ k : 2 * k ] + self . reverseStr ( s [ 2 * k : ] , k ) if s else " " NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def updateMatrix ( self , mat : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT m = len ( mat ) NEW_LINE n = len ( mat [ 0 ] ) NEW_LINE dirs = [ 0 , 1 , 0 , - 1 , 0 ] NEW_LINE q = deque ( ) NEW_LINE seen = [ [ False ] * n for _ in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] == 0 : NEW_LINE INDENT q . append ( ( i , j ) ) NEW_LINE seen [ i ] [ j ] = True NEW_LINE DEDENT DEDENT DEDENT while q : NEW_LINE INDENT i , j = q . popleft ( ) NEW_LINE for k in range ( 4 ) : NEW_LINE INDENT x = i + dirs [ k ] NEW_LINE y = j + dirs [ k + 1 ] NEW_LINE if x < 0 or x == m or y < 0 or y == n : NEW_LINE INDENT continue NEW_LINE DEDENT if seen [ x ] [ y ] : NEW_LINE INDENT continue NEW_LINE DEDENT mat [ x ] [ y ] = mat [ i ] [ j ] + 1 NEW_LINE q . append ( ( x , y ) ) NEW_LINE seen [ x ] [ y ] = True NEW_LINE DEDENT DEDENT return mat NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def diameterOfBinaryTree ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE def maxDepth ( root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT nonlocal ans NEW_LINE if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = maxDepth ( root . left ) NEW_LINE r = maxDepth ( root . right ) NEW_LINE ans = max ( ans , l + r ) NEW_LINE return 1 + max ( l , r ) NEW_LINE DEDENT maxDepth ( root ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findContestMatch ( self , n : int ) -> str : NEW_LINE INDENT def generateMatches ( matches : List [ str ] ) -> str : NEW_LINE INDENT if len ( matches ) == 1 : NEW_LINE INDENT return matches [ 0 ] NEW_LINE DEDENT nextMatches = [ ] NEW_LINE for i in range ( len ( matches ) // 2 ) : NEW_LINE INDENT nextMatches . append ( ' ( ' + matches [ i ] + ' , ' + matches [ len ( matches ) - 1 - i ] + ' ) ' ) NEW_LINE DEDENT return generateMatches ( nextMatches ) NEW_LINE DEDENT return generateMatches ( [ str ( i + 1 ) for i in range ( n ) ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def boundaryOfBinaryTree ( self , root : Optional [ TreeNode ] ) -> List [ int ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return [ ] NEW_LINE DEDENT ans = [ root . val ] NEW_LINE def dfs ( root : Optional [ TreeNode ] , lb : bool , rb : bool ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT if lb : NEW_LINE INDENT ans . append ( root . val ) NEW_LINE DEDENT if not lb and not rb and not root . left and not root . right : NEW_LINE INDENT ans . append ( root . val ) NEW_LINE DEDENT dfs ( root . left , lb , rb and not root . right ) NEW_LINE dfs ( root . right , lb and not root . left , rb ) NEW_LINE if rb : NEW_LINE INDENT ans . append ( root . val ) NEW_LINE DEDENT DEDENT dfs ( root . left , True , False ) NEW_LINE dfs ( root . right , False , True ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeBoxes ( self , boxes : List [ int ] ) -> int : NEW_LINE INDENT @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int , j : int , k : int ) -> int : NEW_LINE INDENT if i > j : NEW_LINE INDENT return 0 NEW_LINE DEDENT r = j NEW_LINE sameBoxes = k + 1 NEW_LINE while r > 0 and boxes [ r - 1 ] == boxes [ r ] : NEW_LINE INDENT r -= 1 NEW_LINE sameBoxes += 1 NEW_LINE DEDENT ans = dp ( i , r - 1 , 0 ) + sameBoxes * sameBoxes NEW_LINE for p in range ( i , r ) : NEW_LINE INDENT if boxes [ p ] == boxes [ r ] : NEW_LINE INDENT ans = max ( ans , dp ( i , p , sameBoxes ) + dp ( p + 1 , r - 1 , 0 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT return dp ( 0 , len ( boxes ) - 1 , 0 ) NEW_LINE DEDENT DEDENT
class UnionFind : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . count = n NEW_LINE self . id = list ( range ( n ) ) NEW_LINE DEDENT def union ( self , u : int , v : int ) -> None : NEW_LINE INDENT i = self . find ( u ) NEW_LINE j = self . find ( v ) NEW_LINE if i == j : NEW_LINE INDENT return NEW_LINE DEDENT self . id [ i ] = j NEW_LINE self . count -= 1 NEW_LINE DEDENT def find ( self , u : int ) -> int : NEW_LINE INDENT if self . id [ u ] != u : NEW_LINE INDENT self . id [ u ] = self . find ( self . id [ u ] ) NEW_LINE DEDENT return self . id [ u ] NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def findCircleNum ( self , M : List [ List [ int ] ] ) -> int : NEW_LINE INDENT n = len ( M ) NEW_LINE uf = UnionFind ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if M [ i ] [ j ] == 1 : NEW_LINE INDENT uf . union ( i , j ) NEW_LINE DEDENT DEDENT DEDENT return uf . count NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canJump ( self , nums : List [ int ] ) -> bool : NEW_LINE INDENT i = 0 NEW_LINE reach = 0 NEW_LINE while i < len ( nums ) and i <= reach : NEW_LINE INDENT reach = max ( reach , i + nums [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return i == len ( nums ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkRecord ( self , s : str ) -> bool : NEW_LINE INDENT return s . count ( ' A ' ) <= 1 and ' LLL ' not in s NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkRecord ( self , n : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE dp = [ [ 0 ] * 3 for _ in range ( 2 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT prev = [ A [ : ] for A in dp ] NEW_LINE dp [ 0 ] [ 0 ] = ( prev [ 0 ] [ 0 ] + prev [ 0 ] [ 1 ] + prev [ 0 ] [ 2 ] ) % kMod NEW_LINE dp [ 0 ] [ 1 ] = prev [ 0 ] [ 0 ] NEW_LINE dp [ 0 ] [ 2 ] = prev [ 0 ] [ 1 ] NEW_LINE dp [ 1 ] [ 0 ] = ( prev [ 0 ] [ 0 ] + prev [ 0 ] [ 1 ] + prev [ 0 ] [ 2 ] + prev [ 1 ] [ 0 ] + prev [ 1 ] [ 1 ] + prev [ 1 ] [ 2 ] ) % kMod NEW_LINE dp [ 1 ] [ 1 ] = prev [ 1 ] [ 0 ] NEW_LINE dp [ 1 ] [ 2 ] = prev [ 1 ] [ 1 ] NEW_LINE DEDENT return ( sum ( dp [ 0 ] ) + sum ( dp [ 1 ] ) ) % kMod NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def optimalDivision ( self , nums : List [ int ] ) -> str : NEW_LINE INDENT ans = str ( nums [ 0 ] ) NEW_LINE if len ( nums ) == 1 : NEW_LINE INDENT return ans NEW_LINE DEDENT if len ( nums ) == 2 : NEW_LINE INDENT return ans + ' / ' + str ( nums [ 1 ] ) NEW_LINE DEDENT ans += ' / ( ' + str ( nums [ 1 ] ) NEW_LINE for i in range ( 2 , len ( nums ) ) : NEW_LINE INDENT ans += ' / ' + str ( nums [ i ] ) NEW_LINE DEDENT ans += ' ) ' NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def leastBricks ( self , wall : List [ List [ int ] ] ) -> int : NEW_LINE INDENT maxFreq = 0 NEW_LINE count = defaultdict ( int ) NEW_LINE for row in wall : NEW_LINE INDENT prefix = 0 NEW_LINE for i in range ( len ( row ) - 1 ) : NEW_LINE INDENT prefix += row [ i ] NEW_LINE count [ prefix ] += 1 NEW_LINE maxFreq = max ( maxFreq , count [ prefix ] ) NEW_LINE DEDENT DEDENT return len ( wall ) - maxFreq NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def splitLoopedString ( self , strs : List [ str ] ) -> str : NEW_LINE INDENT ans = ' ' NEW_LINE sortedStrs = [ max ( s , s [ : : - 1 ] ) for s in strs ] NEW_LINE for i , sortedStr in enumerate ( sortedStrs ) : NEW_LINE INDENT for s in ( sortedStr , sortedStr [ : : - 1 ] ) : NEW_LINE INDENT for j in range ( len ( s ) + 1 ) : NEW_LINE INDENT ans = max ( ans , s [ j : ] + ' ' . join ( sortedStrs [ i + 1 : ] + sortedStrs [ : i ] ) + s [ : j ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nextGreaterElement ( self , n : int ) -> int : NEW_LINE INDENT def nextPermutation ( s : List [ chr ] ) -> str : NEW_LINE INDENT i = len ( s ) - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if s [ i ] < s [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if i >= 0 : NEW_LINE INDENT for j in range ( len ( s ) - 1 , i , - 1 ) : NEW_LINE INDENT if s [ j ] > s [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT s [ i ] , s [ j ] = s [ j ] , s [ i ] NEW_LINE DEDENT reverse ( s , i + 1 , len ( s ) - 1 ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT def reverse ( s : List [ chr ] , l : int , r : int ) : NEW_LINE INDENT while l < r : NEW_LINE INDENT s [ l ] , s [ r ] = s [ r ] , s [ l ] NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT s = nextPermutation ( list ( str ( n ) ) ) NEW_LINE ans = int ( s ) NEW_LINE return - 1 if ans > 2 ** 31 - 1 or ans <= n else ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxDepth ( self , root : ' Node ' ) -> int : NEW_LINE INDENT if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT if not root . children : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 + max ( self . maxDepth ( child ) for child in root . children ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def merge ( self , intervals : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE for interval in sorted ( intervals ) : NEW_LINE INDENT if not ans or ans [ - 1 ] [ 1 ] < interval [ 0 ] : NEW_LINE INDENT ans . append ( interval ) NEW_LINE DEDENT else : NEW_LINE INDENT ans [ - 1 ] [ 1 ] = max ( ans [ - 1 ] [ 1 ] , interval [ 1 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def subarraySum ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prefix = 0 NEW_LINE count = Counter ( { 0 : 1 } ) NEW_LINE for num in nums : NEW_LINE INDENT prefix += num NEW_LINE ans += count [ prefix - k ] NEW_LINE count [ prefix ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def arrayPairSum ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT return sum ( sorted ( nums ) [ : : 2 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestLine ( self , mat : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( mat ) NEW_LINE n = len ( mat [ 0 ] ) NEW_LINE ans = 0 NEW_LINE dp = [ [ [ 0 ] * 4 for j in range ( n ) ] for _ in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] == 1 : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = dp [ i ] [ j - 1 ] [ 0 ] + 1 if j > 0 else 1 NEW_LINE dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 1 ] + 1 if i > 0 else 1 NEW_LINE dp [ i ] [ j ] [ 2 ] = dp [ i - 1 ] [ j - 1 ] [ 2 ] + 1 if i > 0 and j > 0 else 1 NEW_LINE dp [ i ] [ j ] [ 3 ] = dp [ i - 1 ] [ j + 1 ] [ 3 ] + 1 if i > 0 and j < n - 1 else 1 NEW_LINE ans = max ( ans , max ( dp [ i ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findTilt ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE def summ ( root : Optional [ TreeNode ] ) -> None : NEW_LINE INDENT nonlocal ans NEW_LINE if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = summ ( root . left ) NEW_LINE r = summ ( root . right ) NEW_LINE ans += abs ( l - r ) NEW_LINE return root . val + l + r NEW_LINE DEDENT summ ( root ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nearestPalindromic ( self , n : str ) -> str : NEW_LINE INDENT def getPalindromes ( s : str ) -> tuple : NEW_LINE INDENT num = int ( s ) NEW_LINE k = len ( s ) NEW_LINE palindromes = [ ] NEW_LINE half = s [ 0 : ( k + 1 ) // 2 ] NEW_LINE reversedHalf = half [ : k // 2 ] [ : : - 1 ] NEW_LINE candidate = int ( half + reversedHalf ) NEW_LINE if candidate < num : NEW_LINE INDENT palindromes . append ( candidate ) NEW_LINE DEDENT else : NEW_LINE INDENT prevHalf = str ( int ( half ) - 1 ) NEW_LINE reversedPrevHalf = prevHalf [ : k // 2 ] [ : : - 1 ] NEW_LINE if k % 2 == 0 and int ( prevHalf ) == 0 : NEW_LINE INDENT palindromes . append ( 9 ) NEW_LINE DEDENT elif k % 2 == 0 and ( int ( prevHalf ) + 1 ) % 10 == 0 : NEW_LINE INDENT palindromes . append ( int ( prevHalf + '9' + reversedPrevHalf ) ) NEW_LINE DEDENT else : NEW_LINE INDENT palindromes . append ( int ( prevHalf + reversedPrevHalf ) ) NEW_LINE DEDENT DEDENT if candidate > num : NEW_LINE INDENT palindromes . append ( candidate ) NEW_LINE DEDENT else : NEW_LINE INDENT nextHalf = str ( int ( half ) + 1 ) NEW_LINE reversedNextHalf = nextHalf [ : k // 2 ] [ : : - 1 ] NEW_LINE palindromes . append ( int ( nextHalf + reversedNextHalf ) ) NEW_LINE DEDENT return palindromes NEW_LINE DEDENT prevPalindrome , nextPalindrome = getPalindromes ( n ) NEW_LINE return str ( prevPalindrome ) if abs ( prevPalindrome - int ( n ) ) <= abs ( nextPalindrome - int ( n ) ) else str ( nextPalindrome ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def arrayNesting ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for num in nums : NEW_LINE INDENT if num == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT index = num NEW_LINE count = 0 NEW_LINE while nums [ index ] != - 1 : NEW_LINE INDENT temp = index NEW_LINE index = nums [ index ] NEW_LINE nums [ temp ] = - 1 NEW_LINE count += 1 NEW_LINE DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def matrixReshape ( self , nums : List [ List [ int ] ] , r : int , c : int ) -> List [ List [ int ] ] : NEW_LINE INDENT if nums == [ ] or r * c != len ( nums ) * len ( nums [ 0 ] ) : NEW_LINE INDENT return nums NEW_LINE DEDENT ans = [ [ 0 for j in range ( c ) ] for i in range ( r ) ] NEW_LINE k = 0 NEW_LINE for row in nums : NEW_LINE INDENT for num in row : NEW_LINE INDENT ans [ k // c ] [ k % c ] = num NEW_LINE k += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def insert ( self , intervals : List [ List [ int ] ] , newInterval : List [ int ] ) -> List [ List [ int ] ] : NEW_LINE INDENT n = len ( intervals ) NEW_LINE ans = [ ] NEW_LINE i = 0 NEW_LINE while i < n and intervals [ i ] [ 1 ] < newInterval [ 0 ] : NEW_LINE INDENT ans . append ( intervals [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT while i < n and intervals [ i ] [ 0 ] <= newInterval [ 1 ] : NEW_LINE INDENT newInterval [ 0 ] = min ( newInterval [ 0 ] , intervals [ i ] [ 0 ] ) NEW_LINE newInterval [ 1 ] = max ( newInterval [ 1 ] , intervals [ i ] [ 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT ans . append ( newInterval ) NEW_LINE while i < n : NEW_LINE INDENT ans . append ( intervals [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minDistance ( self , height : int , width : int , tree : List [ int ] , squirrel : List [ int ] , nuts : List [ List [ int ] ] ) -> int : NEW_LINE INDENT def dist ( a : List [ int ] , b : List [ int ] ) -> int : NEW_LINE INDENT return abs ( a [ 0 ] - b [ 0 ] ) + abs ( a [ 1 ] - b [ 1 ] ) NEW_LINE DEDENT totDist = sum ( dist ( nut , tree ) for nut in nuts ) * 2 NEW_LINE maxSave = max ( dist ( nut , tree ) - dist ( nut , squirrel ) for nut in nuts ) NEW_LINE return totDist - maxSave NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def distributeCandies ( self , candies : List [ int ] ) -> int : NEW_LINE INDENT return min ( len ( candies ) // 2 , len ( set ( candies ) ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def lengthOfLastWord ( self , s : str ) -> int : NEW_LINE INDENT i = len ( s ) - 1 NEW_LINE while i >= 0 and s [ i ] == ' ▁ ' : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT lastIndex = i NEW_LINE while i >= 0 and s [ i ] != ' ▁ ' : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT return lastIndex - i NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findUnsortedSubarray ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT mini = math . inf NEW_LINE maxi = - math . inf NEW_LINE flag = False NEW_LINE for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT if nums [ i ] < nums [ i - 1 ] : NEW_LINE INDENT flag = True NEW_LINE DEDENT if flag : NEW_LINE INDENT mini = min ( mini , nums [ i ] ) NEW_LINE DEDENT DEDENT flag = False NEW_LINE for i in reversed ( range ( len ( nums ) - 1 ) ) : NEW_LINE INDENT if nums [ i ] > nums [ i + 1 ] : NEW_LINE INDENT flag = True NEW_LINE DEDENT if flag : NEW_LINE INDENT maxi = max ( maxi , nums [ i ] ) NEW_LINE DEDENT DEDENT for l in range ( len ( nums ) ) : NEW_LINE INDENT if nums [ l ] > mini : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for r , num in reversed ( list ( enumerate ( nums ) ) ) : NEW_LINE INDENT if num < maxi : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return 0 if l >= r else r - l + 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def killProcess ( self , pid : List [ int ] , ppid : List [ int ] , kill : int ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE tree = defaultdict ( list ) NEW_LINE for v , u in zip ( pid , ppid ) : NEW_LINE INDENT if u == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT tree [ u ] . append ( v ) NEW_LINE DEDENT def dfs ( u : int ) -> None : NEW_LINE INDENT ans . append ( u ) NEW_LINE for v in tree . get ( u , [ ] ) : NEW_LINE INDENT dfs ( v ) NEW_LINE DEDENT DEDENT dfs ( kill ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minDistance ( self , word1 : str , word2 : str ) -> int : NEW_LINE INDENT m = len ( word1 ) NEW_LINE n = len ( word2 ) NEW_LINE dp = [ 0 ] * ( n + 1 ) NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT dp [ j ] = j NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT newDp = [ i ] + [ 0 ] * n NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if word1 [ i - 1 ] == word2 [ j - 1 ] : NEW_LINE INDENT newDp [ j ] = dp [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT newDp [ j ] = min ( newDp [ j - 1 ] , dp [ j ] ) + 1 NEW_LINE DEDENT DEDENT dp = newDp NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def outerTrees ( self , trees : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT hull = [ ] NEW_LINE trees . sort ( key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) NEW_LINE def cross ( p : List [ int ] , q : List [ int ] , r : List [ int ] ) -> int : NEW_LINE INDENT return ( q [ 1 ] - p [ 1 ] ) * ( r [ 0 ] - q [ 0 ] ) - ( q [ 0 ] - p [ 0 ] ) * ( r [ 1 ] - q [ 1 ] ) NEW_LINE DEDENT for tree in trees : NEW_LINE INDENT while len ( hull ) > 1 and cross ( hull [ - 1 ] , hull [ - 2 ] , tree ) > 0 : NEW_LINE INDENT hull . pop ( ) NEW_LINE DEDENT hull . append ( tuple ( tree ) ) NEW_LINE DEDENT hull . pop ( ) NEW_LINE for tree in reversed ( trees ) : NEW_LINE INDENT while len ( hull ) > 1 and cross ( hull [ - 1 ] , hull [ - 2 ] , tree ) > 0 : NEW_LINE INDENT hull . pop ( ) NEW_LINE DEDENT hull . append ( tuple ( tree ) ) NEW_LINE DEDENT return list ( set ( hull ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def generateMatrix ( self , n : int ) -> List [ List [ int ] ] : NEW_LINE INDENT ans = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE count = 1 NEW_LINE for min in range ( n // 2 ) : NEW_LINE INDENT max = n - min - 1 NEW_LINE for i in range ( min , max ) : NEW_LINE INDENT ans [ min ] [ i ] = count NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( min , max ) : NEW_LINE INDENT ans [ i ] [ max ] = count NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( max , min , - 1 ) : NEW_LINE INDENT ans [ max ] [ i ] = count NEW_LINE count += 1 NEW_LINE DEDENT for i in range ( max , min , - 1 ) : NEW_LINE INDENT ans [ i ] [ min ] = count NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if n & 1 : NEW_LINE INDENT ans [ n // 2 ] [ n // 2 ] = count NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isValid ( self , code : str ) -> bool : NEW_LINE INDENT if code [ 0 ] != ' < ' or code [ - 1 ] != ' > ' : NEW_LINE INDENT return False NEW_LINE DEDENT containsTag = False NEW_LINE stack = [ ] NEW_LINE def isValidCdata ( s : str ) -> bool : NEW_LINE INDENT return s . find ( ' [ CDATA [ ' ) == 0 NEW_LINE DEDENT def isValidTagName ( tagName : str , isEndTag : bool ) -> bool : NEW_LINE INDENT nonlocal containsTag NEW_LINE if not tagName or len ( tagName ) > 9 : NEW_LINE INDENT return False NEW_LINE DEDENT if any ( not c . isupper ( ) for c in tagName ) : NEW_LINE INDENT return False NEW_LINE DEDENT if isEndTag : NEW_LINE INDENT return stack and stack . pop ( ) == tagName NEW_LINE DEDENT containsTag = True NEW_LINE stack . append ( tagName ) NEW_LINE return True NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( code ) : NEW_LINE INDENT if not stack and containsTag : NEW_LINE INDENT return False NEW_LINE DEDENT if code [ i ] == ' < ' : NEW_LINE INDENT if stack and code [ i + 1 ] == ' ! ' : NEW_LINE INDENT closeIndex = code . find ( ' ] ] > ' , i + 2 ) NEW_LINE if closeIndex == - 1 or not isValidCdata ( code [ i + 2 : closeIndex ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif code [ i + 1 ] == ' / ' : NEW_LINE INDENT closeIndex = code . find ( ' > ' , i + 2 ) NEW_LINE if closeIndex == - 1 or not isValidTagName ( code [ i + 2 : closeIndex ] , True ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT closeIndex = code . find ( ' > ' , i + 1 ) NEW_LINE if closeIndex == - 1 or not isValidTagName ( code [ i + 1 : closeIndex ] , False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT i = closeIndex NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return not stack and containsTag NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def fractionAddition ( self , expression : str ) -> str : NEW_LINE INDENT ints = list ( map ( int , re . findall ( ' [ + - ] ? [0-9 ] + ' , expression ) ) ) NEW_LINE A = 0 NEW_LINE B = 1 NEW_LINE for a , b in zip ( ints [ : : 2 ] , ints [ 1 : : 2 ] ) : NEW_LINE INDENT A = A * b + a * B NEW_LINE B *= b NEW_LINE g = math . gcd ( A , B ) NEW_LINE A //= g NEW_LINE B //= g NEW_LINE DEDENT return str ( A ) + ' / ' + str ( B ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def validSquare ( self , p1 : List [ int ] , p2 : List [ int ] , p3 : List [ int ] , p4 : List [ int ] ) -> bool : NEW_LINE INDENT def dist ( p1 : List [ int ] , p2 : List [ int ] ) -> int : NEW_LINE INDENT return ( p1 [ 0 ] - p2 [ 0 ] ) ** 2 + ( p1 [ 1 ] - p2 [ 1 ] ) ** 2 NEW_LINE DEDENT distSet = set ( [ dist ( * pair ) for pair in list ( itertools . combinations ( [ p1 , p2 , p3 , p4 ] , 2 ) ) ] ) NEW_LINE return 0 not in distSet and len ( distSet ) == 2 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findLHS ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = Counter ( nums ) NEW_LINE for num , freq in count . items ( ) : NEW_LINE INDENT if num + 1 in count : NEW_LINE INDENT ans = max ( ans , freq + count [ num + 1 ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxCount ( self , m : int , n : int , ops : List [ List [ int ] ] ) -> int : NEW_LINE INDENT minY = m NEW_LINE minX = n NEW_LINE for y , x in ops : NEW_LINE INDENT minY = min ( minY , y ) NEW_LINE minX = min ( minX , x ) NEW_LINE DEDENT return minX * minY NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findRestaurant ( self , list1 : List [ str ] , list2 : List [ str ] ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE restaurantToIndex = { restaurant : i for i , restaurant in enumerate ( list1 ) } NEW_LINE minSum = math . inf NEW_LINE for i , restaurant in enumerate ( list2 ) : NEW_LINE INDENT if restaurant in restaurantToIndex : NEW_LINE INDENT summ = restaurantToIndex [ restaurant ] + i NEW_LINE if summ < minSum : NEW_LINE INDENT ans . clear ( ) NEW_LINE DEDENT if summ <= minSum : NEW_LINE INDENT ans . append ( restaurant ) NEW_LINE minSum = summ NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def convert ( self , s : str , numRows : int ) -> str : NEW_LINE INDENT rows = [ ' ' ] * numRows NEW_LINE k = 0 NEW_LINE direction = ( numRows == 1 ) - 1 NEW_LINE for c in s : NEW_LINE INDENT rows [ k ] += c NEW_LINE if k == 0 or k == numRows - 1 : NEW_LINE INDENT direction *= - 1 NEW_LINE DEDENT k += direction NEW_LINE DEDENT return ' ' . join ( rows ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getPermutation ( self , n : int , k : int ) -> str : NEW_LINE INDENT ans = ' ' NEW_LINE nums = [ i + 1 for i in range ( n ) ] NEW_LINE factorial = [ 1 ] * ( n + 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT factorial [ i ] = factorial [ i - 1 ] * i NEW_LINE DEDENT k -= 1 NEW_LINE for i in reversed ( range ( n ) ) : NEW_LINE INDENT j = k // factorial [ i ] NEW_LINE k %= factorial [ i ] NEW_LINE ans += str ( nums [ j ] ) NEW_LINE nums . pop ( j ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class StringIterator : NEW_LINE INDENT def __init__ ( self , compressedString : str ) : NEW_LINE INDENT self . s = compressedString NEW_LINE self . i = 0 NEW_LINE self . num = 0 NEW_LINE self . currentChar = ' ▁ ' NEW_LINE DEDENT def next ( self ) -> str : NEW_LINE INDENT if not self . hasNext ( ) : NEW_LINE INDENT return ' ▁ ' NEW_LINE DEDENT if self . num == 0 : NEW_LINE INDENT self . currentChar = self . s [ self . i ] NEW_LINE self . i += 1 NEW_LINE while self . i < len ( self . s ) and self . s [ self . i ] . isdigit ( ) : NEW_LINE INDENT self . num = self . num * 10 + ( ord ( self . s [ self . i ] ) - ord ( '0' ) ) NEW_LINE self . i += 1 NEW_LINE DEDENT DEDENT self . num -= 1 NEW_LINE return self . currentChar NEW_LINE DEDENT def hasNext ( self ) -> bool : NEW_LINE INDENT return self . i < len ( self . s ) or self . num > 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def canPlaceFlowers ( self , flowerbed : List [ int ] , n : int ) -> bool : NEW_LINE INDENT for i , flower in enumerate ( flowerbed ) : NEW_LINE INDENT if flower == 0 and ( i == 0 or flowerbed [ i - 1 ] == 0 ) and ( i == len ( flowerbed ) - 1 or flowerbed [ i + 1 ] == 0 ) : NEW_LINE INDENT flowerbed [ i ] = 1 NEW_LINE n -= 1 NEW_LINE DEDENT if n <= 0 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def tree2str ( self , t : Optional [ TreeNode ] ) -> str : NEW_LINE INDENT def dfs ( root : Optional [ TreeNode ] ) -> str : NEW_LINE INDENT if not root : NEW_LINE INDENT return ' ' NEW_LINE DEDENT if root . right : NEW_LINE INDENT return str ( root . val ) + ' ( ' + dfs ( root . left ) + ' ) ( ' + dfs ( root . right ) + ' ) ' NEW_LINE DEDENT if root . left : NEW_LINE INDENT return str ( root . val ) + ' ( ' + dfs ( root . left ) + ' ) ' NEW_LINE DEDENT return str ( root . val ) NEW_LINE DEDENT return dfs ( t ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findDuplicate ( self , paths : List [ str ] ) -> List [ List [ str ] ] : NEW_LINE INDENT contentToPathFiles = defaultdict ( list ) NEW_LINE for path in paths : NEW_LINE INDENT words = path . split ( ' ▁ ' ) NEW_LINE rootPath = words [ 0 ] NEW_LINE for fileAndContent in words [ 1 : ] : NEW_LINE INDENT l = fileAndContent . find ( ' ( ' ) NEW_LINE r = fileAndContent . find ( ' ) ' ) NEW_LINE file = fileAndContent [ : l ] NEW_LINE content = fileAndContent [ l + 1 : r ] NEW_LINE filePath = rootPath + ' / ' + file NEW_LINE contentToPathFiles [ content ] . append ( filePath ) NEW_LINE DEDENT DEDENT return [ filePath for filePath in contentToPathFiles . values ( ) if len ( filePath ) > 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def rotateRight ( self , head : ListNode , k : int ) -> ListNode : NEW_LINE INDENT if not head or not head . next or k == 0 : NEW_LINE INDENT return head NEW_LINE DEDENT tail = head NEW_LINE length = 1 NEW_LINE while tail . next : NEW_LINE INDENT tail = tail . next NEW_LINE length += 1 NEW_LINE DEDENT tail . next = head NEW_LINE t = length - k % length NEW_LINE for _ in range ( t ) : NEW_LINE INDENT tail = tail . next NEW_LINE DEDENT newHead = tail . next NEW_LINE tail . next = None NEW_LINE return newHead NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def triangleNumber ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE nums . sort ( ) NEW_LINE for k in range ( len ( nums ) - 1 , 1 , - 1 ) : NEW_LINE INDENT i = 0 NEW_LINE j = k - 1 NEW_LINE while i < j : NEW_LINE INDENT if nums [ i ] + nums [ j ] > nums [ k ] : NEW_LINE INDENT ans += j - i NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def addBoldTag ( self , s : str , words : List [ str ] ) -> str : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = [ ] NEW_LINE bold = [ 0 ] * n NEW_LINE boldEnd = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for word in words : NEW_LINE INDENT if s [ i : ] . startswith ( word ) : NEW_LINE INDENT boldEnd = max ( boldEnd , i + len ( word ) ) NEW_LINE DEDENT DEDENT bold [ i ] = boldEnd > i NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if bold [ i ] : NEW_LINE INDENT j = i NEW_LINE while j < n and bold [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans . append ( ' < b > ' + s [ i : j ] + ' < / b > ' ) NEW_LINE i = j NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( s [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mergeTrees ( self , root1 : Optional [ TreeNode ] , root2 : Optional [ TreeNode ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT if not root1 and not root2 : NEW_LINE INDENT return None NEW_LINE DEDENT val = ( root1 . val if root1 else 0 ) + ( root2 . val if root2 else 0 ) NEW_LINE root = TreeNode ( val ) NEW_LINE root . left = self . mergeTrees ( root1 . left if root1 else None , root2 . left if root2 else None ) NEW_LINE root . right = self . mergeTrees ( root1 . right if root1 else None , root2 . right if root2 else None ) NEW_LINE return root NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def uniquePaths ( self , m : int , n : int ) -> int : NEW_LINE INDENT dp = [ [ 1 ] * n for _ in range ( m ) ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ - 1 ] [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def leastInterval ( self , tasks : List [ str ] , n : int ) -> int : NEW_LINE INDENT count = Counter ( tasks ) NEW_LINE maxFreq = max ( count . values ( ) ) NEW_LINE maxFreqTaskOccupy = ( maxFreq - 1 ) * ( n + 1 ) NEW_LINE nMaxFreq = sum ( value == maxFreq for value in count . values ( ) ) NEW_LINE return max ( maxFreqTaskOccupy + nMaxFreq , len ( tasks ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxDistance ( self , arrays : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE mini = 10000 NEW_LINE maxi = - 10000 NEW_LINE for A in arrays : NEW_LINE INDENT ans = max ( ans , A [ - 1 ] - mini , maxi - A [ 0 ] ) NEW_LINE mini = min ( mini , A [ 0 ] ) NEW_LINE maxi = max ( maxi , A [ - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestFactorization ( self , num : int ) -> int : NEW_LINE INDENT if num == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE base = 1 NEW_LINE for i in range ( 9 , 1 , - 1 ) : NEW_LINE INDENT while num % i == 0 : NEW_LINE INDENT num //= i NEW_LINE ans = base * i + ans NEW_LINE base *= 10 NEW_LINE DEDENT DEDENT return ans if num == 1 and ans < 2 ** 31 - 1 else 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumProduct ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT nums . sort ( ) NEW_LINE return max ( nums [ - 1 ] * nums [ 0 ] * nums [ 1 ] , nums [ - 1 ] * nums [ - 2 ] * nums [ - 3 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def kInversePairs ( self , n : int , k : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE dp = [ [ 0 ] * ( k + 1 ) for _ in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] ) % kMod NEW_LINE if j - i >= 0 : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j ] - dp [ i - 1 ] [ j - i ] + kMod ) % kMod NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def uniquePathsWithObstacles ( self , obstacleGrid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( obstacleGrid ) NEW_LINE n = len ( obstacleGrid [ 0 ] ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE dp [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if obstacleGrid [ i - 1 ] [ j - 1 ] == 0 : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def scheduleCourse ( self , courses : List [ List [ int ] ] ) -> int : NEW_LINE INDENT time = 0 NEW_LINE maxHeap = [ ] NEW_LINE for duration , lastDay in sorted ( courses , key = lambda x : x [ 1 ] ) : NEW_LINE INDENT heapq . heappush ( maxHeap , - duration ) NEW_LINE time += duration NEW_LINE if time > lastDay : NEW_LINE INDENT time += heapq . heappop ( maxHeap ) NEW_LINE DEDENT DEDENT return len ( maxHeap ) NEW_LINE DEDENT DEDENT
class Cell : NEW_LINE INDENT def __init__ ( self , val : int , posCount : Optional [ Dict [ Tuple [ int , int ] , int ] ] ) : NEW_LINE INDENT self . val = val NEW_LINE self . posCount = posCount NEW_LINE DEDENT DEDENT class Excel : NEW_LINE INDENT def __init__ ( self , height : int , width : str ) : NEW_LINE INDENT self . sheet = [ [ Cell ( 0 , None ) for i in range ( height ) ] for _ in range ( ord ( width ) - ord ( ' A ' ) + 1 ) ] NEW_LINE DEDENT def set ( self , row : int , column : str , val : int ) -> None : NEW_LINE INDENT self . sheet [ row - 1 ] [ ord ( column ) - ord ( ' A ' ) ] = Cell ( val , None ) NEW_LINE DEDENT def get ( self , row : int , column : str ) -> int : NEW_LINE INDENT cell = self . sheet [ row - 1 ] [ ord ( column ) - ord ( ' A ' ) ] NEW_LINE if cell . posCount : NEW_LINE INDENT return sum ( self . get ( * pos ) * freq for pos , freq in cell . posCount . items ( ) ) NEW_LINE DEDENT return cell . val NEW_LINE DEDENT def sum ( self , row : int , column : str , numbers : List [ str ] ) -> int : NEW_LINE INDENT self . sheet [ row - 1 ] [ ord ( column ) - ord ( ' A ' ) ] . posCount = self . _parse ( numbers ) NEW_LINE return self . get ( row , column ) NEW_LINE DEDENT def _parse ( self , numbers : List [ str ] ) : NEW_LINE INDENT count = Counter ( ) NEW_LINE for n in numbers : NEW_LINE INDENT s , e = n . split ( ' : ' ) [ 0 ] , n . split ( ' : ' ) [ 1 ] if ' : ' in n else n NEW_LINE for i in range ( int ( s [ 1 : ] ) , int ( e [ 1 : ] ) + 1 ) : NEW_LINE INDENT for j in range ( ord ( s [ 0 ] ) - ord ( ' A ' ) , ord ( e [ 0 ] ) - ord ( ' A ' ) + 1 ) : NEW_LINE INDENT count [ ( i , chr ( j + ord ( ' A ' ) ) ) ] += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestRange ( self , nums : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT minHeap = [ ( row [ 0 ] , i , 0 ) for i , row in enumerate ( nums ) ] NEW_LINE heapq . heapify ( minHeap ) NEW_LINE maxRange = max ( row [ 0 ] for row in nums ) NEW_LINE minRange = heapq . nsmallest ( 1 , minHeap ) [ 0 ] [ 0 ] NEW_LINE ans = [ minRange , maxRange ] NEW_LINE while len ( minHeap ) == len ( nums ) : NEW_LINE INDENT num , r , c = heapq . heappop ( minHeap ) NEW_LINE if c + 1 < len ( nums [ r ] ) : NEW_LINE INDENT heapq . heappush ( minHeap , ( nums [ r ] [ c + 1 ] , r , c + 1 ) ) NEW_LINE maxRange = max ( maxRange , nums [ r ] [ c + 1 ] ) NEW_LINE minRange = heapq . nsmallest ( 1 , minHeap ) [ 0 ] [ 0 ] NEW_LINE if maxRange - minRange < ans [ 1 ] - ans [ 0 ] : NEW_LINE INDENT ans [ 0 ] , ans [ 1 ] = minRange , maxRange NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def judgeSquareSum ( self , c : int ) -> bool : NEW_LINE INDENT l = 0 NEW_LINE r = int ( sqrt ( c ) ) NEW_LINE while l <= r : NEW_LINE INDENT summ = l * l + r * r NEW_LINE if summ == c : NEW_LINE INDENT return True NEW_LINE DEDENT if summ < c : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findDerangement ( self , n : int ) -> int : NEW_LINE INDENT kMod = 1_000_000_007 NEW_LINE @ functools . lru_cache ( None ) NEW_LINE def dp ( i : int ) -> int : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if i == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( i - 1 ) * ( dp ( i - 1 ) + dp ( i - 2 ) ) % kMod NEW_LINE DEDENT return dp ( n ) NEW_LINE DEDENT DEDENT
class LogSystem : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . granularityToIndices = { ' Year ' : 4 , ' Month ' : 7 , ' Day ' : 10 , ' Hour ' : 13 , ' Minute ' : 16 , ' Second ' : 19 } NEW_LINE self . idAndTimestamps = [ ] NEW_LINE DEDENT def put ( self , id : int , timestamp : str ) -> None : NEW_LINE INDENT self . idAndTimestamps . append ( ( id , timestamp ) ) NEW_LINE DEDENT def retrieve ( self , start : str , end : str , granularity : str ) -> List [ int ] : NEW_LINE INDENT index = self . granularityToIndices [ granularity ] NEW_LINE s = start [ : index ] NEW_LINE e = end [ : index ] NEW_LINE return [ id for id , timestamp in self . idAndTimestamps if s <= timestamp [ : index ] <= e ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def shoppingOffers ( self , price : List [ int ] , special : List [ List [ int ] ] , needs : List [ int ] ) -> int : NEW_LINE INDENT def dfs ( s : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE for i , need in enumerate ( needs ) : NEW_LINE INDENT ans += need * price [ i ] NEW_LINE DEDENT for i in range ( s , len ( special ) ) : NEW_LINE INDENT offer = special [ i ] NEW_LINE if all ( offer [ j ] <= need for j , need in enumerate ( needs ) ) : NEW_LINE INDENT for j in range ( len ( needs ) ) : NEW_LINE INDENT needs [ j ] -= offer [ j ] NEW_LINE DEDENT ans = min ( ans , offer [ - 1 ] + dfs ( i ) ) NEW_LINE for j in range ( len ( needs ) ) : NEW_LINE INDENT needs [ j ] += offer [ j ] NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT return dfs ( 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minPathSum ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i > 0 and j > 0 : NEW_LINE INDENT grid [ i ] [ j ] += min ( grid [ i - 1 ] [ j ] , grid [ i ] [ j - 1 ] ) NEW_LINE DEDENT elif i > 0 : NEW_LINE INDENT grid [ i ] [ 0 ] += grid [ i - 1 ] [ 0 ] NEW_LINE DEDENT elif j > 0 : NEW_LINE INDENT grid [ 0 ] [ j ] += grid [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return grid [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def solveEquation ( self , equation : str ) -> str : NEW_LINE INDENT def calculate ( s : str ) -> tuple : NEW_LINE INDENT coefficient = 0 NEW_LINE constant = 0 NEW_LINE num = 0 NEW_LINE sign = 1 NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT if c . isdigit ( ) : NEW_LINE INDENT num = num * 10 + ord ( c ) - ord ( '0' ) NEW_LINE DEDENT elif c in ' + - ' : NEW_LINE INDENT constant += sign * num NEW_LINE sign = 1 if c == ' + ' else - 1 NEW_LINE num = 0 NEW_LINE DEDENT else : NEW_LINE INDENT if i > 0 and num == 0 and s [ i - 1 ] == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT coefficient += sign if num == 0 else sign * num NEW_LINE num = 0 NEW_LINE DEDENT DEDENT return coefficient , constant + sign * num NEW_LINE DEDENT lhsEquation , rhsEquation = equation . split ( ' = ' ) NEW_LINE lhsCoefficient , lhsConstant = calculate ( lhsEquation ) NEW_LINE rhsCoefficient , rhsConstant = calculate ( rhsEquation ) NEW_LINE coefficient = lhsCoefficient - rhsCoefficient NEW_LINE constant = rhsConstant - lhsConstant NEW_LINE if coefficient == 0 and constant == 0 : NEW_LINE INDENT return " Infinite ▁ solutions " NEW_LINE DEDENT if coefficient == 0 and constant != 0 : NEW_LINE INDENT return " No ▁ solution " NEW_LINE DEDENT return " x = " + str ( constant // coefficient ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMaxAverage ( self , nums : List [ int ] , k : int ) -> float : NEW_LINE INDENT summ = sum ( nums [ : k ] ) NEW_LINE ans = summ NEW_LINE for i in range ( k , len ( nums ) ) : NEW_LINE INDENT summ += nums [ i ] - nums [ i - k ] NEW_LINE ans = max ( ans , summ ) NEW_LINE DEDENT return ans / k NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMaxAverage ( self , nums : List [ int ] , k : int ) -> float : NEW_LINE INDENT kErr = 1e-5 NEW_LINE l = min ( nums ) NEW_LINE r = max ( nums ) NEW_LINE def check ( m : float ) -> bool : NEW_LINE INDENT summ = 0 NEW_LINE prevSum = 0 NEW_LINE minPrevSum = 0 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT summ += num - m NEW_LINE if i >= k : NEW_LINE INDENT prevSum += nums [ i - k ] - m NEW_LINE minPrevSum = min ( minPrevSum , prevSum ) NEW_LINE DEDENT if i + 1 >= k and summ >= minPrevSum : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT while r - l > kErr : NEW_LINE INDENT m = ( l + r ) / 2 NEW_LINE if check ( m ) : NEW_LINE INDENT l = m NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findErrorNums ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT for num in nums : NEW_LINE INDENT if nums [ abs ( num ) - 1 ] < 0 : NEW_LINE INDENT duplicate = abs ( num ) NEW_LINE DEDENT else : NEW_LINE INDENT nums [ abs ( num ) - 1 ] *= - 1 NEW_LINE DEDENT DEDENT for i , num in enumerate ( nums ) : NEW_LINE INDENT if num > 0 : NEW_LINE INDENT return [ duplicate , i + 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def findLongestChain ( self , pairs : List [ List [ int ] ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prevEnd = - math . inf NEW_LINE for s , e in sorted ( pairs , key = lambda x : x [ 1 ] ) : NEW_LINE INDENT if s > prevEnd : NEW_LINE INDENT ans += 1 NEW_LINE prevEnd = e NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countSubstrings ( self , s : str ) -> int : NEW_LINE INDENT def extendPalindromes ( l : int , r : int ) -> int : NEW_LINE INDENT count = 0 NEW_LINE while l >= 0 and r < len ( s ) and s [ l ] == s [ r ] : NEW_LINE INDENT count += 1 NEW_LINE l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT ans += extendPalindromes ( i , i ) NEW_LINE ans += extendPalindromes ( i , i + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . root = { } NEW_LINE DEDENT def insert ( self , word : str ) -> None : NEW_LINE INDENT node = self . root NEW_LINE for c in word : NEW_LINE INDENT if c not in node : NEW_LINE INDENT node [ c ] = { } NEW_LINE DEDENT node = node [ c ] NEW_LINE DEDENT node [ ' word ' ] = word NEW_LINE DEDENT def search ( self , word : str ) -> str : NEW_LINE INDENT node = self . root NEW_LINE for c in word : NEW_LINE INDENT if ' word ' in node : NEW_LINE INDENT return node [ ' word ' ] NEW_LINE DEDENT if c not in node : NEW_LINE INDENT return word NEW_LINE DEDENT node = node [ c ] NEW_LINE DEDENT return word NEW_LINE DEDENT def replaceWords ( self , dict : List [ str ] , sentence : str ) -> str : NEW_LINE INDENT for word in dict : NEW_LINE INDENT self . insert ( word ) NEW_LINE DEDENT words = sentence . split ( ' ▁ ' ) NEW_LINE return ' ▁ ' . join ( [ self . search ( word ) for word in words ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isNumber ( self , s : str ) -> bool : NEW_LINE INDENT s = s . strip ( ) NEW_LINE if not s : NEW_LINE INDENT return False NEW_LINE DEDENT seenNum = False NEW_LINE seenDot = False NEW_LINE seenE = False NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT if c == ' . ' : NEW_LINE INDENT if seenDot or seenE : NEW_LINE INDENT return False NEW_LINE DEDENT seenDot = True NEW_LINE DEDENT elif c == ' e ' or c == ' E ' : NEW_LINE INDENT if seenE or not seenNum : NEW_LINE INDENT return False NEW_LINE DEDENT seenE = True NEW_LINE seenNum = False NEW_LINE DEDENT elif c in ' + - ' : NEW_LINE INDENT if i > 0 and s [ i - 1 ] != ' e ' : NEW_LINE INDENT return False NEW_LINE DEDENT seenNum = False NEW_LINE DEDENT else : NEW_LINE INDENT if not c . isdigit ( ) : NEW_LINE INDENT return False NEW_LINE DEDENT seenNum = True NEW_LINE DEDENT DEDENT return seenNum NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minSteps ( self , n : int ) -> int : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ i for i in range ( n + 1 ) ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( i // 2 , 2 , - 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT dp [ i ] = dp [ j ] + i // j NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findDuplicateSubtrees ( self , root : Optional [ TreeNode ] ) -> List [ Optional [ TreeNode ] ] : NEW_LINE INDENT ans = [ ] NEW_LINE count = Counter ( ) NEW_LINE def encode ( root : Optional [ TreeNode ] ) -> str : NEW_LINE INDENT if not root : NEW_LINE INDENT return ' ' NEW_LINE DEDENT encoded = str ( root . val ) + ' # ' + encode ( root . left ) + ' # ' + encode ( root . right ) NEW_LINE count [ encoded ] += 1 NEW_LINE if count [ encoded ] == 2 : NEW_LINE INDENT ans . append ( root ) NEW_LINE DEDENT return encoded NEW_LINE DEDENT encode ( root ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class BSTIterator : NEW_LINE INDENT def __init__ ( self , root : Optional [ TreeNode ] , leftToRight : bool ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . leftToRight = leftToRight NEW_LINE self . pushUntilNone ( root ) NEW_LINE DEDENT def next ( self ) -> int : NEW_LINE INDENT node = self . stack . pop ( ) NEW_LINE if self . leftToRight : NEW_LINE INDENT self . pushUntilNone ( node . right ) NEW_LINE DEDENT else : NEW_LINE INDENT self . pushUntilNone ( node . left ) NEW_LINE DEDENT return node . val NEW_LINE DEDENT def pushUntilNone ( self , root : Optional [ TreeNode ] ) : NEW_LINE INDENT while root : NEW_LINE INDENT self . stack . append ( root ) NEW_LINE root = root . left if self . leftToRight else root . right NEW_LINE DEDENT DEDENT DEDENT class Solution : NEW_LINE INDENT def findTarget ( self , root : Optional [ TreeNode ] , k : int ) -> bool : NEW_LINE INDENT if not root : NEW_LINE INDENT return False NEW_LINE DEDENT left = BSTIterator ( root , True ) NEW_LINE right = BSTIterator ( root , False ) NEW_LINE l = left . next ( ) NEW_LINE r = right . next ( ) NEW_LINE while l < r : NEW_LINE INDENT summ = l + r NEW_LINE if summ == k : NEW_LINE INDENT return True NEW_LINE DEDENT if summ < k : NEW_LINE INDENT l = left . next ( ) NEW_LINE DEDENT else : NEW_LINE INDENT r = right . next ( ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def constructMaximumBinaryTree ( self , nums : List [ int ] ) -> Optional [ TreeNode ] : NEW_LINE INDENT def build ( i : int , j : int ) -> Optional [ TreeNode ] : NEW_LINE INDENT if i > j : NEW_LINE INDENT return None NEW_LINE DEDENT maxNum = max ( nums [ i : j + 1 ] ) NEW_LINE maxIndex = nums . index ( maxNum ) NEW_LINE root = TreeNode ( maxNum ) NEW_LINE root . left = build ( i , maxIndex - 1 ) NEW_LINE root . right = build ( maxIndex + 1 , j ) NEW_LINE return root NEW_LINE DEDENT return build ( 0 , len ( nums ) - 1 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def printTree ( self , root : Optional [ TreeNode ] ) -> List [ List [ str ] ] : NEW_LINE INDENT def maxHeight ( root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 + max ( maxHeight ( root . left ) , maxHeight ( root . right ) ) NEW_LINE DEDENT def dfs ( root : Optional [ TreeNode ] , row : int , left : int , right : int ) -> None : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT mid = ( left + right ) // 2 NEW_LINE ans [ row ] [ mid ] = str ( root . val ) NEW_LINE dfs ( root . left , row + 1 , left , mid - 1 ) NEW_LINE dfs ( root . right , row + 1 , mid + 1 , right ) NEW_LINE DEDENT m = maxHeight ( root ) NEW_LINE n = pow ( 2 , m ) - 1 NEW_LINE ans = [ [ ' ' ] * n for _ in range ( m ) ] NEW_LINE dfs ( root , 0 , 0 , len ( ans [ 0 ] ) - 1 ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def cheapestJump ( self , coins : List [ int ] , maxJump : int ) -> List [ int ] : NEW_LINE INDENT if coins [ - 1 ] == - 1 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT n = len ( coins ) NEW_LINE dp = [ math . inf ] * n NEW_LINE next = [ - 1 ] * n NEW_LINE def cheapestJump ( i : int ) -> int : NEW_LINE INDENT if i == len ( coins ) - 1 : NEW_LINE INDENT dp [ i ] = coins [ i ] NEW_LINE return dp [ i ] NEW_LINE DEDENT if dp [ i ] < math . inf : NEW_LINE INDENT return dp [ i ] NEW_LINE DEDENT if coins [ i ] == - 1 : NEW_LINE INDENT return math . inf NEW_LINE DEDENT for j in range ( i + 1 , min ( i + maxJump + 1 , n ) ) : NEW_LINE INDENT res = cheapestJump ( j ) NEW_LINE if res == math . inf : NEW_LINE INDENT continue NEW_LINE DEDENT cost = coins [ i ] + res NEW_LINE if cost < dp [ i ] : NEW_LINE INDENT dp [ i ] = cost NEW_LINE next [ i ] = j NEW_LINE DEDENT DEDENT return dp [ i ] NEW_LINE DEDENT cheapestJump ( 0 ) NEW_LINE if dp [ 0 ] == math . inf : NEW_LINE INDENT return [ ] NEW_LINE DEDENT return self . _constructPath ( next , 0 ) NEW_LINE DEDENT def _constructPath ( self , next : List [ int ] , i : int ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE while i != - 1 : NEW_LINE INDENT ans . append ( i + 1 ) NEW_LINE i = next [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def judgeCircle ( self , moves : str ) -> bool : NEW_LINE INDENT return moves . count ( ' R ' ) == moves . count ( ' L ' ) and moves . count ( ' U ' ) == moves . count ( ' D ' ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findClosestElements ( self , arr : List [ int ] , k : int , x : int ) -> List [ int ] : NEW_LINE INDENT l = 0 NEW_LINE r = len ( arr ) - k NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if x - arr [ m ] <= arr [ m + k ] - x : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return arr [ l : l + k ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def plusOne ( self , digits : List [ int ] ) -> List [ int ] : NEW_LINE INDENT for i , d in reversed ( list ( enumerate ( digits ) ) ) : NEW_LINE INDENT if d < 9 : NEW_LINE INDENT digits [ i ] += 1 NEW_LINE return digits NEW_LINE DEDENT digits [ i ] = 0 NEW_LINE DEDENT return [ 1 ] + digits NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def newInteger ( self , n : int ) -> int : NEW_LINE INDENT ans = [ ] NEW_LINE while n : NEW_LINE INDENT ans . append ( str ( n % 9 ) ) NEW_LINE n //= 9 NEW_LINE DEDENT return ' ' . join ( reversed ( ans ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def imageSmoother ( self , M : List [ List [ int ] ] ) -> List [ List [ int ] ] : NEW_LINE INDENT m = len ( M ) NEW_LINE n = len ( M [ 0 ] ) NEW_LINE ans = [ [ 0 for j in range ( n ) ] for i in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT ones = 0 NEW_LINE count = 0 NEW_LINE for y in range ( max ( 0 , i - 1 ) , min ( m , i + 2 ) ) : NEW_LINE INDENT for x in range ( max ( 0 , j - 1 ) , min ( n , j + 2 ) ) : NEW_LINE INDENT ones += M [ y ] [ x ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT ans [ i ] [ j ] = ones // count NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkEqualTree ( self , root : Optional [ TreeNode ] ) -> bool : NEW_LINE INDENT if not root : NEW_LINE INDENT return False NEW_LINE DEDENT seen = set ( ) NEW_LINE def dfs ( root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT summ = root . val + dfs ( root . left ) + dfs ( root . right ) NEW_LINE seen . add ( summ ) NEW_LINE return summ NEW_LINE DEDENT summ = root . val + dfs ( root . left ) + dfs ( root . right ) NEW_LINE return summ % 2 == 0 and summ // 2 in seen NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkPossibility ( self , nums : List [ int ] ) -> bool : NEW_LINE INDENT j = None NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT if nums [ i ] > nums [ i + 1 ] : NEW_LINE INDENT if j is not None : NEW_LINE INDENT return False NEW_LINE DEDENT j = i NEW_LINE DEDENT DEDENT return j is None or j == 0 or j == len ( nums ) - 2 or nums [ j - 1 ] <= nums [ j + 1 ] or nums [ j ] <= nums [ j + 2 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def pathSum ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE tree = [ [ - 1 ] * 8 for _ in range ( 4 ) ] NEW_LINE for num in nums : NEW_LINE INDENT d = num // 100 - 1 NEW_LINE p = ( num % 100 ) // 10 - 1 NEW_LINE v = num % 10 NEW_LINE tree [ d ] [ p ] = v NEW_LINE DEDENT def dfs ( i : int , j : int , path : int ) -> None : NEW_LINE INDENT nonlocal ans NEW_LINE if tree [ i ] [ j ] == - 1 : NEW_LINE INDENT return NEW_LINE DEDENT if i == 3 or max ( tree [ i + 1 ] [ j * 2 ] , tree [ i + 1 ] [ j * 2 + 1 ] ) == - 1 : NEW_LINE INDENT ans += path + tree [ i ] [ j ] NEW_LINE return NEW_LINE DEDENT dfs ( i + 1 , j * 2 , path + tree [ i ] [ j ] ) NEW_LINE dfs ( i + 1 , j * 2 + 1 , path + tree [ i ] [ j ] ) NEW_LINE DEDENT dfs ( 0 , 0 , 0 ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def constructArray ( self , n : int , k : int ) -> List [ int ] : NEW_LINE INDENT ans = list ( range ( 1 , n - k + 1 ) ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT ans . append ( n - i // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( n - k + ( i + 1 ) // 2 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def addBinary ( self , a : str , b : str ) -> str : NEW_LINE INDENT s = [ ] NEW_LINE carry = 0 NEW_LINE i = len ( a ) - 1 NEW_LINE j = len ( b ) - 1 NEW_LINE while i >= 0 or j >= 0 or carry : NEW_LINE INDENT if i >= 0 : NEW_LINE INDENT carry += int ( a [ i ] ) NEW_LINE i -= 1 NEW_LINE DEDENT if j >= 0 : NEW_LINE INDENT carry += int ( b [ j ] ) NEW_LINE j -= 1 NEW_LINE DEDENT s . append ( str ( carry % 2 ) ) NEW_LINE carry //= 2 NEW_LINE DEDENT return ' ' . join ( reversed ( s ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maximumSwap ( self , num : int ) -> int : NEW_LINE INDENT s = list ( str ( num ) ) NEW_LINE dict = { c : i for i , c in enumerate ( s ) } NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT for digit in reversed ( string . digits ) : NEW_LINE INDENT if digit <= c : NEW_LINE INDENT break NEW_LINE DEDENT if digit in dict and dict [ digit ] > i : NEW_LINE INDENT s [ i ] , s [ dict [ digit ] ] = digit , s [ i ] NEW_LINE return int ( ' ' . join ( s ) ) NEW_LINE DEDENT DEDENT DEDENT return num NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def flipLights ( self , n : int , m : int ) -> int : NEW_LINE INDENT n = min ( n , 3 ) NEW_LINE if m == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if m == 1 : NEW_LINE INDENT return [ 2 , 3 , 4 ] [ n - 1 ] NEW_LINE DEDENT if m == 2 : NEW_LINE INDENT return [ 2 , 4 , 7 ] [ n - 1 ] NEW_LINE DEDENT return [ 2 , 4 , 8 ] [ n - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findNumberOfLIS ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE maxLength = 0 NEW_LINE length = [ 1 ] * len ( nums ) NEW_LINE count = [ 1 ] * len ( nums ) NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if nums [ j ] < num : NEW_LINE INDENT if length [ i ] < length [ j ] + 1 : NEW_LINE INDENT length [ i ] = length [ j ] + 1 NEW_LINE count [ i ] = count [ j ] NEW_LINE DEDENT elif length [ i ] == length [ j ] + 1 : NEW_LINE INDENT count [ i ] += count [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT for i , l in enumerate ( length ) : NEW_LINE INDENT if l > maxLength : NEW_LINE INDENT maxLength = l NEW_LINE ans = count [ i ] NEW_LINE DEDENT elif l == maxLength : NEW_LINE INDENT ans += count [ i ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findLengthOfLCIS ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE j = 0 NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT if i > 0 and nums [ i ] <= nums [ i - 1 ] : NEW_LINE INDENT j = i NEW_LINE DEDENT ans = max ( ans , i - j + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class MagicDictionary : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . dict = { } NEW_LINE DEDENT def buildDict ( self , dictionary : List [ str ] ) -> None : NEW_LINE INDENT for word in dictionary : NEW_LINE INDENT for i , c in enumerate ( word ) : NEW_LINE INDENT replaced = self . _getReplaced ( word , i ) NEW_LINE self . dict [ replaced ] = ' * ' if replaced in self . dict else c NEW_LINE DEDENT DEDENT DEDENT def search ( self , searchWord : str ) -> bool : NEW_LINE INDENT for i , c in enumerate ( searchWord ) : NEW_LINE INDENT replaced = self . _getReplaced ( searchWord , i ) NEW_LINE if self . dict . get ( replaced , c ) != c : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def _getReplaced ( self , s : str , i : int ) -> str : NEW_LINE INDENT return s [ : i ] + ' * ' + s [ i + 1 : ] NEW_LINE DEDENT DEDENT
class TrieNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . children : Dict [ str , TrieNode ] = defaultdict ( TrieNode ) NEW_LINE self . sum = 0 NEW_LINE DEDENT DEDENT class MapSum : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . root = TrieNode ( ) NEW_LINE self . keyToVal = { } NEW_LINE DEDENT def insert ( self , key : str , val : int ) -> None : NEW_LINE INDENT diff = val - self . keyToVal . get ( key , 0 ) NEW_LINE node : TrieNode = self . root NEW_LINE for c in key : NEW_LINE INDENT if c not in node . children : NEW_LINE INDENT node . children [ c ] = TrieNode ( ) NEW_LINE DEDENT node = node . children [ c ] NEW_LINE node . sum += diff NEW_LINE DEDENT self . keyToVal [ key ] = val NEW_LINE DEDENT def sum ( self , prefix : str ) -> int : NEW_LINE INDENT node : TrieNode = self . root NEW_LINE for c in prefix : NEW_LINE INDENT if c not in node . children : NEW_LINE INDENT return 0 NEW_LINE DEDENT node = node . children [ c ] NEW_LINE DEDENT return node . sum NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def checkValidString ( self , s : str ) -> bool : NEW_LINE INDENT low = 0 NEW_LINE high = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == ' ( ' : NEW_LINE INDENT low += 1 NEW_LINE high += 1 NEW_LINE DEDENT elif c == ' ) ' : NEW_LINE INDENT if low > 0 : NEW_LINE INDENT low -= 1 NEW_LINE DEDENT high -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if low > 0 : NEW_LINE INDENT low -= 1 NEW_LINE DEDENT high += 1 NEW_LINE DEDENT if high < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return low == 0 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def judgePoint24 ( self , nums : List [ int ] ) -> bool : NEW_LINE INDENT def generate ( a : float , b : float ) -> List [ float ] : NEW_LINE INDENT return [ a * b , math . inf if b == 0 else a / b , math . inf if a == 0 else b / a , a + b , a - b , b - a ] NEW_LINE DEDENT def dfs ( nums : List [ float ] ) -> bool : NEW_LINE INDENT if len ( nums ) == 1 : NEW_LINE INDENT return abs ( nums [ 0 ] - 24.0 ) < 0.001 NEW_LINE DEDENT for i in range ( len ( nums ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( nums ) ) : NEW_LINE INDENT for num in generate ( nums [ i ] , nums [ j ] ) : NEW_LINE INDENT nextRound = [ num ] NEW_LINE for k in range ( len ( nums ) ) : NEW_LINE INDENT if k == i or k == j : NEW_LINE INDENT continue NEW_LINE DEDENT nextRound . append ( nums [ k ] ) NEW_LINE DEDENT if dfs ( nextRound ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT return dfs ( nums ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def fullJustify ( self , words : List [ str ] , maxWidth : int ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE row = [ ] NEW_LINE rowLetters = 0 NEW_LINE for word in words : NEW_LINE INDENT if rowLetters + len ( word ) + len ( row ) > maxWidth : NEW_LINE INDENT for i in range ( maxWidth - rowLetters ) : NEW_LINE INDENT row [ i % ( len ( row ) - 1 or 1 ) ] += ' ▁ ' NEW_LINE DEDENT ans . append ( ' ' . join ( row ) ) NEW_LINE row = [ ] NEW_LINE rowLetters = 0 NEW_LINE DEDENT row . append ( word ) NEW_LINE rowLetters += len ( word ) NEW_LINE DEDENT return ans + [ ' ▁ ' . join ( row ) . ljust ( maxWidth ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def validPalindrome ( self , s : str ) -> bool : NEW_LINE INDENT def validPalindrome ( l : int , r : int ) -> bool : NEW_LINE INDENT return all ( s [ i ] == s [ r - i + l ] for i in range ( l , ( l + r ) // 2 + 1 ) ) NEW_LINE DEDENT n = len ( s ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT if s [ i ] != s [ ~ i ] : NEW_LINE INDENT return validPalindrome ( i + 1 , n - 1 - i ) or validPalindrome ( i , n - 2 - i ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nextClosestTime ( self , time : str ) -> str : NEW_LINE INDENT ans = list ( time ) NEW_LINE digits = sorted ( ans ) NEW_LINE def nextClosest ( digit : chr , limit : chr ) -> chr : NEW_LINE INDENT next = bisect_right ( digits , digit ) NEW_LINE return digits [ 0 ] if next == 4 or digits [ next ] > limit else digits [ next ] NEW_LINE DEDENT ans [ 4 ] = nextClosest ( ans [ 4 ] , '9' ) NEW_LINE if time [ 4 ] < ans [ 4 ] : NEW_LINE INDENT return ' ' . join ( ans ) NEW_LINE DEDENT ans [ 3 ] = nextClosest ( ans [ 3 ] , '5' ) NEW_LINE if time [ 3 ] < ans [ 3 ] : NEW_LINE INDENT return ' ' . join ( ans ) NEW_LINE DEDENT ans [ 1 ] = nextClosest ( ans [ 1 ] , '3' if ans [ 0 ] == '2' else '9' ) NEW_LINE if time [ 1 ] < ans [ 1 ] : NEW_LINE INDENT return ' ' . join ( ans ) NEW_LINE DEDENT ans [ 0 ] = nextClosest ( ans [ 0 ] , '2' ) NEW_LINE return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def kEmptySlots ( self , bulbs : List [ int ] , k : int ) -> int : NEW_LINE INDENT n = len ( bulbs ) NEW_LINE ans = math . inf NEW_LINE day = [ 0 ] * n NEW_LINE for i , bulb in enumerate ( bulbs ) : NEW_LINE INDENT day [ bulb - 1 ] = i + 1 NEW_LINE DEDENT l = 0 NEW_LINE r = l + k + 1 NEW_LINE i = 1 NEW_LINE while r < n : NEW_LINE INDENT if i == r : NEW_LINE INDENT ans = min ( ans , max ( day [ l ] , day [ r ] ) ) NEW_LINE l = i NEW_LINE r = i + k + 1 NEW_LINE DEDENT elif day [ i ] < max ( day [ l ] , day [ r ] ) : NEW_LINE INDENT l = i NEW_LINE r = i + k + 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return - 1 if ans == math . inf else ans NEW_LINE DEDENT DEDENT
class UnionFind : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . id = [ i for i in range ( n + 1 ) ] NEW_LINE DEDENT def union ( self , u : int , v : int ) -> bool : NEW_LINE INDENT i = self . find ( u ) NEW_LINE j = self . find ( v ) NEW_LINE if i == j : NEW_LINE INDENT return False NEW_LINE DEDENT self . id [ i ] = j NEW_LINE return True NEW_LINE DEDENT def find ( self , u : int ) -> int : NEW_LINE INDENT if self . id [ u ] != u : NEW_LINE INDENT self . id [ u ] = self . find ( self . id [ u ] ) NEW_LINE DEDENT return self . id [ u ] NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def findRedundantConnection ( self , edges : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT uf = UnionFind ( len ( edges ) ) NEW_LINE for edge in edges : NEW_LINE INDENT if not uf . union ( edge [ 0 ] , edge [ 1 ] ) : NEW_LINE INDENT return edge NEW_LINE DEDENT DEDENT DEDENT DEDENT
class UnionFind : NEW_LINE INDENT def __init__ ( self , n : int ) : NEW_LINE INDENT self . id = [ i for i in range ( n + 1 ) ] NEW_LINE DEDENT def union ( self , u : int , v : int ) -> bool : NEW_LINE INDENT i = self . find ( u ) NEW_LINE j = self . find ( v ) NEW_LINE if i == j : NEW_LINE INDENT return False NEW_LINE DEDENT self . id [ i ] = j NEW_LINE return True NEW_LINE DEDENT def find ( self , u : int ) -> int : NEW_LINE INDENT if self . id [ u ] != u : NEW_LINE INDENT self . id [ u ] = self . find ( self . id [ u ] ) NEW_LINE DEDENT return self . id [ u ] NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def findRedundantDirectedConnection ( self , edges : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT ids = [ 0 ] * ( len ( edges ) + 1 ) NEW_LINE nodeWithTwoParents = 0 NEW_LINE for u , v in edges : NEW_LINE INDENT ids [ v ] += 1 NEW_LINE if ids [ v ] == 2 : NEW_LINE INDENT nodeWithTwoParents = v NEW_LINE DEDENT DEDENT def findRedundantDirectedConnection ( skippedEdgeIndex : int ) -> List [ int ] : NEW_LINE INDENT uf = UnionFind ( len ( edges ) + 1 ) NEW_LINE for i , edge in enumerate ( edges ) : NEW_LINE INDENT if i == skippedEdgeIndex : NEW_LINE INDENT continue NEW_LINE DEDENT if not uf . union ( edge [ 0 ] , edge [ 1 ] ) : NEW_LINE INDENT return edge NEW_LINE DEDENT DEDENT return [ ] NEW_LINE DEDENT if nodeWithTwoParents == 0 : NEW_LINE INDENT return findRedundantDirectedConnection ( - 1 ) NEW_LINE DEDENT for i in reversed ( range ( len ( edges ) ) ) : NEW_LINE INDENT _ , v = edges [ i ] NEW_LINE if v == nodeWithTwoParents : NEW_LINE INDENT if not findRedundantDirectedConnection ( i ) : NEW_LINE INDENT return edges [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def repeatedStringMatch ( self , a : str , b : str ) -> int : NEW_LINE INDENT n = ceil ( len ( b ) / len ( a ) ) NEW_LINE s = a * n NEW_LINE if b in s : NEW_LINE INDENT return n NEW_LINE DEDENT if b in s + a : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestUnivaluePath ( self , root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE def longestUnivaluePathDownFrom ( root : Optional [ TreeNode ] ) -> int : NEW_LINE INDENT nonlocal ans NEW_LINE if not root : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = longestUnivaluePathDownFrom ( root . left ) NEW_LINE r = longestUnivaluePathDownFrom ( root . right ) NEW_LINE arrowLeft = l + 1 if root . left and root . left . val == root . val else 0 NEW_LINE arrowRight = r + 1 if root . right and root . right . val == root . val else 0 NEW_LINE ans = max ( ans , arrowLeft + arrowRight ) NEW_LINE return max ( arrowLeft , arrowRight ) NEW_LINE DEDENT longestUnivaluePathDownFrom ( root ) NEW_LINE return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def knightProbability ( self , N : int , K : int , r : int , c : int ) -> float : NEW_LINE INDENT dirs = [ ( 1 , 2 ) , ( 2 , 1 ) , ( 2 , - 1 ) , ( 1 , - 2 ) , ( - 1 , - 2 ) , ( - 2 , - 1 ) , ( - 2 , 1 ) , ( - 1 , 2 ) ] NEW_LINE dp = [ [ 0 ] * N for _ in range ( N ) ] NEW_LINE dp [ r ] [ c ] = 1 NEW_LINE for _ in range ( K ) : NEW_LINE INDENT newDp = [ [ 0 ] * N for _ in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT for dx , dy in dirs : NEW_LINE INDENT x = i + dx NEW_LINE y = j + dy NEW_LINE if 0 <= x < N and 0 <= y < N : NEW_LINE INDENT newDp [ i ] [ j ] += dp [ x ] [ y ] NEW_LINE DEDENT DEDENT DEDENT DEDENT dp = newDp NEW_LINE DEDENT return sum ( map ( sum , dp ) ) / 8 ** K NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxSumOfThreeSubarrays ( self , nums : List [ int ] , k : int ) -> List [ int ] : NEW_LINE INDENT ans = [ - 1 ] * 3 NEW_LINE subarrayCount = len ( nums ) - k + 1 NEW_LINE dp = [ 0 ] * subarrayCount NEW_LINE summ = 0 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT summ += num NEW_LINE if i >= k : NEW_LINE INDENT summ -= nums [ i - k ] NEW_LINE DEDENT if i >= k - 1 : NEW_LINE INDENT dp [ i - k + 1 ] = summ NEW_LINE DEDENT DEDENT left = [ 0 ] * subarrayCount NEW_LINE maxIndex = 0 NEW_LINE for i in range ( subarrayCount ) : NEW_LINE INDENT if dp [ i ] > dp [ maxIndex ] : NEW_LINE INDENT maxIndex = i NEW_LINE DEDENT left [ i ] = maxIndex NEW_LINE DEDENT right = [ 0 ] * subarrayCount NEW_LINE maxIndex = subarrayCount - 1 NEW_LINE for i in reversed ( range ( subarrayCount ) ) : NEW_LINE INDENT if dp [ i ] >= dp [ maxIndex ] : NEW_LINE INDENT maxIndex = i NEW_LINE DEDENT right [ i ] = maxIndex NEW_LINE DEDENT for i in range ( k , subarrayCount - k ) : NEW_LINE INDENT if ans [ 0 ] == - 1 or dp [ left [ i - k ] ] + dp [ i ] + dp [ right [ i + k ] ] > dp [ ans [ 0 ] ] + dp [ ans [ 1 ] ] + dp [ ans [ 2 ] ] : NEW_LINE INDENT ans = [ left [ i - k ] , i , right [ i + k ] ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def mySqrt ( self , x : int ) -> int : NEW_LINE INDENT l = 1 NEW_LINE r = x + 1 NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if m * m > x : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return l - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def getImportance ( self , employees : List [ ' Employee ' ] , id : int ) -> int : NEW_LINE INDENT idToEmployee = { employee . id : employee for employee in employees } NEW_LINE def dfs ( id : int ) -> int : NEW_LINE INDENT values = idToEmployee [ id ] . importance NEW_LINE for subId in idToEmployee [ id ] . subordinates : NEW_LINE INDENT values += dfs ( subId ) NEW_LINE DEDENT return values NEW_LINE DEDENT return dfs ( id ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minStickers ( self , stickers : List [ str ] , target : str ) -> int : NEW_LINE INDENT n = len ( target ) NEW_LINE maxMask = 1 << n NEW_LINE dp = [ math . inf ] * maxMask NEW_LINE dp [ 0 ] = 0 NEW_LINE for mask in range ( maxMask ) : NEW_LINE INDENT if dp [ mask ] == math . inf : NEW_LINE INDENT continue NEW_LINE DEDENT for sticker in stickers : NEW_LINE INDENT superMask = mask NEW_LINE for c in sticker : NEW_LINE INDENT for i , t in enumerate ( target ) : NEW_LINE INDENT if c == t and not ( superMask >> i & 1 ) : NEW_LINE INDENT superMask |= 1 << i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT dp [ superMask ] = min ( dp [ superMask ] , dp [ mask ] + 1 ) NEW_LINE DEDENT DEDENT return - 1 if dp [ - 1 ] == math . inf else dp [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def topKFrequent ( self , words : List [ str ] , k : int ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE bucket = [ [ ] for _ in range ( len ( words ) + 1 ) ] NEW_LINE for word , freq in Counter ( words ) . items ( ) : NEW_LINE INDENT bucket [ freq ] . append ( word ) NEW_LINE DEDENT for b in reversed ( bucket ) : NEW_LINE INDENT for word in sorted ( b ) : NEW_LINE INDENT ans . append ( word ) NEW_LINE if len ( ans ) == k : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def numDistinctIslands ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT seen = set ( ) NEW_LINE def dfs ( i : int , j : int , i0 : int , j0 : int ) : NEW_LINE INDENT if i < 0 or i == len ( grid ) or j < 0 or j == len ( grid [ 0 ] ) : NEW_LINE INDENT return NEW_LINE DEDENT if grid [ i ] [ j ] == 0 or ( i , j ) in seen : NEW_LINE INDENT return NEW_LINE DEDENT seen . add ( ( i , j ) ) NEW_LINE island . append ( ( i - i0 , j - j0 ) ) NEW_LINE dfs ( i + 1 , j , i0 , j0 ) NEW_LINE dfs ( i - 1 , j , i0 , j0 ) NEW_LINE dfs ( i , j + 1 , i0 , j0 ) NEW_LINE dfs ( i , j - 1 , i0 , j0 ) NEW_LINE DEDENT islands = set ( ) NEW_LINE for i in range ( len ( grid ) ) : NEW_LINE INDENT for j in range ( len ( grid [ 0 ] ) ) : NEW_LINE INDENT island = [ ] NEW_LINE dfs ( i , j , i , j ) NEW_LINE if island : NEW_LINE INDENT islands . add ( frozenset ( island ) ) NEW_LINE DEDENT DEDENT DEDENT return len ( islands ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxAreaOfIsland ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT def dfs ( i : int , j : int ) -> int : NEW_LINE INDENT if i < 0 or i == len ( grid ) or j < 0 or j == len ( grid [ 0 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if grid [ i ] [ j ] != 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT grid [ i ] [ j ] = 2 NEW_LINE return 1 + dfs ( i + 1 , j ) + dfs ( i - 1 , j ) + dfs ( i , j + 1 ) + dfs ( i , j - 1 ) NEW_LINE DEDENT return max ( dfs ( i , j ) for i in range ( len ( grid ) ) for j in range ( len ( grid [ 0 ] ) ) ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countBinarySubstrings ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE prevCount = 0 NEW_LINE equals = 1 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT equals += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += min ( prevCount , equals ) NEW_LINE prevCount = equals NEW_LINE equals = 1 NEW_LINE DEDENT DEDENT return ans + min ( prevCount , equals ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findShortestSubArray ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE degree = 0 NEW_LINE debut = { } NEW_LINE count = Counter ( ) NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT debut . setdefault ( num , i ) NEW_LINE count [ num ] += 1 NEW_LINE if count [ num ] > degree : NEW_LINE INDENT degree = count [ num ] NEW_LINE ans = i - debut [ num ] + 1 NEW_LINE DEDENT elif count [ num ] == degree : NEW_LINE INDENT ans = min ( ans , i - debut [ num ] + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reverse ( self , x : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE sign = - 1 if x < 0 else 1 NEW_LINE x *= sign NEW_LINE while x : NEW_LINE INDENT ans = ans * 10 + x % 10 NEW_LINE x //= 10 NEW_LINE DEDENT return 0 if ans < - 2 ** 31 or ans > 2 ** 31 - 1 else sign * ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def climbStairs ( self , n : int ) -> int : NEW_LINE INDENT dp = [ 1 , 1 ] + [ 0 ] * ( n - 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def searchBST ( self , root : Optional [ TreeNode ] , val : int ) -> Optional [ TreeNode ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return None NEW_LINE DEDENT if root . val == val : NEW_LINE INDENT return root NEW_LINE DEDENT if root . val > val : NEW_LINE INDENT return self . searchBST ( root . left , val ) NEW_LINE DEDENT return self . searchBST ( root . right , val ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def insertIntoBST ( self , root : Optional [ TreeNode ] , val : int ) -> Optional [ TreeNode ] : NEW_LINE INDENT if not root : NEW_LINE INDENT return TreeNode ( val ) NEW_LINE DEDENT if root . val > val : NEW_LINE INDENT root . left = self . insertIntoBST ( root . left , val ) NEW_LINE DEDENT else : NEW_LINE INDENT root . right = self . insertIntoBST ( root . right , val ) NEW_LINE DEDENT return root NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def search ( self , reader : ' ArrayReader ' , target : int ) -> int : NEW_LINE INDENT l = 0 NEW_LINE r = 10 ** 4 NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if reader . get ( m ) < target : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return l if reader . get ( l ) == target else - 1 NEW_LINE DEDENT DEDENT
class MyHashSet : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . set = [ False ] * 1000001 NEW_LINE DEDENT def add ( self , key : int ) -> None : NEW_LINE INDENT self . set [ key ] = True NEW_LINE DEDENT def remove ( self , key : int ) -> None : NEW_LINE INDENT self . set [ key ] = False NEW_LINE DEDENT def contains ( self , key : int ) -> bool : NEW_LINE INDENT return self . set [ key ] NEW_LINE DEDENT DEDENT
class ListNode : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . val = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class MyLinkedList : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . length = 0 NEW_LINE self . dummy = ListNode ( 0 ) NEW_LINE DEDENT def get ( self , index : int ) -> int : NEW_LINE INDENT if index < 0 or index >= self . length : NEW_LINE INDENT return - 1 NEW_LINE DEDENT curr = self . dummy . next NEW_LINE for _ in range ( index ) : NEW_LINE INDENT curr = curr . next NEW_LINE DEDENT return curr . val NEW_LINE DEDENT def addAtHead ( self , val : int ) -> None : NEW_LINE INDENT curr = self . dummy . next NEW_LINE self . dummy . next = ListNode ( val ) NEW_LINE self . dummy . next . next = curr NEW_LINE self . length += 1 NEW_LINE DEDENT def addAtTail ( self , val : int ) -> None : NEW_LINE INDENT curr = self . dummy NEW_LINE while curr . next : NEW_LINE INDENT curr = curr . next NEW_LINE DEDENT curr . next = ListNode ( val ) NEW_LINE self . length += 1 NEW_LINE DEDENT def addAtIndex ( self , index : int , val : int ) -> None : NEW_LINE INDENT if index > self . length : NEW_LINE INDENT return NEW_LINE DEDENT curr = self . dummy NEW_LINE for _ in range ( index ) : NEW_LINE INDENT curr = curr . next NEW_LINE DEDENT temp = curr . next NEW_LINE curr . next = ListNode ( val ) NEW_LINE curr . next . next = temp NEW_LINE self . length += 1 NEW_LINE DEDENT def deleteAtIndex ( self , index : int ) -> None : NEW_LINE INDENT if index < 0 or index >= self . length : NEW_LINE INDENT return NEW_LINE DEDENT curr = self . dummy NEW_LINE for _ in range ( index ) : NEW_LINE INDENT curr = curr . next NEW_LINE DEDENT temp = curr . next NEW_LINE curr . next = temp . next NEW_LINE self . length -= 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def toLowerCase ( self , str : str ) -> str : NEW_LINE INDENT return ' ' . join ( chr ( ord ( c ) + 32 ) if ' A ' <= c <= ' Z ' else c for c in str ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def simplifyPath ( self , path : str ) -> str : NEW_LINE INDENT stack = [ ] NEW_LINE for str in path . split ( ' / ' ) : NEW_LINE INDENT if str in ( ' ' , ' . ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT if str == ' . . ' : NEW_LINE INDENT if stack : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT stack . append ( str ) NEW_LINE DEDENT DEDENT return ' / ' + ' / ' . join ( stack ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def __init__ ( self , N : int , blacklist : List [ int ] ) : NEW_LINE INDENT self . validRange = N - len ( blacklist ) NEW_LINE self . dict = { } NEW_LINE for b in blacklist : NEW_LINE INDENT self . dict [ b ] = - 1 NEW_LINE DEDENT for b in blacklist : NEW_LINE INDENT if b < self . validRange : NEW_LINE INDENT while N - 1 in self . dict : NEW_LINE INDENT N -= 1 NEW_LINE DEDENT self . dict [ b ] = N - 1 NEW_LINE N -= 1 NEW_LINE DEDENT DEDENT DEDENT def pick ( self ) -> int : NEW_LINE INDENT value = randint ( 0 , self . validRange - 1 ) NEW_LINE if value in self . dict : NEW_LINE INDENT return self . dict [ value ] NEW_LINE DEDENT return value NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numDistinctIslands2 ( self , grid : List [ List [ int ] ] ) -> int : NEW_LINE INDENT seen = set ( ) NEW_LINE def dfs ( i : int , j : int ) : NEW_LINE INDENT if i < 0 or i == len ( grid ) or j < 0 or j == len ( grid [ 0 ] ) : NEW_LINE INDENT return NEW_LINE DEDENT if grid [ i ] [ j ] == 0 or ( i , j ) in seen : NEW_LINE INDENT return NEW_LINE DEDENT seen . add ( ( i , j ) ) NEW_LINE island . append ( ( i , j ) ) NEW_LINE dfs ( i + 1 , j ) NEW_LINE dfs ( i - 1 , j ) NEW_LINE dfs ( i , j + 1 ) NEW_LINE dfs ( i , j - 1 ) NEW_LINE DEDENT def normalize ( island : List [ tuple ] ) -> List [ tuple ] : NEW_LINE INDENT points = [ [ ] for _ in range ( 8 ) ] NEW_LINE for i , j in island : NEW_LINE INDENT points [ 0 ] . append ( ( i , j ) ) NEW_LINE points [ 1 ] . append ( ( i , - j ) ) NEW_LINE points [ 2 ] . append ( ( - i , j ) ) NEW_LINE points [ 3 ] . append ( ( - i , - j ) ) NEW_LINE points [ 4 ] . append ( ( j , i ) ) NEW_LINE points [ 5 ] . append ( ( j , - i ) ) NEW_LINE points [ 6 ] . append ( ( - j , i ) ) NEW_LINE points [ 7 ] . append ( ( - j , - i ) ) NEW_LINE DEDENT points = [ sorted ( p ) for p in points ] NEW_LINE for p in points : NEW_LINE INDENT for i in range ( 1 , len ( island ) ) : NEW_LINE INDENT p [ i ] = ( p [ i ] [ 0 ] - p [ 0 ] [ 0 ] , p [ i ] [ 1 ] - p [ 0 ] [ 1 ] ) NEW_LINE DEDENT p [ 0 ] = ( 0 , 0 ) NEW_LINE DEDENT return sorted ( points ) [ 0 ] NEW_LINE DEDENT islands = set ( ) NEW_LINE for i in range ( len ( grid ) ) : NEW_LINE INDENT for j in range ( len ( grid [ 0 ] ) ) : NEW_LINE INDENT island = [ ] NEW_LINE dfs ( i , j ) NEW_LINE if island : NEW_LINE INDENT islands . add ( frozenset ( normalize ( island ) ) ) NEW_LINE DEDENT DEDENT DEDENT return len ( islands ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def numSubarrayProductLessThanK ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT if k <= 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE prod = 1 NEW_LINE j = 0 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT prod *= num NEW_LINE while prod >= k : NEW_LINE INDENT prod /= nums [ j ] NEW_LINE j += 1 NEW_LINE DEDENT ans += i - j + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxProfit ( self , prices : List [ int ] , fee : int ) -> int : NEW_LINE INDENT sell = 0 NEW_LINE hold = - math . inf NEW_LINE for price in prices : NEW_LINE INDENT sell = max ( sell , hold + price ) NEW_LINE hold = max ( hold , sell - price - fee ) NEW_LINE DEDENT return sell NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isOneBitCharacter ( self , bits : List [ int ] ) -> bool : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( bits ) - 1 : NEW_LINE INDENT i += bits [ i ] + 1 NEW_LINE DEDENT return i == len ( bits ) - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findLength ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> int : NEW_LINE INDENT m = len ( nums1 ) NEW_LINE n = len ( nums2 ) NEW_LINE ans = 0 NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for i in reversed ( range ( m ) ) : NEW_LINE INDENT for j in reversed ( range ( n ) ) : NEW_LINE INDENT if nums1 [ i ] == nums2 [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i + 1 ] [ j + 1 ] + 1 NEW_LINE ans = max ( ans , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def smallestDistancePair ( self , nums : List [ int ] , k : int ) -> int : NEW_LINE INDENT nums . sort ( ) NEW_LINE l = 0 NEW_LINE r = nums [ - 1 ] - nums [ 0 ] NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE count = 0 NEW_LINE j = 0 NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT while j < len ( nums ) and nums [ j ] <= nums [ i ] + m : NEW_LINE INDENT j += 1 NEW_LINE DEDENT count += j - i - 1 NEW_LINE DEDENT if count < k : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return l NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minDistance ( self , word1 : str , word2 : str ) -> int : NEW_LINE INDENT m = len ( word1 ) NEW_LINE n = len ( word2 ) NEW_LINE dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = i NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = j NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if word1 [ i - 1 ] == word2 [ j - 1 ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + 1 NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestWord ( self , words : List [ str ] ) -> str : NEW_LINE INDENT root = { } NEW_LINE for word in words : NEW_LINE INDENT node = root NEW_LINE for c in word : NEW_LINE INDENT if c not in node : NEW_LINE INDENT node [ c ] = { } NEW_LINE DEDENT node = node [ c ] NEW_LINE DEDENT node [ ' word ' ] = word NEW_LINE DEDENT def dfs ( node : dict ) -> str : NEW_LINE INDENT ans = node [ ' word ' ] if ' word ' in node else ' ' NEW_LINE for child in node : NEW_LINE INDENT if ' word ' in node [ child ] and len ( node [ child ] [ ' word ' ] ) > 0 : NEW_LINE INDENT childWord = dfs ( node [ child ] ) NEW_LINE if len ( childWord ) > len ( ans ) or ( len ( childWord ) == len ( ans ) and childWord < ans ) : NEW_LINE INDENT ans = childWord NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT return dfs ( root ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def removeComments ( self , source : List [ str ] ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE commenting = False NEW_LINE modified = ' ' NEW_LINE for line in source : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( line ) : NEW_LINE INDENT if i + 1 == len ( line ) : NEW_LINE INDENT if not commenting : NEW_LINE INDENT modified += line [ i ] NEW_LINE DEDENT i += 1 NEW_LINE break NEW_LINE DEDENT twoChars = line [ i : i + 2 ] NEW_LINE if twoChars == ' / * ' and not commenting : NEW_LINE INDENT commenting = True NEW_LINE i += 2 NEW_LINE DEDENT elif twoChars == ' * / ' and commenting : NEW_LINE INDENT commenting = False NEW_LINE i += 2 NEW_LINE DEDENT elif twoChars == ' / / ' : NEW_LINE INDENT if not commenting : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT i += 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if not commenting : NEW_LINE INDENT modified += line [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT if modified and not commenting : NEW_LINE INDENT ans . append ( modified ) NEW_LINE modified = ' ' NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def pivotIndex ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT summ = sum ( nums ) NEW_LINE prefix = 0 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT if prefix == summ - prefix - num : NEW_LINE INDENT return i NEW_LINE DEDENT prefix += num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def splitListToParts ( self , root : ListNode , k : int ) -> List [ ListNode ] : NEW_LINE INDENT ans = [ [ ] for _ in range ( k ) ] NEW_LINE length = 0 NEW_LINE curr = root NEW_LINE while curr : NEW_LINE INDENT length += 1 NEW_LINE curr = curr . next NEW_LINE DEDENT subLength = length // k NEW_LINE remainder = length % k NEW_LINE prev = None NEW_LINE head = root NEW_LINE for i in range ( k ) : NEW_LINE INDENT ans [ i ] = head NEW_LINE for j in range ( subLength + ( 1 if remainder > 0 else 0 ) ) : NEW_LINE INDENT prev = head NEW_LINE head = head . next NEW_LINE DEDENT if prev : NEW_LINE INDENT prev . next = None NEW_LINE DEDENT remainder -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def countOfAtoms ( self , formula : str ) -> str : NEW_LINE INDENT def parse ( ) -> dict : NEW_LINE INDENT ans = defaultdict ( int ) NEW_LINE nonlocal i NEW_LINE while i < n : NEW_LINE INDENT if formula [ i ] == ' ( ' : NEW_LINE INDENT i += 1 NEW_LINE for elem , freq in parse ( ) . items ( ) : NEW_LINE INDENT ans [ elem ] += freq NEW_LINE DEDENT DEDENT elif formula [ i ] == ' ) ' : NEW_LINE INDENT i += 1 NEW_LINE numStart = i NEW_LINE while i < n and formula [ i ] . isdigit ( ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT factor = int ( formula [ numStart : i ] ) NEW_LINE for elem , freq in ans . items ( ) : NEW_LINE INDENT ans [ elem ] *= factor NEW_LINE DEDENT return ans NEW_LINE DEDENT elif formula [ i ] . isupper ( ) : NEW_LINE INDENT elemStart = i NEW_LINE i += 1 NEW_LINE while i < n and formula [ i ] . islower ( ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elem = formula [ elemStart : i ] NEW_LINE numStart = i NEW_LINE while i < n and formula [ i ] . isdigit ( ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT num = 1 if i == numStart else int ( formula [ numStart : i ] ) NEW_LINE ans [ elem ] += num NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = len ( formula ) NEW_LINE ans = " " NEW_LINE i = 0 NEW_LINE count = parse ( ) NEW_LINE for elem in sorted ( count . keys ( ) ) : NEW_LINE INDENT ans += elem NEW_LINE if count [ elem ] > 1 : NEW_LINE INDENT ans += str ( count [ elem ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def selfDividingNumbers ( self , left : int , right : int ) -> List [ int ] : NEW_LINE INDENT return [ num for num in range ( left , right + 1 ) if all ( n != 0 and num % n == 0 for n in map ( int , str ( num ) ) ) ] NEW_LINE DEDENT DEDENT
class MyCalendar : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . timeline = [ ] NEW_LINE DEDENT def book ( self , start : int , end : int ) -> bool : NEW_LINE INDENT for s , e in self . timeline : NEW_LINE INDENT if max ( start , s ) < min ( end , e ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT self . timeline . append ( ( start , end ) ) NEW_LINE return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def setZeroes ( self , matrix : List [ List [ int ] ] ) -> None : NEW_LINE INDENT m = len ( matrix ) NEW_LINE n = len ( matrix [ 0 ] ) NEW_LINE shouldFillFirstRow = 0 in matrix [ 0 ] NEW_LINE shouldFillFirstCol = 0 in list ( zip ( * matrix ) ) [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if matrix [ i ] [ j ] == 0 : NEW_LINE INDENT matrix [ i ] [ 0 ] = 0 NEW_LINE matrix [ 0 ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if matrix [ i ] [ 0 ] == 0 or matrix [ 0 ] [ j ] == 0 : NEW_LINE INDENT matrix [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT if shouldFillFirstRow : NEW_LINE INDENT matrix [ 0 ] = [ 0 ] * n NEW_LINE DEDENT if shouldFillFirstCol : NEW_LINE INDENT for row in matrix : NEW_LINE INDENT row [ 0 ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def countPalindromicSubsequences ( self , s : str ) -> int : NEW_LINE INDENT def count ( l : int , r : int ) -> int : NEW_LINE INDENT if l > r : NEW_LINE INDENT return 0 NEW_LINE DEDENT if l == r : NEW_LINE INDENT return 1 NEW_LINE DEDENT key = l * len ( s ) + r NEW_LINE if key in memo : NEW_LINE INDENT return memo [ key ] NEW_LINE DEDENT if s [ l ] == s [ r ] : NEW_LINE INDENT lo = l + 1 NEW_LINE hi = r - 1 NEW_LINE while lo <= hi and s [ lo ] != s [ l ] : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT while lo <= hi and s [ hi ] != s [ l ] : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT if lo > hi : NEW_LINE INDENT ans = count ( l + 1 , r - 1 ) * 2 + 2 NEW_LINE DEDENT elif lo == hi : NEW_LINE INDENT ans = count ( l + 1 , r - 1 ) * 2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = count ( l + 1 , r - 1 ) * 2 - count ( lo + 1 , hi - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = count ( l , r - 1 ) + count ( l + 1 , r ) - count ( l + 1 , r - 1 ) NEW_LINE DEDENT memo [ key ] = ( ans + kMod ) % kMod NEW_LINE return memo [ key ] NEW_LINE DEDENT kMod = 1_000_000_007 NEW_LINE memo = { } NEW_LINE return count ( 0 , len ( s ) - 1 ) NEW_LINE DEDENT DEDENT
from sortedcontainers import SortedDict NEW_LINE class MyCalendarThree : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . timeline = SortedDict ( ) NEW_LINE DEDENT def book ( self , start : int , end : int ) -> int : NEW_LINE INDENT self . timeline [ start ] = self . timeline . get ( start , 0 ) + 1 NEW_LINE self . timeline [ end ] = self . timeline . get ( end , 0 ) - 1 NEW_LINE ans = 0 NEW_LINE activeEvents = 0 NEW_LINE for count in self . timeline . values ( ) : NEW_LINE INDENT activeEvents += count NEW_LINE ans = max ( ans , activeEvents ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def floodFill ( self , image : List [ List [ int ] ] , sr : int , sc : int , newColor : int ) -> List [ List [ int ] ] : NEW_LINE INDENT startColor = image [ sr ] [ sc ] NEW_LINE seen = set ( ) NEW_LINE def dfs ( i : int , j : int ) -> None : NEW_LINE INDENT if i < 0 or i == len ( image ) or j < 0 or j == len ( image [ 0 ] ) : NEW_LINE INDENT return NEW_LINE DEDENT if image [ i ] [ j ] != startColor or ( i , j ) in seen : NEW_LINE INDENT return NEW_LINE DEDENT image [ i ] [ j ] = newColor NEW_LINE seen . add ( ( i , j ) ) NEW_LINE dfs ( i + 1 , j ) NEW_LINE dfs ( i - 1 , j ) NEW_LINE dfs ( i , j + 1 ) NEW_LINE dfs ( i , j - 1 ) NEW_LINE DEDENT dfs ( sr , sc ) NEW_LINE return image NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def areSentencesSimilar ( self , sentence1 : List [ str ] , sentence2 : List [ str ] , similarPairs : List [ List [ str ] ] ) -> bool : NEW_LINE INDENT if len ( sentence1 ) != len ( sentence2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT map = defaultdict ( set ) NEW_LINE for a , b in similarPairs : NEW_LINE INDENT map [ a ] . add ( b ) NEW_LINE map [ b ] . add ( a ) NEW_LINE DEDENT for word1 , word2 in zip ( sentence1 , sentence2 ) : NEW_LINE INDENT if word1 == word2 : NEW_LINE INDENT continue NEW_LINE DEDENT if word1 not in map : NEW_LINE INDENT return False NEW_LINE DEDENT if word2 not in map [ word1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def asteroidCollision ( self , asteroids : List [ int ] ) -> List [ int ] : NEW_LINE INDENT stack = [ ] NEW_LINE for a in asteroids : NEW_LINE INDENT if a > 0 : NEW_LINE INDENT stack . append ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT while stack and stack [ - 1 ] > 0 and stack [ - 1 ] < - a : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT if not stack or stack [ - 1 ] < 0 : NEW_LINE INDENT stack . append ( a ) NEW_LINE DEDENT elif stack [ - 1 ] == - a : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT return stack NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def evaluate ( self , expression : str ) -> int : NEW_LINE INDENT def evaluate ( e : str , prevScope : dict ) -> int : NEW_LINE INDENT if e [ 0 ] . isdigit ( ) or e [ 0 ] == ' - ' : NEW_LINE INDENT return int ( e ) NEW_LINE DEDENT if e in prevScope : NEW_LINE INDENT return prevScope [ e ] NEW_LINE DEDENT scope = prevScope . copy ( ) NEW_LINE nextExpression = e [ e . index ( ' ▁ ' ) + 1 : - 1 ] NEW_LINE tokens = parse ( nextExpression ) NEW_LINE if e [ 1 ] == ' a ' : NEW_LINE INDENT return evaluate ( tokens [ 0 ] , scope ) + evaluate ( tokens [ 1 ] , scope ) NEW_LINE DEDENT if e [ 1 ] == ' m ' : NEW_LINE INDENT return evaluate ( tokens [ 0 ] , scope ) * evaluate ( tokens [ 1 ] , scope ) NEW_LINE DEDENT for i in range ( 0 , len ( tokens ) - 2 , 2 ) : NEW_LINE INDENT scope [ tokens [ i ] ] = evaluate ( tokens [ i + 1 ] , scope ) NEW_LINE DEDENT return evaluate ( tokens [ - 1 ] , scope ) NEW_LINE DEDENT def parse ( e : str ) : NEW_LINE INDENT tokens = [ ] NEW_LINE s = ' ' NEW_LINE parenthesis = 0 NEW_LINE for c in e : NEW_LINE INDENT if c == ' ( ' : NEW_LINE INDENT parenthesis += 1 NEW_LINE DEDENT elif c == ' ) ' : NEW_LINE INDENT parenthesis -= 1 NEW_LINE DEDENT if parenthesis == 0 and c == ' ▁ ' : NEW_LINE INDENT tokens . append ( s ) NEW_LINE s = ' ' NEW_LINE DEDENT else : NEW_LINE INDENT s += c NEW_LINE DEDENT DEDENT if len ( s ) > 0 : NEW_LINE INDENT tokens . append ( s ) NEW_LINE DEDENT return tokens NEW_LINE DEDENT return evaluate ( expression , { } ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def areSentencesSimilarTwo ( self , words1 : List [ str ] , words2 : List [ str ] , pairs : List [ List [ str ] ] ) -> bool : NEW_LINE INDENT if len ( words1 ) != len ( words2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT graph = defaultdict ( set ) NEW_LINE for a , b in pairs : NEW_LINE INDENT graph [ a ] . add ( b ) NEW_LINE graph [ b ] . add ( a ) NEW_LINE DEDENT def dfs ( word1 : str , word2 : str , seen : set ) -> bool : NEW_LINE INDENT if word1 in graph [ word2 ] : NEW_LINE INDENT return True NEW_LINE DEDENT seen . add ( word1 ) NEW_LINE for child in graph [ word1 ] : NEW_LINE INDENT if child in seen : NEW_LINE INDENT continue NEW_LINE DEDENT if dfs ( child , word2 , seen ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT for word1 , word2 in zip ( words1 , words2 ) : NEW_LINE INDENT if word1 == word2 : NEW_LINE INDENT continue NEW_LINE DEDENT if word1 not in graph : NEW_LINE INDENT return False NEW_LINE DEDENT if not dfs ( word1 , word2 , set ( ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def dailyTemperatures ( self , temperatures : List [ int ] ) -> List [ int ] : NEW_LINE INDENT ans = [ 0 ] * len ( temperatures ) NEW_LINE stack = [ ] NEW_LINE for i , t in enumerate ( temperatures ) : NEW_LINE INDENT while stack and t > temperatures [ stack [ - 1 ] ] : NEW_LINE INDENT index = stack . pop ( ) NEW_LINE ans [ index ] = i - index NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def searchMatrix ( self , matrix : List [ List [ int ] ] , target : int ) -> bool : NEW_LINE INDENT if not matrix : NEW_LINE INDENT return False NEW_LINE DEDENT m = len ( matrix ) NEW_LINE n = len ( matrix [ 0 ] ) NEW_LINE l = 0 NEW_LINE r = m * n NEW_LINE while l < r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE i = mid // n NEW_LINE j = mid % n NEW_LINE if matrix [ i ] [ j ] == target : NEW_LINE INDENT return True NEW_LINE DEDENT if matrix [ i ] [ j ] < target : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def nextGreatestLetter ( self , letters : List [ str ] , target : str ) -> str : NEW_LINE INDENT l = 0 NEW_LINE r = len ( letters ) NEW_LINE while l < r : NEW_LINE INDENT m = ( l + r ) >> 1 NEW_LINE if letters [ m ] <= target : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT return letters [ l % len ( letters ) ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minCostClimbingStairs ( self , cost : List [ int ] ) -> int : NEW_LINE INDENT cost . append ( 0 ) NEW_LINE for i in range ( 2 , len ( cost ) ) : NEW_LINE INDENT cost [ i ] += min ( cost [ i - 1 ] , cost [ i - 2 ] ) NEW_LINE DEDENT return cost [ - 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def dominantIndex ( self , nums : List [ int ] ) -> int : NEW_LINE INDENT max = 0 NEW_LINE secondMax = 0 NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT if num > max : NEW_LINE INDENT secondMax = max NEW_LINE max = num NEW_LINE ans = i NEW_LINE DEDENT elif num > secondMax : NEW_LINE INDENT secondMax = num NEW_LINE DEDENT DEDENT return ans if max >= 2 * secondMax else - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def shortestCompletingWord ( self , licensePlate : str , words : List [ str ] ) -> str : NEW_LINE INDENT def isMatch ( word : str ) -> bool : NEW_LINE INDENT wordCount = Counter ( word ) NEW_LINE return False if any ( wordCount [ i ] < count [ i ] for i in string . ascii_letters ) else True NEW_LINE DEDENT ans = ' * ' * 16 NEW_LINE count = defaultdict ( int ) NEW_LINE for c in licensePlate : NEW_LINE INDENT if c . isalpha ( ) : NEW_LINE INDENT count [ c . lower ( ) ] += 1 NEW_LINE DEDENT DEDENT for word in words : NEW_LINE INDENT if len ( word ) < len ( ans ) and isMatch ( word ) : NEW_LINE INDENT ans = word NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def sortColors ( self , nums : List [ int ] ) -> None : NEW_LINE INDENT zero = - 1 NEW_LINE one = - 1 NEW_LINE two = - 1 NEW_LINE for num in nums : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT two += 1 NEW_LINE one += 1 NEW_LINE zero += 1 NEW_LINE nums [ two ] = 2 NEW_LINE nums [ one ] = 1 NEW_LINE nums [ zero ] = 0 NEW_LINE DEDENT elif num == 1 : NEW_LINE INDENT two += 1 NEW_LINE one += 1 NEW_LINE nums [ two ] = 2 NEW_LINE nums [ one ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT two += 1 NEW_LINE nums [ two ] = 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def ipToCIDR ( self , ip : str , n : int ) -> List [ str ] : NEW_LINE INDENT ans = [ ] NEW_LINE num = self . _getNum ( ip . split ( ' . ' ) ) NEW_LINE while n > 0 : NEW_LINE INDENT lowbit = num & - num NEW_LINE count = self . _maxLow ( n ) if lowbit == 0 else self . _firstFit ( lowbit , n ) NEW_LINE ans . append ( self . _getCIDR ( num , self . _getPrefix ( count ) ) ) NEW_LINE n -= count NEW_LINE num += count NEW_LINE DEDENT return ans NEW_LINE DEDENT def _getNum ( self , x : List [ str ] ) -> int : NEW_LINE INDENT num = 0 NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT num = num * 256 + int ( x [ i ] ) NEW_LINE DEDENT return num NEW_LINE DEDENT def _maxLow ( self , n : int ) -> Optional [ int ] : NEW_LINE INDENT for i in range ( 32 ) : NEW_LINE INDENT if 1 << i + 1 > n : NEW_LINE INDENT return 1 << i NEW_LINE DEDENT DEDENT DEDENT def _firstFit ( self , lowbit : int , n : int ) -> int : NEW_LINE INDENT while lowbit > n : NEW_LINE INDENT lowbit >>= 1 NEW_LINE DEDENT return lowbit NEW_LINE DEDENT def _getCIDR ( self , num : int , prefix : int ) -> str : NEW_LINE INDENT d = num & 255 NEW_LINE num >>= 8 NEW_LINE c = num & 255 NEW_LINE num >>= 8 NEW_LINE b = num & 255 NEW_LINE num >>= 8 NEW_LINE a = num & 255 NEW_LINE return ' . ' . join ( [ str ( s ) for s in [ a , b , c , d ] ] ) + ' / ' + str ( prefix ) NEW_LINE DEDENT def _getPrefix ( self , count : int ) -> Optional [ int ] : NEW_LINE INDENT for i in range ( 32 ) : NEW_LINE INDENT if count == 1 << i : NEW_LINE INDENT return 32 - i NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def crackSafe ( self , n : int , k : int ) -> str : NEW_LINE INDENT passwordSize = k ** n NEW_LINE path = '0' * n NEW_LINE seen = set ( ) NEW_LINE seen . add ( path ) NEW_LINE def dfs ( path : str ) -> str : NEW_LINE INDENT if len ( seen ) == passwordSize : NEW_LINE INDENT return path NEW_LINE DEDENT for c in map ( str , range ( k ) ) : NEW_LINE INDENT node = path [ - n + 1 : ] + c if n > 1 else c NEW_LINE if node not in seen : NEW_LINE INDENT seen . add ( node ) NEW_LINE res = dfs ( path + c ) NEW_LINE if res : NEW_LINE INDENT return res NEW_LINE DEDENT seen . remove ( node ) NEW_LINE DEDENT DEDENT DEDENT return dfs ( path ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reachNumber ( self , target : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE pos = 0 NEW_LINE target = abs ( target ) NEW_LINE while pos < target : NEW_LINE INDENT ans += 1 NEW_LINE pos += ans NEW_LINE DEDENT while ( pos - target ) & 1 : NEW_LINE INDENT ans += 1 NEW_LINE pos += ans NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def pyramidTransition ( self , bottom : str , allowed : List [ str ] ) -> bool : NEW_LINE INDENT prefixToBlocks = defaultdict ( list ) NEW_LINE for a in allowed : NEW_LINE INDENT prefixToBlocks [ a [ : 2 ] ] . append ( a [ 2 ] ) NEW_LINE DEDENT def dfs ( row : str , nextRow : str , i : int ) -> bool : NEW_LINE INDENT if len ( row ) == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if len ( nextRow ) + 1 == len ( row ) : NEW_LINE INDENT return dfs ( nextRow , ' ' , 0 ) NEW_LINE DEDENT for c in prefixToBlocks [ row [ i : i + 2 ] ] : NEW_LINE INDENT if dfs ( row , nextRow + c , i + 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT return dfs ( bottom , ' ' , 0 ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def boldWords ( self , words : List [ str ] , s : str ) -> str : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = [ ] NEW_LINE bold = [ 0 ] * n NEW_LINE boldEnd = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for word in words : NEW_LINE INDENT if s [ i : ] . startswith ( word ) : NEW_LINE INDENT boldEnd = max ( boldEnd , i + len ( word ) ) NEW_LINE DEDENT DEDENT bold [ i ] = boldEnd > i NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT if bold [ i ] : NEW_LINE INDENT j = i NEW_LINE while j < n and bold [ j ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT ans . append ( ' < b > ' + s [ i : j ] + ' < / b > ' ) NEW_LINE i = j NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( s [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def employeeFreeTime ( self , schedule : ' [ [ Interval ] ] ' ) -> ' [ Interval ] ' : NEW_LINE INDENT ans = [ ] NEW_LINE intervals = [ ] NEW_LINE for s in schedule : NEW_LINE INDENT intervals . extend ( s ) NEW_LINE DEDENT intervals . sort ( key = lambda x : x . start ) NEW_LINE prevEnd = intervals [ 0 ] . end NEW_LINE for interval in intervals : NEW_LINE INDENT if interval . start > prevEnd : NEW_LINE INDENT ans . append ( Interval ( prevEnd , interval . start ) ) NEW_LINE DEDENT prevEnd = max ( prevEnd , interval . end ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def minWindow ( self , s : str , t : str ) -> str : NEW_LINE INDENT count = Counter ( t ) NEW_LINE required = len ( t ) NEW_LINE bestLeft = - 1 NEW_LINE minLength = len ( s ) + 1 NEW_LINE l = 0 NEW_LINE for r , c in enumerate ( s ) : NEW_LINE INDENT count [ c ] -= 1 NEW_LINE if count [ c ] >= 0 : NEW_LINE INDENT required -= 1 NEW_LINE DEDENT while required == 0 : NEW_LINE INDENT if r - l + 1 < minLength : NEW_LINE INDENT bestLeft = l NEW_LINE minLength = r - l + 1 NEW_LINE DEDENT count [ s [ l ] ] += 1 NEW_LINE if count [ s [ l ] ] > 0 : NEW_LINE INDENT required += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT return ' ' if bestLeft == - 1 else s [ bestLeft : bestLeft + minLength ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def makeLargestSpecial ( self , S : str ) -> str : NEW_LINE INDENT specials = [ ] NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE for j , c in enumerate ( S ) : NEW_LINE INDENT count += 1 if c == '1' else - 1 NEW_LINE if count == 0 : NEW_LINE INDENT specials . append ( '1' + self . makeLargestSpecial ( S [ i + 1 : j ] ) + '0' ) NEW_LINE i = j + 1 NEW_LINE DEDENT DEDENT return ' ' . join ( sorted ( specials ) [ : : - 1 ] ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def partitionLabels ( self , S : str ) -> List [ int ] : NEW_LINE INDENT ans = [ ] NEW_LINE letterToRightmostIndex = { c : i for i , c in enumerate ( S ) } NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE for i , c in enumerate ( S ) : NEW_LINE INDENT r = max ( r , letterToRightmostIndex [ c ] ) NEW_LINE if i == r : NEW_LINE INDENT ans . append ( r - l + 1 ) NEW_LINE l = r + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isToeplitzMatrix ( self , matrix : List [ List [ int ] ] ) -> bool : NEW_LINE INDENT for i in range ( len ( matrix ) - 1 ) : NEW_LINE INDENT for j in range ( len ( matrix [ 0 ] ) - 1 ) : NEW_LINE INDENT if matrix [ i ] [ j ] != matrix [ i + 1 ] [ j + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reorganizeString ( self , s : str ) -> str : NEW_LINE INDENT count = Counter ( s ) NEW_LINE if max ( count . values ( ) ) > ( len ( s ) + 1 ) // 2 : NEW_LINE INDENT return ' ' NEW_LINE DEDENT ans = [ ] NEW_LINE maxHeap = [ ( - freq , c ) for c , freq in count . items ( ) ] NEW_LINE heapq . heapify ( maxHeap ) NEW_LINE prevFreq = 0 NEW_LINE prevChar = ' @ ' NEW_LINE while maxHeap : NEW_LINE INDENT freq , c = heapq . heappop ( maxHeap ) NEW_LINE ans . append ( c ) NEW_LINE if prevFreq < 0 : NEW_LINE INDENT heapq . heappush ( maxHeap , ( prevFreq , prevChar ) ) NEW_LINE DEDENT prevFreq = freq + 1 NEW_LINE prevChar = c NEW_LINE DEDENT return ' ' . join ( ans ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def maxChunksToSorted ( self , arr : List [ int ] ) -> int : NEW_LINE INDENT n = len ( arr ) NEW_LINE ans = 0 NEW_LINE maxi = - math . inf NEW_LINE mini = [ arr [ - 1 ] ] * n NEW_LINE for i in reversed ( range ( n - 1 ) ) : NEW_LINE INDENT mini [ i ] = min ( mini [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT maxi = max ( maxi , arr [ i ] ) NEW_LINE if maxi <= mini [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT DEDENT
def transpose_dict ( d ) : NEW_LINE INDENT return { k : [ d [ k ] for d in d ] for k in d [ 0 ] } NEW_LINE DEDENT transpose_dict ( [ { ' a ' : 1 , ' b ' : 2 } , { ' a ' : 3 , ' b ' : 4 } , { ' a ' : 5 , ' b ' : 6 } ] ) NEW_LINE
def find_index ( to_search , target ) : NEW_LINE INDENT for i , value in enumerate ( to_search ) : NEW_LINE INDENT if value == target : NEW_LINE INDENT yield i NEW_LINE DEDENT DEDENT DEDENT my_list = [ ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' a ' , ' b ' , ' c ' ] NEW_LINE print ( list ( find_index ( my_list , ' b ' ) ) ) NEW_LINE
tup = ( 1 , 2 , 3 ) NEW_LINE lst = list ( tup ) NEW_LINE lst . append ( 4 ) NEW_LINE tup = tuple ( lst ) NEW_LINE print ( tup ) NEW_LINE
from google . appengine . ext import db NEW_LINE class Person ( db . Model ) : NEW_LINE INDENT name = db . StringProperty ( ) NEW_LINE DEDENT class Car ( db . Model ) : NEW_LINE INDENT owner = db . ReferenceProperty ( Person ) NEW_LINE DEDENT query = Car . all ( ) NEW_LINE query . filter ( ' owner ▁ = ' , Person . get_by_key_name ( ' John ' ) ) NEW_LINE
def sum_list_of_lists ( list_of_lists ) : NEW_LINE INDENT return [ sum ( x ) for x in zip ( * list_of_lists ) ] NEW_LINE DEDENT sum_list_of_lists ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE
def unzip ( pairs ) : NEW_LINE INDENT return zip ( * pairs ) NEW_LINE DEDENT
def string_to_pairs ( s ) : NEW_LINE INDENT return list ( zip ( s , s [ 1 : ] ) ) NEW_LINE DEDENT string_to_pairs ( ' abcd ' ) NEW_LINE
def print_tsv ( lst ) : NEW_LINE INDENT print ( ' \t ' . join ( lst ) ) NEW_LINE DEDENT print_tsv ( [ ' a ' , ' b ' , ' c ' ] ) NEW_LINE
list_of_lists = [ [ ' a ' , ' b ' , ' c ' ] , [ ' d ' , ' e ' , ' f ' ] , [ ' g ' , ' h ' , ' i ' ] ] NEW_LINE merged_list = [ y for x in list_of_lists for y in x ] NEW_LINE print ( merged_list ) NEW_LINE
import pandas as pd NEW_LINE import matplotlib . pyplot as plt NEW_LINE df = pd . DataFrame ( { ' lab ' : [ ' A ' , ' B ' , ' C ' ] , ' val ' : [ 10 , 30 , 20 ] } ) NEW_LINE fig , ax = plt . subplots ( ) NEW_LINE for i in range ( len ( df [ ' val ' ] ) ) : NEW_LINE INDENT ax . bar ( df [ ' lab ' ] [ i ] , df [ ' val ' ] [ i ] , label = df [ ' lab ' ] [ i ] ) NEW_LINE DEDENT ax . set_xticklabels ( df [ ' lab ' ] ) NEW_LINE ax . legend ( ) NEW_LINE plt . show ( ) NEW_LINE
import re NEW_LINE def find_brackets ( string ) : NEW_LINE INDENT return re . findall ( r ' \ [ ( . * ? ) \ ] ' , string ) NEW_LINE DEDENT find_brackets ( ' [ hello ] ▁ [ world ] ' ) NEW_LINE
d = { ' a ' : 1 , ' b ' : 2 } NEW_LINE d [ ' c ' ] = 3 NEW_LINE
def hex_to_float ( h ) : NEW_LINE INDENT return struct . unpack ( ' > f ' , h . decode ( ' hex ' ) ) [ 0 ] NEW_LINE DEDENT
l = [ ] NEW_LINE l . append ( ( 1 , 2 ) ) NEW_LINE l . append ( ( 3 , 4 ) ) NEW_LINE l . append ( ( 5 , 6 ) ) NEW_LINE
import re NEW_LINE regexes = [ re . compile ( p ) for p in [ ' this ' , ' that ' ] ] NEW_LINE text = ' Does ▁ this ▁ text ▁ match ▁ the ▁ pattern ? ' NEW_LINE print ( ' Text : ▁ { ! r } \n ' . format ( text ) ) NEW_LINE for regex in regexes : NEW_LINE INDENT print ( ' Seeking ▁ " { } " ▁ - > ' . format ( regex . pattern ) , end = ' ▁ ' ) NEW_LINE if regex . search ( text ) : NEW_LINE INDENT print ( ' match ! ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' no ▁ match ' ) NEW_LINE DEDENT DEDENT
import os NEW_LINE import random NEW_LINE def random_file ( path ) : NEW_LINE INDENT files = os . listdir ( path ) NEW_LINE index = random . randrange ( 0 , len ( files ) ) NEW_LINE return files [ index ] NEW_LINE DEDENT print ( random_file ( ' / home / user / dir ' ) ) NEW_LINE
def remove_strings ( lst ) : NEW_LINE INDENT return [ x for x in lst if not isinstance ( x , str ) ] NEW_LINE DEDENT
import ipaddress NEW_LINE for ip in ipaddress . IPv4Network ( '192.168.0.0/24' ) : NEW_LINE INDENT print ( ip ) NEW_LINE DEDENT
def check_identical ( lst ) : NEW_LINE INDENT return len ( set ( lst ) ) == 1 NEW_LINE DEDENT
def increment ( s ) : NEW_LINE INDENT return str ( int ( s ) + 1 ) . zfill ( len ( s ) ) NEW_LINE DEDENT
a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE for i in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE keys = [ ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' ] NEW_LINE values = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] , [ 10 , 11 , 12 ] , [ 13 , 14 , 15 ] , [ 16 , 17 , 18 ] ] NEW_LINE d = defaultdict ( list ) NEW_LINE for k , v in zip ( keys , values ) : NEW_LINE INDENT d [ k ] . append ( v ) NEW_LINE DEDENT print ( d ) NEW_LINE
with open ( ' file . txt ' , ' r ' ) as f : NEW_LINE INDENT for line in f : NEW_LINE INDENT print ( line , end = ' ' ) NEW_LINE DEDENT DEDENT
import datetime NEW_LINE def order_by_date ( list_of_dicts ) : NEW_LINE INDENT return sorted ( list_of_dicts , key = lambda x : datetime . datetime . strptime ( x [ ' date ' ] , ' % Y - % m - % d ' ) ) NEW_LINE DEDENT
def is_all_upper ( text : str ) -> bool : NEW_LINE INDENT return text . isupper ( ) NEW_LINE DEDENT
from operator import itemgetter NEW_LINE list_of_strings = [ ' a , b , c ' , ' d , e , f ' , ' g , h , i ' ] NEW_LINE sorted_list = sorted ( list_of_strings , key = lambda x : x . split ( ' , ' ) [ 1 ] ) NEW_LINE print ( sorted_list ) NEW_LINE
def remove_if ( predicate , lst ) : NEW_LINE INDENT return [ x for x in lst if not predicate ( x ) ] NEW_LINE DEDENT
def sum_nested_list ( nested_list ) : NEW_LINE INDENT total = 0 NEW_LINE for item in nested_list : NEW_LINE INDENT if isinstance ( item , list ) : NEW_LINE INDENT total += sum_nested_list ( item ) NEW_LINE DEDENT else : NEW_LINE INDENT total += item NEW_LINE DEDENT DEDENT return total NEW_LINE DEDENT
import re NEW_LINE re . sub ( r ' [ ^ a - zA - Z0-9 ] ' , ' ' , ' abc123' ) NEW_LINE
import numpy as np NEW_LINE import matplotlib . pyplot as plt NEW_LINE from matplotlib . colors import LogNorm NEW_LINE np . random . seed ( 19680801 ) NEW_LINE dt = 0.01 NEW_LINE t = np . arange ( 0 , 30 , dt ) NEW_LINE nse1 = np . random . randn ( len ( t ) ) NEW_LINE nse2 = np . random . randn ( len ( t ) ) NEW_LINE s1 = np . sin ( 2 * np . pi * 10 * t ) + nse1 NEW_LINE s2 = np . sin ( 2 * np . pi * 10 * t ) + nse2 NEW_LINE fig , axs = plt . subplots ( 2 , 1 ) NEW_LINE axs [ 0 ] . plot ( t , s1 , t , s2 ) NEW_LINE axs [ 0 ] . set_xlim ( 0 , 2 ) NEW_LINE axs [ 0 ] . set_xlabel ( ' time ' ) NEW_LINE axs [ 0 ] . set_ylabel ( ' s1 ▁ and ▁ s2' ) NEW_LINE axs [ 0 ] . grid ( True ) NEW_LINE cxy , f = axs [ 1 ] . cohere ( s1 , s2 , 256 , 1. / dt ) NEW_LINE axs [ 1 ] . set_ylabel ( ' coherence ' ) NEW_LINE fig . tight_layout ( ) NEW_LINE plt . show ( ) NEW_LINE
from django . db . models import Max NEW_LINE max_value = Model . objects . all ( ) . aggregate ( Max ( ' field _ name ' ) ) NEW_LINE
import re NEW_LINE def find_between ( s , first , last ) : NEW_LINE INDENT try : NEW_LINE INDENT start = s . index ( first ) + len ( first ) NEW_LINE end = s . index ( last , start ) NEW_LINE return s [ start : end ] NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return " " NEW_LINE DEDENT DEDENT def find_between_r ( s , first , last ) : NEW_LINE INDENT try : NEW_LINE INDENT start = s . rindex ( first ) + len ( first ) NEW_LINE end = s . rindex ( last , start ) NEW_LINE return s [ start : end ] NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return " " NEW_LINE DEDENT DEDENT def find_between_regex ( s , first , last ) : NEW_LINE INDENT try : NEW_LINE INDENT start = re . search ( first , s ) . end ( ) NEW_LINE end = re . search ( last , s ) . start ( ) NEW_LINE return s [ start : end ] NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT return " " NEW_LINE DEDENT DEDENT s = " This ▁ is ▁ a ▁ string " NEW_LINE print find_between ( s , " is " , " a " ) NEW_LINE print find_between_r ( s , " is " , " a " ) NEW_LINE print find_between_regex ( s , " is " , " a " ) NEW_LINE
import xlrd NEW_LINE book = xlrd . open_workbook ( " file . xls " ) NEW_LINE sheet = book . sheet_by_name ( " Sheet1" ) NEW_LINE data = [ sheet . row_values ( i ) for i in range ( sheet . nrows ) ] NEW_LINE with open ( ' file . txt ' , ' w ' ) as f : NEW_LINE INDENT for line in data : NEW_LINE INDENT f . write ( str ( line ) + ' \n ' ) NEW_LINE DEDENT DEDENT
for file in files : NEW_LINE INDENT print ( file ) NEW_LINE DEDENT
def longest_word ( words ) : NEW_LINE INDENT longest = 0 NEW_LINE for word in words : NEW_LINE INDENT if len ( word ) > longest : NEW_LINE INDENT longest = len ( word ) NEW_LINE DEDENT DEDENT return longest NEW_LINE DEDENT print ( longest_word ( [ ' cat ' , ' dog ' , ' elephant ' ] ) ) NEW_LINE
import pprint NEW_LINE import logging NEW_LINE logging . basicConfig ( filename = ' example . log ' , level = logging . DEBUG ) NEW_LINE data = [ ( i , { ' a ' : ' A ' , ' b ' : ' B ' , ' c ' : ' C ' , ' d ' : ' D ' , ' e ' : ' E ' , ' f ' : ' F ' , ' g ' : ' G ' , ' h ' : ' H ' , ' i ' : ' I ' , ' j ' : ' J ' , ' k ' : ' K ' , ' l ' : ' L ' , ' m ' : ' M ' , ' n ' : ' N ' , ' o ' : ' O ' , ' p ' : ' P ' , ' q ' : ' Q ' , ' r ' : ' R ' , ' s ' : ' S ' , ' t ' : ' T ' , ' u ' : ' U ' , ' v ' : ' V ' , ' w ' : ' W ' , ' x ' : ' X ' , ' y ' : ' Y ' , ' z ' : ' Z ' } ) for i in range ( 10 ) ] NEW_LINE logging . debug ( pprint . pformat ( data ) ) NEW_LINE
import os NEW_LINE def check_dir ( dir ) : NEW_LINE INDENT if not os . path . exists ( dir ) : NEW_LINE INDENT os . makedirs ( dir ) NEW_LINE DEDENT DEDENT
def convert_list_of_lists_to_list_of_integers ( list_of_lists ) : NEW_LINE INDENT return [ int ( item ) for sublist in list_of_lists for item in sublist ] NEW_LINE DEDENT
d = { ' a ' : 1 , ' b ' : None , ' c ' : 3 } NEW_LINE d = { k : v for k , v in d . items ( ) if v is not None } NEW_LINE
def find_largest_key ( d ) : NEW_LINE INDENT return max ( k for k , v in d . items ( ) if v ) NEW_LINE DEDENT d = { ' a ' : 0 , ' b ' : 1 , ' c ' : 2 , ' d ' : 0 } NEW_LINE print ( find_largest_key ( d ) ) NEW_LINE
for key , value in cursor : NEW_LINE INDENT print ( key , value ) NEW_LINE DEDENT
l = [ True , False , True , False , True ] NEW_LINE l . index ( True ) NEW_LINE
f = open ( ' test . txt ' , ' w ' ) NEW_LINE f . write ( ' This ▁ is ▁ a ▁ test \n ' ) NEW_LINE f . close ( ) NEW_LINE
list1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE list2 = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE list1 . extend ( list2 ) NEW_LINE print ( list1 ) NEW_LINE
import datetime NEW_LINE def convert_epoch_to_datetime ( epoch_time ) : NEW_LINE INDENT return datetime . datetime . fromtimestamp ( epoch_time / 1000 ) NEW_LINE DEDENT print ( convert_epoch_to_datetime ( 1588291200000 ) ) NEW_LINE
import re NEW_LINE def replace_word ( text , word , replacement ) : NEW_LINE INDENT regex = r " \b " + word + r " \b " NEW_LINE return re . sub ( regex , replacement , text ) NEW_LINE DEDENT
from datetime import date , timedelta NEW_LINE from dateutil . rrule import rrule , MONTHLY , FR NEW_LINE def get_second_friday ( year , month ) : NEW_LINE INDENT return list ( rrule ( freq = MONTHLY , byweekday = FR ( 2 ) , dtstart = date ( year , month , 1 ) ) ) [ 1 ] NEW_LINE DEDENT def get_daterange ( year , month ) : NEW_LINE INDENT second_friday = get_second_friday ( year , month ) NEW_LINE return second_friday - timedelta ( days = 7 ) , second_friday + timedelta ( days = 7 ) NEW_LINE DEDENT print ( get_daterange ( 2020 , 1 ) ) NEW_LINE
import codecs NEW_LINE s = ' Привет ' NEW_LINE s = s . decode ( ' cp1251' ) NEW_LINE s = s . encode ( ' utf - 8' ) NEW_LINE
def get_last_part ( s , c ) : NEW_LINE INDENT return s . rsplit ( c , 1 ) [ - 1 ] NEW_LINE DEDENT print ( get_last_part ( ' https : / / www . w3resource . com / python - exercises / string ' , ' / ' ) ) NEW_LINE print ( get_last_part ( ' https : / / www . w3resource . com / python - exercises / string ' , ' - ' ) ) NEW_LINE
import os NEW_LINE def find_files ( suffix , path ) : NEW_LINE INDENT if not os . path . isdir ( path ) : NEW_LINE INDENT return " Not ▁ a ▁ valid ▁ directory " NEW_LINE DEDENT if not suffix : NEW_LINE INDENT return " Suffix ▁ cannot ▁ be ▁ empty " NEW_LINE DEDENT if not path : NEW_LINE INDENT return " Path ▁ cannot ▁ be ▁ empty " NEW_LINE DEDENT if not os . path . exists ( path ) : NEW_LINE INDENT return " Path ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( suffix ) : NEW_LINE INDENT return " Suffix ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( path ) : NEW_LINE INDENT return " Path ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( suffix ) : NEW_LINE INDENT return " Suffix ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( path ) : NEW_LINE INDENT return " Path ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( suffix ) : NEW_LINE INDENT return " Suffix ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( path ) : NEW_LINE INDENT return " Path ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( suffix ) : NEW_LINE INDENT return " Suffix ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( path ) : NEW_LINE INDENT return " Path ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( suffix ) : NEW_LINE INDENT return " Suffix ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( path ) : NEW_LINE INDENT return " Path ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( suffix ) : NEW_LINE INDENT return " Suffix ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( path ) : NEW_LINE INDENT return " Path ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( suffix ) : NEW_LINE INDENT return   " Suffix does not exist NEW_LINE DEDENT DEDENT
import urllib2 NEW_LINE url = ' http : / / www . python . org / ftp / python / 2.7.5 / Python - 2.7.5 . tar . bz2' NEW_LINE response = urllib2 . urlopen ( url ) NEW_LINE data = response . read ( ) NEW_LINE with open ( ' Python - 2.7.5 . tar . bz2' , ' wb ' ) as f : NEW_LINE INDENT f . write ( data ) NEW_LINE DEDENT
import re NEW_LINE def replace_whitespace ( string , replace_with ) : NEW_LINE INDENT return re . sub ( r ' \s + ' , replace_with , string ) NEW_LINE DEDENT replace_whitespace ( ' Hello ▁ World ' , ' _ ' ) NEW_LINE replace_whitespace ( ' Hello _ World ' , ' ▁ ' ) NEW_LINE
from operator import attrgetter NEW_LINE class Person : NEW_LINE INDENT def __init__ ( self , name , age ) : NEW_LINE INDENT self . name = name NEW_LINE self . age = age NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return repr ( ( self . name , self . age ) ) NEW_LINE DEDENT DEDENT people = [ Person ( ' John ' , 30 ) , Person ( ' Adam ' , 20 ) , Person ( ' Smith ' , 40 ) ] NEW_LINE print ( sorted ( people , key = attrgetter ( ' age ' ) ) ) NEW_LINE
def convert_list_of_string_to_list_of_integer ( list_of_string ) : NEW_LINE INDENT list_of_integer = [ ] NEW_LINE for string in list_of_string : NEW_LINE INDENT list_of_integer . append ( int ( string ) ) NEW_LINE DEDENT return list_of_integer NEW_LINE DEDENT
from operator import itemgetter NEW_LINE list_of_dicts = [ { ' name ' : ' John ' , ' age ' : 25 } , { ' name ' : ' Jane ' , ' age ' : 17 } , { ' name ' : ' Bob ' , ' age ' : 30 } ] NEW_LINE sorted ( list_of_dicts , key = itemgetter ( ' age ' ) ) NEW_LINE sorted ( list_of_dicts , key = itemgetter ( ' age ' ) , reverse = True ) NEW_LINE
def remove_special_characters ( string ) : NEW_LINE INDENT regex = re . compile ( ' [ ^ a - zA - Z\d ] ' ) NEW_LINE return regex . sub ( ' ' , string ) NEW_LINE DEDENT remove_special_characters ( " The ▁ quick ▁ brown ▁ fox ! " ) NEW_LINE
class MyModel ( models . Model ) : NEW_LINE INDENT my_field = models . CharField ( max_length = 100 , default = ' default ▁ value ' ) NEW_LINE DEDENT
from pycassa . system_manager import * NEW_LINE sys = SystemManager ( '127.0.0.1:9160' ) NEW_LINE ks = sys . get_keyspace ( ' Keyspace1' ) NEW_LINE cf = ks . get_column_family ( ' Standard1' ) NEW_LINE for key in cf . get_range ( ) : NEW_LINE INDENT print key NEW_LINE DEDENT
import numpy as np NEW_LINE a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE b = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE c = np . array ( [ a , b ] ) NEW_LINE print ( c ) NEW_LINE
string = " Hello ▁ World " NEW_LINE string . count ( " l " ) NEW_LINE
import re NEW_LINE def escape_quotes ( s ) : NEW_LINE INDENT return re . sub ( r ' ( [ " \ ' ] ) ' , r ' \\\1' , s ) NEW_LINE DEDENT
from datetime import datetime , timedelta NEW_LINE datetime . now ( ) - timedelta ( days = 365 * 100 ) NEW_LINE datetime . now ( ) + timedelta ( days = 365 * 100 ) NEW_LINE
def remove_escape_char ( string ) : NEW_LINE INDENT return string . replace ( ' \\ ' , ' ' ) NEW_LINE DEDENT
import numpy as np NEW_LINE a = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE print ( np . mean ( a , axis = 0 ) ) NEW_LINE print ( np . mean ( a , axis = 1 ) ) NEW_LINE
import sys NEW_LINE while True : NEW_LINE INDENT print ( " Please ▁ enter ▁ a ▁ number : " ) NEW_LINE try : NEW_LINE INDENT number = int ( sys . stdin . readline ( ) ) NEW_LINE print ( " You ▁ entered : " , number ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT print ( " That ▁ was ▁ not ▁ a ▁ number ! " ) NEW_LINE DEDENT DEDENT
import re NEW_LINE text = " This ▁ is ▁ a ▁ [ test ] ▁ of ▁ [ bracket ] ▁ matching " NEW_LINE re . findall ( r ' \ [ ( . * ? ) \ ] ' , text ) NEW_LINE
def last_occurrence ( string , char ) : NEW_LINE INDENT return string . rfind ( char ) NEW_LINE DEDENT
my_list = [ ' a ' , ' b ' , ' c ' , ' d ' ] NEW_LINE ' , ' . join ( my_list ) NEW_LINE
d = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 } NEW_LINE l = [ k for k , v in d . items ( ) ] NEW_LINE
try : NEW_LINE INDENT print ( 1 / 0 ) NEW_LINE DEDENT except : NEW_LINE INDENT print ( " Error " ) NEW_LINE DEDENT
areas = [ " hallway " , 11.25 , " kitchen " , 18.0 , " living ▁ room " , 20.0 , " bedroom " , 10.75 , " bathroom " , 9.50 ] NEW_LINE print ( areas [ 1 ] ) NEW_LINE print ( areas [ - 1 ] ) NEW_LINE print ( areas [ 5 ] ) NEW_LINE areas = [ " hallway " , 11.25 , " kitchen " , 18.0 , " living ▁ room " , 20.0 , " bedroom " , 10.75 , " bathroom " , 9.50 ] NEW_LINE eat_sleep_area = areas [ 3 ] + areas [ - 3 ] NEW_LINE print ( eat_sleep_area ) NEW_LINE areas = [ " hallway " , 11.25 , " kitchen " , 18.0 , " living ▁ room " , 20.0 , " bedroom " , 10.75 , " bathroom " , 9.50 ] NEW_LINE downstairs = areas [ : 6 ] NEW_LINE upstairs = areas [ 6 : ] NEW_LINE print ( downstairs ) NEW_LINE print ( upstairs ) NEW_LINE areas = [ " hallway " , 11.25 , " kitchen " , 18.0 , " living ▁ room " , 20.0 , " bedroom " , 10.75 , " bathroom " , 9.50 ] NEW_LINE downstairs = areas [ : 6 ] NEW_LINE upstairs = areas [ - 4 : ] NEW_LINE areas = [ " hallway " , 11.25 , " kitchen " , 18.0 , " living ▁ room " , 20.0 , " bedroom " , 10.75 , " bathroom " , 9.50 ] NEW_LINE areas [ - 1 ] = 10.50 NEW_LINE
if ' foo ' in locals ( ) : NEW_LINE INDENT print ( ' foo ▁ exists ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' foo ▁ does ▁ not ▁ exist ' ) NEW_LINE DEDENT
import requests NEW_LINE r = requests . get ( ' https : / / httpbin . org / get ' ) NEW_LINE print ( r . text ) NEW_LINE r = requests . post ( ' https : / / httpbin . org / post ' , data = { ' key ' : ' value ' } ) NEW_LINE print ( r . text ) NEW_LINE
def convert_to_int ( list_of_strings ) : NEW_LINE INDENT return [ int ( i ) for i in list_of_strings ] NEW_LINE DEDENT
def to_uppercase ( str ) : NEW_LINE INDENT return str . upper ( ) NEW_LINE DEDENT
my_dict = { i : i for i in my_list } NEW_LINE my_dict = dict . fromkeys ( my_list , 1 ) NEW_LINE my_dict = dict . fromkeys ( my_list ) NEW_LINE
def word_count ( str ) : NEW_LINE INDENT counts = dict ( ) NEW_LINE words = str . split ( ) NEW_LINE for word in words : NEW_LINE INDENT if word in counts : NEW_LINE INDENT counts [ word ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT counts [ word ] = 1 NEW_LINE DEDENT DEDENT return counts NEW_LINE DEDENT print ( word_count ( ' the ▁ quick ▁ brown ▁ fox ▁ jumps ▁ over ▁ the ▁ lazy ▁ dog . ' ) ) NEW_LINE
list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists NEW_LINE
def sum_list_of_tuples ( list_of_tuples ) : NEW_LINE INDENT return sum ( map ( sum , list_of_tuples ) ) NEW_LINE DEDENT
import re NEW_LINE def sort_nicely ( l ) : NEW_LINE INDENT convert = lambda text : int ( text ) if text . isdigit ( ) else text NEW_LINE alphanum_key = lambda key : [ convert ( c ) for c in re . split ( ' ( [0-9 ] + ) ' , key ) ] NEW_LINE l . sort ( key = alphanum_key ) NEW_LINE DEDENT l = [ '1' , '2' , '10' , '11' , '20' , '21' , '100' , '101' , '200' , '201' ] NEW_LINE sort_nicely ( l ) NEW_LINE print ( l ) NEW_LINE
import re NEW_LINE def remove_parentheses ( string ) : NEW_LINE INDENT return re . sub ( r ' \ ( ( [ ^ ) ] + ) \ ) ' , r ' \1' , string ) NEW_LINE DEDENT
a = [ 1 , 2 , 3 ] NEW_LINE b = [ 4 , 5 , 6 ] NEW_LINE a [ : 0 ] = b NEW_LINE print ( a ) NEW_LINE
l = [ 1 , 2 , None , 3 , None , 4 , None ] NEW_LINE l . count ( None ) NEW_LINE
def rreplace ( s , old , new , occurrence ) : NEW_LINE INDENT li = s . rsplit ( old , occurrence ) NEW_LINE return new . join ( li ) NEW_LINE DEDENT
from sqlalchemy import func NEW_LINE session . query ( func . now ( ) ) . all ( ) NEW_LINE
import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . random . randn ( 1000 ) NEW_LINE y = np . random . randn ( 1000 ) NEW_LINE plt . hist2d ( x , y , bins = 40 ) NEW_LINE plt . colorbar ( ) NEW_LINE plt . show ( ) NEW_LINE
def get_all_combination ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return [ [ 0 ] , [ 1 ] ] NEW_LINE DEDENT else : NEW_LINE INDENT result = [ ] NEW_LINE for i in get_all_combination ( n - 1 ) : NEW_LINE INDENT result . append ( i + [ 0 ] ) NEW_LINE result . append ( i + [ 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT print ( get_all_combination ( 3 ) ) NEW_LINE
from collections import Counter NEW_LINE my_list = [ 1 , 1 , 2 , 3 , 4 , 5 , 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 ] NEW_LINE Counter ( my_list ) NEW_LINE Counter ( { 2 : 4 , 3 : 4 , 1 : 3 , 4 : 2 , 5 : 1 } ) NEW_LINE Counter ( my_list ) . items ( ) NEW_LINE dict_items ( [ ( 1 , 3 ) , ( 2 , 4 ) , ( 3 , 4 ) , ( 4 , 2 ) , ( 5 , 1 ) ] ) NEW_LINE Counter ( my_list ) . keys ( ) NEW_LINE dict_keys ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE Counter ( my_list ) . values ( ) NEW_LINE dict_values ( [ 3 , 4 , 4 , 2 , 1 ] ) NEW_LINE
from lxml import etree NEW_LINE html = ''' STRNEWLINE < div > STRNEWLINE ▁ ▁ ▁ ▁ < ul > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 0 " > < a ▁ href = " link1 . html " > first ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 1 " > < a ▁ href = " link2 . html " > second ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - inactive " > < a ▁ href = " link3 . html " > third ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 1 " > < a ▁ href = " link4 . html " > fourth ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 0 " > < a ▁ href = " link5 . html " > fifth ▁ item < / a > STRNEWLINE ▁ ▁ ▁ ▁ ▁ < / ul > STRNEWLINE ▁ < / div > STRNEWLINE ''' NEW_LINE selector = etree . HTML ( html ) NEW_LINE content = selector . xpath ( ' / / li [ @ class = " item - 0 " ] / a / text ( ) ' ) NEW_LINE print ( content ) NEW_LINE
import re NEW_LINE def remove_periods_in_acronyms ( text ) : NEW_LINE INDENT return re . sub ( r ' \b ( [ A - Z ] \ . ) + \b ' , lambda m : m . group ( ) . replace ( ' . ' , ' ' ) , text ) NEW_LINE DEDENT
import re NEW_LINE def replace_non_alphanumeric ( string ) : NEW_LINE INDENT return re . sub ( r ' \W + ' , ' ' , string ) NEW_LINE DEDENT replace_non_alphanumeric ( ' Hello , ▁ World ! ' ) NEW_LINE
matrix = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE my_dict = { ' a ' : [ 1 , 2 , 3 ] , ' b ' : [ 4 , 5 , 6 ] , ' c ' : [ 7 , 8 , 9 ] } NEW_LINE print ( my_dict ) NEW_LINE print ( type ( my_dict ) ) NEW_LINE
def reverse_sublist ( lst , start , end ) : NEW_LINE INDENT lst [ start : end ] = lst [ start : end ] [ : : - 1 ] NEW_LINE return lst NEW_LINE DEDENT
def search_list_in_dict ( dict_to_search , list_to_search ) : NEW_LINE INDENT for key , value in dict_to_search . items ( ) : NEW_LINE INDENT if set ( list_to_search ) . issubset ( value ) : NEW_LINE INDENT return key NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT
import json NEW_LINE json_data = ' { " a " :1 , " b " :2 , " c " :3 , " d " :4 , " e " :5 } ' NEW_LINE text = json . loads ( json_data ) NEW_LINE print ( text ) NEW_LINE
list_of_tuples_1 = [ ( 1 , 2 ) , ( 3 , 4 ) , ( 5 , 6 ) ] NEW_LINE list_of_tuples_2 = [ ( 1 , 2 ) , ( 3 , 4 ) , ( 5 , 6 ) ] NEW_LINE print ( list_of_tuples_1 == list_of_tuples_2 ) NEW_LINE
import re NEW_LINE def sort_by_regex ( lst , regex ) : NEW_LINE INDENT return sorted ( lst , key = lambda x : re . search ( regex , x ) . group ( 0 ) ) NEW_LINE DEDENT
def unicode_to_byte_string ( unicode_string ) : NEW_LINE INDENT return unicode_string . encode ( ' utf - 8' ) NEW_LINE DEDENT
fellowship = [ ' frodo ' , ' samwise ' , ' merry ' , ' aragorn ' , ' legolas ' , ' boromir ' , ' gimli ' ] NEW_LINE result = filter ( lambda member : ' a ' in member , fellowship ) NEW_LINE result_list = list ( result ) NEW_LINE print ( result_list ) NEW_LINE
def delete_item ( list , item ) : NEW_LINE INDENT if item in list : NEW_LINE INDENT list . remove ( item ) NEW_LINE DEDENT DEDENT
a = [ 1 , 2 , 3 ] NEW_LINE b = [ 4 , 5 , 6 ] NEW_LINE c = a + b NEW_LINE print ( c ) NEW_LINE
import datetime NEW_LINE def last_day_of_month ( any_day ) : NEW_LINE INDENT next_month = any_day . replace ( day = 28 ) + datetime . timedelta ( days = 4 ) NEW_LINE return next_month - datetime . timedelta ( days = next_month . day ) NEW_LINE DEDENT
def remove_key ( d , key ) : NEW_LINE INDENT r = dict ( d ) NEW_LINE del r [ key ] NEW_LINE return r NEW_LINE DEDENT def remove_key_from_list ( l , key ) : NEW_LINE INDENT return [ remove_key ( d , key ) for d in l ] NEW_LINE DEDENT
def remove_substring ( string_list , substring_list ) : NEW_LINE INDENT return [ string for string in string_list if not any ( substring in string for substring in substring_list ) ] NEW_LINE DEDENT
list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE zipped_list = list ( zip ( * list_of_lists ) ) NEW_LINE print ( zipped_list ) NEW_LINE
import unicodedata NEW_LINE unicodedata . normalize ( ' NFKD ' , ' \u00e9' ) . upper ( ) NEW_LINE
import numpy as np NEW_LINE a = [ ( ' a ' , np . nan ) , ( ' b ' , 2.0 ) , ( ' c ' , 1.0 ) ] NEW_LINE min ( a , key = lambda x : x [ 1 ] ) NEW_LINE
def most_frequent ( string ) : NEW_LINE INDENT return max ( string , key = string . count ) NEW_LINE DEDENT most_frequent ( ' abca ' ) NEW_LINE
import re NEW_LINE def has_letters ( input_string ) : NEW_LINE INDENT return bool ( re . search ( ' [ a - zA - Z ] ' , input_string ) ) NEW_LINE DEDENT
d = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 , ' d ' : 4 , ' e ' : 5 } NEW_LINE d_avg = { k : sum ( v ) / len ( v ) for k , v in d . items ( ) } NEW_LINE print ( d_avg ) NEW_LINE
a = [ [ 1 , 2 ] , [ 3 , 4 ] , [ 1 , 3 ] ] NEW_LINE a . sort ( key = lambda x : ( x [ 1 ] , - x [ 0 ] ) ) NEW_LINE print ( a ) NEW_LINE
d = { ' a ' : 1 , ' b ' : 2 } NEW_LINE d [ ' c ' ] = 3 NEW_LINE
def first_letter ( word ) : NEW_LINE INDENT return word [ 0 ] NEW_LINE DEDENT first_letter ( " Hello " ) NEW_LINE
import itertools NEW_LINE def get_combinations ( lst ) : NEW_LINE INDENT return list ( itertools . combinations ( lst , 3 ) ) NEW_LINE DEDENT print ( get_combinations ( [ 10 , 1 , 2 , 7 , 6 , 1 , 5 ] ) ) NEW_LINE
from operator import attrgetter NEW_LINE sorted ( student_objects , key = attrgetter ( ' grade ' , ' age ' ) ) NEW_LINE
import numpy as np NEW_LINE import matplotlib . pyplot as plt NEW_LINE
def find_same_index ( list1 , list2 ) : NEW_LINE INDENT index_list = [ ] NEW_LINE for i in range ( len ( list1 ) ) : NEW_LINE INDENT if list1 [ i ] in list2 : NEW_LINE INDENT index_list . append ( i ) NEW_LINE DEDENT DEDENT return index_list NEW_LINE DEDENT list1 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE list2 = [ 1 , 3 , 5 , 7 , 9 ] NEW_LINE print ( find_same_index ( list1 , list2 ) ) NEW_LINE
url = ' http : / / www . example . com / path / to / file . html ' NEW_LINE url . rsplit ( ' / ' , 1 ) [ - 1 ] NEW_LINE
def delete_letters ( string , letters ) : NEW_LINE INDENT for letter in letters : NEW_LINE INDENT string = string . replace ( letter , ' ' ) NEW_LINE DEDENT return string NEW_LINE DEDENT
def is_alpha_space ( string ) : NEW_LINE INDENT return string . replace ( " ▁ " , " " ) . isalpha ( ) NEW_LINE DEDENT print ( is_alpha_space ( " Hello ▁ World " ) ) NEW_LINE print ( is_alpha_space ( " HelloWorld " ) ) NEW_LINE print ( is_alpha_space ( " Hello ▁ World ▁ 123" ) ) NEW_LINE
a = [ 1 , 2 , 3 ] NEW_LINE b = [ [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE c = a + b NEW_LINE print ( c ) NEW_LINE
stock = { ' GOOG ' : 520.54 , ' FB ' : 76.45 , ' YHOO ' : 39.28 , ' AMZN ' : 306.21 , ' AAPL ' : 99.76 } NEW_LINE print ( stock ) NEW_LINE min_price = min ( zip ( stock . values ( ) , stock . keys ( ) ) ) NEW_LINE max_price = max ( zip ( stock . values ( ) , stock . keys ( ) ) ) NEW_LINE print ( min_price ) NEW_LINE print ( max_price ) NEW_LINE prices_sorted = sorted ( zip ( stock . values ( ) , stock . keys ( ) ) ) NEW_LINE print ( prices_sorted ) NEW_LINE
if item in list : NEW_LINE INDENT print ( " Item ▁ is ▁ in ▁ the ▁ list " ) NEW_LINE DEDENT
from operator import itemgetter NEW_LINE list_of_dicts = [ { ' name ' : ' John ' , ' age ' : 25 } , { ' name ' : ' Jane ' , ' age ' : 17 } , { ' name ' : ' Bob ' , ' age ' : 30 } ] NEW_LINE sorted ( list_of_dicts , key = itemgetter ( ' age ' ) ) NEW_LINE
import re NEW_LINE def is_ascii ( s ) : NEW_LINE INDENT return all ( ord ( c ) < 128 for c in s ) NEW_LINE DEDENT def is_ascii_re ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] + $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re2 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re3 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] {0 , } $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re4 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re5 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re6 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re7 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re8 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re9 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re10 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re11 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re12 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT
import datetime NEW_LINE current_date = datetime . datetime . now ( ) NEW_LINE six_months_later = current_date + datetime . timedelta ( days = 180 ) NEW_LINE print ( six_months_later ) NEW_LINE
tuple1 = ( 1 , 2 , 3 ) NEW_LINE tuple2 = ( 4 , 5 , 6 ) NEW_LINE tuple3 = tuple1 + tuple2 NEW_LINE print ( tuple3 ) NEW_LINE
import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE y = np . sin ( x ) NEW_LINE fig , ax = plt . subplots ( ) NEW_LINE im = ax . imshow ( y . reshape ( ( 10 , 10 ) ) , cmap = ' viridis ' ) NEW_LINE fig . colorbar ( im , ax = ax ) NEW_LINE plt . show ( ) NEW_LINE
def decode_string ( s ) : NEW_LINE INDENT try : NEW_LINE INDENT return s . decode ( ' utf8' ) NEW_LINE DEDENT except UnicodeDecodeError : NEW_LINE INDENT return s . decode ( ' latin1' ) NEW_LINE DEDENT DEDENT def encode_string ( s ) : NEW_LINE INDENT try : NEW_LINE INDENT return s . encode ( ' utf8' ) NEW_LINE DEDENT except UnicodeEncodeError : NEW_LINE INDENT return s . encode ( ' latin1' ) NEW_LINE DEDENT DEDENT
list1 = [ 1 , 2 , 3 ] NEW_LINE list2 = [ 4 , 5 , 6 ] NEW_LINE list3 = list1 + list2 NEW_LINE print ( list3 ) NEW_LINE
f = open ( " test . txt " , " a " ) NEW_LINE f . write ( " Hello ▁ World " ) NEW_LINE f . close ( ) NEW_LINE
import psutil NEW_LINE print ( psutil . cpu_percent ( ) ) NEW_LINE print ( psutil . virtual_memory ( ) ) NEW_LINE
import unicodedata NEW_LINE def unicode_name ( s ) : NEW_LINE INDENT return unicodedata . name ( s ) NEW_LINE DEDENT
def trim_whitespace ( s ) : NEW_LINE INDENT return s . strip ( ) NEW_LINE DEDENT
def remove_none ( lst ) : NEW_LINE INDENT return [ i for i in lst if i is not None ] NEW_LINE DEDENT
import re NEW_LINE def find_surrounding_sentence ( text , word ) : NEW_LINE INDENT sentences = re . split ( r ' ▁ * [ \ . \ ? ! ] [ \ ' " \ ) \ ] ] * ▁ * ' , text ) NEW_LINE for sentence in sentences : NEW_LINE INDENT if word in sentence : NEW_LINE INDENT return sentence NEW_LINE DEDENT DEDENT DEDENT text = " Hello , ▁ my ▁ name ▁ is ▁ John . ▁ I ▁ am ▁ a ▁ software ▁ engineer . ▁ I ▁ like ▁ to ▁ code ▁ in ▁ Python . " NEW_LINE word = " Python " NEW_LINE print ( find_surrounding_sentence ( text , word ) ) NEW_LINE
from sklearn . cluster import KMeans NEW_LINE import numpy as np NEW_LINE X = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ) NEW_LINE kmeans = KMeans ( n_clusters = 3 , random_state = 0 ) . fit ( X . reshape ( - 1 , 1 ) ) NEW_LINE print ( kmeans . labels_ ) NEW_LINE
import datetime NEW_LINE import pytz NEW_LINE utc = pytz . utc NEW_LINE today = datetime . date . today ( ) NEW_LINE print ( today ) NEW_LINE utc_today = utc . localize ( today ) NEW_LINE print ( utc_today ) NEW_LINE
def checkKey ( dict , key ) : NEW_LINE INDENT if key in dict . keys ( ) : NEW_LINE INDENT print ( " Present , ▁ " , end = " ▁ " ) NEW_LINE print ( " value ▁ = " , dict [ key ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ present " ) NEW_LINE DEDENT DEDENT dict = { ' a ' : 100 , ' b ' : 200 , ' c ' : 300 } NEW_LINE key = ' b ' NEW_LINE checkKey ( dict , key ) NEW_LINE key = ' w ' NEW_LINE checkKey ( dict , key ) NEW_LINE
def sort_list_of_lists ( list_of_lists , index ) : NEW_LINE INDENT return sorted ( list_of_lists , key = lambda x : x [ index ] ) NEW_LINE DEDENT
import urllib NEW_LINE import urllib2 NEW_LINE def url_get ( url , params ) : NEW_LINE INDENT return urllib2 . urlopen ( url + ' ? ' + urllib . urlencode ( params ) ) . read ( ) NEW_LINE DEDENT def url_post ( url , params ) : NEW_LINE INDENT return urllib2 . urlopen ( url , urllib . urlencode ( params ) ) . read ( ) NEW_LINE DEDENT
import json NEW_LINE with open ( ' data . json ' ) as f : NEW_LINE INDENT data = json . load ( f ) NEW_LINE DEDENT sorted_data = sorted ( data . items ( ) , key = lambda x : x [ 1 ] [ ' key ' ] ) NEW_LINE
import random NEW_LINE def random_item ( list ) : NEW_LINE INDENT return random . choice ( list ) NEW_LINE DEDENT
numbers = [ '1' , '2' , '3' , '4' , '5' ] NEW_LINE numbers = [ int ( i ) for i in numbers ] NEW_LINE
def remove_duplicates ( list_of_sets ) : NEW_LINE INDENT return list ( set ( map ( frozenset , list_of_sets ) ) ) NEW_LINE DEDENT
objects = [ { ' name ' : ' John ' , ' age ' : 20 } , { ' name ' : ' Mary ' , ' age ' : 30 } , { ' name ' : ' Bob ' , ' age ' : 25 } ] NEW_LINE names = [ obj [ ' name ' ] for obj in objects ] NEW_LINE ages = [ obj [ ' age ' ] for obj in objects ] NEW_LINE
import sys NEW_LINE from PyQt5 . QtWidgets import QApplication , QWidget , QPushButton NEW_LINE from PyQt5 . QtGui import QIcon NEW_LINE from PyQt5 . QtCore import pyqtSlot NEW_LINE class App ( QWidget ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT super ( ) . __init__ ( ) NEW_LINE self . title = ' PyQt5 ▁ button ▁ - ▁ pythonspot . com ' NEW_LINE self . left = 10 NEW_LINE self . top = 10 NEW_LINE self . width = 320 NEW_LINE self . height = 200 NEW_LINE self . initUI ( ) NEW_LINE DEDENT def initUI ( self ) : NEW_LINE INDENT self . setWindowTitle ( self . title ) NEW_LINE self . setGeometry ( self . left , self . top , self . width , self . height ) NEW_LINE button = QPushButton ( ' PyQt5 ▁ button ' , self ) NEW_LINE button . setStyleSheet ( " background - color : ▁ green " ) NEW_LINE button . setToolTip ( ' This ▁ is ▁ an ▁ example ▁ button ' ) NEW_LINE button . move ( 100 , 70 ) NEW_LINE button . clicked . connect ( self . on_click ) NEW_LINE self . show ( ) NEW_LINE DEDENT @ pyqtSlot ( ) NEW_LINE def on_click ( self ) : NEW_LINE INDENT print ( ' PyQt5 ▁ button ▁ click ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT app = QApplication ( sys . argv ) NEW_LINE ex = App ( ) NEW_LINE sys . exit ( app . exec_ ( ) ) NEW_LINE DEDENT
import re NEW_LINE re . findall ( r ' \d + ' , ' abc123def456' ) NEW_LINE
from google . appengine . ext import webapp NEW_LINE class MainPage ( webapp . RequestHandler ) : NEW_LINE INDENT def get ( self ) : NEW_LINE INDENT self . response . headers [ ' Content - Type ' ] = ' text / plain ' NEW_LINE self . response . out . write ( self . request . query_string ) NEW_LINE DEDENT DEDENT
import re NEW_LINE text = " Hello , ▁ my ▁ name ▁ is ▁ John . ▁ I ▁ am ▁ a ▁ software ▁ engineer . ▁ I ▁ am ▁ from ▁ Egypt . ▁ I ▁ speak ▁ Arabic ▁ and ▁ English . " NEW_LINE arabic_text = re . findall ( r ' [ \u0600 - \u06FF ] + ' , text ) NEW_LINE print ( arabic_text ) NEW_LINE
fellowship = [ ' frodo ' , ' samwise ' , ' merry ' , ' aragorn ' , ' legolas ' , ' boromir ' , ' gimli ' ] NEW_LINE new_fellowship = { member : len ( member ) for member in fellowship } NEW_LINE print ( new_fellowship ) NEW_LINE
from itertools import permutations NEW_LINE def find_all_sequences ( lst ) : NEW_LINE INDENT return list ( permutations ( lst ) ) NEW_LINE DEDENT
def reverse_string ( string ) : NEW_LINE INDENT return string [ : : - 1 ] NEW_LINE DEDENT print ( reverse_string ( " Hello " ) ) NEW_LINE
import json NEW_LINE with open ( ' data . json ' ) as json_file : NEW_LINE INDENT data = json . load ( json_file ) NEW_LINE for p in data [ ' people ' ] : NEW_LINE INDENT print ( ' Name : ▁ ' + p [ ' name ' ] ) NEW_LINE print ( ' Website : ▁ ' + p [ ' website ' ] ) NEW_LINE print ( ' From : ▁ ' + p [ ' from ' ] ) NEW_LINE print ( ' ' ) NEW_LINE DEDENT DEDENT
def chunks ( l , n ) : NEW_LINE INDENT for i in range ( 0 , len ( l ) , n ) : NEW_LINE INDENT yield l [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list_2 ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list_3 ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list_4 ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list_5 ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list_6 ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list_7 ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list_8 ( s , n ) : NEW_LINE
def sort_list ( list_of_lists ) : NEW_LINE INDENT return sorted ( list_of_lists , key = lambda x : x [ 1 ] ) NEW_LINE DEDENT
def starts_with_number ( s ) : NEW_LINE INDENT return s [ 0 ] . isdigit ( ) NEW_LINE DEDENT
def is_number ( s ) : NEW_LINE INDENT try : NEW_LINE INDENT float ( s ) NEW_LINE return True NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
import re NEW_LINE text = ' abbaaabbbbaaaaa ' NEW_LINE pattern = ' ab ' NEW_LINE for match in re . finditer ( pattern , text ) : NEW_LINE INDENT s = match . start ( ) NEW_LINE e = match . end ( ) NEW_LINE print ( ' Found ▁ " % s " ▁ at ▁ % d : % d ' % ( text [ s : e ] , s , e ) ) NEW_LINE DEDENT
from hashlib import sha256 NEW_LINE def hash_dict ( d ) : NEW_LINE INDENT return sha256 ( str ( sorted ( d . items ( ) ) ) . encode ( ' utf - 8' ) ) . hexdigest ( ) NEW_LINE DEDENT d1 = { ' a ' : 1 , ' b ' : 2 } NEW_LINE d2 = { ' b ' : 2 , ' a ' : 1 } NEW_LINE print ( hash_dict ( d1 ) ) NEW_LINE print ( hash_dict ( d2 ) ) NEW_LINE
from tkinter import * NEW_LINE root = Tk ( ) NEW_LINE canvas = Canvas ( root , width = 200 , height = 100 ) NEW_LINE canvas . pack ( ) NEW_LINE canvas . create_text ( 100 , 50 , text = " Hello ▁ World " , font = ( " Times " , 20 ) ) NEW_LINE root . mainloop ( ) NEW_LINE
def contains_lists ( lst ) : NEW_LINE INDENT for item in lst : NEW_LINE INDENT if isinstance ( item , list ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
import binascii NEW_LINE binascii . unhexlify ( '1a2b3c ' ) NEW_LINE
a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE a [ - 1 ] NEW_LINE
import sys NEW_LINE def get_input ( ) : NEW_LINE INDENT return sys . stdin . read ( 1 ) NEW_LINE DEDENT
def find ( s , ch ) : NEW_LINE INDENT return [ i for i , ltr in enumerate ( s ) if ltr == ch ] NEW_LINE DEDENT
import numpy as np NEW_LINE def str_to_float ( x ) : NEW_LINE INDENT return np . float ( hash ( x ) ) NEW_LINE DEDENT df [ ' Fault ' ] = df [ ' Fault ' ] . apply ( str_to_float ) NEW_LINE
import re NEW_LINE def replace_all ( text , dic ) : NEW_LINE INDENT for i , j in dic . iteritems ( ) : NEW_LINE INDENT text = re . sub ( i , j , text ) NEW_LINE DEDENT return text NEW_LINE DEDENT text = " My ▁ name ▁ is ▁ David . ▁ Hi ▁ David . " NEW_LINE dic = { ' David ' : ' Amy ' } NEW_LINE print replace_all ( text , dic ) NEW_LINE
def find_all ( a_list , elem ) : NEW_LINE INDENT return [ i for i , x in enumerate ( a_list ) if x == elem ] NEW_LINE DEDENT
import requests NEW_LINE from bs4 import BeautifulSoup NEW_LINE url = ' https : / / www . nytimes . com / ' NEW_LINE r = requests . get ( url ) NEW_LINE r_html = r . text NEW_LINE soup = BeautifulSoup ( r_html , ' html . parser ' ) NEW_LINE for story_heading in soup . find_all ( class_ = " story - heading " ) : NEW_LINE INDENT if story_heading . a : NEW_LINE INDENT print ( story_heading . a . text . replace ( " \n " , " ▁ " ) . strip ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( story_heading . contents [ 0 ] . strip ( ) ) NEW_LINE DEDENT DEDENT
x = 5 NEW_LINE if type ( x ) == int : NEW_LINE INDENT print ( " x ▁ is ▁ an ▁ integer " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " x ▁ is ▁ not ▁ an ▁ integer " ) NEW_LINE DEDENT
import numpy as np NEW_LINE arr = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE arr [ arr [ : , 1 ] . argsort ( ) ] NEW_LINE
class A : NEW_LINE INDENT pass NEW_LINE DEDENT class B ( A ) : NEW_LINE INDENT pass NEW_LINE DEDENT b = B ( ) NEW_LINE print ( b . __class__ . __name__ ) NEW_LINE
def sort_tuple ( tup ) : NEW_LINE INDENT return sorted ( tup , key = lambda x : x [ 1 ] ) NEW_LINE DEDENT
import re NEW_LINE def find_pattern ( string ) : NEW_LINE INDENT pattern = re . compile ( r ' ( \w + ) \1' ) NEW_LINE match = pattern . search ( string ) NEW_LINE if match : NEW_LINE INDENT return match . group ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT print ( find_pattern ( ' abcabcabc ' ) ) NEW_LINE print ( find_pattern ( ' abcabc ' ) ) NEW_LINE print ( find_pattern ( ' abc ' ) ) NEW_LINE print ( find_pattern ( ' ababab ' ) ) NEW_LINE print ( find_pattern ( ' abab ' ) ) NEW_LINE print ( find_pattern ( ' ab ' ) ) NEW_LINE print ( find_pattern ( ' a ' ) ) NEW_LINE print ( find_pattern ( ' ' ) ) NEW_LINE
import mysql . connector NEW_LINE cnx = mysql . connector . connect ( user = ' scott ' , password = ' password ' , host = '127.0.0.1' , database = ' employees ' ) NEW_LINE cursor = cnx . cursor ( ) NEW_LINE cursor . execute ( " SET ▁ SESSION ▁ query _ cache _ type ▁ = ▁ OFF " ) NEW_LINE cursor . execute ( " SELECT ▁ * ▁ FROM ▁ employees ▁ LIMIT ▁ 10" ) NEW_LINE results = cursor . fetchall ( ) NEW_LINE for row in results : NEW_LINE INDENT print ( row ) NEW_LINE DEDENT cursor . close ( ) NEW_LINE cnx . close ( ) NEW_LINE
import urllib . request NEW_LINE url = ' http : / / www . python . org / ' NEW_LINE urllib . request . urlretrieve ( url , ' python . html ' ) NEW_LINE
import requests NEW_LINE from bs4 import BeautifulSoup NEW_LINE url = ' https : / / www . youtube . com / watch ? v = 9bZkp7q19f0' NEW_LINE r = requests . get ( url ) NEW_LINE soup = BeautifulSoup ( r . text , ' html . parser ' ) NEW_LINE title = soup . find ( ' meta ' , attrs = { ' property ' : ' og : title ' } ) NEW_LINE description = soup . find ( ' meta ' , attrs = { ' property ' : ' og : description ' } ) NEW_LINE image = soup . find ( ' meta ' , attrs = { ' property ' : ' og : image ' } ) NEW_LINE print ( title [ ' content ' ] ) NEW_LINE print ( description [ ' content ' ] ) NEW_LINE print ( image [ ' content ' ] ) NEW_LINE
sorted ( [ ' abc ' , ' a ' , ' ab ' ] , key = lambda x : ( len ( x ) , x ) ) NEW_LINE [ ' a ' , ' ab ' , ' abc ' ] NEW_LINE
def convert_to_base_10 ( string ) : NEW_LINE INDENT return int ( string , 2 ) NEW_LINE DEDENT
def count_substring ( string , sub_string ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i : i + len ( sub_string ) ] == sub_string : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = input ( ) . strip ( ) NEW_LINE sub_string = input ( ) . strip ( ) NEW_LINE count = count_substring ( string , sub_string ) NEW_LINE print ( count ) NEW_LINE DEDENT
from bs4 import UnicodeDammit NEW_LINE def decode_html ( html_string ) : NEW_LINE INDENT converted = UnicodeDammit ( html_string , is_html = True ) NEW_LINE if not converted . unicode_markup : NEW_LINE INDENT raise UnicodeDecodeError ( " Failed ▁ to ▁ detect ▁ encoding , ▁ tried ▁ [ % s ] " , ' , ▁ ' . join ( converted . tried_encodings ) ) NEW_LINE DEDENT return converted . unicode_markup NEW_LINE DEDENT
a = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE del a [ 1 : 5 ] NEW_LINE a NEW_LINE [ 1 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE
import xlsxwriter NEW_LINE workbook = xlsxwriter . Workbook ( ' / home / user / Desktop / test . xlsx ' ) NEW_LINE worksheet = workbook . add_worksheet ( ) NEW_LINE worksheet . write ( ' A1' , ' Hello ▁ world ' ) NEW_LINE workbook . close ( ) NEW_LINE
d = { ' a ' : '1' , ' b ' : '2' , ' c ' : '3' } NEW_LINE d = { k : int ( v ) for k , v in d . items ( ) } NEW_LINE
d = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 } NEW_LINE l = list ( d . items ( ) ) NEW_LINE
s = " Hello ▁ World " NEW_LINE print ( s [ 0 : 5 ] ) NEW_LINE
def find_consecutive_consonants ( word ) : NEW_LINE INDENT vowels = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] NEW_LINE consonants = [ ] NEW_LINE for letter in word : NEW_LINE INDENT if letter not in vowels : NEW_LINE INDENT consonants . append ( letter ) NEW_LINE DEDENT DEDENT return ' ' . join ( consonants ) NEW_LINE DEDENT print ( find_consecutive_consonants ( ' strengths ' ) ) NEW_LINE
objects = [ { ' name ' : ' object1' , ' id ' : 1 } , { ' name ' : ' object2' , ' id ' : 2 } , { ' name ' : ' object3' , ' id ' : 3 } , { ' name ' : ' object4' , ' id ' : 4 } , { ' name ' : ' object5' , ' id ' : 5 } , ] NEW_LINE for obj in objects : NEW_LINE INDENT obj . delete ( ) NEW_LINE DEDENT
import yaml NEW_LINE with open ( ' config . yaml ' ) as f : NEW_LINE INDENT config = yaml . load ( f ) NEW_LINE DEDENT print ( config ) NEW_LINE
import numpy as np NEW_LINE data = np . recfromcsv ( ' data / data . csv ' ) NEW_LINE print data . dtype NEW_LINE print data [ 0 ] NEW_LINE print data [ - 1 ] NEW_LINE
import psycopg2 NEW_LINE conn = psycopg2 . connect ( database = " testdb " , user = " postgres " , password = " pass123" , host = "127.0.0.1" , port = "5432" ) NEW_LINE print ( " Opened ▁ database ▁ successfully " ) NEW_LINE cur = conn . cursor ( ) NEW_LINE cur . execute ( " SELECT ▁ * ▁ FROM ▁ COMPANY ▁ WHERE ▁ SALARY ▁ > ▁ % s " , ( 1000 , ) ) NEW_LINE rows = cur . fetchall ( ) NEW_LINE for row in rows : NEW_LINE INDENT print ( " ID ▁ = ▁ " , row [ 0 ] ) NEW_LINE print ( " NAME ▁ = ▁ " , row [ 1 ] ) NEW_LINE print ( " ADDRESS ▁ = ▁ " , row [ 2 ] ) NEW_LINE print ( " SALARY ▁ = ▁ " , row [ 3 ] , " \n " ) NEW_LINE DEDENT print ( " Operation ▁ done ▁ successfully " ) NEW_LINE conn . close ( ) NEW_LINE
def merge_lists ( list1 , list2 ) : NEW_LINE INDENT return list ( zip ( list1 , list2 ) ) NEW_LINE DEDENT
def find_item ( item , string ) : NEW_LINE INDENT return item in string NEW_LINE DEDENT
import pandas as pd NEW_LINE import numpy as np NEW_LINE df = pd . DataFrame ( { ' A ' : [ 1 , 2 , np . nan ] , ' B ' : [ 5 , np . nan , np . nan ] , ' C ' : [ 1 , 2 , 3 ] } ) NEW_LINE df NEW_LINE df . isnull ( ) NEW_LINE df . isnull ( ) . sum ( ) NEW_LINE df . dropna ( ) NEW_LINE df . dropna ( axis = 1 ) NEW_LINE df . dropna ( thresh = 2 ) NEW_LINE df . fillna ( value = ' FILL ▁ VALUE ' ) NEW_LINE df [ ' A ' ] . fillna ( value = df [ ' A ' ] . mean ( ) ) NEW_LINE
def remove_empty_strings ( list_of_strings ) : NEW_LINE INDENT return [ string for string in list_of_strings if string ] NEW_LINE DEDENT
s = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE print ( s [ 2 : ] ) NEW_LINE
import re NEW_LINE re . search ( r ' ( . * ? ) \n ' , ' foo \n bar \n ' , re . DOTALL ) NEW_LINE
def all_same ( lst ) : NEW_LINE INDENT return lst [ 1 : ] == lst [ : - 1 ] NEW_LINE DEDENT
def is_empty ( lst ) : NEW_LINE INDENT if lst == [ ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
import threading NEW_LINE def function1 ( ) : NEW_LINE INDENT print ( " Hello " ) NEW_LINE print ( " World " ) NEW_LINE DEDENT def function2 ( ) : NEW_LINE INDENT print ( " Goodbye " ) NEW_LINE print ( " World " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT threading . Thread ( target = function1 ) . start ( ) NEW_LINE threading . Thread ( target = function2 ) . start ( ) NEW_LINE DEDENT
list1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE list2 = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE list3 = [ list1 [ 0 ] , list2 [ - 1 ] ] NEW_LINE print ( list3 ) NEW_LINE
from django . db . models import F NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . distinct ( ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( ' field ' ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( ' - field ' ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( F ( ' field ' ) . desc ( ) ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( F ( ' field ' ) . asc ( ) ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( ' field ' ) . distinct ( ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( ' - field ' ) . distinct ( ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( F ( ' field ' ) . desc ( ) ) . distinct ( ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( F ( ' field ' ) . asc ( ) ) . distinct ( ) NEW_LINE
def adjacent_pairs ( lst ) : NEW_LINE INDENT return [ ( lst [ i ] , lst [ i + 1 ] ) for i in range ( len ( lst ) - 1 ) if lst [ i ] == lst [ i + 1 ] ] NEW_LINE DEDENT
import os NEW_LINE def list_files ( dir ) : NEW_LINE INDENT r = [ ] NEW_LINE subdirs = [ x [ 0 ] for x in os . walk ( dir ) ] NEW_LINE for subdir in subdirs : NEW_LINE INDENT files = os . walk ( subdir ) . next ( ) [ 2 ] NEW_LINE if ( len ( files ) > 0 ) : NEW_LINE INDENT for file in files : NEW_LINE INDENT r . append ( subdir + " / " + file ) NEW_LINE DEDENT DEDENT DEDENT return r NEW_LINE DEDENT
import json NEW_LINE def encode_tuple ( t ) : NEW_LINE INDENT return { ' _ _ tuple _ _ ' : True , ' items ' : t } NEW_LINE DEDENT def decode_tuple ( d ) : NEW_LINE INDENT if d . get ( ' _ _ tuple _ _ ' ) : NEW_LINE INDENT return tuple ( d [ ' items ' ] ) NEW_LINE DEDENT return d NEW_LINE DEDENT t = ( 1 , 2 , 3 ) NEW_LINE print ( json . dumps ( t , default = encode_tuple ) ) NEW_LINE print ( json . loads ( ' { " _ _ tuple _ _ " : ▁ true , ▁ " items " : ▁ [ 1 , ▁ 2 , ▁ 3 ] } ' , object_hook = decode_tuple ) ) NEW_LINE
import random NEW_LINE random . randint ( 0 , 9 ) NEW_LINE
def chunks ( l , n ) : NEW_LINE INDENT for i in range ( 0 , len ( l ) , n ) : NEW_LINE INDENT yield l [ i : i + n ] NEW_LINE DEDENT DEDENT
def xor ( a , b ) : NEW_LINE INDENT return ( a or b ) and not ( a and b ) NEW_LINE DEDENT
def prepend_string ( string , list ) : NEW_LINE INDENT return [ string + item for item in list ] NEW_LINE DEDENT
import random NEW_LINE def random_list ( n ) : NEW_LINE INDENT my_list = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT my_list . append ( random . randint ( 1 , 100 ) ) NEW_LINE DEDENT return my_list NEW_LINE DEDENT print ( random_list ( 10 ) ) NEW_LINE
import requests NEW_LINE from bs4 import BeautifulSoup NEW_LINE url = ' https : / / www . google . com / search ? q = python ' NEW_LINE response = requests . get ( url ) NEW_LINE soup = BeautifulSoup ( response . text , ' html . parser ' ) NEW_LINE results = soup . find_all ( ' div ' , attrs = { ' class ' : ' g ' } ) NEW_LINE for result in results : NEW_LINE INDENT link = result . find ( ' a ' , href = True ) NEW_LINE title = result . find ( ' h3' ) NEW_LINE description = result . find ( ' span ' , attrs = { ' class ' : ' st ' } ) NEW_LINE if link and title : NEW_LINE INDENT link = link [ ' href ' ] NEW_LINE title = title . get_text ( ) NEW_LINE if description : NEW_LINE INDENT description = description . get_text ( ) NEW_LINE DEDENT if link != ' # ' : NEW_LINE INDENT print ( ' \n Title : ▁ { } ' . format ( title ) ) NEW_LINE print ( ' Link : ▁ { } ' . format ( link ) ) NEW_LINE print ( ' Description : ▁ { } ' . format ( description ) ) NEW_LINE DEDENT DEDENT DEDENT
def replace_char ( string , char , replacement ) : NEW_LINE INDENT return string . replace ( char , replacement ) NEW_LINE DEDENT
d = { ' a ' : [ 1 , 2 , 3 ] , ' b ' : [ 4 , 5 , 6 ] } NEW_LINE d [ ' a ' ] . append ( 4 ) NEW_LINE d [ ' b ' ] . append ( 7 ) NEW_LINE
def remove_char ( string_list , char ) : NEW_LINE INDENT return [ s . replace ( char , ' ' ) for s in string_list ] NEW_LINE DEDENT
import datetime NEW_LINE def time_converter ( time ) : NEW_LINE INDENT time = datetime . datetime . strptime ( time , ' % H : % M ' ) NEW_LINE return time . strftime ( ' % I : % M ▁ % p ' ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( " Example : " ) NEW_LINE print ( time_converter ( '12:30' ) ) NEW_LINE assert time_converter ( '12:30' ) == '12:30 ▁ PM ' NEW_LINE assert time_converter ( '09:00' ) == '09:00 ▁ AM ' NEW_LINE assert time_converter ( '23:15' ) == '11:15 ▁ PM ' NEW_LINE print ( " Coding ▁ complete ? ▁ Click ▁ ' Check ' ▁ to ▁ earn ▁ cool ▁ rewards ! " ) NEW_LINE DEDENT
def replace_string ( list_of_lists , old_string , new_string ) : NEW_LINE INDENT for i in range ( len ( list_of_lists ) ) : NEW_LINE INDENT for j in range ( len ( list_of_lists [ i ] ) ) : NEW_LINE INDENT if list_of_lists [ i ] [ j ] == old_string : NEW_LINE INDENT list_of_lists [ i ] [ j ] = new_string NEW_LINE DEDENT DEDENT DEDENT return list_of_lists NEW_LINE DEDENT
def close_window ( ) : NEW_LINE INDENT window . destroy ( ) NEW_LINE exit ( ) NEW_LINE DEDENT
from sqlalchemy import create_engine NEW_LINE engine = create_engine ( ' postgresql + psycopg2 : / / student : datacamp @ postgresql . csrrinzqubik . us - east - 1 . rds . amazonaws . com : 5432 / census ' ) NEW_LINE print ( engine . table_names ( ) ) NEW_LINE results = engine . execute ( ' SELECT ▁ * ▁ FROM ▁ state _ fact ' ) NEW_LINE print ( results . fetchall ( ) ) NEW_LINE print ( results . first ( ) ) NEW_LINE print ( results . rowcount ) NEW_LINE
from bisect import bisect_left NEW_LINE def insert ( a , x ) : NEW_LINE INDENT i = bisect_left ( a , x ) NEW_LINE a . insert ( i , x ) NEW_LINE DEDENT a = [ ] NEW_LINE insert ( a , [ 2 , 3 ] ) NEW_LINE insert ( a , [ 1 , 2 ] ) NEW_LINE insert ( a , [ 3 , 4 ] ) NEW_LINE print ( a ) NEW_LINE
fellowship = [ ' frodo ' , ' samwise ' , ' merry ' , ' aragorn ' , ' legolas ' , ' boromir ' , ' gimli ' ] NEW_LINE new_fellowship = [ member for member in fellowship if len ( member ) >= 7 ] NEW_LINE print ( new_fellowship ) NEW_LINE
import os NEW_LINE import pandas as pd NEW_LINE path = ' C : / Users / User / Desktop / Python / Data / ' NEW_LINE data = [ ] NEW_LINE for root , dirs , files in os . walk ( path ) : NEW_LINE INDENT for file in files : NEW_LINE INDENT if file . endswith ( ' . csv ' ) : NEW_LINE INDENT filepath = os . path . join ( root , file ) NEW_LINE df = pd . read_csv ( filepath ) NEW_LINE data . append ( df ) NEW_LINE DEDENT DEDENT DEDENT df = pd . concat ( data ) NEW_LINE print ( df . head ( ) ) NEW_LINE
import re NEW_LINE re . sub ( r ' \ ( [ ^ ) ] * \ ) ' , ' ' , ' This ▁ is ▁ a ▁ ( test ) ▁ string ' ) NEW_LINE
from collections import defaultdict NEW_LINE def group_similar_items ( items ) : NEW_LINE INDENT groups = defaultdict ( list ) NEW_LINE for item in items : NEW_LINE INDENT groups [ item ] . append ( item ) NEW_LINE DEDENT return groups NEW_LINE DEDENT
I have two lists : NEW_LINE < code > a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE b = [ 2 , 4 , 1 , 3 , 5 ] NEW_LINE < / code > NEW_LINE I want to sort < code > a < / code > based on the order of < code > b < / code > . NEW_LINE The result should be : NEW_LINE < code > a = [ 2 , 4 , 1 , 3 , 5 ] NEW_LINE < / code > NEW_LINE How can I do this ? NEW_LINE A : NEW_LINE You can use < code > sorted < / code > with a custom key function : NEW_LINE < code > & gt ; & gt ; & gt ; a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE & gt ; & gt ; & gt ; b = [ 2 , 4 , 1 , 3 , 5 ] NEW_LINE & gt ; & gt ; & gt ; sorted ( a , key = b . index ) NEW_LINE [ 2 , 4 , 1 , 3 , 5 ] NEW_LINE < / code > NEW_LINE
a = [ 1 , 2 , 3 , 2 , 4 , 2 ] NEW_LINE [ i for i , j in enumerate ( a ) if j == max ( a ) ] NEW_LINE [ 2 , 5 ] NEW_LINE
import os NEW_LINE os . remove ( ' path / to / file ' ) NEW_LINE
from selenium import webdriver NEW_LINE from selenium . webdriver . common . by import By NEW_LINE from selenium . webdriver . support . ui import WebDriverWait NEW_LINE from selenium . webdriver . support import expected_conditions as EC NEW_LINE driver = webdriver . Firefox ( ) NEW_LINE driver . get ( " http : / / somedomain / url _ that _ delays _ loading " ) NEW_LINE try : NEW_LINE INDENT element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located ( ( By . PARTIAL_LINK_TEXT , " onclick " ) ) ) NEW_LINE DEDENT finally : NEW_LINE INDENT driver . quit ( ) NEW_LINE DEDENT
def remove_whitespace ( string ) : NEW_LINE INDENT return string . replace ( " ▁ " , " " ) NEW_LINE DEDENT print ( remove_whitespace ( " hello ▁ world " ) ) NEW_LINE
def sort_list ( list_of_numbers ) : NEW_LINE INDENT return sorted ( list_of_numbers . split ( ' . ' ) , key = int ) NEW_LINE DEDENT
import re NEW_LINE def add_character ( string , character ) : NEW_LINE INDENT return re . sub ( r ' ( . ) ' , r ' \1' + character , string ) NEW_LINE DEDENT
def flatten_list_of_lists ( list_of_lists ) : NEW_LINE INDENT return [ item for sublist in list_of_lists for item in sublist ] NEW_LINE DEDENT
def count_end_char ( string , char ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( string ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if string [ i ] == char : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def sum_of_power ( lst ) : NEW_LINE INDENT return sum ( x ** i for i , x in enumerate ( lst ) ) NEW_LINE DEDENT
I have a plot with multiple lines . I want to avoid line color repetition . NEW_LINE I have tried to use the following code : NEW_LINE < code > NEW_LINE import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT y = np . random . rand ( 100 ) NEW_LINE plt . plot ( x , y ) NEW_LINE DEDENT plt . show ( ) NEW_LINE < / code > NEW_LINE But I get the following plot : NEW_LINE I want to avoid line color repetition . NEW_LINE I have tried to use the following code : NEW_LINE < code > NEW_LINE import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT y = np . random . rand ( 100 ) NEW_LINE plt . plot ( x , y , color = plt . cm . Set1 ( i ) ) NEW_LINE DEDENT plt . show ( ) NEW_LINE < / code > NEW_LINE But I get the following plot : NEW_LINE I want to avoid line color repetition . NEW_LINE I have tried to use the following code : NEW_LINE < code > NEW_LINE import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT y = np . random . rand ( 100 ) NEW_LINE plt . plot ( x , y , color = plt . cm . Set1 ( i / 10 ) ) NEW_LINE DEDENT plt . show ( ) NEW_LINE < / code > NEW_LINE But I get the following plot : NEW_LINE I want to avoid line color repetition . NEW_LINE I have tried to use the following code : NEW_LINE < code > NEW_LINE import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT y = np . random . rand ( 100 ) NEW_LINE plt . plot ( x , y , color = plt . cm . Set1 ( i / 10.0 ) ) NEW_LINE DEDENT plt . show ( ) NEW_LINE < / code > NEW_LINE But I get the following plot : NEW_LINE I want to avoid line color repetition . NEW_LINE
import matplotlib . pyplot as plt NEW_LINE plt . figure ( ) NEW_LINE plt . plot ( x , y ) NEW_LINE plt . xlabel ( ' x ' ) NEW_LINE plt . ylabel ( ' y ' ) NEW_LINE plt . title ( ' title ' ) NEW_LINE ax = plt . gca ( ) NEW_LINE ax . xaxis . set_ticks_position ( ' top ' ) NEW_LINE ax . xaxis . set_label_position ( ' top ' ) NEW_LINE plt . show ( ) NEW_LINE
import re NEW_LINE def remove_between ( text , begin , end ) : NEW_LINE INDENT return re . sub ( r ' { } . * ? { } ' . format ( begin , end ) , ' ' , text ) NEW_LINE DEDENT remove_between ( ' abc123def456ghi789' , '123' , '789' ) NEW_LINE
def union ( lists ) : NEW_LINE INDENT return list ( set ( ) . union ( * lists ) ) NEW_LINE DEDENT
from flask import Flask , request NEW_LINE from flask_restful import Resource , Api NEW_LINE from flask_cors import CORS NEW_LINE app = Flask ( __name__ ) NEW_LINE api = Api ( app ) NEW_LINE CORS ( app ) NEW_LINE class HelloWorld ( Resource ) : NEW_LINE INDENT def get ( self ) : NEW_LINE INDENT return { ' hello ' : ' world ' } NEW_LINE DEDENT DEDENT api . add_resource ( HelloWorld , ' / ' ) NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT app . run ( debug = True ) NEW_LINE DEDENT
def all_combinations ( lists ) : NEW_LINE INDENT if len ( lists ) == 0 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT elif len ( lists ) == 1 : NEW_LINE INDENT return lists [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return [ x + [ y ] for x in all_combinations ( lists [ : - 1 ] ) for y in lists [ - 1 ] ] NEW_LINE DEDENT DEDENT
import re NEW_LINE with open ( ' file . txt ' , ' r ' ) as f : NEW_LINE INDENT lines = f . readlines ( ) NEW_LINE DEDENT with open ( ' file . txt ' , ' w ' ) as f : NEW_LINE INDENT for line in lines : NEW_LINE INDENT f . write ( re . sub ( ' \n ' , ' ' , line ) ) NEW_LINE DEDENT DEDENT
my_list = [ ' a ' , ' b ' , ' c ' ] NEW_LINE my_list . insert ( 1 , ' d ' ) NEW_LINE print ( my_list ) NEW_LINE
def unique_characters ( str ) : NEW_LINE INDENT return set ( str ) NEW_LINE DEDENT
from mongoengine import Document , StringField , IntField NEW_LINE class User ( Document ) : NEW_LINE INDENT name = StringField ( required = True ) NEW_LINE age = IntField ( required = True ) NEW_LINE DEDENT user = User ( name = ' John ' ) NEW_LINE user . validate ( ) NEW_LINE user . errors NEW_LINE
import struct NEW_LINE def bin2float ( b ) : NEW_LINE INDENT bf = int ( b , 2 ) NEW_LINE bf = struct . pack ( ' > l ' , bf ) NEW_LINE return struct . unpack ( ' > f ' , bf ) [ 0 ] NEW_LINE DEDENT print ( bin2float ( '0100000101010100000000000000000' ) ) NEW_LINE
def gen_to_dict ( gen ) : NEW_LINE INDENT return { k : v for k , v in gen } NEW_LINE DEDENT
def all_binary_4_tuples ( ) : NEW_LINE INDENT for i in range ( 2 ** 4 ) : NEW_LINE INDENT yield tuple ( int ( x ) for x in bin ( i ) [ 2 : ] . zfill ( 4 ) ) NEW_LINE DEDENT DEDENT for t in all_binary_4_tuples ( ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT
import pandas as pd NEW_LINE df = pd . DataFrame ( { ' Name ' : [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' , ' G ' , ' H ' , ' I ' , ' J ' ] , ' Score ' : [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] , ' Age ' : [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 ] } ) NEW_LINE df . sort_values ( by = [ ' Score ' , ' Age ' ] , ascending = [ True , False ] ) NEW_LINE
europe = { ' spain ' : ' madrid ' , ' france ' : ' paris ' , ' germany ' : ' berlin ' , ' norway ' : ' oslo ' , ' italy ' : ' rome ' , ' poland ' : ' warsaw ' , ' austria ' : ' vienna ' } NEW_LINE for key , value in europe . items ( ) : NEW_LINE INDENT print ( " the ▁ capital ▁ of ▁ " + key + " ▁ is ▁ " + value ) NEW_LINE DEDENT
with open ( ' file . txt ' ) as f : NEW_LINE INDENT for line in f : NEW_LINE INDENT print ( line , end = ' ' ) NEW_LINE DEDENT DEDENT
d = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 } NEW_LINE keys = list ( d . keys ( ) ) NEW_LINE values = list ( d . values ( ) ) NEW_LINE
def check_ending ( strng , ending ) : NEW_LINE INDENT return strng . endswith ( tuple ( ending ) ) NEW_LINE DEDENT
class Person : NEW_LINE INDENT def __init__ ( self , name , age ) : NEW_LINE INDENT self . name = name NEW_LINE self . age = age NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' { } ▁ is ▁ { } ▁ years ▁ old ' . format ( self . name , self . age ) NEW_LINE DEDENT DEDENT people = [ Person ( ' Alice ' , 25 ) , Person ( ' Bob ' , 30 ) , Person ( ' Charlie ' , 50 ) , Person ( ' Dan ' , 21 ) ] NEW_LINE people . sort ( key = lambda person : person . age ) NEW_LINE print ( people ) NEW_LINE people . sort ( key = lambda person : person . name ) NEW_LINE print ( people ) NEW_LINE
def sum_of_product_of_combinations ( lst ) : NEW_LINE INDENT return sum ( [ x * y for x in lst for y in lst if x != y ] ) NEW_LINE DEDENT print ( sum_of_product_of_combinations ( [ 1 , 2 , 3 , 4 , 5 ] ) ) NEW_LINE
import os NEW_LINE os . remove ( " myfile " ) NEW_LINE
dictionary = { ' key1' : ' value1' , ' key2' : ' value2' } NEW_LINE print ( dictionary [ ' key1' ] ) NEW_LINE dictionary = { ' key1' : ' value1' , ' key2' : ' value2' } NEW_LINE key = ' key1' NEW_LINE print ( dictionary [ key ] ) NEW_LINE
import datetime NEW_LINE date_string = '01/01/17 ▁ 12:10:03.234567' NEW_LINE date_dt = datetime . datetime . strptime ( date_string , ' % m / % d / % y ▁ % H : % M : % S . % f ' ) NEW_LINE print ( date_dt ) NEW_LINE
def nth_to_last_element ( n , head ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return None NEW_LINE DEDENT if head is None : NEW_LINE INDENT return None NEW_LINE DEDENT if head . next is None : NEW_LINE INDENT return head NEW_LINE DEDENT current = head NEW_LINE nth_to_last = head NEW_LINE for i in range ( n ) : NEW_LINE INDENT if current . next is None : NEW_LINE INDENT return None NEW_LINE DEDENT current = current . next NEW_LINE DEDENT while current . next is not None : NEW_LINE INDENT current = current . next NEW_LINE nth_to_last = nth_to_last . next NEW_LINE DEDENT return nth_to_last NEW_LINE DEDENT
a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE b = [ 5 , 4 , 3 , 2 , 1 ] NEW_LINE a . sort ( key = lambda x : b [ x - 1 ] ) NEW_LINE print ( a ) NEW_LINE
a = [ 1 , 2 , 3 ] NEW_LINE b = [ ' a ' , ' b ' , ' c ' ] NEW_LINE for i , j in zip ( a , b ) : NEW_LINE INDENT print ( i , j ) NEW_LINE DEDENT
for key in sorted ( d ) : NEW_LINE INDENT print ( key , d [ key ] ) NEW_LINE DEDENT
def find_difference ( list1 , list2 , list3 ) : NEW_LINE INDENT return list ( set ( list1 ) - set ( list2 ) - set ( list3 ) ) NEW_LINE DEDENT
from django . db . models import Q NEW_LINE Book . objects . filter ( Q ( authors__name = ' Author1' ) & Q ( authors__name = ' Author2' ) ) NEW_LINE
from flask import Flask NEW_LINE from flask_sqlalchemy import SQLAlchemy NEW_LINE app = Flask ( __name__ ) NEW_LINE app . config [ ' SQLALCHEMY _ DATABASE _ URI ' ] = ' sqlite : / / / / tmp / test . db ' NEW_LINE db = SQLAlchemy ( app ) NEW_LINE class User ( db . Model ) : NEW_LINE INDENT id = db . Column ( db . Integer , primary_key = True ) NEW_LINE username = db . Column ( db . String ( 80 ) , unique = True ) NEW_LINE email = db . Column ( db . String ( 120 ) , unique = True ) NEW_LINE def __init__ ( self , username , email ) : NEW_LINE INDENT self . username = username NEW_LINE self . email = email NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' < User ▁ % r > ' % self . username NEW_LINE DEDENT DEDENT db . create_all ( ) NEW_LINE admin = User ( ' admin ' , ' admin @ example . com ' ) NEW_LINE guest = User ( ' guest ' , ' guest @ example . com ' ) NEW_LINE db . session . add ( admin ) NEW_LINE db . session . add ( guest ) NEW_LINE db . session . commit ( ) NEW_LINE db . session . delete ( guest ) NEW_LINE db . session . commit ( ) NEW_LINE
list1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE list2 = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE list3 = [ ] NEW_LINE for i in range ( len ( list1 ) ) : NEW_LINE INDENT list3 . append ( list1 [ i ] + list2 [ i ] ) NEW_LINE DEDENT print ( list3 ) NEW_LINE
from collections import defaultdict NEW_LINE def transform_list_of_dicts_into_dict_of_dicts ( list_of_dicts ) : NEW_LINE INDENT dict_of_dicts = defaultdict ( dict ) NEW_LINE for d in list_of_dicts : NEW_LINE INDENT dict_of_dicts [ d [ ' key ' ] ] . update ( d ) NEW_LINE DEDENT return dict_of_dicts NEW_LINE DEDENT
import datetime NEW_LINE def is_today ( date ) : NEW_LINE INDENT return date . date ( ) == datetime . date . today ( ) NEW_LINE DEDENT
l = [ ( ' a ' , 1 ) , ( ' b ' , 2 ) , ( ' c ' , 3 ) ] NEW_LINE dict ( l ) NEW_LINE { ' a ' : 1 , ' c ' : 3 , ' b ' : 2 } NEW_LINE
s = " ▁ ▁ hello ▁ world ▁ ▁ " NEW_LINE s . strip ( ) NEW_LINE
import re NEW_LINE s = "30M1000N20M " NEW_LINE re . findall ( r ' \d + | \D + ' , s ) NEW_LINE
import re NEW_LINE name = " John ▁ Smith " NEW_LINE if re . match ( " John " , name ) : NEW_LINE INDENT print ( " Match " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ match " ) NEW_LINE DEDENT
a = [ 1 , 2 , 0 , 0 , 4 , 0 ] NEW_LINE [ i for i , e in enumerate ( a ) if e != 0 ] NEW_LINE [ 0 , 1 , 4 ] NEW_LINE
import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE fig , ax = plt . subplots ( ) NEW_LINE ax . plot ( x , np . sin ( x ) , ' - ' , label = ' Sine ' ) NEW_LINE ax . plot ( x , np . cos ( x ) , ' - - ' , label = ' Cosine ' ) NEW_LINE ax . axis ( ' equal ' ) NEW_LINE leg = ax . legend ( ) NEW_LINE leg . get_frame ( ) . set_linewidth ( 0.0 ) NEW_LINE plt . show ( ) NEW_LINE
- Python is an interpreted language NEW_LINE - Python is a dynamically typed language NEW_LINE - Python is a garbage collected language NEW_LINE - Python is a high - level language NEW_LINE - Python is a scripting language NEW_LINE - Python is an object - oriented language NEW_LINE - Python is a functional language NEW_LINE - Python is a procedural language NEW_LINE - Python is a reflective language NEW_LINE - Python is a general - purpose language NEW_LINE - Python is a cross - platform language NEW_LINE - Python is a portable language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE
import json NEW_LINE import urllib . request NEW_LINE url = ' https : / / api . github . com / repos / jupyter / notebook / issues ? state = closed ' NEW_LINE response = urllib . request . urlopen ( url ) NEW_LINE data = json . loads ( response . read ( ) ) NEW_LINE with open ( ' data . json ' , ' w ' ) as f : NEW_LINE INDENT json . dump ( data , f , indent = 4 ) NEW_LINE DEDENT
def sort_by_key ( list_of_tuples , key ) : NEW_LINE INDENT return sorted ( list_of_tuples , key = lambda x : x [ key ] ) NEW_LINE DEDENT
list1 = [ 1 , 2 , 3 ] NEW_LINE list2 = [ 4 , 5 , 6 ] NEW_LINE list3 = list1 + list2 NEW_LINE print ( list3 ) NEW_LINE
def greater_than ( list , value ) : NEW_LINE INDENT return [ x for x in list if x > value ] NEW_LINE DEDENT greater_than ( [ 1 , 2 , 3 , 4 , 5 ] , 3 ) NEW_LINE
import re NEW_LINE def is_valid ( word ) : NEW_LINE INDENT return re . match ( r ' ^ ( ? ! . * [ aeiou ] {2 } ) [ a - z ] + $ ' , word ) NEW_LINE DEDENT
my_list = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE my_list . extend ( [ 6 , 7 , 8 , 9 , 10 ] ) NEW_LINE print ( my_list ) NEW_LINE
import matplotlib . pyplot as plt NEW_LINE plt . figure ( figsize = ( 10 , 5 ) ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . NEW_LINE
x , y = 1 , 2 NEW_LINE print ( x , y ) NEW_LINE
list = [ ' a ' , ' b ' , ' ' , ' c ' , ' d ' , ' ' ] NEW_LINE list = [ x for x in list if x != ' ' ] NEW_LINE
def sort_list ( list_to_sort , index_1 , index_2 ) : NEW_LINE INDENT return sorted ( list_to_sort , key = lambda x : ( x [ index_1 ] , x [ index_2 ] ) ) NEW_LINE DEDENT
a = [ 1 , 2 , 3 ] NEW_LINE b = a [ : ] NEW_LINE
import requests NEW_LINE def check_website ( url ) : NEW_LINE INDENT try : NEW_LINE INDENT r = requests . get ( url ) NEW_LINE if r . status_code == 200 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT check_website ( ' https : / / www . google . com ' ) NEW_LINE
a = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE b = [ 2 , 4 , 6 , 8 , 10 ] NEW_LINE c = [ x for x in a if x not in b ] NEW_LINE print ( c ) NEW_LINE
import re NEW_LINE def remove_duplicate_chars ( s ) : NEW_LINE INDENT return re . sub ( r ' ( . ) \1 + ' , r ' \1' , s ) NEW_LINE DEDENT
members = { ' member1' : { ' name ' : ' John ' , ' age ' : '27' , ' sex ' : ' Male ' } , ' member2' : { ' name ' : ' Marie ' , ' age ' : '22' , ' sex ' : ' Female ' } , ' member3' : { ' name ' : ' Luna ' , ' age ' : '24' , ' sex ' : ' Female ' } , ' member4' : { ' name ' : ' Peter ' , ' age ' : '29' , ' sex ' : ' Male ' } , ' member5' : { ' name ' : ' Sara ' , ' age ' : '23' , ' sex ' : ' Female ' } , ' member6' : { ' name ' : ' Thomas ' , ' age ' : '24' , ' sex ' : ' Male ' } , ' member7' : { ' name ' : ' Martha ' , ' age ' : '29' , ' sex ' : ' Female ' } , ' member8' : { ' name ' : ' David ' , ' age ' : '31' , ' sex ' : ' Male ' } , ' member9' : { ' name ' : ' Nina ' , ' age ' : '26' , ' sex ' : ' Female ' } , ' member10' : { ' name ' : ' Randy ' , ' age ' : '23' , ' sex ' : ' Male ' } } NEW_LINE member_keys = [ member for member in members ] NEW_LINE print ( member_keys ) NEW_LINE
import os NEW_LINE import time NEW_LINE def get_file_creation_modification_times ( file_path ) : NEW_LINE INDENT file_creation_time = os . path . getctime ( file_path ) NEW_LINE file_modification_time = os . path . getmtime ( file_path ) NEW_LINE file_creation_time = time . ctime ( file_creation_time ) NEW_LINE file_modification_time = time . ctime ( file_modification_time ) NEW_LINE return file_creation_time , file_modification_time NEW_LINE DEDENT file_creation_time , file_modification_time = get_file_creation_modification_times ( file_path ) NEW_LINE print ( " File ▁ creation ▁ time : " , file_creation_time ) NEW_LINE print ( " File ▁ modification ▁ time : " , file_modification_time ) NEW_LINE
def find_nth ( haystack , needle , n ) : NEW_LINE INDENT start = haystack . find ( needle ) NEW_LINE while start >= 0 and n > 1 : NEW_LINE INDENT start = haystack . find ( needle , start + len ( needle ) ) NEW_LINE n -= 1 NEW_LINE DEDENT return start NEW_LINE DEDENT print ( find_nth ( " Python ▁ is ▁ awesome , ▁ isn ' t ▁ it ? " , " is " , 2 ) ) NEW_LINE
def coalesce ( column , default ) : NEW_LINE INDENT return case ( [ ( column != None , column ) ] , else_ = default ) NEW_LINE DEDENT
import subprocess NEW_LINE subprocess . call ( [ " ls " , " - l " ] ) NEW_LINE
def remove_letters ( list ) : NEW_LINE INDENT return [ x for x in list if type ( x ) == int ] NEW_LINE DEDENT
import re NEW_LINE def remove_punctuation ( input_string ) : NEW_LINE INDENT return re . sub ( r ' [ ^ \w\s ] ' , ' ' , input_string ) NEW_LINE DEDENT print ( remove_punctuation ( " Hello , ▁ I ▁ am ▁ a ▁ string ! " ) ) NEW_LINE
import json NEW_LINE print ( json . dumps ( container , ensure_ascii = False ) ) NEW_LINE
def remove_adjacent_duplicates ( lst ) : NEW_LINE INDENT return [ lst [ i ] for i in range ( len ( lst ) ) if i == 0 or lst [ i ] != lst [ i - 1 ] ] NEW_LINE DEDENT print ( remove_adjacent_duplicates ( [ 1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 5 ] ) ) NEW_LINE
import codecs NEW_LINE codecs . escape_decode ( b ' \\x61\\x62\\x63' ) NEW_LINE ( b ' abc ' , 6 ) NEW_LINE
if my_dict [ ' key ' ] == ' value ' : NEW_LINE INDENT print ( ' The ▁ value ▁ of ▁ the ▁ key ▁ is ▁ value ' ) NEW_LINE DEDENT
import os NEW_LINE if os . path . isfile ( ' / etc / passwd ' ) : NEW_LINE INDENT print ( ' File ▁ exists ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' File ▁ does ▁ not ▁ exist ' ) NEW_LINE DEDENT
import ast NEW_LINE def string_to_dict ( string ) : NEW_LINE INDENT return ast . literal_eval ( string ) NEW_LINE DEDENT string_to_dict ( ' { " a " : ▁ 1 , ▁ " b " : ▁ 2 } ' ) NEW_LINE
d = { ' banana ' : 3 , ' apple ' : 4 , ' pear ' : 1 , ' orange ' : 2 } NEW_LINE def get_value ( x ) : NEW_LINE INDENT return d [ x ] NEW_LINE DEDENT sorted ( d , key = get_value ) NEW_LINE
l = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE l = [ x + 1 for x in l ] NEW_LINE
import re NEW_LINE def strip_random_chars ( url ) : NEW_LINE INDENT return re . sub ( r ' [ ^ a - zA - Z0-9 ] ' , ' ' , url ) NEW_LINE DEDENT
import datetime NEW_LINE date_string = '2018-01-01' NEW_LINE date_object = datetime . datetime . strptime ( date_string , ' % Y - % m - % d ' ) NEW_LINE print ( date_object ) NEW_LINE
def remove_final_characters ( string , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return string NEW_LINE DEDENT else : NEW_LINE INDENT return remove_final_characters ( string [ : - 1 ] , n - 1 ) NEW_LINE DEDENT DEDENT
import requests NEW_LINE from bs4 import BeautifulSoup NEW_LINE url = ' https : / / www . nytimes . com / ' NEW_LINE r = requests . get ( url ) NEW_LINE r_html = r . text NEW_LINE soup = BeautifulSoup ( r_html , " html . parser " ) NEW_LINE for story_heading in soup . find_all ( class_ = " story - heading " ) : NEW_LINE INDENT if story_heading . a : NEW_LINE INDENT print ( story_heading . a . text . replace ( " \n " , " ▁ " ) . strip ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( story_heading . contents [ 0 ] . strip ( ) ) NEW_LINE DEDENT DEDENT
x = 5.5 NEW_LINE print ( int ( x ) ) NEW_LINE
def all_true ( lst ) : NEW_LINE INDENT return all ( lst ) NEW_LINE DEDENT
import subprocess NEW_LINE subprocess . call ( " ls ▁ - l ▁ | ▁ grep ▁ test " , shell = True ) NEW_LINE
import datetime NEW_LINE date_string = "2020-01-01" NEW_LINE date_object = datetime . datetime . strptime ( date_string , " % Y - % m - % d " ) NEW_LINE print ( date_object ) NEW_LINE print ( date_object . strftime ( " % d - % m - % Y " ) ) NEW_LINE
def compare_lists ( list_of_lists ) : NEW_LINE INDENT return [ max ( l ) for l in list_of_lists ] NEW_LINE DEDENT
f = open ( ' data . txt ' , ' a ' ) NEW_LINE f . write ( ' This ▁ is ▁ a ▁ new ▁ line \n ' ) NEW_LINE f . close ( ) NEW_LINE
sentence = " The ▁ quick ▁ brown ▁ fox ▁ jumps ▁ over ▁ the ▁ lazy ▁ dog " NEW_LINE words = sentence . split ( ) NEW_LINE word_lengths = [ ] NEW_LINE for word in words : NEW_LINE INDENT if word != " the " : NEW_LINE INDENT word_lengths . append ( len ( word ) ) NEW_LINE DEDENT DEDENT print ( words ) NEW_LINE print ( word_lengths ) NEW_LINE
from itertools import chain NEW_LINE def split_dict_of_lists ( d ) : NEW_LINE INDENT return [ dict ( zip ( d , t ) ) for t in zip ( * d . values ( ) ) ] NEW_LINE DEDENT d = { ' a ' : [ 1 , 2 , 3 ] , ' b ' : [ 4 , 5 , 6 ] } NEW_LINE split_dict_of_lists ( d ) NEW_LINE
if ' a ' not in [ ' a ' , ' b ' , ' c ' ] : NEW_LINE INDENT print ( ' a ▁ is ▁ not ▁ in ▁ the ▁ list ' ) NEW_LINE DEDENT
def is_empty ( string ) : NEW_LINE INDENT if string == " " : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
a = [ 1 , 2 , 3 ] NEW_LINE b = [ 4 , 5 , 6 ] NEW_LINE c = [ 4 , 5 , 6 , 7 , 8 ] NEW_LINE map ( lambda x , y : x + y , a , b ) NEW_LINE [ 5 , 7 , 9 ] NEW_LINE map ( lambda x , y : x + y , a , c ) NEW_LINE Traceback ( most recent call last ) : NEW_LINE INDENT File " < stdin > " , line 1 , in < module > NEW_LINE File " < stdin > " , line 1 , in < lambda > NEW_LINE DEDENT TypeError : unsupported operand type ( s ) for + : ' int ' and ' NoneType ' NEW_LINE
import unicodedata NEW_LINE unicodedata . normalize ( ' NFKD ' , unicode_text ) . encode ( ' ascii ' , ' ignore ' ) NEW_LINE
def generate_all_strings ( tokens , length ) : NEW_LINE INDENT if length == 0 : NEW_LINE INDENT return [ ' ' ] NEW_LINE DEDENT else : NEW_LINE INDENT return [ token + suffix for token in tokens for suffix in generate_all_strings ( tokens , length - 1 ) ] NEW_LINE DEDENT DEDENT print ( generate_all_strings ( [ ' a ' , ' b ' ] , 3 ) ) NEW_LINE
def greater_than ( list , number ) : NEW_LINE INDENT count = 0 NEW_LINE for i in list : NEW_LINE INDENT if i > number : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
import urllib . parse NEW_LINE url = ' http : / / example . com / path / to / page . html # fragment ' NEW_LINE parsed = urllib . parse . urlparse ( url ) NEW_LINE print ( parsed . fragment ) NEW_LINE print ( parsed . path ) NEW_LINE print ( parsed . scheme ) NEW_LINE print ( parsed . netloc ) NEW_LINE print ( parsed . geturl ( ) ) NEW_LINE print ( urllib . parse . urlunparse ( parsed ) ) NEW_LINE parsed = parsed . _replace ( fragment = ' ' ) NEW_LINE print ( urllib . parse . urlunparse ( parsed ) ) NEW_LINE
import random NEW_LINE random . sample ( range ( 1 , 100 ) , 100 ) NEW_LINE
import win32gui NEW_LINE win32gui . SetForegroundWindow ( hwnd ) NEW_LINE
def convert_to_tuple ( string ) : NEW_LINE INDENT return tuple ( string . split ( ' , ' ) ) NEW_LINE DEDENT def add_to_tuple ( tuple , string ) : NEW_LINE INDENT return tuple + convert_to_tuple ( string ) NEW_LINE DEDENT
l = [ 11 , 22 , 33 ] NEW_LINE int ( ' ' . join ( map ( str , l ) ) ) NEW_LINE 112233 NEW_LINE
def split_list ( lst , field ) : NEW_LINE INDENT return [ list ( g ) for k , g in groupby ( lst , lambda x : x [ field ] ) ] NEW_LINE DEDENT
l_of_l = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 ] , [ 8 , 9 ] ] NEW_LINE flat_list = [ ] NEW_LINE for x in l_of_l : NEW_LINE INDENT for y in x : NEW_LINE INDENT flat_list . append ( y ) NEW_LINE DEDENT DEDENT print ( flat_list ) NEW_LINE
import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE fig = plt . figure ( ) NEW_LINE plt . plot ( x , np . sin ( x ) , ' - ' ) NEW_LINE plt . plot ( x , np . cos ( x ) , ' - - ' ) NEW_LINE fig . savefig ( ' my _ figure . png ' , bbox_inches = ' tight ' ) NEW_LINE plt . show ( ) NEW_LINE
if ' key ' in my_dict : NEW_LINE INDENT del my_dict [ ' key ' ] NEW_LINE DEDENT
import re NEW_LINE re . sub ( r ' \n ' , ' ' , text ) NEW_LINE
def contains_substring ( string , substring ) : NEW_LINE INDENT return substring in string NEW_LINE DEDENT
import re NEW_LINE text = " The ▁ ghost ▁ that ▁ says ▁ boo ▁ haunts ▁ the ▁ loo " NEW_LINE m = re . findall ( " . oo " , text , re . IGNORECASE ) NEW_LINE print ( m ) NEW_LINE
def average ( numbers ) : NEW_LINE INDENT total = 0 NEW_LINE for number in numbers : NEW_LINE INDENT total += number NEW_LINE DEDENT return total / len ( numbers ) NEW_LINE DEDENT average ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE
import ast NEW_LINE ast . literal_eval ( " { ' a ' : ▁ 1 , ▁ ' b ' : ▁ 2 } " ) NEW_LINE
def count_elements ( d ) : NEW_LINE INDENT if isinstance ( d , dict ) : NEW_LINE INDENT return sum ( count_elements ( v ) for v in d . values ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT
def remove_chars ( string , chars ) : NEW_LINE INDENT return " " . join ( c for c in string if c not in chars ) NEW_LINE DEDENT remove_chars ( " Battle ▁ of ▁ the ▁ Vowels : ▁ Hawaii ▁ vs . ▁ Grozny " , " aeiou " ) NEW_LINE
def read_line ( string ) : NEW_LINE INDENT return string . split ( ' \n ' ) [ 0 ] NEW_LINE DEDENT
float ( string ) NEW_LINE int ( string ) NEW_LINE
def add_to_ints ( ints , add ) : NEW_LINE INDENT for i in range ( len ( ints ) ) : NEW_LINE INDENT ints [ i ] += add NEW_LINE DEDENT return ints NEW_LINE DEDENT
import hashlib NEW_LINE def md5 ( fname ) : NEW_LINE INDENT hash_md5 = hashlib . md5 ( ) NEW_LINE with open ( fname , " rb " ) as f : NEW_LINE INDENT for chunk in iter ( lambda : f . read ( 4096 ) , b " " ) : NEW_LINE INDENT hash_md5 . update ( chunk ) NEW_LINE DEDENT DEDENT return hash_md5 . hexdigest ( ) NEW_LINE DEDENT
def get_str_after_substr ( string , substr ) : NEW_LINE INDENT return string [ string . find ( substr ) + len ( substr ) : ] NEW_LINE DEDENT
def find_non_common_elements ( list1 , list2 ) : NEW_LINE INDENT return list ( set ( list1 ) - set ( list2 ) ) NEW_LINE DEDENT list1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE list2 = [ 5 , 6 , 7 , 8 , 9 ] NEW_LINE print ( find_non_common_elements ( list1 , list2 ) ) NEW_LINE
def sum_list ( l ) : NEW_LINE INDENT s = 0 NEW_LINE for i in l : NEW_LINE INDENT s += i NEW_LINE DEDENT return s NEW_LINE DEDENT
import random NEW_LINE def print_random_variable ( variables ) : NEW_LINE INDENT print ( variables [ random . randint ( 0 , len ( variables ) - 1 ) ] ) NEW_LINE DEDENT variables = [ ' a ' , ' b ' , ' c ' , ' d ' , ' e ' ] NEW_LINE print_random_variable ( variables ) NEW_LINE
class Base ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT print " Base ▁ created " NEW_LINE DEDENT DEDENT class ChildA ( Base ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT Base . __init__ ( self ) NEW_LINE print " ChildA ▁ created " NEW_LINE DEDENT DEDENT class ChildB ( Base ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT super ( ChildB , self ) . __init__ ( ) NEW_LINE print " ChildB ▁ created " NEW_LINE DEDENT DEDENT ChildA ( ) NEW_LINE ChildB ( ) NEW_LINE
from datetime import datetime NEW_LINE date_string = '2019-01-01' NEW_LINE date_object = datetime . strptime ( date_string , ' % Y - % m - % d ' ) NEW_LINE
import itertools NEW_LINE def generate_pairs ( n ) : NEW_LINE INDENT return list ( itertools . combinations ( range ( n ) , 2 ) ) NEW_LINE DEDENT
def remove_substring ( string , substring ) : NEW_LINE INDENT if string . endswith ( substring ) : NEW_LINE INDENT return string [ : - len ( substring ) ] NEW_LINE DEDENT return string NEW_LINE DEDENT
import numpy as np NEW_LINE a = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ) NEW_LINE np . savetxt ( " foo . csv " , a , delimiter = " , " ) NEW_LINE
from operator import itemgetter NEW_LINE sorted ( list_of_dicts , key = itemgetter ( ' key ' ) ) NEW_LINE
my_dict = { ' T1' : [ '1' , '2' , '3' ] , ' T2' : [ '4' , '5' ] , ' T3' : [ '6' , '7' ] } NEW_LINE df = pd . DataFrame ( my_dict ) NEW_LINE hier_index = df . columns . map ( lambda x : my_dict [ x ] ) NEW_LINE df . columns = pd . MultiIndex . from_tuples ( hier_index ) NEW_LINE print ( df ) NEW_LINE
import datetime NEW_LINE now = datetime . datetime . now ( ) NEW_LINE print now . strftime ( " % Y - % m - % d ▁ % H : % M " ) NEW_LINE
script_dir = os . path . dirname ( os . path . realpath ( __file__ ) ) NEW_LINE config_file = os . path . join ( script_dir , ' config . ini ' ) NEW_LINE log_file = os . path . join ( script_dir , ' log . txt ' ) NEW_LINE
def max_string_length ( lst ) : NEW_LINE INDENT max_len = 0 NEW_LINE for item in lst : NEW_LINE INDENT if isinstance ( item , list ) : NEW_LINE INDENT max_len = max ( max_len , max_string_length ( item ) ) NEW_LINE DEDENT else : NEW_LINE INDENT max_len = max ( max_len , len ( item ) ) NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT
def reverse_string ( string ) : NEW_LINE INDENT return string [ : : - 1 ] NEW_LINE DEDENT print ( reverse_string ( " Hello " ) ) NEW_LINE
x = 1.23456 NEW_LINE format ( x , '0.2f ' ) NEW_LINE ' value ▁ is ▁ { :0.3f } ' . format ( x ) NEW_LINE
d = [ { ' a ' : 1 , ' b ' : 2 } , { ' a ' : 3 , ' b ' : 4 } , { ' a ' : 5 , ' b ' : 6 } ] NEW_LINE max ( d , key = lambda x : x [ ' a ' ] ) NEW_LINE
import sys NEW_LINE def replace_char ( filename , old_char , new_char ) : NEW_LINE INDENT with open ( filename , ' r ' ) as f : NEW_LINE INDENT text = f . read ( ) NEW_LINE DEDENT text = text . replace ( old_char , new_char ) NEW_LINE with open ( filename , ' w ' ) as f : NEW_LINE INDENT f . write ( text ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT replace_char ( sys . argv [ 1 ] , sys . argv [ 2 ] , sys . argv [ 3 ] ) NEW_LINE DEDENT
def max_list ( lst , length ) : NEW_LINE INDENT if length == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lst [ : length ] ) NEW_LINE DEDENT DEDENT print ( max_list ( [ 1 , 2 , 3 , 4 , 5 ] , 3 ) ) NEW_LINE print ( max_list ( [ 1 , 2 , 3 , 4 , 5 ] , 0 ) ) NEW_LINE print ( max_list ( [ 1 , 2 , 3 , 4 , 5 ] , 5 ) ) NEW_LINE
my_list [ 0 ] NEW_LINE my_list [ 1 ] NEW_LINE my_list [ 2 ] NEW_LINE my_list [ 3 ] NEW_LINE my_list [ 4 ] NEW_LINE my_list [ 5 ] NEW_LINE my_list [ 6 ] NEW_LINE my_list [ 7 ] NEW_LINE my_list [ 8 ] NEW_LINE my_list [ 9 ] NEW_LINE
def get_keys ( d , value ) : NEW_LINE INDENT return [ k for k , v in d . items ( ) if v == value ] NEW_LINE DEDENT
if not my_string : NEW_LINE INDENT print ( " String ▁ is ▁ empty " ) NEW_LINE DEDENT
def replace_first ( string , old , new ) : NEW_LINE INDENT return new . join ( string . split ( old , 1 ) ) NEW_LINE DEDENT
list1 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE list2 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE list3 = [ x for x in list1 if x not in list2 ] NEW_LINE print ( list3 ) NEW_LINE
import time NEW_LINE time . sleep ( 5 ) NEW_LINE
import matplotlib . pyplot as plt NEW_LINE x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE plt . plot ( x , y ) NEW_LINE plt . legend ( [ ' Legend ' ] , prop = { ' size ' : 20 } ) NEW_LINE plt . show ( ) NEW_LINE
def convert_to_string ( array ) : NEW_LINE INDENT return ' , ' . join ( array ) NEW_LINE DEDENT
import os NEW_LINE print ( os . getcwd ( ) ) NEW_LINE print ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) NEW_LINE
d = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 , ' d ' : 4 , ' e ' : 5 } NEW_LINE sorted_by_value = sorted ( d . items ( ) , key = lambda kv : kv [ 1 ] ) NEW_LINE sorted_by_key = sorted ( d . items ( ) , key = lambda kv : kv [ 0 ] ) NEW_LINE sorted_by_value_then_key = sorted ( d . items ( ) , key = lambda kv : ( kv [ 1 ] , kv [ 0 ] ) ) NEW_LINE
def extract_keys ( lst ) : NEW_LINE INDENT return [ key for d in lst for key in d . keys ( ) ] NEW_LINE DEDENT
def sort_list_of_tuples ( list_of_tuples ) : NEW_LINE INDENT return sorted ( list_of_tuples , key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) NEW_LINE DEDENT
import os NEW_LINE def get_files ( path , extension ) : NEW_LINE INDENT files = [ ] NEW_LINE for file in os . listdir ( path ) : NEW_LINE INDENT if file . endswith ( extension ) : NEW_LINE INDENT files . append ( file ) NEW_LINE DEDENT DEDENT return files NEW_LINE DEDENT
from pyzabbix import ZabbixAPI NEW_LINE zapi = ZabbixAPI ( " http : / / localhost / zabbix " ) NEW_LINE zapi . login ( " Admin " , " zabbix " ) NEW_LINE for h in zapi . host . get ( output = " extend " ) : NEW_LINE INDENT print ( " Host : ▁ % s " % h [ " host " ] ) NEW_LINE for i in zapi . item . get ( hostids = h [ " hostid " ] , output = " extend " ) : NEW_LINE INDENT print ( " ▁ ▁ Item : ▁ % s " % i [ " name " ] ) NEW_LINE for g in zapi . graph . get ( itemids = i [ " itemid " ] , output = " extend " ) : NEW_LINE INDENT print ( " ▁ ▁ ▁ ▁ Graph : ▁ % s " % g [ " name " ] ) NEW_LINE for t in zapi . graphitem . get ( graphids = g [ " graphid " ] , output = " extend " ) : NEW_LINE INDENT print ( " ▁ ▁ ▁ ▁ ▁ ▁ Graph ▁ item : ▁ % s " % t [ " itemid " ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def replace_empty_strings ( string ) : NEW_LINE INDENT return string . replace ( " " , " ▁ " ) NEW_LINE DEDENT
def is_number ( s ) : NEW_LINE INDENT try : NEW_LINE INDENT float ( s ) NEW_LINE return True NEW_LINE DEDENT except ValueError : NEW_LINE INDENT pass NEW_LINE DEDENT try : NEW_LINE INDENT import unicodedata NEW_LINE unicodedata . numeric ( s ) NEW_LINE return True NEW_LINE DEDENT except ( TypeError , ValueError ) : NEW_LINE INDENT pass NEW_LINE DEDENT return False NEW_LINE DEDENT
import re NEW_LINE def extract_float ( string ) : NEW_LINE INDENT return float ( re . findall ( r ' [ - + ] ? \d * \ . \d + | \d + ' , string ) [ 0 ] ) NEW_LINE DEDENT extract_float ( ' $ 123.45' ) NEW_LINE
import sqlite3 NEW_LINE conn = sqlite3 . connect ( ' example . db ' ) NEW_LINE c = conn . cursor ( ) NEW_LINE c . execute ( " SELECT ▁ * ▁ FROM ▁ stocks " ) NEW_LINE print ( c . description ) NEW_LINE
def get_indexes ( lst ) : NEW_LINE INDENT return [ i for i , x in enumerate ( lst ) if x ] NEW_LINE DEDENT
import random NEW_LINE random . seed ( 0 ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT print ( random . randint ( 0 , 10 ) ) NEW_LINE DEDENT
import random NEW_LINE def get_random_item ( model ) : NEW_LINE INDENT count = model . objects . count ( ) NEW_LINE random_index = random . randint ( 0 , count - 1 ) NEW_LINE return model . objects . all ( ) [ random_index ] NEW_LINE DEDENT
def switch_chars ( string ) : NEW_LINE INDENT if len ( string ) < 2 : NEW_LINE INDENT return string NEW_LINE DEDENT else : NEW_LINE INDENT return string [ 1 ] + string [ 0 ] + switch_chars ( string [ 2 : ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import doctest NEW_LINE doctest . testmod ( ) NEW_LINE DEDENT
s = set ( [ 1 , 2 , 3 ] ) NEW_LINE s . pop ( ) NEW_LINE print ( s ) NEW_LINE
def unicode_to_str ( unicode_string ) : NEW_LINE INDENT return unicode_string . encode ( ' utf - 8' ) NEW_LINE DEDENT
import numpy as np NEW_LINE a = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE print ( a ) NEW_LINE b = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ) NEW_LINE print ( b ) NEW_LINE c = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] , dtype = np . float64 ) NEW_LINE print ( c ) NEW_LINE d = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] , dtype = np . complex ) NEW_LINE print ( d ) NEW_LINE e = np . zeros ( ( 3 , 4 ) ) NEW_LINE print ( e ) NEW_LINE f = np . ones ( ( 2 , 3 , 4 ) , dtype = np . int16 ) NEW_LINE print ( f ) NEW_LINE g = np . empty ( ( 2 , 3 ) ) NEW_LINE print ( g ) NEW_LINE h = np . arange ( 10 , 30 , 5 ) NEW_LINE print ( h ) NEW_LINE i = np . arange ( 0 , 2 , 0.3 ) NEW_LINE print ( i ) NEW_LINE j = np . linspace ( 0 , 2 , 9 ) NEW_LINE print ( j ) NEW_LINE
import re NEW_LINE def repl ( m ) : NEW_LINE INDENT return ' { } ▁ { } ' . format ( m . group ( 1 ) , m . group ( 2 ) ) NEW_LINE DEDENT re . sub ( r ' ( \w + ) ▁ ( \w + ) ' , repl , ' hello ▁ world ' ) NEW_LINE
d = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 , ' d ' : 4 , ' e ' : 5 } NEW_LINE d = { k : v for k , v in d . items ( ) if v >= 3 } NEW_LINE d = { k : v for k , v in d . items ( ) if v < 3 } NEW_LINE
def replace_single_quote ( string ) : NEW_LINE INDENT return string . replace ( " ' " , " " ) NEW_LINE DEDENT
def find_element ( lst , elem ) : NEW_LINE INDENT for i in range ( len ( lst ) ) : NEW_LINE INDENT if lst [ i ] [ 0 ] == elem : NEW_LINE INDENT return lst [ i ] [ 1 ] NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT
def slice_list ( l , n ) : NEW_LINE INDENT return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ] NEW_LINE DEDENT
def add_tuple ( tuple_list , tuple_to_add ) : NEW_LINE INDENT tuple_list . append ( tuple_to_add ) NEW_LINE return tuple_list NEW_LINE DEDENT
import hashlib NEW_LINE h = hashlib . md5 ( ) NEW_LINE h . update ( " Hello ▁ World " ) NEW_LINE digest = h . digest ( ) NEW_LINE key = Key ( bucket , digest ) NEW_LINE key . set_contents_from_string ( " Hello ▁ World " ) NEW_LINE
def max_length ( list_of_lists ) : NEW_LINE INDENT max_lengths = [ ] NEW_LINE for i in range ( len ( list_of_lists [ 0 ] ) ) : NEW_LINE INDENT max_lengths . append ( max ( [ len ( str ( row [ i ] ) ) for row in list_of_lists ] ) ) NEW_LINE DEDENT return max_lengths NEW_LINE DEDENT def print_table ( list_of_lists ) : NEW_LINE INDENT max_lengths = max_length ( list_of_lists ) NEW_LINE for row in list_of_lists : NEW_LINE INDENT for i in range ( len ( row ) ) : NEW_LINE INDENT print ( str ( row [ i ] ) . ljust ( max_lengths [ i ] ) , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT print_table ( [ [ ' apples ' , ' oranges ' , ' cherries ' , ' banana ' ] , [ ' Alice ' , ' Bob ' , ' Carol ' , ' David ' ] , [ ' dogs ' , ' cats ' , ' moose ' , ' goose ' ] ] ) NEW_LINE
import datetime NEW_LINE today = datetime . date . today ( ) NEW_LINE six_months = datetime . timedelta ( days = 180 ) NEW_LINE six_months_from_now = today + six_months NEW_LINE print ( six_months_from_now ) NEW_LINE
import numpy as np NEW_LINE a = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , np . nan ] , [ 7 , 8 , 9 ] ] ) NEW_LINE a [ ~ np . isnan ( a ) . any ( axis = 1 ) ] NEW_LINE
from django . db . models import F NEW_LINE Model . objects . order_by ( F ( ' one _ to _ one _ model _ _ name ' ) ) NEW_LINE
list_of_lists_of_lists = [ [ [ 1 , 2 ] , [ 3 , 4 ] ] , [ [ 5 , 6 ] , [ 7 , 8 ] ] ] NEW_LINE sum ( [ item [ 1 ] for item in [ item for item in list_of_lists_of_lists ] ] ) NEW_LINE
for i , v in enumerate ( [ ' tic ' , ' tac ' , ' toe ' ] ) : NEW_LINE INDENT print ( i , v ) NEW_LINE DEDENT
def remove_duplicates ( string ) : NEW_LINE INDENT return ' ' . join ( set ( string ) ) NEW_LINE DEDENT print ( remove_duplicates ( ' abcdabcd ' ) ) NEW_LINE
import re NEW_LINE def match_all_but ( string ) : NEW_LINE INDENT return re . compile ( r ' ^ ( ? : ( ? ! { } ) . ) * $ ' . format ( string ) ) NEW_LINE DEDENT
import datetime NEW_LINE def sort_dates ( dates ) : NEW_LINE INDENT return sorted ( dates , key = lambda x : datetime . datetime . strptime ( x , ' % m / % d / % Y ' ) ) NEW_LINE DEDENT
import numpy as np NEW_LINE A = np . matrix ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE A . tolist ( ) NEW_LINE
def coalesce ( s ) : NEW_LINE INDENT return ' ' . join ( c for c , _ in itertools . groupby ( s ) ) NEW_LINE DEDENT
import numpy as np NEW_LINE a = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE print ( a [ 0 , 1 ] ) NEW_LINE print ( a [ 1 , 2 ] ) NEW_LINE print ( a [ 2 , 0 ] ) NEW_LINE
from google . appengine . api import app_identity NEW_LINE from google . appengine . api import urlfetch NEW_LINE import json NEW_LINE import urllib NEW_LINE def upload_file ( file_name , file_content ) : NEW_LINE INDENT bucket_name = app_identity . get_default_gcs_bucket_name ( ) NEW_LINE url = ' https : / / www . googleapis . com / upload / storage / v1 / b / ' + bucket_name + ' / o ? uploadType = media & name = ' + file_name NEW_LINE headers = { ' Content - Type ' : ' application / octet - stream ' } NEW_LINE result = urlfetch . fetch ( url = url , payload = file_content , method = urlfetch . POST , headers = headers ) NEW_LINE if result . status_code == 200 : NEW_LINE INDENT return json . loads ( result . content ) NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def sort_list ( lst ) : NEW_LINE INDENT return sorted ( lst , key = lambda x : int ( filter ( str . isdigit , x ) ) ) NEW_LINE DEDENT print sort_list ( [ '1' , '2' , '10' , '20' , '100' , '200' , '1000' , '2000' ] ) NEW_LINE print sort_list ( [ '1' , '2' , '10' , '20' , '100' , '200' , '1000' , '2000' , ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' , ' g ' , ' h ' ] ) NEW_LINE print sort_list ( [ '1' , '2' , '10' , '20' , '100' , '200' , '1000' , '2000' , ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' , ' g ' , ' h ' , '1a ' , '2b ' , '10c ' , '20d ' , '100e ' , '200f ' , '1000g ' , '2000h ' ] ) NEW_LINE print sort_list ( [ '1' , '2' , '10' , '20' , '100' , '200' , '1000' , '2000' , ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' , ' g ' , ' h ' , '1a ' , '2b ' , '10c ' , '20d ' , '100e ' , '200f ' , '1000g ' , '2000h ' , '1a1' , '2b2' , '10c10' , '20d20' , '100e100' , '200f200' , '1000g1000' , '2000h2000' ] ) NEW_LINE
import matplotlib . pyplot as plt NEW_LINE plt . figure ( figsize = ( 8 , 6 ) , dpi = 80 ) NEW_LINE plt . subplot ( 1 , 1 , 1 ) NEW_LINE X = np . linspace ( - np . pi , np . pi , 256 , endpoint = True ) NEW_LINE C , S = np . cos ( X ) , np . sin ( X ) NEW_LINE plt . plot ( X , C , color = " blue " , linewidth = 1.0 , linestyle = " - " ) NEW_LINE plt . plot ( X , S , color = " green " , linewidth = 1.0 , linestyle = " - " ) NEW_LINE plt . xlim ( - 4.0 , 4.0 ) NEW_LINE plt . xticks ( np . linspace ( - 4 , 4 , 9 , endpoint = True ) ) NEW_LINE plt . ylim ( - 1.0 , 1.0 ) NEW_LINE plt . yticks ( np . linspace ( - 1 , 1 , 5 , endpoint = True ) ) NEW_LINE plt . show ( ) NEW_LINE
def get_list ( request ) : NEW_LINE INDENT list = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE return render ( request , ' list . html ' , { ' list ' : list } ) NEW_LINE DEDENT
from operator import itemgetter NEW_LINE def sort_list_of_dict ( list_of_dict , order ) : NEW_LINE INDENT return sorted ( list_of_dict , key = itemgetter ( * order ) ) NEW_LINE DEDENT
import socket NEW_LINE import struct NEW_LINE def ip2long ( ip ) : NEW_LINE INDENT packedIP = socket . inet_aton ( ip ) NEW_LINE return struct . unpack ( " ! L " , packedIP ) [ 0 ] NEW_LINE DEDENT def long2ip ( ip ) : NEW_LINE INDENT return socket . inet_ntoa ( struct . pack ( ' ! L ' , ip ) ) NEW_LINE DEDENT print ip2long ( '192.168.1.1' ) NEW_LINE print long2ip ( 3232235777 ) NEW_LINE
hex_bytes = [ '0x01' , '0x02' , '0x03' , '0x04' ] NEW_LINE hex_ints = [ int ( h , 16 ) for h in hex_bytes ] NEW_LINE hex_ints NEW_LINE [ 1 , 2 , 3 , 4 ] NEW_LINE
s = u ' \u4e2d\u6587' NEW_LINE s NEW_LINE s . split ( ) NEW_LINE [ u ' \u4e2d\u6587' ] NEW_LINE list ( s ) NEW_LINE [ u ' \u4e2d ' , u ' \u6587' ] NEW_LINE
def decrypt ( encrypted_string , key ) : NEW_LINE INDENT encrypted_bytes = encrypted_string . decode ( ' utf - 8' ) NEW_LINE decrypted_bytes = decrypt_bytes ( encrypted_bytes , key ) NEW_LINE decrypted_string = decrypted_bytes . decode ( ' utf - 8' ) NEW_LINE return decrypted_string NEW_LINE DEDENT
I ' m ▁ trying ▁ to ▁ create ▁ a ▁ MITM ▁ proxy ▁ over ▁ SSL . ▁ I ' m using the following code : NEW_LINE < code > import socket NEW_LINE import ssl NEW_LINE def main ( ) : NEW_LINE INDENT context = ssl . create_default_context ( ssl . Purpose . CLIENT_AUTH ) NEW_LINE context . load_cert_chain ( certfile = " cert . pem " , keyfile = " key . pem " ) NEW_LINE bindsocket = socket . socket ( ) NEW_LINE bindsocket . bind ( ( ' ' , 443 ) ) NEW_LINE bindsocket . listen ( 5 ) NEW_LINE while True : NEW_LINE INDENT newsocket , fromaddr = bindsocket . accept ( ) NEW_LINE conn = context . wrap_socket ( newsocket , server_side = True ) NEW_LINE try : NEW_LINE INDENT deal_with_client ( conn ) NEW_LINE DEDENT finally : NEW_LINE INDENT conn . shutdown ( socket . SHUT_RDWR ) NEW_LINE conn . close ( ) NEW_LINE DEDENT DEDENT DEDENT def deal_with_client ( conn ) : NEW_LINE INDENT data = conn . recv ( 1024 ) NEW_LINE print ( data ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT < / code > NEW_LINE I ' m using the following command to generate the certificate : NEW_LINE < code > openssl req - x509 - newkey rsa : 4096 - keyout key . pem - out cert . pem - days 365 - nodes NEW_LINE < / code > NEW_LINE I ' m using the following command to connect to the proxy : NEW_LINE < code > curl - - proxy https : // localhost : 443 https : // www . google . com NEW_LINE < / code > NEW_LINE The problem is that the < code > wrap_socket < / code > call hangs . I ' ve tried using < code > context . check_hostname = False < / code > and < code > context . verify_mode = ssl . CERT_NONE < / code > but it still hangs . NEW_LINE I ' ve also tried using < code > context . verify_mode = ssl . CERT_REQUIRED < / code > and < code > context . check_hostname = True < / code > but it still hangs . NEW_LINE I ' ve also tried using < code > context . verify_mode = ssl . CERT_REQUIRED < / code > and < code > context . check_hostname = False < / code > but it still hangs . NEW_LINE I ' ve also tried using < code > context . NEW_LINE
def replace_empty_string_with_zero ( string ) : NEW_LINE INDENT return ' , ' . join ( str ( int ( x ) if x else 0 ) for x in string . split ( ' , ' ) ) NEW_LINE DEDENT
numbers = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE def squared ( num ) : NEW_LINE INDENT return num ** 2 NEW_LINE DEDENT squared_numbers = [ squared ( num ) for num in numbers ] NEW_LINE print ( squared_numbers ) NEW_LINE
import lxml . html NEW_LINE html = ''' STRNEWLINE < div > STRNEWLINE ▁ ▁ ▁ ▁ < ul > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 0 " > < a ▁ href = " link1 . html " > first ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 1 " > < a ▁ href = " link2 . html " > second ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - inactive " > < a ▁ href = " link3 . html " > third ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 1 " > < a ▁ href = " link4 . html " > fourth ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 0 " > < a ▁ href = " link5 . html " > fifth ▁ item < / a > STRNEWLINE ▁ ▁ ▁ ▁ ▁ < / ul > STRNEWLINE ▁ < / div > STRNEWLINE ''' NEW_LINE selector = lxml . html . fromstring ( html ) NEW_LINE result = selector . xpath ( ' / / li ' ) NEW_LINE print ( result ) NEW_LINE result = selector . xpath ( ' / / li [ @ class = " item - 0 " ] ' ) NEW_LINE print ( result ) NEW_LINE result = selector . xpath ( ' / / li / a / @ href ' ) NEW_LINE print ( result ) NEW_LINE result = selector . xpath ( ' / / li [ @ class = " item - 0 " ] / a / @ href ' ) NEW_LINE print ( result ) NEW_LINE result = selector . xpath ( ' / / li [ @ class = " item - 0 " ▁ or ▁ @ class = " item - 1 " ] / a / @ href ' ) NEW_LINE print ( result ) NEW_LINE
def first_last_n ( lst , n ) : NEW_LINE INDENT return lst [ : n ] + lst [ - n : ] NEW_LINE DEDENT
import requests NEW_LINE from bs4 import BeautifulSoup NEW_LINE url = ' https : / / www . nytimes . com / ' NEW_LINE r = requests . get ( url ) NEW_LINE r_html = r . text NEW_LINE soup = BeautifulSoup ( r_html , " html . parser " ) NEW_LINE for tag in soup . find_all ( class_ = " story - heading " ) : NEW_LINE INDENT if tag . a : NEW_LINE INDENT print ( tag . a . text . replace ( " \n " , " ▁ " ) . strip ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( tag . contents [ 0 ] . strip ( ) ) NEW_LINE DEDENT DEDENT
def sort_pos_neg ( lst ) : NEW_LINE INDENT return sorted ( lst , key = lambda x : ( x < 0 , abs ( x ) ) ) NEW_LINE DEDENT
def contains ( string , substring ) : NEW_LINE INDENT return substring in string NEW_LINE DEDENT
s = ' \u00e9' NEW_LINE s NEW_LINE s . encode ( ' utf - 8' ) NEW_LINE s . encode ( ' utf - 8' ) . decode ( ' utf - 8' ) NEW_LINE
import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE plt . plot ( x , x , label = ' linear ' ) NEW_LINE plt . legend ( ) NEW_LINE plt . title ( ' Linear ▁ vs . ▁ Quadratic ▁ progression ' ) NEW_LINE plt . xlabel ( ' Input ' ) NEW_LINE plt . ylabel ( ' Output ' ) NEW_LINE plt . grid ( True ) NEW_LINE plt . xticks ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ) NEW_LINE plt . yticks ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ) NEW_LINE plt . tick_params ( axis = ' both ' , which = ' major ' , labelsize = 14 ) NEW_LINE plt . legend ( prop = { ' size ' : 14 } ) NEW_LINE plt . title ( ' Linear ▁ vs . ▁ Quadratic ▁ progression ' , fontsize = 20 ) NEW_LINE plt . xlabel ( ' Input ' , fontsize = 14 ) NEW_LINE plt . ylabel ( ' Output ' , fontsize = 14 ) NEW_LINE plt . show ( ) NEW_LINE
import numpy as np NEW_LINE def mag_sq ( x , y , z ) : NEW_LINE INDENT return x * x + y * y + z * z NEW_LINE DEDENT def mag_sq_numpy ( x , y , z ) : NEW_LINE INDENT return np . sum ( x * x + y * y + z * z ) NEW_LINE DEDENT
import re NEW_LINE def find_dict_items ( d , substr ) : NEW_LINE INDENT return { k : v for k , v in d . items ( ) if re . search ( substr , k ) } NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 , ' d ' : 4 , ' e ' : 5 } NEW_LINE print ( find_dict_items ( d , ' a ' ) ) NEW_LINE print ( find_dict_items ( d , ' b ' ) ) NEW_LINE print ( find_dict_items ( d , ' c ' ) ) NEW_LINE print ( find_dict_items ( d , ' d ' ) ) NEW_LINE print ( find_dict_items ( d , ' e ' ) ) NEW_LINE print ( find_dict_items ( d , ' f ' ) ) NEW_LINE DEDENT ` ` ` NEW_LINE ` ` ` shell NEW_LINE $ . / find_dict_items . py NEW_LINE { ' a ' : 1 } NEW_LINE { ' b ' : 2 } NEW_LINE { ' c ' : 3 } NEW_LINE { ' d ' : 4 } NEW_LINE { ' e ' : 5 } NEW_LINE { } NEW_LINE
def sort_list ( list_of_tuples ) : NEW_LINE INDENT return sorted ( list_of_tuples , key = lambda x : x [ 1 ] + x [ 2 ] ) NEW_LINE DEDENT
def sort_by_keys ( lst , * keys ) : NEW_LINE INDENT if len ( keys ) == 1 : NEW_LINE INDENT return sorted ( lst , key = lambda x : x [ keys [ 0 ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return sorted ( lst , key = lambda x : [ x [ key ] for key in keys ] ) NEW_LINE DEDENT DEDENT
def check_value_exist ( list , value ) : NEW_LINE INDENT if value in list : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT list = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE value = 3 NEW_LINE print ( check_value_exist ( list , value ) ) NEW_LINE
import datetime NEW_LINE def convert_date_to_day_of_week ( date_string ) : NEW_LINE INDENT date_object = datetime . datetime . strptime ( date_string , ' % Y - % m - % d ' ) NEW_LINE return date_object . strftime ( ' % A ' ) NEW_LINE DEDENT convert_date_to_day_of_week ( '2018-01-01' ) NEW_LINE
my_list = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE my_list = [ x for x in my_list if x % 2 == 0 ] NEW_LINE print ( my_list ) NEW_LINE
def reverse_list ( l ) : NEW_LINE INDENT return l [ : : - 1 ] NEW_LINE DEDENT
def limit_sentences ( text , max_sentences ) : NEW_LINE INDENT sentences = text . split ( ' . ' ) NEW_LINE if len ( sentences ) > max_sentences : NEW_LINE INDENT return ' . ' . join ( sentences [ : max_sentences ] ) + ' . ' NEW_LINE DEDENT else : NEW_LINE INDENT return text NEW_LINE DEDENT DEDENT limit_sentences ( ' This ▁ is ▁ a ▁ sentence . ▁ This ▁ is ▁ another ▁ sentence . ▁ This ▁ is ▁ a ▁ third ▁ sentence . ' , 2 ) NEW_LINE
def get_size ( l ) : NEW_LINE INDENT return len ( l ) NEW_LINE DEDENT
import tkinter as tk NEW_LINE root = tk . Tk ( ) NEW_LINE root . geometry ( "500x500" ) NEW_LINE root . mainloop ( ) NEW_LINE
test_str = " geeksforgeeks " NEW_LINE print ( " The ▁ original ▁ string ▁ is ▁ : ▁ " + str ( test_str ) ) NEW_LINE res = test_str [ : : 2 ] NEW_LINE print ( " The ▁ alternate ▁ characters ▁ of ▁ string ▁ are ▁ : ▁ " + str ( res ) ) NEW_LINE test_str = " geeksforgeeks " NEW_LINE print ( " The ▁ original ▁ string ▁ is ▁ : ▁ " + str ( test_str ) ) NEW_LINE res = " " NEW_LINE for i in range ( 0 , len ( test_str ) , 2 ) : NEW_LINE INDENT res += test_str [ i ] NEW_LINE DEDENT print ( " The ▁ alternate ▁ characters ▁ of ▁ string ▁ are ▁ : ▁ " + str ( res ) ) NEW_LINE test_str = " geeksforgeeks " NEW_LINE print ( " The ▁ original ▁ string ▁ is ▁ : ▁ " + str ( test_str ) ) NEW_LINE res = [ test_str [ i ] for i in range ( 0 , len ( test_str ) , 2 ) ] NEW_LINE print ( " The ▁ alternate ▁ characters ▁ of ▁ string ▁ are ▁ : ▁ " + str ( res ) ) NEW_LINE test_str = " geeksforgeeks " NEW_LINE print ( " The ▁ original ▁ string ▁ is ▁ : ▁ " + str ( test_str ) ) NEW_LINE res = filter ( lambda x : test_str . index ( x ) % 2 == 0 , test_str ) NEW_LINE print ( " The ▁ alternate ▁ characters ▁ of ▁ string ▁ are ▁ : ▁ " + str ( res ) ) NEW_LINE
def flatten ( l ) : NEW_LINE INDENT return [ item for sublist in l for item in sublist ] NEW_LINE DEDENT
def extract_values ( obj , key ) : NEW_LINE INDENT arr = [ ] NEW_LINE def extract ( obj , arr , key ) : NEW_LINE INDENT if isinstance ( obj , dict ) : NEW_LINE INDENT for k , v in obj . items ( ) : NEW_LINE INDENT if isinstance ( v , ( dict , list ) ) : NEW_LINE INDENT extract ( v , arr , key ) NEW_LINE DEDENT elif k == key : NEW_LINE INDENT arr . append ( v ) NEW_LINE DEDENT DEDENT DEDENT elif isinstance ( obj , list ) : NEW_LINE INDENT for item in obj : NEW_LINE INDENT extract ( item , arr , key ) NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT results = extract ( obj , arr , key ) NEW_LINE return results NEW_LINE DEDENT
def sum_second_value ( lst ) : NEW_LINE INDENT return sum ( map ( lambda x : x [ 1 ] , lst ) ) NEW_LINE DEDENT
list_of_dicts = [ { ' name ' : ' John ' , ' age ' : 20 } , { ' name ' : ' Mary ' , ' age ' : 25 } ] NEW_LINE [ d [ ' name ' ] for d in list_of_dicts ] NEW_LINE
from PIL import Image NEW_LINE im = Image . open ( " image . png " ) NEW_LINE if im . mode == " RGBA " : NEW_LINE INDENT im = im . convert ( " RGB " ) NEW_LINE DEDENT im . save ( " image . jpg " ) NEW_LINE
def check_if_all_in ( tup , lst ) : NEW_LINE INDENT return all ( x in lst for x in tup ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE def merge_dicts ( dicts ) : NEW_LINE INDENT result = defaultdict ( list ) NEW_LINE for d in dicts : NEW_LINE INDENT for k , v in d . items ( ) : NEW_LINE INDENT result [ k ] . append ( v ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
import re NEW_LINE def is_valid_IP ( strng ) : NEW_LINE INDENT return bool ( re . match ( r ' ^ ( ( [ 1-9 ] ? \d | 1\d\d | 2[0-4 ] \d | 25[0-5 ] ) ( \ . ( ? ! $ ) | $ ) ) { 4 } $ ' , strng ) ) NEW_LINE DEDENT
from PyQt5 . QtWidgets import QApplication , QWidget , QPushButton NEW_LINE from PyQt5 . QtGui import QColor NEW_LINE from PyQt5 . QtCore import Qt NEW_LINE import sys NEW_LINE class Example ( QWidget ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT super ( ) . __init__ ( ) NEW_LINE self . initUI ( ) NEW_LINE DEDENT def initUI ( self ) : NEW_LINE INDENT self . setGeometry ( 300 , 300 , 300 , 300 ) NEW_LINE self . setWindowTitle ( ' QPushButton ' ) NEW_LINE self . btn = QPushButton ( ' Button ' , self ) NEW_LINE self . btn . setStyleSheet ( ' background - color : ▁ red ; ▁ color : ▁ white ' ) NEW_LINE self . btn . resize ( self . btn . sizeHint ( ) ) NEW_LINE self . btn . move ( 50 , 50 ) NEW_LINE self . show ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT app = QApplication ( sys . argv ) NEW_LINE ex = Example ( ) NEW_LINE sys . exit ( app . exec_ ( ) ) NEW_LINE DEDENT
l = [ '1' , '2' , '3' ] NEW_LINE l = [ int ( i ) for i in l ] NEW_LINE
import matplotlib . pyplot as plt NEW_LINE x = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE y = [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 , 20 ] NEW_LINE plt . scatter ( x , y , s = 100 ) NEW_LINE plt . show ( ) NEW_LINE
s = " Hello , ▁ World ! \n " NEW_LINE s . rstrip ( ) NEW_LINE
def combinate ( set , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return [ [ ] ] NEW_LINE DEDENT else : NEW_LINE INDENT return [ x + [ y ] for x in combinate ( set , n - 1 ) for y in set if y not in x ] NEW_LINE DEDENT DEDENT
def list_to_hex_string ( l ) : NEW_LINE INDENT return ' ' . join ( map ( lambda x : ' % 02x ' % x , l ) ) NEW_LINE DEDENT
import datetime NEW_LINE date_string = "01/01/17 ▁ 12:10:03.234567" NEW_LINE date_dt = datetime . datetime . strptime ( date_string , " % d / % m / % y ▁ % H : % M : % S . % f " ) NEW_LINE print ( date_dt ) NEW_LINE
def find_closest ( L , target ) : NEW_LINE INDENT low = 0 NEW_LINE high = len ( L ) - 1 NEW_LINE while low < high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if target < L [ mid ] : NEW_LINE INDENT high = mid NEW_LINE DEDENT elif target > L [ mid ] : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT L = [ 1 , 2 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE target = 3 NEW_LINE print ( find_closest ( L , target ) ) NEW_LINE
my_list = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE print ( my_list ) NEW_LINE print ( my_list [ 0 ] ) NEW_LINE print ( my_list [ - 1 ] ) NEW_LINE print ( my_list [ - 2 ] ) NEW_LINE print ( my_list [ 0 : 3 ] ) NEW_LINE print ( my_list [ - 3 : ] ) NEW_LINE print ( my_list [ 2 : ] ) NEW_LINE print ( my_list [ : - 2 ] ) NEW_LINE print ( my_list [ : - 2 ] + my_list [ : - 2 ] [ : : - 1 ] ) NEW_LINE print ( my_list [ : : - 1 ] ) NEW_LINE print ( my_list [ : : - 2 ] ) NEW_LINE print ( my_list [ - 2 : : - 2 ] ) NEW_LINE print ( my_list [ - 2 : 0 : - 2 ] ) NEW_LINE print ( my_list [ - 3 : 0 : - 2 ] ) NEW_LINE print ( my_list [ - 4 : 0 : - 2 ] ) NEW_LINE print ( my_list [ - 5 : 0 : - 2 ] ) NEW_LINE print ( my_list [ - 6 : 0 : - 2 ] ) NEW_LINE print ( my_list [ - 7 : 0 : - 2 ] ) NEW_LINE
import re NEW_LINE def extract_first_two_characters ( string ) : NEW_LINE INDENT return re . findall ( r ' ^ \w { 2 } ' , string ) NEW_LINE DEDENT print ( extract_first_two_characters ( ' Python ' ) ) NEW_LINE print ( extract_first_two_characters ( ' Py ' ) ) NEW_LINE print ( extract_first_two_characters ( ' Java ' ) ) NEW_LINE
def to_lowercase ( s ) : NEW_LINE INDENT return s . lower ( ) NEW_LINE DEDENT
from flask import Flask , request NEW_LINE app = Flask ( __name__ ) NEW_LINE @ app . route ( ' / ' ) NEW_LINE def index ( ) : NEW_LINE INDENT return ' Index ▁ Page ' NEW_LINE DEDENT @ app . route ( ' / hello ' ) NEW_LINE def hello ( ) : NEW_LINE INDENT return ' Hello , ▁ World ' NEW_LINE DEDENT @ app . route ( ' / user / < username > ' ) NEW_LINE def show_user_profile ( username ) : NEW_LINE INDENT return ' User ▁ % s ' % username NEW_LINE DEDENT @ app . route ( ' / post / < int : post _ id > ' ) NEW_LINE def show_post ( post_id ) : NEW_LINE INDENT return ' Post ▁ % d ' % post_id NEW_LINE DEDENT @ app . route ( ' / path / < path : subpath > ' ) NEW_LINE def show_subpath ( subpath ) : NEW_LINE INDENT return ' Subpath ▁ % s ' % subpath NEW_LINE DEDENT @ app . route ( ' / projects / ' ) NEW_LINE def projects ( ) : NEW_LINE INDENT return ' The ▁ project ▁ page ' NEW_LINE DEDENT @ app . route ( ' / about ' ) NEW_LINE def about ( ) : NEW_LINE INDENT return ' The ▁ about ▁ page ' NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT app . run ( ) NEW_LINE DEDENT
def rgb_to_hex ( rgb ) : NEW_LINE INDENT return ' # % 02x % 02x % 02x ' % rgb NEW_LINE DEDENT def hex_to_rgb ( value ) : NEW_LINE INDENT value = value . lstrip ( ' # ' ) NEW_LINE lv = len ( value ) NEW_LINE return tuple ( int ( value [ i : i + lv // 3 ] , 16 ) for i in range ( 0 , lv , lv // 3 ) ) NEW_LINE DEDENT
import os NEW_LINE def is_descendant ( parent , child ) : NEW_LINE INDENT parent = os . path . abspath ( parent ) NEW_LINE child = os . path . abspath ( child ) NEW_LINE return child . startswith ( parent ) NEW_LINE DEDENT
import cv2 NEW_LINE import numpy as np NEW_LINE img = cv2 . imread ( ' lena . jpg ' , 0 ) NEW_LINE cv2 . imshow ( ' image ' , img ) NEW_LINE cv2 . waitKey ( 0 ) NEW_LINE cv2 . destroyAllWindows ( ) NEW_LINE
import os NEW_LINE def convert_line_endings ( file , in_encoding , out_encoding ) : NEW_LINE INDENT content = ' ' NEW_LINE outsize = 0 NEW_LINE with open ( file , ' rb ' ) as infile : NEW_LINE INDENT content = infile . read ( ) NEW_LINE outsize = len ( content ) NEW_LINE content = content . replace ( b ' \n ' , b ' \n ' ) NEW_LINE content = content . replace ( b ' ' , b ' \n ' ) NEW_LINE content = content . replace ( b ' \n ' , b ' \n ' ) NEW_LINE DEDENT with open ( file , ' wb ' ) as output : NEW_LINE INDENT for line in content . splitlines ( True ) : NEW_LINE INDENT outsize += len ( line ) - 1 NEW_LINE output . write ( line ) NEW_LINE DEDENT DEDENT print ( " Done . ▁ Saved ▁ % s ▁ bytes . " % ( len ( content ) - outsize ) ) NEW_LINE DEDENT convert_line_endings ( ' file . txt ' , ' utf - 8' , ' utf - 8' ) NEW_LINE
def string_to_list ( string ) : NEW_LINE INDENT return [ int ( x ) for x in string . split ( ) ] NEW_LINE DEDENT
import pygame NEW_LINE pygame . init ( ) NEW_LINE infoObject = pygame . display . Info ( ) NEW_LINE print ( infoObject . current_w ) NEW_LINE print ( infoObject . current_h ) NEW_LINE
def closest ( lst , K ) : NEW_LINE INDENT return lst [ min ( range ( len ( lst ) ) , key = lambda i : abs ( lst [ i ] - K ) ) ] NEW_LINE DEDENT lst = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE K = 5 NEW_LINE print ( closest ( lst , K ) ) NEW_LINE
def lookup ( name , scope ) : NEW_LINE INDENT if name in scope : NEW_LINE INDENT return scope [ name ] NEW_LINE DEDENT elif scope . get ( ' parent ' ) : NEW_LINE INDENT return lookup ( name , scope [ ' parent ' ] ) NEW_LINE DEDENT else : NEW_LINE INDENT raise NameError ( name ) NEW_LINE DEDENT DEDENT
import re NEW_LINE with open ( ' file . txt ' , ' r ' ) as f : NEW_LINE INDENT for line in f : NEW_LINE INDENT if re . search ( r ' $ ' , line ) : NEW_LINE INDENT print ( ' DOS ▁ line ▁ break ▁ found ! ' ) NEW_LINE DEDENT DEDENT DEDENT
