def transpose_dict ( d ) : NEW_LINE INDENT return { k : [ d [ k ] for d in d ] for k in d [ 0 ] } NEW_LINE DEDENT transpose_dict ( [ { ' a ' : 1 , ' b ' : 2 } , { ' a ' : 3 , ' b ' : 4 } , { ' a ' : 5 , ' b ' : 6 } ] ) NEW_LINE
def find_index ( to_search , target ) : NEW_LINE INDENT for i , value in enumerate ( to_search ) : NEW_LINE INDENT if value == target : NEW_LINE INDENT yield i NEW_LINE DEDENT DEDENT DEDENT my_list = [ ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' a ' , ' b ' , ' c ' ] NEW_LINE print ( list ( find_index ( my_list , ' b ' ) ) ) NEW_LINE
tup = ( 1 , 2 , 3 ) NEW_LINE lst = list ( tup ) NEW_LINE lst . append ( 4 ) NEW_LINE tup = tuple ( lst ) NEW_LINE print ( tup ) NEW_LINE
from google . appengine . ext import db NEW_LINE class Person ( db . Model ) : NEW_LINE INDENT name = db . StringProperty ( ) NEW_LINE DEDENT class Car ( db . Model ) : NEW_LINE INDENT owner = db . ReferenceProperty ( Person ) NEW_LINE DEDENT query = Car . all ( ) NEW_LINE query . filter ( ' owner ▁ = ' , Person . get_by_key_name ( ' John ' ) ) NEW_LINE
def sum_list_of_lists ( list_of_lists ) : NEW_LINE INDENT return [ sum ( x ) for x in zip ( * list_of_lists ) ] NEW_LINE DEDENT sum_list_of_lists ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE
def unzip ( pairs ) : NEW_LINE INDENT return zip ( * pairs ) NEW_LINE DEDENT
def string_to_pairs ( s ) : NEW_LINE INDENT return list ( zip ( s , s [ 1 : ] ) ) NEW_LINE DEDENT string_to_pairs ( ' abcd ' ) NEW_LINE
def print_tsv ( lst ) : NEW_LINE INDENT print ( ' \t ' . join ( lst ) ) NEW_LINE DEDENT print_tsv ( [ ' a ' , ' b ' , ' c ' ] ) NEW_LINE
list_of_lists = [ [ ' a ' , ' b ' , ' c ' ] , [ ' d ' , ' e ' , ' f ' ] , [ ' g ' , ' h ' , ' i ' ] ] NEW_LINE merged_list = [ y for x in list_of_lists for y in x ] NEW_LINE print ( merged_list ) NEW_LINE
import pandas as pd NEW_LINE import matplotlib . pyplot as plt NEW_LINE df = pd . DataFrame ( { ' lab ' : [ ' A ' , ' B ' , ' C ' ] , ' val ' : [ 10 , 30 , 20 ] } ) NEW_LINE fig , ax = plt . subplots ( ) NEW_LINE for i in range ( len ( df [ ' val ' ] ) ) : NEW_LINE INDENT ax . bar ( df [ ' lab ' ] [ i ] , df [ ' val ' ] [ i ] , label = df [ ' lab ' ] [ i ] ) NEW_LINE DEDENT ax . set_xticklabels ( df [ ' lab ' ] ) NEW_LINE ax . legend ( ) NEW_LINE plt . show ( ) NEW_LINE
import re NEW_LINE def find_brackets ( string ) : NEW_LINE INDENT return re . findall ( r ' \ [ ( . * ? ) \ ] ' , string ) NEW_LINE DEDENT find_brackets ( ' [ hello ] ▁ [ world ] ' ) NEW_LINE
d = { ' a ' : 1 , ' b ' : 2 } NEW_LINE d [ ' c ' ] = 3 NEW_LINE
def hex_to_float ( h ) : NEW_LINE INDENT return struct . unpack ( ' > f ' , h . decode ( ' hex ' ) ) [ 0 ] NEW_LINE DEDENT
l = [ ] NEW_LINE l . append ( ( 1 , 2 ) ) NEW_LINE l . append ( ( 3 , 4 ) ) NEW_LINE l . append ( ( 5 , 6 ) ) NEW_LINE
import re NEW_LINE regexes = [ re . compile ( p ) for p in [ ' this ' , ' that ' ] ] NEW_LINE text = ' Does ▁ this ▁ text ▁ match ▁ the ▁ pattern ? ' NEW_LINE print ( ' Text : ▁ { ! r } \n ' . format ( text ) ) NEW_LINE for regex in regexes : NEW_LINE INDENT print ( ' Seeking ▁ " { } " ▁ - > ' . format ( regex . pattern ) , end = ' ▁ ' ) NEW_LINE if regex . search ( text ) : NEW_LINE INDENT print ( ' match ! ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' no ▁ match ' ) NEW_LINE DEDENT DEDENT
import os NEW_LINE import random NEW_LINE def random_file ( path ) : NEW_LINE INDENT files = os . listdir ( path ) NEW_LINE index = random . randrange ( 0 , len ( files ) ) NEW_LINE return files [ index ] NEW_LINE DEDENT print ( random_file ( ' / home / user / dir ' ) ) NEW_LINE
def remove_strings ( lst ) : NEW_LINE INDENT return [ x for x in lst if not isinstance ( x , str ) ] NEW_LINE DEDENT
import ipaddress NEW_LINE for ip in ipaddress . IPv4Network ( '192.168.0.0/24' ) : NEW_LINE INDENT print ( ip ) NEW_LINE DEDENT
def check_identical ( lst ) : NEW_LINE INDENT return len ( set ( lst ) ) == 1 NEW_LINE DEDENT
def increment ( s ) : NEW_LINE INDENT return str ( int ( s ) + 1 ) . zfill ( len ( s ) ) NEW_LINE DEDENT
a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE for i in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE keys = [ ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' ] NEW_LINE values = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] , [ 10 , 11 , 12 ] , [ 13 , 14 , 15 ] , [ 16 , 17 , 18 ] ] NEW_LINE d = defaultdict ( list ) NEW_LINE for k , v in zip ( keys , values ) : NEW_LINE INDENT d [ k ] . append ( v ) NEW_LINE DEDENT print ( d ) NEW_LINE
with open ( ' file . txt ' , ' r ' ) as f : NEW_LINE INDENT for line in f : NEW_LINE INDENT print ( line , end = ' ' ) NEW_LINE DEDENT DEDENT
import datetime NEW_LINE def order_by_date ( list_of_dicts ) : NEW_LINE INDENT return sorted ( list_of_dicts , key = lambda x : datetime . datetime . strptime ( x [ ' date ' ] , ' % Y - % m - % d ' ) ) NEW_LINE DEDENT
def is_all_upper ( text : str ) -> bool : NEW_LINE INDENT return text . isupper ( ) NEW_LINE DEDENT
from operator import itemgetter NEW_LINE list_of_strings = [ ' a , b , c ' , ' d , e , f ' , ' g , h , i ' ] NEW_LINE sorted_list = sorted ( list_of_strings , key = lambda x : x . split ( ' , ' ) [ 1 ] ) NEW_LINE print ( sorted_list ) NEW_LINE
def remove_if ( predicate , lst ) : NEW_LINE INDENT return [ x for x in lst if not predicate ( x ) ] NEW_LINE DEDENT
def sum_nested_list ( nested_list ) : NEW_LINE INDENT total = 0 NEW_LINE for item in nested_list : NEW_LINE INDENT if isinstance ( item , list ) : NEW_LINE INDENT total += sum_nested_list ( item ) NEW_LINE DEDENT else : NEW_LINE INDENT total += item NEW_LINE DEDENT DEDENT return total NEW_LINE DEDENT
import re NEW_LINE re . sub ( r ' [ ^ a - zA - Z0-9 ] ' , ' ' , ' abc123' ) NEW_LINE
import numpy as np NEW_LINE import matplotlib . pyplot as plt NEW_LINE from matplotlib . colors import LogNorm NEW_LINE np . random . seed ( 19680801 ) NEW_LINE dt = 0.01 NEW_LINE t = np . arange ( 0 , 30 , dt ) NEW_LINE nse1 = np . random . randn ( len ( t ) ) NEW_LINE nse2 = np . random . randn ( len ( t ) ) NEW_LINE s1 = np . sin ( 2 * np . pi * 10 * t ) + nse1 NEW_LINE s2 = np . sin ( 2 * np . pi * 10 * t ) + nse2 NEW_LINE fig , axs = plt . subplots ( 2 , 1 ) NEW_LINE axs [ 0 ] . plot ( t , s1 , t , s2 ) NEW_LINE axs [ 0 ] . set_xlim ( 0 , 2 ) NEW_LINE axs [ 0 ] . set_xlabel ( ' time ' ) NEW_LINE axs [ 0 ] . set_ylabel ( ' s1 ▁ and ▁ s2' ) NEW_LINE axs [ 0 ] . grid ( True ) NEW_LINE cxy , f = axs [ 1 ] . cohere ( s1 , s2 , 256 , 1. / dt ) NEW_LINE axs [ 1 ] . set_ylabel ( ' coherence ' ) NEW_LINE fig . tight_layout ( ) NEW_LINE plt . show ( ) NEW_LINE
from django . db . models import Max NEW_LINE max_value = Model . objects . all ( ) . aggregate ( Max ( ' field _ name ' ) ) NEW_LINE
import re NEW_LINE def find_between ( s , first , last ) : NEW_LINE INDENT try : NEW_LINE INDENT start = s . index ( first ) + len ( first ) NEW_LINE end = s . index ( last , start ) NEW_LINE return s [ start : end ] NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return " " NEW_LINE DEDENT DEDENT def find_between_r ( s , first , last ) : NEW_LINE INDENT try : NEW_LINE INDENT start = s . rindex ( first ) + len ( first ) NEW_LINE end = s . rindex ( last , start ) NEW_LINE return s [ start : end ] NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return " " NEW_LINE DEDENT DEDENT def find_between_regex ( s , first , last ) : NEW_LINE INDENT try : NEW_LINE INDENT start = re . search ( first , s ) . end ( ) NEW_LINE end = re . search ( last , s ) . start ( ) NEW_LINE return s [ start : end ] NEW_LINE DEDENT except AttributeError : NEW_LINE INDENT return " " NEW_LINE DEDENT DEDENT s = " This ▁ is ▁ a ▁ string " NEW_LINE print find_between ( s , " is " , " a " ) NEW_LINE print find_between_r ( s , " is " , " a " ) NEW_LINE print find_between_regex ( s , " is " , " a " ) NEW_LINE
import xlrd NEW_LINE book = xlrd . open_workbook ( " file . xls " ) NEW_LINE sheet = book . sheet_by_name ( " Sheet1" ) NEW_LINE data = [ sheet . row_values ( i ) for i in range ( sheet . nrows ) ] NEW_LINE with open ( ' file . txt ' , ' w ' ) as f : NEW_LINE INDENT for line in data : NEW_LINE INDENT f . write ( str ( line ) + ' \n ' ) NEW_LINE DEDENT DEDENT
for file in files : NEW_LINE INDENT print ( file ) NEW_LINE DEDENT
def longest_word ( words ) : NEW_LINE INDENT longest = 0 NEW_LINE for word in words : NEW_LINE INDENT if len ( word ) > longest : NEW_LINE INDENT longest = len ( word ) NEW_LINE DEDENT DEDENT return longest NEW_LINE DEDENT print ( longest_word ( [ ' cat ' , ' dog ' , ' elephant ' ] ) ) NEW_LINE
import pprint NEW_LINE import logging NEW_LINE logging . basicConfig ( filename = ' example . log ' , level = logging . DEBUG ) NEW_LINE data = [ ( i , { ' a ' : ' A ' , ' b ' : ' B ' , ' c ' : ' C ' , ' d ' : ' D ' , ' e ' : ' E ' , ' f ' : ' F ' , ' g ' : ' G ' , ' h ' : ' H ' , ' i ' : ' I ' , ' j ' : ' J ' , ' k ' : ' K ' , ' l ' : ' L ' , ' m ' : ' M ' , ' n ' : ' N ' , ' o ' : ' O ' , ' p ' : ' P ' , ' q ' : ' Q ' , ' r ' : ' R ' , ' s ' : ' S ' , ' t ' : ' T ' , ' u ' : ' U ' , ' v ' : ' V ' , ' w ' : ' W ' , ' x ' : ' X ' , ' y ' : ' Y ' , ' z ' : ' Z ' } ) for i in range ( 10 ) ] NEW_LINE logging . debug ( pprint . pformat ( data ) ) NEW_LINE
import os NEW_LINE def check_dir ( dir ) : NEW_LINE INDENT if not os . path . exists ( dir ) : NEW_LINE INDENT os . makedirs ( dir ) NEW_LINE DEDENT DEDENT
def convert_list_of_lists_to_list_of_integers ( list_of_lists ) : NEW_LINE INDENT return [ int ( item ) for sublist in list_of_lists for item in sublist ] NEW_LINE DEDENT
d = { ' a ' : 1 , ' b ' : None , ' c ' : 3 } NEW_LINE d = { k : v for k , v in d . items ( ) if v is not None } NEW_LINE
def find_largest_key ( d ) : NEW_LINE INDENT return max ( k for k , v in d . items ( ) if v ) NEW_LINE DEDENT d = { ' a ' : 0 , ' b ' : 1 , ' c ' : 2 , ' d ' : 0 } NEW_LINE print ( find_largest_key ( d ) ) NEW_LINE
for key , value in cursor : NEW_LINE INDENT print ( key , value ) NEW_LINE DEDENT
l = [ True , False , True , False , True ] NEW_LINE l . index ( True ) NEW_LINE
f = open ( ' test . txt ' , ' w ' ) NEW_LINE f . write ( ' This ▁ is ▁ a ▁ test \n ' ) NEW_LINE f . close ( ) NEW_LINE
list1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE list2 = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE list1 . extend ( list2 ) NEW_LINE print ( list1 ) NEW_LINE
import datetime NEW_LINE def convert_epoch_to_datetime ( epoch_time ) : NEW_LINE INDENT return datetime . datetime . fromtimestamp ( epoch_time / 1000 ) NEW_LINE DEDENT print ( convert_epoch_to_datetime ( 1588291200000 ) ) NEW_LINE
import re NEW_LINE def replace_word ( text , word , replacement ) : NEW_LINE INDENT regex = r " \b " + word + r " \b " NEW_LINE return re . sub ( regex , replacement , text ) NEW_LINE DEDENT
from datetime import date , timedelta NEW_LINE from dateutil . rrule import rrule , MONTHLY , FR NEW_LINE def get_second_friday ( year , month ) : NEW_LINE INDENT return list ( rrule ( freq = MONTHLY , byweekday = FR ( 2 ) , dtstart = date ( year , month , 1 ) ) ) [ 1 ] NEW_LINE DEDENT def get_daterange ( year , month ) : NEW_LINE INDENT second_friday = get_second_friday ( year , month ) NEW_LINE return second_friday - timedelta ( days = 7 ) , second_friday + timedelta ( days = 7 ) NEW_LINE DEDENT print ( get_daterange ( 2020 , 1 ) ) NEW_LINE
import codecs NEW_LINE s = ' Привет ' NEW_LINE s = s . decode ( ' cp1251' ) NEW_LINE s = s . encode ( ' utf - 8' ) NEW_LINE
def get_last_part ( s , c ) : NEW_LINE INDENT return s . rsplit ( c , 1 ) [ - 1 ] NEW_LINE DEDENT print ( get_last_part ( ' https : / / www . w3resource . com / python - exercises / string ' , ' / ' ) ) NEW_LINE print ( get_last_part ( ' https : / / www . w3resource . com / python - exercises / string ' , ' - ' ) ) NEW_LINE
import os NEW_LINE def find_files ( suffix , path ) : NEW_LINE INDENT if not os . path . isdir ( path ) : NEW_LINE INDENT return " Not ▁ a ▁ valid ▁ directory " NEW_LINE DEDENT if not suffix : NEW_LINE INDENT return " Suffix ▁ cannot ▁ be ▁ empty " NEW_LINE DEDENT if not path : NEW_LINE INDENT return " Path ▁ cannot ▁ be ▁ empty " NEW_LINE DEDENT if not os . path . exists ( path ) : NEW_LINE INDENT return " Path ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( suffix ) : NEW_LINE INDENT return " Suffix ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( path ) : NEW_LINE INDENT return " Path ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( suffix ) : NEW_LINE INDENT return " Suffix ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( path ) : NEW_LINE INDENT return " Path ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( suffix ) : NEW_LINE INDENT return " Suffix ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( path ) : NEW_LINE INDENT return " Path ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( suffix ) : NEW_LINE INDENT return " Suffix ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( path ) : NEW_LINE INDENT return " Path ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( suffix ) : NEW_LINE INDENT return " Suffix ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( path ) : NEW_LINE INDENT return " Path ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( suffix ) : NEW_LINE INDENT return " Suffix ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( path ) : NEW_LINE INDENT return " Path ▁ does ▁ not ▁ exist " NEW_LINE DEDENT if not os . path . exists ( suffix ) : NEW_LINE INDENT return   " Suffix does not exist NEW_LINE DEDENT DEDENT
import urllib2 NEW_LINE url = ' http : / / www . python . org / ftp / python / 2.7.5 / Python - 2.7.5 . tar . bz2' NEW_LINE response = urllib2 . urlopen ( url ) NEW_LINE data = response . read ( ) NEW_LINE with open ( ' Python - 2.7.5 . tar . bz2' , ' wb ' ) as f : NEW_LINE INDENT f . write ( data ) NEW_LINE DEDENT
import re NEW_LINE def replace_whitespace ( string , replace_with ) : NEW_LINE INDENT return re . sub ( r ' \s + ' , replace_with , string ) NEW_LINE DEDENT replace_whitespace ( ' Hello ▁ World ' , ' _ ' ) NEW_LINE replace_whitespace ( ' Hello _ World ' , ' ▁ ' ) NEW_LINE
from operator import attrgetter NEW_LINE class Person : NEW_LINE INDENT def __init__ ( self , name , age ) : NEW_LINE INDENT self . name = name NEW_LINE self . age = age NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return repr ( ( self . name , self . age ) ) NEW_LINE DEDENT DEDENT people = [ Person ( ' John ' , 30 ) , Person ( ' Adam ' , 20 ) , Person ( ' Smith ' , 40 ) ] NEW_LINE print ( sorted ( people , key = attrgetter ( ' age ' ) ) ) NEW_LINE
def convert_list_of_string_to_list_of_integer ( list_of_string ) : NEW_LINE INDENT list_of_integer = [ ] NEW_LINE for string in list_of_string : NEW_LINE INDENT list_of_integer . append ( int ( string ) ) NEW_LINE DEDENT return list_of_integer NEW_LINE DEDENT
from operator import itemgetter NEW_LINE list_of_dicts = [ { ' name ' : ' John ' , ' age ' : 25 } , { ' name ' : ' Jane ' , ' age ' : 17 } , { ' name ' : ' Bob ' , ' age ' : 30 } ] NEW_LINE sorted ( list_of_dicts , key = itemgetter ( ' age ' ) ) NEW_LINE sorted ( list_of_dicts , key = itemgetter ( ' age ' ) , reverse = True ) NEW_LINE
def remove_special_characters ( string ) : NEW_LINE INDENT regex = re . compile ( ' [ ^ a - zA - Z\d ] ' ) NEW_LINE return regex . sub ( ' ' , string ) NEW_LINE DEDENT remove_special_characters ( " The ▁ quick ▁ brown ▁ fox ! " ) NEW_LINE
class MyModel ( models . Model ) : NEW_LINE INDENT my_field = models . CharField ( max_length = 100 , default = ' default ▁ value ' ) NEW_LINE DEDENT
from pycassa . system_manager import * NEW_LINE sys = SystemManager ( '127.0.0.1:9160' ) NEW_LINE ks = sys . get_keyspace ( ' Keyspace1' ) NEW_LINE cf = ks . get_column_family ( ' Standard1' ) NEW_LINE for key in cf . get_range ( ) : NEW_LINE INDENT print key NEW_LINE DEDENT
import numpy as np NEW_LINE a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE b = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE c = np . array ( [ a , b ] ) NEW_LINE print ( c ) NEW_LINE
string = " Hello ▁ World " NEW_LINE string . count ( " l " ) NEW_LINE
import re NEW_LINE def escape_quotes ( s ) : NEW_LINE INDENT return re . sub ( r ' ( [ " \ ' ] ) ' , r ' \\\1' , s ) NEW_LINE DEDENT
from datetime import datetime , timedelta NEW_LINE datetime . now ( ) - timedelta ( days = 365 * 100 ) NEW_LINE datetime . now ( ) + timedelta ( days = 365 * 100 ) NEW_LINE
def remove_escape_char ( string ) : NEW_LINE INDENT return string . replace ( ' \\ ' , ' ' ) NEW_LINE DEDENT
import numpy as np NEW_LINE a = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE print ( np . mean ( a , axis = 0 ) ) NEW_LINE print ( np . mean ( a , axis = 1 ) ) NEW_LINE
import sys NEW_LINE while True : NEW_LINE INDENT print ( " Please ▁ enter ▁ a ▁ number : " ) NEW_LINE try : NEW_LINE INDENT number = int ( sys . stdin . readline ( ) ) NEW_LINE print ( " You ▁ entered : " , number ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT print ( " That ▁ was ▁ not ▁ a ▁ number ! " ) NEW_LINE DEDENT DEDENT
import re NEW_LINE text = " This ▁ is ▁ a ▁ [ test ] ▁ of ▁ [ bracket ] ▁ matching " NEW_LINE re . findall ( r ' \ [ ( . * ? ) \ ] ' , text ) NEW_LINE
def last_occurrence ( string , char ) : NEW_LINE INDENT return string . rfind ( char ) NEW_LINE DEDENT
my_list = [ ' a ' , ' b ' , ' c ' , ' d ' ] NEW_LINE ' , ' . join ( my_list ) NEW_LINE
d = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 } NEW_LINE l = [ k for k , v in d . items ( ) ] NEW_LINE
try : NEW_LINE INDENT print ( 1 / 0 ) NEW_LINE DEDENT except : NEW_LINE INDENT print ( " Error " ) NEW_LINE DEDENT
areas = [ " hallway " , 11.25 , " kitchen " , 18.0 , " living ▁ room " , 20.0 , " bedroom " , 10.75 , " bathroom " , 9.50 ] NEW_LINE print ( areas [ 1 ] ) NEW_LINE print ( areas [ - 1 ] ) NEW_LINE print ( areas [ 5 ] ) NEW_LINE areas = [ " hallway " , 11.25 , " kitchen " , 18.0 , " living ▁ room " , 20.0 , " bedroom " , 10.75 , " bathroom " , 9.50 ] NEW_LINE eat_sleep_area = areas [ 3 ] + areas [ - 3 ] NEW_LINE print ( eat_sleep_area ) NEW_LINE areas = [ " hallway " , 11.25 , " kitchen " , 18.0 , " living ▁ room " , 20.0 , " bedroom " , 10.75 , " bathroom " , 9.50 ] NEW_LINE downstairs = areas [ : 6 ] NEW_LINE upstairs = areas [ 6 : ] NEW_LINE print ( downstairs ) NEW_LINE print ( upstairs ) NEW_LINE areas = [ " hallway " , 11.25 , " kitchen " , 18.0 , " living ▁ room " , 20.0 , " bedroom " , 10.75 , " bathroom " , 9.50 ] NEW_LINE downstairs = areas [ : 6 ] NEW_LINE upstairs = areas [ - 4 : ] NEW_LINE areas = [ " hallway " , 11.25 , " kitchen " , 18.0 , " living ▁ room " , 20.0 , " bedroom " , 10.75 , " bathroom " , 9.50 ] NEW_LINE areas [ - 1 ] = 10.50 NEW_LINE
if ' foo ' in locals ( ) : NEW_LINE INDENT print ( ' foo ▁ exists ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' foo ▁ does ▁ not ▁ exist ' ) NEW_LINE DEDENT
import requests NEW_LINE r = requests . get ( ' https : / / httpbin . org / get ' ) NEW_LINE print ( r . text ) NEW_LINE r = requests . post ( ' https : / / httpbin . org / post ' , data = { ' key ' : ' value ' } ) NEW_LINE print ( r . text ) NEW_LINE
def convert_to_int ( list_of_strings ) : NEW_LINE INDENT return [ int ( i ) for i in list_of_strings ] NEW_LINE DEDENT
def to_uppercase ( str ) : NEW_LINE INDENT return str . upper ( ) NEW_LINE DEDENT
my_dict = { i : i for i in my_list } NEW_LINE my_dict = dict . fromkeys ( my_list , 1 ) NEW_LINE my_dict = dict . fromkeys ( my_list ) NEW_LINE
def word_count ( str ) : NEW_LINE INDENT counts = dict ( ) NEW_LINE words = str . split ( ) NEW_LINE for word in words : NEW_LINE INDENT if word in counts : NEW_LINE INDENT counts [ word ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT counts [ word ] = 1 NEW_LINE DEDENT DEDENT return counts NEW_LINE DEDENT print ( word_count ( ' the ▁ quick ▁ brown ▁ fox ▁ jumps ▁ over ▁ the ▁ lazy ▁ dog . ' ) ) NEW_LINE
list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list_of_lists NEW_LINE
def sum_list_of_tuples ( list_of_tuples ) : NEW_LINE INDENT return sum ( map ( sum , list_of_tuples ) ) NEW_LINE DEDENT
import re NEW_LINE def sort_nicely ( l ) : NEW_LINE INDENT convert = lambda text : int ( text ) if text . isdigit ( ) else text NEW_LINE alphanum_key = lambda key : [ convert ( c ) for c in re . split ( ' ( [0-9 ] + ) ' , key ) ] NEW_LINE l . sort ( key = alphanum_key ) NEW_LINE DEDENT l = [ '1' , '2' , '10' , '11' , '20' , '21' , '100' , '101' , '200' , '201' ] NEW_LINE sort_nicely ( l ) NEW_LINE print ( l ) NEW_LINE
import re NEW_LINE def remove_parentheses ( string ) : NEW_LINE INDENT return re . sub ( r ' \ ( ( [ ^ ) ] + ) \ ) ' , r ' \1' , string ) NEW_LINE DEDENT
a = [ 1 , 2 , 3 ] NEW_LINE b = [ 4 , 5 , 6 ] NEW_LINE a [ : 0 ] = b NEW_LINE print ( a ) NEW_LINE
l = [ 1 , 2 , None , 3 , None , 4 , None ] NEW_LINE l . count ( None ) NEW_LINE
def rreplace ( s , old , new , occurrence ) : NEW_LINE INDENT li = s . rsplit ( old , occurrence ) NEW_LINE return new . join ( li ) NEW_LINE DEDENT
from sqlalchemy import func NEW_LINE session . query ( func . now ( ) ) . all ( ) NEW_LINE
import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . random . randn ( 1000 ) NEW_LINE y = np . random . randn ( 1000 ) NEW_LINE plt . hist2d ( x , y , bins = 40 ) NEW_LINE plt . colorbar ( ) NEW_LINE plt . show ( ) NEW_LINE
def get_all_combination ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return [ [ 0 ] , [ 1 ] ] NEW_LINE DEDENT else : NEW_LINE INDENT result = [ ] NEW_LINE for i in get_all_combination ( n - 1 ) : NEW_LINE INDENT result . append ( i + [ 0 ] ) NEW_LINE result . append ( i + [ 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT print ( get_all_combination ( 3 ) ) NEW_LINE
from collections import Counter NEW_LINE my_list = [ 1 , 1 , 2 , 3 , 4 , 5 , 3 , 2 , 3 , 4 , 2 , 1 , 2 , 3 ] NEW_LINE Counter ( my_list ) NEW_LINE Counter ( { 2 : 4 , 3 : 4 , 1 : 3 , 4 : 2 , 5 : 1 } ) NEW_LINE Counter ( my_list ) . items ( ) NEW_LINE dict_items ( [ ( 1 , 3 ) , ( 2 , 4 ) , ( 3 , 4 ) , ( 4 , 2 ) , ( 5 , 1 ) ] ) NEW_LINE Counter ( my_list ) . keys ( ) NEW_LINE dict_keys ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE Counter ( my_list ) . values ( ) NEW_LINE dict_values ( [ 3 , 4 , 4 , 2 , 1 ] ) NEW_LINE
from lxml import etree NEW_LINE html = ''' STRNEWLINE < div > STRNEWLINE ▁ ▁ ▁ ▁ < ul > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 0 " > < a ▁ href = " link1 . html " > first ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 1 " > < a ▁ href = " link2 . html " > second ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - inactive " > < a ▁ href = " link3 . html " > third ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 1 " > < a ▁ href = " link4 . html " > fourth ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 0 " > < a ▁ href = " link5 . html " > fifth ▁ item < / a > STRNEWLINE ▁ ▁ ▁ ▁ ▁ < / ul > STRNEWLINE ▁ < / div > STRNEWLINE ''' NEW_LINE selector = etree . HTML ( html ) NEW_LINE content = selector . xpath ( ' / / li [ @ class = " item - 0 " ] / a / text ( ) ' ) NEW_LINE print ( content ) NEW_LINE
import re NEW_LINE def remove_periods_in_acronyms ( text ) : NEW_LINE INDENT return re . sub ( r ' \b ( [ A - Z ] \ . ) + \b ' , lambda m : m . group ( ) . replace ( ' . ' , ' ' ) , text ) NEW_LINE DEDENT
import re NEW_LINE def replace_non_alphanumeric ( string ) : NEW_LINE INDENT return re . sub ( r ' \W + ' , ' ' , string ) NEW_LINE DEDENT replace_non_alphanumeric ( ' Hello , ▁ World ! ' ) NEW_LINE
matrix = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE my_dict = { ' a ' : [ 1 , 2 , 3 ] , ' b ' : [ 4 , 5 , 6 ] , ' c ' : [ 7 , 8 , 9 ] } NEW_LINE print ( my_dict ) NEW_LINE print ( type ( my_dict ) ) NEW_LINE
def reverse_sublist ( lst , start , end ) : NEW_LINE INDENT lst [ start : end ] = lst [ start : end ] [ : : - 1 ] NEW_LINE return lst NEW_LINE DEDENT
def search_list_in_dict ( dict_to_search , list_to_search ) : NEW_LINE INDENT for key , value in dict_to_search . items ( ) : NEW_LINE INDENT if set ( list_to_search ) . issubset ( value ) : NEW_LINE INDENT return key NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT
import json NEW_LINE json_data = ' { " a " :1 , " b " :2 , " c " :3 , " d " :4 , " e " :5 } ' NEW_LINE text = json . loads ( json_data ) NEW_LINE print ( text ) NEW_LINE
list_of_tuples_1 = [ ( 1 , 2 ) , ( 3 , 4 ) , ( 5 , 6 ) ] NEW_LINE list_of_tuples_2 = [ ( 1 , 2 ) , ( 3 , 4 ) , ( 5 , 6 ) ] NEW_LINE print ( list_of_tuples_1 == list_of_tuples_2 ) NEW_LINE
import re NEW_LINE def sort_by_regex ( lst , regex ) : NEW_LINE INDENT return sorted ( lst , key = lambda x : re . search ( regex , x ) . group ( 0 ) ) NEW_LINE DEDENT
def unicode_to_byte_string ( unicode_string ) : NEW_LINE INDENT return unicode_string . encode ( ' utf - 8' ) NEW_LINE DEDENT
fellowship = [ ' frodo ' , ' samwise ' , ' merry ' , ' aragorn ' , ' legolas ' , ' boromir ' , ' gimli ' ] NEW_LINE result = filter ( lambda member : ' a ' in member , fellowship ) NEW_LINE result_list = list ( result ) NEW_LINE print ( result_list ) NEW_LINE
def delete_item ( list , item ) : NEW_LINE INDENT if item in list : NEW_LINE INDENT list . remove ( item ) NEW_LINE DEDENT DEDENT
a = [ 1 , 2 , 3 ] NEW_LINE b = [ 4 , 5 , 6 ] NEW_LINE c = a + b NEW_LINE print ( c ) NEW_LINE
import datetime NEW_LINE def last_day_of_month ( any_day ) : NEW_LINE INDENT next_month = any_day . replace ( day = 28 ) + datetime . timedelta ( days = 4 ) NEW_LINE return next_month - datetime . timedelta ( days = next_month . day ) NEW_LINE DEDENT
def remove_key ( d , key ) : NEW_LINE INDENT r = dict ( d ) NEW_LINE del r [ key ] NEW_LINE return r NEW_LINE DEDENT def remove_key_from_list ( l , key ) : NEW_LINE INDENT return [ remove_key ( d , key ) for d in l ] NEW_LINE DEDENT
def remove_substring ( string_list , substring_list ) : NEW_LINE INDENT return [ string for string in string_list if not any ( substring in string for substring in substring_list ) ] NEW_LINE DEDENT
list_of_lists = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE zipped_list = list ( zip ( * list_of_lists ) ) NEW_LINE print ( zipped_list ) NEW_LINE
import unicodedata NEW_LINE unicodedata . normalize ( ' NFKD ' , ' \u00e9' ) . upper ( ) NEW_LINE
import numpy as np NEW_LINE a = [ ( ' a ' , np . nan ) , ( ' b ' , 2.0 ) , ( ' c ' , 1.0 ) ] NEW_LINE min ( a , key = lambda x : x [ 1 ] ) NEW_LINE
def most_frequent ( string ) : NEW_LINE INDENT return max ( string , key = string . count ) NEW_LINE DEDENT most_frequent ( ' abca ' ) NEW_LINE
import re NEW_LINE def has_letters ( input_string ) : NEW_LINE INDENT return bool ( re . search ( ' [ a - zA - Z ] ' , input_string ) ) NEW_LINE DEDENT
d = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 , ' d ' : 4 , ' e ' : 5 } NEW_LINE d_avg = { k : sum ( v ) / len ( v ) for k , v in d . items ( ) } NEW_LINE print ( d_avg ) NEW_LINE
a = [ [ 1 , 2 ] , [ 3 , 4 ] , [ 1 , 3 ] ] NEW_LINE a . sort ( key = lambda x : ( x [ 1 ] , - x [ 0 ] ) ) NEW_LINE print ( a ) NEW_LINE
d = { ' a ' : 1 , ' b ' : 2 } NEW_LINE d [ ' c ' ] = 3 NEW_LINE
def first_letter ( word ) : NEW_LINE INDENT return word [ 0 ] NEW_LINE DEDENT first_letter ( " Hello " ) NEW_LINE
import itertools NEW_LINE def get_combinations ( lst ) : NEW_LINE INDENT return list ( itertools . combinations ( lst , 3 ) ) NEW_LINE DEDENT print ( get_combinations ( [ 10 , 1 , 2 , 7 , 6 , 1 , 5 ] ) ) NEW_LINE
from operator import attrgetter NEW_LINE sorted ( student_objects , key = attrgetter ( ' grade ' , ' age ' ) ) NEW_LINE
import numpy as np NEW_LINE import matplotlib . pyplot as plt NEW_LINE
def find_same_index ( list1 , list2 ) : NEW_LINE INDENT index_list = [ ] NEW_LINE for i in range ( len ( list1 ) ) : NEW_LINE INDENT if list1 [ i ] in list2 : NEW_LINE INDENT index_list . append ( i ) NEW_LINE DEDENT DEDENT return index_list NEW_LINE DEDENT list1 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE list2 = [ 1 , 3 , 5 , 7 , 9 ] NEW_LINE print ( find_same_index ( list1 , list2 ) ) NEW_LINE
url = ' http : / / www . example . com / path / to / file . html ' NEW_LINE url . rsplit ( ' / ' , 1 ) [ - 1 ] NEW_LINE
def delete_letters ( string , letters ) : NEW_LINE INDENT for letter in letters : NEW_LINE INDENT string = string . replace ( letter , ' ' ) NEW_LINE DEDENT return string NEW_LINE DEDENT
def is_alpha_space ( string ) : NEW_LINE INDENT return string . replace ( " ▁ " , " " ) . isalpha ( ) NEW_LINE DEDENT print ( is_alpha_space ( " Hello ▁ World " ) ) NEW_LINE print ( is_alpha_space ( " HelloWorld " ) ) NEW_LINE print ( is_alpha_space ( " Hello ▁ World ▁ 123" ) ) NEW_LINE
a = [ 1 , 2 , 3 ] NEW_LINE b = [ [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE c = a + b NEW_LINE print ( c ) NEW_LINE
stock = { ' GOOG ' : 520.54 , ' FB ' : 76.45 , ' YHOO ' : 39.28 , ' AMZN ' : 306.21 , ' AAPL ' : 99.76 } NEW_LINE print ( stock ) NEW_LINE min_price = min ( zip ( stock . values ( ) , stock . keys ( ) ) ) NEW_LINE max_price = max ( zip ( stock . values ( ) , stock . keys ( ) ) ) NEW_LINE print ( min_price ) NEW_LINE print ( max_price ) NEW_LINE prices_sorted = sorted ( zip ( stock . values ( ) , stock . keys ( ) ) ) NEW_LINE print ( prices_sorted ) NEW_LINE
if item in list : NEW_LINE INDENT print ( " Item ▁ is ▁ in ▁ the ▁ list " ) NEW_LINE DEDENT
from operator import itemgetter NEW_LINE list_of_dicts = [ { ' name ' : ' John ' , ' age ' : 25 } , { ' name ' : ' Jane ' , ' age ' : 17 } , { ' name ' : ' Bob ' , ' age ' : 30 } ] NEW_LINE sorted ( list_of_dicts , key = itemgetter ( ' age ' ) ) NEW_LINE
import re NEW_LINE def is_ascii ( s ) : NEW_LINE INDENT return all ( ord ( c ) < 128 for c in s ) NEW_LINE DEDENT def is_ascii_re ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] + $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re2 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re3 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] {0 , } $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re4 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re5 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re6 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re7 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re8 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re9 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re10 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re11 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT def is_ascii_re12 ( s ) : NEW_LINE INDENT return bool ( re . match ( ' ^ [ \x00 - \x7F ] * $ ' , s ) ) NEW_LINE DEDENT
import datetime NEW_LINE current_date = datetime . datetime . now ( ) NEW_LINE six_months_later = current_date + datetime . timedelta ( days = 180 ) NEW_LINE print ( six_months_later ) NEW_LINE
tuple1 = ( 1 , 2 , 3 ) NEW_LINE tuple2 = ( 4 , 5 , 6 ) NEW_LINE tuple3 = tuple1 + tuple2 NEW_LINE print ( tuple3 ) NEW_LINE
import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE y = np . sin ( x ) NEW_LINE fig , ax = plt . subplots ( ) NEW_LINE im = ax . imshow ( y . reshape ( ( 10 , 10 ) ) , cmap = ' viridis ' ) NEW_LINE fig . colorbar ( im , ax = ax ) NEW_LINE plt . show ( ) NEW_LINE
def decode_string ( s ) : NEW_LINE INDENT try : NEW_LINE INDENT return s . decode ( ' utf8' ) NEW_LINE DEDENT except UnicodeDecodeError : NEW_LINE INDENT return s . decode ( ' latin1' ) NEW_LINE DEDENT DEDENT def encode_string ( s ) : NEW_LINE INDENT try : NEW_LINE INDENT return s . encode ( ' utf8' ) NEW_LINE DEDENT except UnicodeEncodeError : NEW_LINE INDENT return s . encode ( ' latin1' ) NEW_LINE DEDENT DEDENT
list1 = [ 1 , 2 , 3 ] NEW_LINE list2 = [ 4 , 5 , 6 ] NEW_LINE list3 = list1 + list2 NEW_LINE print ( list3 ) NEW_LINE
f = open ( " test . txt " , " a " ) NEW_LINE f . write ( " Hello ▁ World " ) NEW_LINE f . close ( ) NEW_LINE
import psutil NEW_LINE print ( psutil . cpu_percent ( ) ) NEW_LINE print ( psutil . virtual_memory ( ) ) NEW_LINE
import unicodedata NEW_LINE def unicode_name ( s ) : NEW_LINE INDENT return unicodedata . name ( s ) NEW_LINE DEDENT
def trim_whitespace ( s ) : NEW_LINE INDENT return s . strip ( ) NEW_LINE DEDENT
def remove_none ( lst ) : NEW_LINE INDENT return [ i for i in lst if i is not None ] NEW_LINE DEDENT
import re NEW_LINE def find_surrounding_sentence ( text , word ) : NEW_LINE INDENT sentences = re . split ( r ' ▁ * [ \ . \ ? ! ] [ \ ' " \ ) \ ] ] * ▁ * ' , text ) NEW_LINE for sentence in sentences : NEW_LINE INDENT if word in sentence : NEW_LINE INDENT return sentence NEW_LINE DEDENT DEDENT DEDENT text = " Hello , ▁ my ▁ name ▁ is ▁ John . ▁ I ▁ am ▁ a ▁ software ▁ engineer . ▁ I ▁ like ▁ to ▁ code ▁ in ▁ Python . " NEW_LINE word = " Python " NEW_LINE print ( find_surrounding_sentence ( text , word ) ) NEW_LINE
from sklearn . cluster import KMeans NEW_LINE import numpy as np NEW_LINE X = np . array ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ) NEW_LINE kmeans = KMeans ( n_clusters = 3 , random_state = 0 ) . fit ( X . reshape ( - 1 , 1 ) ) NEW_LINE print ( kmeans . labels_ ) NEW_LINE
import datetime NEW_LINE import pytz NEW_LINE utc = pytz . utc NEW_LINE today = datetime . date . today ( ) NEW_LINE print ( today ) NEW_LINE utc_today = utc . localize ( today ) NEW_LINE print ( utc_today ) NEW_LINE
def checkKey ( dict , key ) : NEW_LINE INDENT if key in dict . keys ( ) : NEW_LINE INDENT print ( " Present , ▁ " , end = " ▁ " ) NEW_LINE print ( " value ▁ = " , dict [ key ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ present " ) NEW_LINE DEDENT DEDENT dict = { ' a ' : 100 , ' b ' : 200 , ' c ' : 300 } NEW_LINE key = ' b ' NEW_LINE checkKey ( dict , key ) NEW_LINE key = ' w ' NEW_LINE checkKey ( dict , key ) NEW_LINE
def sort_list_of_lists ( list_of_lists , index ) : NEW_LINE INDENT return sorted ( list_of_lists , key = lambda x : x [ index ] ) NEW_LINE DEDENT
import urllib NEW_LINE import urllib2 NEW_LINE def url_get ( url , params ) : NEW_LINE INDENT return urllib2 . urlopen ( url + ' ? ' + urllib . urlencode ( params ) ) . read ( ) NEW_LINE DEDENT def url_post ( url , params ) : NEW_LINE INDENT return urllib2 . urlopen ( url , urllib . urlencode ( params ) ) . read ( ) NEW_LINE DEDENT
import json NEW_LINE with open ( ' data . json ' ) as f : NEW_LINE INDENT data = json . load ( f ) NEW_LINE DEDENT sorted_data = sorted ( data . items ( ) , key = lambda x : x [ 1 ] [ ' key ' ] ) NEW_LINE
import random NEW_LINE def random_item ( list ) : NEW_LINE INDENT return random . choice ( list ) NEW_LINE DEDENT
numbers = [ '1' , '2' , '3' , '4' , '5' ] NEW_LINE numbers = [ int ( i ) for i in numbers ] NEW_LINE
def remove_duplicates ( list_of_sets ) : NEW_LINE INDENT return list ( set ( map ( frozenset , list_of_sets ) ) ) NEW_LINE DEDENT
objects = [ { ' name ' : ' John ' , ' age ' : 20 } , { ' name ' : ' Mary ' , ' age ' : 30 } , { ' name ' : ' Bob ' , ' age ' : 25 } ] NEW_LINE names = [ obj [ ' name ' ] for obj in objects ] NEW_LINE ages = [ obj [ ' age ' ] for obj in objects ] NEW_LINE
import sys NEW_LINE from PyQt5 . QtWidgets import QApplication , QWidget , QPushButton NEW_LINE from PyQt5 . QtGui import QIcon NEW_LINE from PyQt5 . QtCore import pyqtSlot NEW_LINE class App ( QWidget ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT super ( ) . __init__ ( ) NEW_LINE self . title = ' PyQt5 ▁ button ▁ - ▁ pythonspot . com ' NEW_LINE self . left = 10 NEW_LINE self . top = 10 NEW_LINE self . width = 320 NEW_LINE self . height = 200 NEW_LINE self . initUI ( ) NEW_LINE DEDENT def initUI ( self ) : NEW_LINE INDENT self . setWindowTitle ( self . title ) NEW_LINE self . setGeometry ( self . left , self . top , self . width , self . height ) NEW_LINE button = QPushButton ( ' PyQt5 ▁ button ' , self ) NEW_LINE button . setStyleSheet ( " background - color : ▁ green " ) NEW_LINE button . setToolTip ( ' This ▁ is ▁ an ▁ example ▁ button ' ) NEW_LINE button . move ( 100 , 70 ) NEW_LINE button . clicked . connect ( self . on_click ) NEW_LINE self . show ( ) NEW_LINE DEDENT @ pyqtSlot ( ) NEW_LINE def on_click ( self ) : NEW_LINE INDENT print ( ' PyQt5 ▁ button ▁ click ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT app = QApplication ( sys . argv ) NEW_LINE ex = App ( ) NEW_LINE sys . exit ( app . exec_ ( ) ) NEW_LINE DEDENT
import re NEW_LINE re . findall ( r ' \d + ' , ' abc123def456' ) NEW_LINE
from google . appengine . ext import webapp NEW_LINE class MainPage ( webapp . RequestHandler ) : NEW_LINE INDENT def get ( self ) : NEW_LINE INDENT self . response . headers [ ' Content - Type ' ] = ' text / plain ' NEW_LINE self . response . out . write ( self . request . query_string ) NEW_LINE DEDENT DEDENT
import re NEW_LINE text = " Hello , ▁ my ▁ name ▁ is ▁ John . ▁ I ▁ am ▁ a ▁ software ▁ engineer . ▁ I ▁ am ▁ from ▁ Egypt . ▁ I ▁ speak ▁ Arabic ▁ and ▁ English . " NEW_LINE arabic_text = re . findall ( r ' [ \u0600 - \u06FF ] + ' , text ) NEW_LINE print ( arabic_text ) NEW_LINE
fellowship = [ ' frodo ' , ' samwise ' , ' merry ' , ' aragorn ' , ' legolas ' , ' boromir ' , ' gimli ' ] NEW_LINE new_fellowship = { member : len ( member ) for member in fellowship } NEW_LINE print ( new_fellowship ) NEW_LINE
from itertools import permutations NEW_LINE def find_all_sequences ( lst ) : NEW_LINE INDENT return list ( permutations ( lst ) ) NEW_LINE DEDENT
def reverse_string ( string ) : NEW_LINE INDENT return string [ : : - 1 ] NEW_LINE DEDENT print ( reverse_string ( " Hello " ) ) NEW_LINE
import json NEW_LINE with open ( ' data . json ' ) as json_file : NEW_LINE INDENT data = json . load ( json_file ) NEW_LINE for p in data [ ' people ' ] : NEW_LINE INDENT print ( ' Name : ▁ ' + p [ ' name ' ] ) NEW_LINE print ( ' Website : ▁ ' + p [ ' website ' ] ) NEW_LINE print ( ' From : ▁ ' + p [ ' from ' ] ) NEW_LINE print ( ' ' ) NEW_LINE DEDENT DEDENT
def chunks ( l , n ) : NEW_LINE INDENT for i in range ( 0 , len ( l ) , n ) : NEW_LINE INDENT yield l [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list_2 ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list_3 ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list_4 ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list_5 ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list_6 ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list_7 ( s , n ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) , n ) : NEW_LINE INDENT yield s [ i : i + n ] NEW_LINE DEDENT DEDENT def chunks_str_list_8 ( s , n ) : NEW_LINE
def sort_list ( list_of_lists ) : NEW_LINE INDENT return sorted ( list_of_lists , key = lambda x : x [ 1 ] ) NEW_LINE DEDENT
def starts_with_number ( s ) : NEW_LINE INDENT return s [ 0 ] . isdigit ( ) NEW_LINE DEDENT
def is_number ( s ) : NEW_LINE INDENT try : NEW_LINE INDENT float ( s ) NEW_LINE return True NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
import re NEW_LINE text = ' abbaaabbbbaaaaa ' NEW_LINE pattern = ' ab ' NEW_LINE for match in re . finditer ( pattern , text ) : NEW_LINE INDENT s = match . start ( ) NEW_LINE e = match . end ( ) NEW_LINE print ( ' Found ▁ " % s " ▁ at ▁ % d : % d ' % ( text [ s : e ] , s , e ) ) NEW_LINE DEDENT
from hashlib import sha256 NEW_LINE def hash_dict ( d ) : NEW_LINE INDENT return sha256 ( str ( sorted ( d . items ( ) ) ) . encode ( ' utf - 8' ) ) . hexdigest ( ) NEW_LINE DEDENT d1 = { ' a ' : 1 , ' b ' : 2 } NEW_LINE d2 = { ' b ' : 2 , ' a ' : 1 } NEW_LINE print ( hash_dict ( d1 ) ) NEW_LINE print ( hash_dict ( d2 ) ) NEW_LINE
from tkinter import * NEW_LINE root = Tk ( ) NEW_LINE canvas = Canvas ( root , width = 200 , height = 100 ) NEW_LINE canvas . pack ( ) NEW_LINE canvas . create_text ( 100 , 50 , text = " Hello ▁ World " , font = ( " Times " , 20 ) ) NEW_LINE root . mainloop ( ) NEW_LINE
def contains_lists ( lst ) : NEW_LINE INDENT for item in lst : NEW_LINE INDENT if isinstance ( item , list ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
import binascii NEW_LINE binascii . unhexlify ( '1a2b3c ' ) NEW_LINE
a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE a [ - 1 ] NEW_LINE
import sys NEW_LINE def get_input ( ) : NEW_LINE INDENT return sys . stdin . read ( 1 ) NEW_LINE DEDENT
def find ( s , ch ) : NEW_LINE INDENT return [ i for i , ltr in enumerate ( s ) if ltr == ch ] NEW_LINE DEDENT
import numpy as np NEW_LINE def str_to_float ( x ) : NEW_LINE INDENT return np . float ( hash ( x ) ) NEW_LINE DEDENT df [ ' Fault ' ] = df [ ' Fault ' ] . apply ( str_to_float ) NEW_LINE
import re NEW_LINE def replace_all ( text , dic ) : NEW_LINE INDENT for i , j in dic . iteritems ( ) : NEW_LINE INDENT text = re . sub ( i , j , text ) NEW_LINE DEDENT return text NEW_LINE DEDENT text = " My ▁ name ▁ is ▁ David . ▁ Hi ▁ David . " NEW_LINE dic = { ' David ' : ' Amy ' } NEW_LINE print replace_all ( text , dic ) NEW_LINE
def find_all ( a_list , elem ) : NEW_LINE INDENT return [ i for i , x in enumerate ( a_list ) if x == elem ] NEW_LINE DEDENT
import requests NEW_LINE from bs4 import BeautifulSoup NEW_LINE url = ' https : / / www . nytimes . com / ' NEW_LINE r = requests . get ( url ) NEW_LINE r_html = r . text NEW_LINE soup = BeautifulSoup ( r_html , ' html . parser ' ) NEW_LINE for story_heading in soup . find_all ( class_ = " story - heading " ) : NEW_LINE INDENT if story_heading . a : NEW_LINE INDENT print ( story_heading . a . text . replace ( " \n " , " ▁ " ) . strip ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( story_heading . contents [ 0 ] . strip ( ) ) NEW_LINE DEDENT DEDENT
x = 5 NEW_LINE if type ( x ) == int : NEW_LINE INDENT print ( " x ▁ is ▁ an ▁ integer " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " x ▁ is ▁ not ▁ an ▁ integer " ) NEW_LINE DEDENT
import numpy as np NEW_LINE arr = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE arr [ arr [ : , 1 ] . argsort ( ) ] NEW_LINE
class A : NEW_LINE INDENT pass NEW_LINE DEDENT class B ( A ) : NEW_LINE INDENT pass NEW_LINE DEDENT b = B ( ) NEW_LINE print ( b . __class__ . __name__ ) NEW_LINE
def sort_tuple ( tup ) : NEW_LINE INDENT return sorted ( tup , key = lambda x : x [ 1 ] ) NEW_LINE DEDENT
import re NEW_LINE def find_pattern ( string ) : NEW_LINE INDENT pattern = re . compile ( r ' ( \w + ) \1' ) NEW_LINE match = pattern . search ( string ) NEW_LINE if match : NEW_LINE INDENT return match . group ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT print ( find_pattern ( ' abcabcabc ' ) ) NEW_LINE print ( find_pattern ( ' abcabc ' ) ) NEW_LINE print ( find_pattern ( ' abc ' ) ) NEW_LINE print ( find_pattern ( ' ababab ' ) ) NEW_LINE print ( find_pattern ( ' abab ' ) ) NEW_LINE print ( find_pattern ( ' ab ' ) ) NEW_LINE print ( find_pattern ( ' a ' ) ) NEW_LINE print ( find_pattern ( ' ' ) ) NEW_LINE
import mysql . connector NEW_LINE cnx = mysql . connector . connect ( user = ' scott ' , password = ' password ' , host = '127.0.0.1' , database = ' employees ' ) NEW_LINE cursor = cnx . cursor ( ) NEW_LINE cursor . execute ( " SET ▁ SESSION ▁ query _ cache _ type ▁ = ▁ OFF " ) NEW_LINE cursor . execute ( " SELECT ▁ * ▁ FROM ▁ employees ▁ LIMIT ▁ 10" ) NEW_LINE results = cursor . fetchall ( ) NEW_LINE for row in results : NEW_LINE INDENT print ( row ) NEW_LINE DEDENT cursor . close ( ) NEW_LINE cnx . close ( ) NEW_LINE
import urllib . request NEW_LINE url = ' http : / / www . python . org / ' NEW_LINE urllib . request . urlretrieve ( url , ' python . html ' ) NEW_LINE
import requests NEW_LINE from bs4 import BeautifulSoup NEW_LINE url = ' https : / / www . youtube . com / watch ? v = 9bZkp7q19f0' NEW_LINE r = requests . get ( url ) NEW_LINE soup = BeautifulSoup ( r . text , ' html . parser ' ) NEW_LINE title = soup . find ( ' meta ' , attrs = { ' property ' : ' og : title ' } ) NEW_LINE description = soup . find ( ' meta ' , attrs = { ' property ' : ' og : description ' } ) NEW_LINE image = soup . find ( ' meta ' , attrs = { ' property ' : ' og : image ' } ) NEW_LINE print ( title [ ' content ' ] ) NEW_LINE print ( description [ ' content ' ] ) NEW_LINE print ( image [ ' content ' ] ) NEW_LINE
sorted ( [ ' abc ' , ' a ' , ' ab ' ] , key = lambda x : ( len ( x ) , x ) ) NEW_LINE [ ' a ' , ' ab ' , ' abc ' ] NEW_LINE
def convert_to_base_10 ( string ) : NEW_LINE INDENT return int ( string , 2 ) NEW_LINE DEDENT
def count_substring ( string , sub_string ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i : i + len ( sub_string ) ] == sub_string : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = input ( ) . strip ( ) NEW_LINE sub_string = input ( ) . strip ( ) NEW_LINE count = count_substring ( string , sub_string ) NEW_LINE print ( count ) NEW_LINE DEDENT
from bs4 import UnicodeDammit NEW_LINE def decode_html ( html_string ) : NEW_LINE INDENT converted = UnicodeDammit ( html_string , is_html = True ) NEW_LINE if not converted . unicode_markup : NEW_LINE INDENT raise UnicodeDecodeError ( " Failed ▁ to ▁ detect ▁ encoding , ▁ tried ▁ [ % s ] " , ' , ▁ ' . join ( converted . tried_encodings ) ) NEW_LINE DEDENT return converted . unicode_markup NEW_LINE DEDENT
a = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE del a [ 1 : 5 ] NEW_LINE a NEW_LINE [ 1 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE
import xlsxwriter NEW_LINE workbook = xlsxwriter . Workbook ( ' / home / user / Desktop / test . xlsx ' ) NEW_LINE worksheet = workbook . add_worksheet ( ) NEW_LINE worksheet . write ( ' A1' , ' Hello ▁ world ' ) NEW_LINE workbook . close ( ) NEW_LINE
d = { ' a ' : '1' , ' b ' : '2' , ' c ' : '3' } NEW_LINE d = { k : int ( v ) for k , v in d . items ( ) } NEW_LINE
d = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 } NEW_LINE l = list ( d . items ( ) ) NEW_LINE
s = " Hello ▁ World " NEW_LINE print ( s [ 0 : 5 ] ) NEW_LINE
def find_consecutive_consonants ( word ) : NEW_LINE INDENT vowels = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] NEW_LINE consonants = [ ] NEW_LINE for letter in word : NEW_LINE INDENT if letter not in vowels : NEW_LINE INDENT consonants . append ( letter ) NEW_LINE DEDENT DEDENT return ' ' . join ( consonants ) NEW_LINE DEDENT print ( find_consecutive_consonants ( ' strengths ' ) ) NEW_LINE
objects = [ { ' name ' : ' object1' , ' id ' : 1 } , { ' name ' : ' object2' , ' id ' : 2 } , { ' name ' : ' object3' , ' id ' : 3 } , { ' name ' : ' object4' , ' id ' : 4 } , { ' name ' : ' object5' , ' id ' : 5 } , ] NEW_LINE for obj in objects : NEW_LINE INDENT obj . delete ( ) NEW_LINE DEDENT
import yaml NEW_LINE with open ( ' config . yaml ' ) as f : NEW_LINE INDENT config = yaml . load ( f ) NEW_LINE DEDENT print ( config ) NEW_LINE
import numpy as np NEW_LINE data = np . recfromcsv ( ' data / data . csv ' ) NEW_LINE print data . dtype NEW_LINE print data [ 0 ] NEW_LINE print data [ - 1 ] NEW_LINE
import psycopg2 NEW_LINE conn = psycopg2 . connect ( database = " testdb " , user = " postgres " , password = " pass123" , host = "127.0.0.1" , port = "5432" ) NEW_LINE print ( " Opened ▁ database ▁ successfully " ) NEW_LINE cur = conn . cursor ( ) NEW_LINE cur . execute ( " SELECT ▁ * ▁ FROM ▁ COMPANY ▁ WHERE ▁ SALARY ▁ > ▁ % s " , ( 1000 , ) ) NEW_LINE rows = cur . fetchall ( ) NEW_LINE for row in rows : NEW_LINE INDENT print ( " ID ▁ = ▁ " , row [ 0 ] ) NEW_LINE print ( " NAME ▁ = ▁ " , row [ 1 ] ) NEW_LINE print ( " ADDRESS ▁ = ▁ " , row [ 2 ] ) NEW_LINE print ( " SALARY ▁ = ▁ " , row [ 3 ] , " \n " ) NEW_LINE DEDENT print ( " Operation ▁ done ▁ successfully " ) NEW_LINE conn . close ( ) NEW_LINE
def merge_lists ( list1 , list2 ) : NEW_LINE INDENT return list ( zip ( list1 , list2 ) ) NEW_LINE DEDENT
def find_item ( item , string ) : NEW_LINE INDENT return item in string NEW_LINE DEDENT
import pandas as pd NEW_LINE import numpy as np NEW_LINE df = pd . DataFrame ( { ' A ' : [ 1 , 2 , np . nan ] , ' B ' : [ 5 , np . nan , np . nan ] , ' C ' : [ 1 , 2 , 3 ] } ) NEW_LINE df NEW_LINE df . isnull ( ) NEW_LINE df . isnull ( ) . sum ( ) NEW_LINE df . dropna ( ) NEW_LINE df . dropna ( axis = 1 ) NEW_LINE df . dropna ( thresh = 2 ) NEW_LINE df . fillna ( value = ' FILL ▁ VALUE ' ) NEW_LINE df [ ' A ' ] . fillna ( value = df [ ' A ' ] . mean ( ) ) NEW_LINE
def remove_empty_strings ( list_of_strings ) : NEW_LINE INDENT return [ string for string in list_of_strings if string ] NEW_LINE DEDENT
s = ' abcdefghijklmnopqrstuvwxyz ' NEW_LINE print ( s [ 2 : ] ) NEW_LINE
import re NEW_LINE re . search ( r ' ( . * ? ) \n ' , ' foo \n bar \n ' , re . DOTALL ) NEW_LINE
def all_same ( lst ) : NEW_LINE INDENT return lst [ 1 : ] == lst [ : - 1 ] NEW_LINE DEDENT
def is_empty ( lst ) : NEW_LINE INDENT if lst == [ ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
import threading NEW_LINE def function1 ( ) : NEW_LINE INDENT print ( " Hello " ) NEW_LINE print ( " World " ) NEW_LINE DEDENT def function2 ( ) : NEW_LINE INDENT print ( " Goodbye " ) NEW_LINE print ( " World " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT threading . Thread ( target = function1 ) . start ( ) NEW_LINE threading . Thread ( target = function2 ) . start ( ) NEW_LINE DEDENT
list1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE list2 = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE list3 = [ list1 [ 0 ] , list2 [ - 1 ] ] NEW_LINE print ( list3 ) NEW_LINE
from django . db . models import F NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . distinct ( ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( ' field ' ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( ' - field ' ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( F ( ' field ' ) . desc ( ) ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( F ( ' field ' ) . asc ( ) ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( ' field ' ) . distinct ( ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( ' - field ' ) . distinct ( ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( F ( ' field ' ) . desc ( ) ) . distinct ( ) NEW_LINE qs = Model . objects . all ( ) . values_list ( ' field ' , flat = True ) . order_by ( F ( ' field ' ) . asc ( ) ) . distinct ( ) NEW_LINE
def adjacent_pairs ( lst ) : NEW_LINE INDENT return [ ( lst [ i ] , lst [ i + 1 ] ) for i in range ( len ( lst ) - 1 ) if lst [ i ] == lst [ i + 1 ] ] NEW_LINE DEDENT
import os NEW_LINE def list_files ( dir ) : NEW_LINE INDENT r = [ ] NEW_LINE subdirs = [ x [ 0 ] for x in os . walk ( dir ) ] NEW_LINE for subdir in subdirs : NEW_LINE INDENT files = os . walk ( subdir ) . next ( ) [ 2 ] NEW_LINE if ( len ( files ) > 0 ) : NEW_LINE INDENT for file in files : NEW_LINE INDENT r . append ( subdir + " / " + file ) NEW_LINE DEDENT DEDENT DEDENT return r NEW_LINE DEDENT
import json NEW_LINE def encode_tuple ( t ) : NEW_LINE INDENT return { ' _ _ tuple _ _ ' : True , ' items ' : t } NEW_LINE DEDENT def decode_tuple ( d ) : NEW_LINE INDENT if d . get ( ' _ _ tuple _ _ ' ) : NEW_LINE INDENT return tuple ( d [ ' items ' ] ) NEW_LINE DEDENT return d NEW_LINE DEDENT t = ( 1 , 2 , 3 ) NEW_LINE print ( json . dumps ( t , default = encode_tuple ) ) NEW_LINE print ( json . loads ( ' { " _ _ tuple _ _ " : ▁ true , ▁ " items " : ▁ [ 1 , ▁ 2 , ▁ 3 ] } ' , object_hook = decode_tuple ) ) NEW_LINE
import random NEW_LINE random . randint ( 0 , 9 ) NEW_LINE
def chunks ( l , n ) : NEW_LINE INDENT for i in range ( 0 , len ( l ) , n ) : NEW_LINE INDENT yield l [ i : i + n ] NEW_LINE DEDENT DEDENT
def xor ( a , b ) : NEW_LINE INDENT return ( a or b ) and not ( a and b ) NEW_LINE DEDENT
def prepend_string ( string , list ) : NEW_LINE INDENT return [ string + item for item in list ] NEW_LINE DEDENT
import random NEW_LINE def random_list ( n ) : NEW_LINE INDENT my_list = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT my_list . append ( random . randint ( 1 , 100 ) ) NEW_LINE DEDENT return my_list NEW_LINE DEDENT print ( random_list ( 10 ) ) NEW_LINE
import requests NEW_LINE from bs4 import BeautifulSoup NEW_LINE url = ' https : / / www . google . com / search ? q = python ' NEW_LINE response = requests . get ( url ) NEW_LINE soup = BeautifulSoup ( response . text , ' html . parser ' ) NEW_LINE results = soup . find_all ( ' div ' , attrs = { ' class ' : ' g ' } ) NEW_LINE for result in results : NEW_LINE INDENT link = result . find ( ' a ' , href = True ) NEW_LINE title = result . find ( ' h3' ) NEW_LINE description = result . find ( ' span ' , attrs = { ' class ' : ' st ' } ) NEW_LINE if link and title : NEW_LINE INDENT link = link [ ' href ' ] NEW_LINE title = title . get_text ( ) NEW_LINE if description : NEW_LINE INDENT description = description . get_text ( ) NEW_LINE DEDENT if link != ' # ' : NEW_LINE INDENT print ( ' \n Title : ▁ { } ' . format ( title ) ) NEW_LINE print ( ' Link : ▁ { } ' . format ( link ) ) NEW_LINE print ( ' Description : ▁ { } ' . format ( description ) ) NEW_LINE DEDENT DEDENT DEDENT
def replace_char ( string , char , replacement ) : NEW_LINE INDENT return string . replace ( char , replacement ) NEW_LINE DEDENT
d = { ' a ' : [ 1 , 2 , 3 ] , ' b ' : [ 4 , 5 , 6 ] } NEW_LINE d [ ' a ' ] . append ( 4 ) NEW_LINE d [ ' b ' ] . append ( 7 ) NEW_LINE
def remove_char ( string_list , char ) : NEW_LINE INDENT return [ s . replace ( char , ' ' ) for s in string_list ] NEW_LINE DEDENT
import datetime NEW_LINE def time_converter ( time ) : NEW_LINE INDENT time = datetime . datetime . strptime ( time , ' % H : % M ' ) NEW_LINE return time . strftime ( ' % I : % M ▁ % p ' ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( " Example : " ) NEW_LINE print ( time_converter ( '12:30' ) ) NEW_LINE assert time_converter ( '12:30' ) == '12:30 ▁ PM ' NEW_LINE assert time_converter ( '09:00' ) == '09:00 ▁ AM ' NEW_LINE assert time_converter ( '23:15' ) == '11:15 ▁ PM ' NEW_LINE print ( " Coding ▁ complete ? ▁ Click ▁ ' Check ' ▁ to ▁ earn ▁ cool ▁ rewards ! " ) NEW_LINE DEDENT
def replace_string ( list_of_lists , old_string , new_string ) : NEW_LINE INDENT for i in range ( len ( list_of_lists ) ) : NEW_LINE INDENT for j in range ( len ( list_of_lists [ i ] ) ) : NEW_LINE INDENT if list_of_lists [ i ] [ j ] == old_string : NEW_LINE INDENT list_of_lists [ i ] [ j ] = new_string NEW_LINE DEDENT DEDENT DEDENT return list_of_lists NEW_LINE DEDENT
def close_window ( ) : NEW_LINE INDENT window . destroy ( ) NEW_LINE exit ( ) NEW_LINE DEDENT
from sqlalchemy import create_engine NEW_LINE engine = create_engine ( ' postgresql + psycopg2 : / / student : datacamp @ postgresql . csrrinzqubik . us - east - 1 . rds . amazonaws . com : 5432 / census ' ) NEW_LINE print ( engine . table_names ( ) ) NEW_LINE results = engine . execute ( ' SELECT ▁ * ▁ FROM ▁ state _ fact ' ) NEW_LINE print ( results . fetchall ( ) ) NEW_LINE print ( results . first ( ) ) NEW_LINE print ( results . rowcount ) NEW_LINE
from bisect import bisect_left NEW_LINE def insert ( a , x ) : NEW_LINE INDENT i = bisect_left ( a , x ) NEW_LINE a . insert ( i , x ) NEW_LINE DEDENT a = [ ] NEW_LINE insert ( a , [ 2 , 3 ] ) NEW_LINE insert ( a , [ 1 , 2 ] ) NEW_LINE insert ( a , [ 3 , 4 ] ) NEW_LINE print ( a ) NEW_LINE
fellowship = [ ' frodo ' , ' samwise ' , ' merry ' , ' aragorn ' , ' legolas ' , ' boromir ' , ' gimli ' ] NEW_LINE new_fellowship = [ member for member in fellowship if len ( member ) >= 7 ] NEW_LINE print ( new_fellowship ) NEW_LINE
import os NEW_LINE import pandas as pd NEW_LINE path = ' C : / Users / User / Desktop / Python / Data / ' NEW_LINE data = [ ] NEW_LINE for root , dirs , files in os . walk ( path ) : NEW_LINE INDENT for file in files : NEW_LINE INDENT if file . endswith ( ' . csv ' ) : NEW_LINE INDENT filepath = os . path . join ( root , file ) NEW_LINE df = pd . read_csv ( filepath ) NEW_LINE data . append ( df ) NEW_LINE DEDENT DEDENT DEDENT df = pd . concat ( data ) NEW_LINE print ( df . head ( ) ) NEW_LINE
import re NEW_LINE re . sub ( r ' \ ( [ ^ ) ] * \ ) ' , ' ' , ' This ▁ is ▁ a ▁ ( test ) ▁ string ' ) NEW_LINE
from collections import defaultdict NEW_LINE def group_similar_items ( items ) : NEW_LINE INDENT groups = defaultdict ( list ) NEW_LINE for item in items : NEW_LINE INDENT groups [ item ] . append ( item ) NEW_LINE DEDENT return groups NEW_LINE DEDENT
I have two lists : NEW_LINE < code > a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE b = [ 2 , 4 , 1 , 3 , 5 ] NEW_LINE < / code > NEW_LINE I want to sort < code > a < / code > based on the order of < code > b < / code > . NEW_LINE The result should be : NEW_LINE < code > a = [ 2 , 4 , 1 , 3 , 5 ] NEW_LINE < / code > NEW_LINE How can I do this ? NEW_LINE A : NEW_LINE You can use < code > sorted < / code > with a custom key function : NEW_LINE < code > & gt ; & gt ; & gt ; a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE & gt ; & gt ; & gt ; b = [ 2 , 4 , 1 , 3 , 5 ] NEW_LINE & gt ; & gt ; & gt ; sorted ( a , key = b . index ) NEW_LINE [ 2 , 4 , 1 , 3 , 5 ] NEW_LINE < / code > NEW_LINE
a = [ 1 , 2 , 3 , 2 , 4 , 2 ] NEW_LINE [ i for i , j in enumerate ( a ) if j == max ( a ) ] NEW_LINE [ 2 , 5 ] NEW_LINE
import os NEW_LINE os . remove ( ' path / to / file ' ) NEW_LINE
from selenium import webdriver NEW_LINE from selenium . webdriver . common . by import By NEW_LINE from selenium . webdriver . support . ui import WebDriverWait NEW_LINE from selenium . webdriver . support import expected_conditions as EC NEW_LINE driver = webdriver . Firefox ( ) NEW_LINE driver . get ( " http : / / somedomain / url _ that _ delays _ loading " ) NEW_LINE try : NEW_LINE INDENT element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located ( ( By . PARTIAL_LINK_TEXT , " onclick " ) ) ) NEW_LINE DEDENT finally : NEW_LINE INDENT driver . quit ( ) NEW_LINE DEDENT
def remove_whitespace ( string ) : NEW_LINE INDENT return string . replace ( " ▁ " , " " ) NEW_LINE DEDENT print ( remove_whitespace ( " hello ▁ world " ) ) NEW_LINE
def sort_list ( list_of_numbers ) : NEW_LINE INDENT return sorted ( list_of_numbers . split ( ' . ' ) , key = int ) NEW_LINE DEDENT
import re NEW_LINE def add_character ( string , character ) : NEW_LINE INDENT return re . sub ( r ' ( . ) ' , r ' \1' + character , string ) NEW_LINE DEDENT
def flatten_list_of_lists ( list_of_lists ) : NEW_LINE INDENT return [ item for sublist in list_of_lists for item in sublist ] NEW_LINE DEDENT
def count_end_char ( string , char ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( string ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if string [ i ] == char : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def sum_of_power ( lst ) : NEW_LINE INDENT return sum ( x ** i for i , x in enumerate ( lst ) ) NEW_LINE DEDENT
I have a plot with multiple lines . I want to avoid line color repetition . NEW_LINE I have tried to use the following code : NEW_LINE < code > NEW_LINE import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT y = np . random . rand ( 100 ) NEW_LINE plt . plot ( x , y ) NEW_LINE DEDENT plt . show ( ) NEW_LINE < / code > NEW_LINE But I get the following plot : NEW_LINE I want to avoid line color repetition . NEW_LINE I have tried to use the following code : NEW_LINE < code > NEW_LINE import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT y = np . random . rand ( 100 ) NEW_LINE plt . plot ( x , y , color = plt . cm . Set1 ( i ) ) NEW_LINE DEDENT plt . show ( ) NEW_LINE < / code > NEW_LINE But I get the following plot : NEW_LINE I want to avoid line color repetition . NEW_LINE I have tried to use the following code : NEW_LINE < code > NEW_LINE import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT y = np . random . rand ( 100 ) NEW_LINE plt . plot ( x , y , color = plt . cm . Set1 ( i / 10 ) ) NEW_LINE DEDENT plt . show ( ) NEW_LINE < / code > NEW_LINE But I get the following plot : NEW_LINE I want to avoid line color repetition . NEW_LINE I have tried to use the following code : NEW_LINE < code > NEW_LINE import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT y = np . random . rand ( 100 ) NEW_LINE plt . plot ( x , y , color = plt . cm . Set1 ( i / 10.0 ) ) NEW_LINE DEDENT plt . show ( ) NEW_LINE < / code > NEW_LINE But I get the following plot : NEW_LINE I want to avoid line color repetition . NEW_LINE
import matplotlib . pyplot as plt NEW_LINE plt . figure ( ) NEW_LINE plt . plot ( x , y ) NEW_LINE plt . xlabel ( ' x ' ) NEW_LINE plt . ylabel ( ' y ' ) NEW_LINE plt . title ( ' title ' ) NEW_LINE ax = plt . gca ( ) NEW_LINE ax . xaxis . set_ticks_position ( ' top ' ) NEW_LINE ax . xaxis . set_label_position ( ' top ' ) NEW_LINE plt . show ( ) NEW_LINE
import re NEW_LINE def remove_between ( text , begin , end ) : NEW_LINE INDENT return re . sub ( r ' { } . * ? { } ' . format ( begin , end ) , ' ' , text ) NEW_LINE DEDENT remove_between ( ' abc123def456ghi789' , '123' , '789' ) NEW_LINE
def union ( lists ) : NEW_LINE INDENT return list ( set ( ) . union ( * lists ) ) NEW_LINE DEDENT
from flask import Flask , request NEW_LINE from flask_restful import Resource , Api NEW_LINE from flask_cors import CORS NEW_LINE app = Flask ( __name__ ) NEW_LINE api = Api ( app ) NEW_LINE CORS ( app ) NEW_LINE class HelloWorld ( Resource ) : NEW_LINE INDENT def get ( self ) : NEW_LINE INDENT return { ' hello ' : ' world ' } NEW_LINE DEDENT DEDENT api . add_resource ( HelloWorld , ' / ' ) NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT app . run ( debug = True ) NEW_LINE DEDENT
def all_combinations ( lists ) : NEW_LINE INDENT if len ( lists ) == 0 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT elif len ( lists ) == 1 : NEW_LINE INDENT return lists [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return [ x + [ y ] for x in all_combinations ( lists [ : - 1 ] ) for y in lists [ - 1 ] ] NEW_LINE DEDENT DEDENT
import re NEW_LINE with open ( ' file . txt ' , ' r ' ) as f : NEW_LINE INDENT lines = f . readlines ( ) NEW_LINE DEDENT with open ( ' file . txt ' , ' w ' ) as f : NEW_LINE INDENT for line in lines : NEW_LINE INDENT f . write ( re . sub ( ' \n ' , ' ' , line ) ) NEW_LINE DEDENT DEDENT
my_list = [ ' a ' , ' b ' , ' c ' ] NEW_LINE my_list . insert ( 1 , ' d ' ) NEW_LINE print ( my_list ) NEW_LINE
def unique_characters ( str ) : NEW_LINE INDENT return set ( str ) NEW_LINE DEDENT
from mongoengine import Document , StringField , IntField NEW_LINE class User ( Document ) : NEW_LINE INDENT name = StringField ( required = True ) NEW_LINE age = IntField ( required = True ) NEW_LINE DEDENT user = User ( name = ' John ' ) NEW_LINE user . validate ( ) NEW_LINE user . errors NEW_LINE
import struct NEW_LINE def bin2float ( b ) : NEW_LINE INDENT bf = int ( b , 2 ) NEW_LINE bf = struct . pack ( ' > l ' , bf ) NEW_LINE return struct . unpack ( ' > f ' , bf ) [ 0 ] NEW_LINE DEDENT print ( bin2float ( '0100000101010100000000000000000' ) ) NEW_LINE
def gen_to_dict ( gen ) : NEW_LINE INDENT return { k : v for k , v in gen } NEW_LINE DEDENT
def all_binary_4_tuples ( ) : NEW_LINE INDENT for i in range ( 2 ** 4 ) : NEW_LINE INDENT yield tuple ( int ( x ) for x in bin ( i ) [ 2 : ] . zfill ( 4 ) ) NEW_LINE DEDENT DEDENT for t in all_binary_4_tuples ( ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT
import pandas as pd NEW_LINE df = pd . DataFrame ( { ' Name ' : [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' , ' G ' , ' H ' , ' I ' , ' J ' ] , ' Score ' : [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] , ' Age ' : [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 ] } ) NEW_LINE df . sort_values ( by = [ ' Score ' , ' Age ' ] , ascending = [ True , False ] ) NEW_LINE
europe = { ' spain ' : ' madrid ' , ' france ' : ' paris ' , ' germany ' : ' berlin ' , ' norway ' : ' oslo ' , ' italy ' : ' rome ' , ' poland ' : ' warsaw ' , ' austria ' : ' vienna ' } NEW_LINE for key , value in europe . items ( ) : NEW_LINE INDENT print ( " the ▁ capital ▁ of ▁ " + key + " ▁ is ▁ " + value ) NEW_LINE DEDENT
with open ( ' file . txt ' ) as f : NEW_LINE INDENT for line in f : NEW_LINE INDENT print ( line , end = ' ' ) NEW_LINE DEDENT DEDENT
d = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 } NEW_LINE keys = list ( d . keys ( ) ) NEW_LINE values = list ( d . values ( ) ) NEW_LINE
def check_ending ( strng , ending ) : NEW_LINE INDENT return strng . endswith ( tuple ( ending ) ) NEW_LINE DEDENT
class Person : NEW_LINE INDENT def __init__ ( self , name , age ) : NEW_LINE INDENT self . name = name NEW_LINE self . age = age NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' { } ▁ is ▁ { } ▁ years ▁ old ' . format ( self . name , self . age ) NEW_LINE DEDENT DEDENT people = [ Person ( ' Alice ' , 25 ) , Person ( ' Bob ' , 30 ) , Person ( ' Charlie ' , 50 ) , Person ( ' Dan ' , 21 ) ] NEW_LINE people . sort ( key = lambda person : person . age ) NEW_LINE print ( people ) NEW_LINE people . sort ( key = lambda person : person . name ) NEW_LINE print ( people ) NEW_LINE
def sum_of_product_of_combinations ( lst ) : NEW_LINE INDENT return sum ( [ x * y for x in lst for y in lst if x != y ] ) NEW_LINE DEDENT print ( sum_of_product_of_combinations ( [ 1 , 2 , 3 , 4 , 5 ] ) ) NEW_LINE
import os NEW_LINE os . remove ( " myfile " ) NEW_LINE
dictionary = { ' key1' : ' value1' , ' key2' : ' value2' } NEW_LINE print ( dictionary [ ' key1' ] ) NEW_LINE dictionary = { ' key1' : ' value1' , ' key2' : ' value2' } NEW_LINE key = ' key1' NEW_LINE print ( dictionary [ key ] ) NEW_LINE
import datetime NEW_LINE date_string = '01/01/17 ▁ 12:10:03.234567' NEW_LINE date_dt = datetime . datetime . strptime ( date_string , ' % m / % d / % y ▁ % H : % M : % S . % f ' ) NEW_LINE print ( date_dt ) NEW_LINE
def nth_to_last_element ( n , head ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return None NEW_LINE DEDENT if head is None : NEW_LINE INDENT return None NEW_LINE DEDENT if head . next is None : NEW_LINE INDENT return head NEW_LINE DEDENT current = head NEW_LINE nth_to_last = head NEW_LINE for i in range ( n ) : NEW_LINE INDENT if current . next is None : NEW_LINE INDENT return None NEW_LINE DEDENT current = current . next NEW_LINE DEDENT while current . next is not None : NEW_LINE INDENT current = current . next NEW_LINE nth_to_last = nth_to_last . next NEW_LINE DEDENT return nth_to_last NEW_LINE DEDENT
a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE b = [ 5 , 4 , 3 , 2 , 1 ] NEW_LINE a . sort ( key = lambda x : b [ x - 1 ] ) NEW_LINE print ( a ) NEW_LINE
a = [ 1 , 2 , 3 ] NEW_LINE b = [ ' a ' , ' b ' , ' c ' ] NEW_LINE for i , j in zip ( a , b ) : NEW_LINE INDENT print ( i , j ) NEW_LINE DEDENT
for key in sorted ( d ) : NEW_LINE INDENT print ( key , d [ key ] ) NEW_LINE DEDENT
def find_difference ( list1 , list2 , list3 ) : NEW_LINE INDENT return list ( set ( list1 ) - set ( list2 ) - set ( list3 ) ) NEW_LINE DEDENT
from django . db . models import Q NEW_LINE Book . objects . filter ( Q ( authors__name = ' Author1' ) & Q ( authors__name = ' Author2' ) ) NEW_LINE
from flask import Flask NEW_LINE from flask_sqlalchemy import SQLAlchemy NEW_LINE app = Flask ( __name__ ) NEW_LINE app . config [ ' SQLALCHEMY _ DATABASE _ URI ' ] = ' sqlite : / / / / tmp / test . db ' NEW_LINE db = SQLAlchemy ( app ) NEW_LINE class User ( db . Model ) : NEW_LINE INDENT id = db . Column ( db . Integer , primary_key = True ) NEW_LINE username = db . Column ( db . String ( 80 ) , unique = True ) NEW_LINE email = db . Column ( db . String ( 120 ) , unique = True ) NEW_LINE def __init__ ( self , username , email ) : NEW_LINE INDENT self . username = username NEW_LINE self . email = email NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return ' < User ▁ % r > ' % self . username NEW_LINE DEDENT DEDENT db . create_all ( ) NEW_LINE admin = User ( ' admin ' , ' admin @ example . com ' ) NEW_LINE guest = User ( ' guest ' , ' guest @ example . com ' ) NEW_LINE db . session . add ( admin ) NEW_LINE db . session . add ( guest ) NEW_LINE db . session . commit ( ) NEW_LINE db . session . delete ( guest ) NEW_LINE db . session . commit ( ) NEW_LINE
list1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE list2 = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE list3 = [ ] NEW_LINE for i in range ( len ( list1 ) ) : NEW_LINE INDENT list3 . append ( list1 [ i ] + list2 [ i ] ) NEW_LINE DEDENT print ( list3 ) NEW_LINE
from collections import defaultdict NEW_LINE def transform_list_of_dicts_into_dict_of_dicts ( list_of_dicts ) : NEW_LINE INDENT dict_of_dicts = defaultdict ( dict ) NEW_LINE for d in list_of_dicts : NEW_LINE INDENT dict_of_dicts [ d [ ' key ' ] ] . update ( d ) NEW_LINE DEDENT return dict_of_dicts NEW_LINE DEDENT
import datetime NEW_LINE def is_today ( date ) : NEW_LINE INDENT return date . date ( ) == datetime . date . today ( ) NEW_LINE DEDENT
l = [ ( ' a ' , 1 ) , ( ' b ' , 2 ) , ( ' c ' , 3 ) ] NEW_LINE dict ( l ) NEW_LINE { ' a ' : 1 , ' c ' : 3 , ' b ' : 2 } NEW_LINE
s = " ▁ ▁ hello ▁ world ▁ ▁ " NEW_LINE s . strip ( ) NEW_LINE
import re NEW_LINE s = "30M1000N20M " NEW_LINE re . findall ( r ' \d + | \D + ' , s ) NEW_LINE
import re NEW_LINE name = " John ▁ Smith " NEW_LINE if re . match ( " John " , name ) : NEW_LINE INDENT print ( " Match " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ match " ) NEW_LINE DEDENT
a = [ 1 , 2 , 0 , 0 , 4 , 0 ] NEW_LINE [ i for i , e in enumerate ( a ) if e != 0 ] NEW_LINE [ 0 , 1 , 4 ] NEW_LINE
import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE fig , ax = plt . subplots ( ) NEW_LINE ax . plot ( x , np . sin ( x ) , ' - ' , label = ' Sine ' ) NEW_LINE ax . plot ( x , np . cos ( x ) , ' - - ' , label = ' Cosine ' ) NEW_LINE ax . axis ( ' equal ' ) NEW_LINE leg = ax . legend ( ) NEW_LINE leg . get_frame ( ) . set_linewidth ( 0.0 ) NEW_LINE plt . show ( ) NEW_LINE
- Python is an interpreted language NEW_LINE - Python is a dynamically typed language NEW_LINE - Python is a garbage collected language NEW_LINE - Python is a high - level language NEW_LINE - Python is a scripting language NEW_LINE - Python is an object - oriented language NEW_LINE - Python is a functional language NEW_LINE - Python is a procedural language NEW_LINE - Python is a reflective language NEW_LINE - Python is a general - purpose language NEW_LINE - Python is a cross - platform language NEW_LINE - Python is a portable language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE - Python is a high - level language NEW_LINE
import json NEW_LINE import urllib . request NEW_LINE url = ' https : / / api . github . com / repos / jupyter / notebook / issues ? state = closed ' NEW_LINE response = urllib . request . urlopen ( url ) NEW_LINE data = json . loads ( response . read ( ) ) NEW_LINE with open ( ' data . json ' , ' w ' ) as f : NEW_LINE INDENT json . dump ( data , f , indent = 4 ) NEW_LINE DEDENT
def sort_by_key ( list_of_tuples , key ) : NEW_LINE INDENT return sorted ( list_of_tuples , key = lambda x : x [ key ] ) NEW_LINE DEDENT
list1 = [ 1 , 2 , 3 ] NEW_LINE list2 = [ 4 , 5 , 6 ] NEW_LINE list3 = list1 + list2 NEW_LINE print ( list3 ) NEW_LINE
def greater_than ( list , value ) : NEW_LINE INDENT return [ x for x in list if x > value ] NEW_LINE DEDENT greater_than ( [ 1 , 2 , 3 , 4 , 5 ] , 3 ) NEW_LINE
import re NEW_LINE def is_valid ( word ) : NEW_LINE INDENT return re . match ( r ' ^ ( ? ! . * [ aeiou ] {2 } ) [ a - z ] + $ ' , word ) NEW_LINE DEDENT
my_list = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE my_list . extend ( [ 6 , 7 , 8 , 9 , 10 ] ) NEW_LINE print ( my_list ) NEW_LINE
import matplotlib . pyplot as plt NEW_LINE plt . figure ( figsize = ( 10 , 5 ) ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . savefig ( ' figure . png ' , format = ' png ' , dpi = 300 ) NEW_LINE plt . NEW_LINE
x , y = 1 , 2 NEW_LINE print ( x , y ) NEW_LINE
list = [ ' a ' , ' b ' , ' ' , ' c ' , ' d ' , ' ' ] NEW_LINE list = [ x for x in list if x != ' ' ] NEW_LINE
def sort_list ( list_to_sort , index_1 , index_2 ) : NEW_LINE INDENT return sorted ( list_to_sort , key = lambda x : ( x [ index_1 ] , x [ index_2 ] ) ) NEW_LINE DEDENT
a = [ 1 , 2 , 3 ] NEW_LINE b = a [ : ] NEW_LINE
import requests NEW_LINE def check_website ( url ) : NEW_LINE INDENT try : NEW_LINE INDENT r = requests . get ( url ) NEW_LINE if r . status_code == 200 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT check_website ( ' https : / / www . google . com ' ) NEW_LINE
a = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE b = [ 2 , 4 , 6 , 8 , 10 ] NEW_LINE c = [ x for x in a if x not in b ] NEW_LINE print ( c ) NEW_LINE
import re NEW_LINE def remove_duplicate_chars ( s ) : NEW_LINE INDENT return re . sub ( r ' ( . ) \1 + ' , r ' \1' , s ) NEW_LINE DEDENT
members = { ' member1' : { ' name ' : ' John ' , ' age ' : '27' , ' sex ' : ' Male ' } , ' member2' : { ' name ' : ' Marie ' , ' age ' : '22' , ' sex ' : ' Female ' } , ' member3' : { ' name ' : ' Luna ' , ' age ' : '24' , ' sex ' : ' Female ' } , ' member4' : { ' name ' : ' Peter ' , ' age ' : '29' , ' sex ' : ' Male ' } , ' member5' : { ' name ' : ' Sara ' , ' age ' : '23' , ' sex ' : ' Female ' } , ' member6' : { ' name ' : ' Thomas ' , ' age ' : '24' , ' sex ' : ' Male ' } , ' member7' : { ' name ' : ' Martha ' , ' age ' : '29' , ' sex ' : ' Female ' } , ' member8' : { ' name ' : ' David ' , ' age ' : '31' , ' sex ' : ' Male ' } , ' member9' : { ' name ' : ' Nina ' , ' age ' : '26' , ' sex ' : ' Female ' } , ' member10' : { ' name ' : ' Randy ' , ' age ' : '23' , ' sex ' : ' Male ' } } NEW_LINE member_keys = [ member for member in members ] NEW_LINE print ( member_keys ) NEW_LINE
import os NEW_LINE import time NEW_LINE def get_file_creation_modification_times ( file_path ) : NEW_LINE INDENT file_creation_time = os . path . getctime ( file_path ) NEW_LINE file_modification_time = os . path . getmtime ( file_path ) NEW_LINE file_creation_time = time . ctime ( file_creation_time ) NEW_LINE file_modification_time = time . ctime ( file_modification_time ) NEW_LINE return file_creation_time , file_modification_time NEW_LINE DEDENT file_creation_time , file_modification_time = get_file_creation_modification_times ( file_path ) NEW_LINE print ( " File ▁ creation ▁ time : " , file_creation_time ) NEW_LINE print ( " File ▁ modification ▁ time : " , file_modification_time ) NEW_LINE
def find_nth ( haystack , needle , n ) : NEW_LINE INDENT start = haystack . find ( needle ) NEW_LINE while start >= 0 and n > 1 : NEW_LINE INDENT start = haystack . find ( needle , start + len ( needle ) ) NEW_LINE n -= 1 NEW_LINE DEDENT return start NEW_LINE DEDENT print ( find_nth ( " Python ▁ is ▁ awesome , ▁ isn ' t ▁ it ? " , " is " , 2 ) ) NEW_LINE
def coalesce ( column , default ) : NEW_LINE INDENT return case ( [ ( column != None , column ) ] , else_ = default ) NEW_LINE DEDENT
import subprocess NEW_LINE subprocess . call ( [ " ls " , " - l " ] ) NEW_LINE
def remove_letters ( list ) : NEW_LINE INDENT return [ x for x in list if type ( x ) == int ] NEW_LINE DEDENT
import re NEW_LINE def remove_punctuation ( input_string ) : NEW_LINE INDENT return re . sub ( r ' [ ^ \w\s ] ' , ' ' , input_string ) NEW_LINE DEDENT print ( remove_punctuation ( " Hello , ▁ I ▁ am ▁ a ▁ string ! " ) ) NEW_LINE
import json NEW_LINE print ( json . dumps ( container , ensure_ascii = False ) ) NEW_LINE
def remove_adjacent_duplicates ( lst ) : NEW_LINE INDENT return [ lst [ i ] for i in range ( len ( lst ) ) if i == 0 or lst [ i ] != lst [ i - 1 ] ] NEW_LINE DEDENT print ( remove_adjacent_duplicates ( [ 1 , 2 , 2 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 5 ] ) ) NEW_LINE
import codecs NEW_LINE codecs . escape_decode ( b ' \\x61\\x62\\x63' ) NEW_LINE ( b ' abc ' , 6 ) NEW_LINE
if my_dict [ ' key ' ] == ' value ' : NEW_LINE INDENT print ( ' The ▁ value ▁ of ▁ the ▁ key ▁ is ▁ value ' ) NEW_LINE DEDENT
import os NEW_LINE if os . path . isfile ( ' / etc / passwd ' ) : NEW_LINE INDENT print ( ' File ▁ exists ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' File ▁ does ▁ not ▁ exist ' ) NEW_LINE DEDENT
import ast NEW_LINE def string_to_dict ( string ) : NEW_LINE INDENT return ast . literal_eval ( string ) NEW_LINE DEDENT string_to_dict ( ' { " a " : ▁ 1 , ▁ " b " : ▁ 2 } ' ) NEW_LINE
d = { ' banana ' : 3 , ' apple ' : 4 , ' pear ' : 1 , ' orange ' : 2 } NEW_LINE def get_value ( x ) : NEW_LINE INDENT return d [ x ] NEW_LINE DEDENT sorted ( d , key = get_value ) NEW_LINE
l = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE l = [ x + 1 for x in l ] NEW_LINE
import re NEW_LINE def strip_random_chars ( url ) : NEW_LINE INDENT return re . sub ( r ' [ ^ a - zA - Z0-9 ] ' , ' ' , url ) NEW_LINE DEDENT
import datetime NEW_LINE date_string = '2018-01-01' NEW_LINE date_object = datetime . datetime . strptime ( date_string , ' % Y - % m - % d ' ) NEW_LINE print ( date_object ) NEW_LINE
def remove_final_characters ( string , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return string NEW_LINE DEDENT else : NEW_LINE INDENT return remove_final_characters ( string [ : - 1 ] , n - 1 ) NEW_LINE DEDENT DEDENT
import requests NEW_LINE from bs4 import BeautifulSoup NEW_LINE url = ' https : / / www . nytimes . com / ' NEW_LINE r = requests . get ( url ) NEW_LINE r_html = r . text NEW_LINE soup = BeautifulSoup ( r_html , " html . parser " ) NEW_LINE for story_heading in soup . find_all ( class_ = " story - heading " ) : NEW_LINE INDENT if story_heading . a : NEW_LINE INDENT print ( story_heading . a . text . replace ( " \n " , " ▁ " ) . strip ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( story_heading . contents [ 0 ] . strip ( ) ) NEW_LINE DEDENT DEDENT
x = 5.5 NEW_LINE print ( int ( x ) ) NEW_LINE
def all_true ( lst ) : NEW_LINE INDENT return all ( lst ) NEW_LINE DEDENT
import subprocess NEW_LINE subprocess . call ( " ls ▁ - l ▁ | ▁ grep ▁ test " , shell = True ) NEW_LINE
import datetime NEW_LINE date_string = "2020-01-01" NEW_LINE date_object = datetime . datetime . strptime ( date_string , " % Y - % m - % d " ) NEW_LINE print ( date_object ) NEW_LINE print ( date_object . strftime ( " % d - % m - % Y " ) ) NEW_LINE
def compare_lists ( list_of_lists ) : NEW_LINE INDENT return [ max ( l ) for l in list_of_lists ] NEW_LINE DEDENT
f = open ( ' data . txt ' , ' a ' ) NEW_LINE f . write ( ' This ▁ is ▁ a ▁ new ▁ line \n ' ) NEW_LINE f . close ( ) NEW_LINE
sentence = " The ▁ quick ▁ brown ▁ fox ▁ jumps ▁ over ▁ the ▁ lazy ▁ dog " NEW_LINE words = sentence . split ( ) NEW_LINE word_lengths = [ ] NEW_LINE for word in words : NEW_LINE INDENT if word != " the " : NEW_LINE INDENT word_lengths . append ( len ( word ) ) NEW_LINE DEDENT DEDENT print ( words ) NEW_LINE print ( word_lengths ) NEW_LINE
from itertools import chain NEW_LINE def split_dict_of_lists ( d ) : NEW_LINE INDENT return [ dict ( zip ( d , t ) ) for t in zip ( * d . values ( ) ) ] NEW_LINE DEDENT d = { ' a ' : [ 1 , 2 , 3 ] , ' b ' : [ 4 , 5 , 6 ] } NEW_LINE split_dict_of_lists ( d ) NEW_LINE
if ' a ' not in [ ' a ' , ' b ' , ' c ' ] : NEW_LINE INDENT print ( ' a ▁ is ▁ not ▁ in ▁ the ▁ list ' ) NEW_LINE DEDENT
def is_empty ( string ) : NEW_LINE INDENT if string == " " : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
a = [ 1 , 2 , 3 ] NEW_LINE b = [ 4 , 5 , 6 ] NEW_LINE c = [ 4 , 5 , 6 , 7 , 8 ] NEW_LINE map ( lambda x , y : x + y , a , b ) NEW_LINE [ 5 , 7 , 9 ] NEW_LINE map ( lambda x , y : x + y , a , c ) NEW_LINE Traceback ( most recent call last ) : NEW_LINE INDENT File " < stdin > " , line 1 , in < module > NEW_LINE File " < stdin > " , line 1 , in < lambda > NEW_LINE DEDENT TypeError : unsupported operand type ( s ) for + : ' int ' and ' NoneType ' NEW_LINE
import unicodedata NEW_LINE unicodedata . normalize ( ' NFKD ' , unicode_text ) . encode ( ' ascii ' , ' ignore ' ) NEW_LINE
def generate_all_strings ( tokens , length ) : NEW_LINE INDENT if length == 0 : NEW_LINE INDENT return [ ' ' ] NEW_LINE DEDENT else : NEW_LINE INDENT return [ token + suffix for token in tokens for suffix in generate_all_strings ( tokens , length - 1 ) ] NEW_LINE DEDENT DEDENT print ( generate_all_strings ( [ ' a ' , ' b ' ] , 3 ) ) NEW_LINE
def greater_than ( list , number ) : NEW_LINE INDENT count = 0 NEW_LINE for i in list : NEW_LINE INDENT if i > number : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
import urllib . parse NEW_LINE url = ' http : / / example . com / path / to / page . html # fragment ' NEW_LINE parsed = urllib . parse . urlparse ( url ) NEW_LINE print ( parsed . fragment ) NEW_LINE print ( parsed . path ) NEW_LINE print ( parsed . scheme ) NEW_LINE print ( parsed . netloc ) NEW_LINE print ( parsed . geturl ( ) ) NEW_LINE print ( urllib . parse . urlunparse ( parsed ) ) NEW_LINE parsed = parsed . _replace ( fragment = ' ' ) NEW_LINE print ( urllib . parse . urlunparse ( parsed ) ) NEW_LINE
import random NEW_LINE random . sample ( range ( 1 , 100 ) , 100 ) NEW_LINE
import win32gui NEW_LINE win32gui . SetForegroundWindow ( hwnd ) NEW_LINE
def convert_to_tuple ( string ) : NEW_LINE INDENT return tuple ( string . split ( ' , ' ) ) NEW_LINE DEDENT def add_to_tuple ( tuple , string ) : NEW_LINE INDENT return tuple + convert_to_tuple ( string ) NEW_LINE DEDENT
l = [ 11 , 22 , 33 ] NEW_LINE int ( ' ' . join ( map ( str , l ) ) ) NEW_LINE 112233 NEW_LINE
def split_list ( lst , field ) : NEW_LINE INDENT return [ list ( g ) for k , g in groupby ( lst , lambda x : x [ field ] ) ] NEW_LINE DEDENT
l_of_l = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 ] , [ 8 , 9 ] ] NEW_LINE flat_list = [ ] NEW_LINE for x in l_of_l : NEW_LINE INDENT for y in x : NEW_LINE INDENT flat_list . append ( y ) NEW_LINE DEDENT DEDENT print ( flat_list ) NEW_LINE
import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE fig = plt . figure ( ) NEW_LINE plt . plot ( x , np . sin ( x ) , ' - ' ) NEW_LINE plt . plot ( x , np . cos ( x ) , ' - - ' ) NEW_LINE fig . savefig ( ' my _ figure . png ' , bbox_inches = ' tight ' ) NEW_LINE plt . show ( ) NEW_LINE
if ' key ' in my_dict : NEW_LINE INDENT del my_dict [ ' key ' ] NEW_LINE DEDENT
import re NEW_LINE re . sub ( r ' \n ' , ' ' , text ) NEW_LINE
def contains_substring ( string , substring ) : NEW_LINE INDENT return substring in string NEW_LINE DEDENT
import re NEW_LINE text = " The ▁ ghost ▁ that ▁ says ▁ boo ▁ haunts ▁ the ▁ loo " NEW_LINE m = re . findall ( " . oo " , text , re . IGNORECASE ) NEW_LINE print ( m ) NEW_LINE
def average ( numbers ) : NEW_LINE INDENT total = 0 NEW_LINE for number in numbers : NEW_LINE INDENT total += number NEW_LINE DEDENT return total / len ( numbers ) NEW_LINE DEDENT average ( [ 1 , 2 , 3 , 4 , 5 ] ) NEW_LINE
import ast NEW_LINE ast . literal_eval ( " { ' a ' : ▁ 1 , ▁ ' b ' : ▁ 2 } " ) NEW_LINE
def count_elements ( d ) : NEW_LINE INDENT if isinstance ( d , dict ) : NEW_LINE INDENT return sum ( count_elements ( v ) for v in d . values ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT
def remove_chars ( string , chars ) : NEW_LINE INDENT return " " . join ( c for c in string if c not in chars ) NEW_LINE DEDENT remove_chars ( " Battle ▁ of ▁ the ▁ Vowels : ▁ Hawaii ▁ vs . ▁ Grozny " , " aeiou " ) NEW_LINE
def read_line ( string ) : NEW_LINE INDENT return string . split ( ' \n ' ) [ 0 ] NEW_LINE DEDENT
float ( string ) NEW_LINE int ( string ) NEW_LINE
def add_to_ints ( ints , add ) : NEW_LINE INDENT for i in range ( len ( ints ) ) : NEW_LINE INDENT ints [ i ] += add NEW_LINE DEDENT return ints NEW_LINE DEDENT
import hashlib NEW_LINE def md5 ( fname ) : NEW_LINE INDENT hash_md5 = hashlib . md5 ( ) NEW_LINE with open ( fname , " rb " ) as f : NEW_LINE INDENT for chunk in iter ( lambda : f . read ( 4096 ) , b " " ) : NEW_LINE INDENT hash_md5 . update ( chunk ) NEW_LINE DEDENT DEDENT return hash_md5 . hexdigest ( ) NEW_LINE DEDENT
def get_str_after_substr ( string , substr ) : NEW_LINE INDENT return string [ string . find ( substr ) + len ( substr ) : ] NEW_LINE DEDENT
def find_non_common_elements ( list1 , list2 ) : NEW_LINE INDENT return list ( set ( list1 ) - set ( list2 ) ) NEW_LINE DEDENT list1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE list2 = [ 5 , 6 , 7 , 8 , 9 ] NEW_LINE print ( find_non_common_elements ( list1 , list2 ) ) NEW_LINE
def sum_list ( l ) : NEW_LINE INDENT s = 0 NEW_LINE for i in l : NEW_LINE INDENT s += i NEW_LINE DEDENT return s NEW_LINE DEDENT
import random NEW_LINE def print_random_variable ( variables ) : NEW_LINE INDENT print ( variables [ random . randint ( 0 , len ( variables ) - 1 ) ] ) NEW_LINE DEDENT variables = [ ' a ' , ' b ' , ' c ' , ' d ' , ' e ' ] NEW_LINE print_random_variable ( variables ) NEW_LINE
class Base ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT print " Base ▁ created " NEW_LINE DEDENT DEDENT class ChildA ( Base ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT Base . __init__ ( self ) NEW_LINE print " ChildA ▁ created " NEW_LINE DEDENT DEDENT class ChildB ( Base ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT super ( ChildB , self ) . __init__ ( ) NEW_LINE print " ChildB ▁ created " NEW_LINE DEDENT DEDENT ChildA ( ) NEW_LINE ChildB ( ) NEW_LINE
from datetime import datetime NEW_LINE date_string = '2019-01-01' NEW_LINE date_object = datetime . strptime ( date_string , ' % Y - % m - % d ' ) NEW_LINE
import itertools NEW_LINE def generate_pairs ( n ) : NEW_LINE INDENT return list ( itertools . combinations ( range ( n ) , 2 ) ) NEW_LINE DEDENT
def remove_substring ( string , substring ) : NEW_LINE INDENT if string . endswith ( substring ) : NEW_LINE INDENT return string [ : - len ( substring ) ] NEW_LINE DEDENT return string NEW_LINE DEDENT
import numpy as np NEW_LINE a = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ) NEW_LINE np . savetxt ( " foo . csv " , a , delimiter = " , " ) NEW_LINE
from operator import itemgetter NEW_LINE sorted ( list_of_dicts , key = itemgetter ( ' key ' ) ) NEW_LINE
my_dict = { ' T1' : [ '1' , '2' , '3' ] , ' T2' : [ '4' , '5' ] , ' T3' : [ '6' , '7' ] } NEW_LINE df = pd . DataFrame ( my_dict ) NEW_LINE hier_index = df . columns . map ( lambda x : my_dict [ x ] ) NEW_LINE df . columns = pd . MultiIndex . from_tuples ( hier_index ) NEW_LINE print ( df ) NEW_LINE
import datetime NEW_LINE now = datetime . datetime . now ( ) NEW_LINE print now . strftime ( " % Y - % m - % d ▁ % H : % M " ) NEW_LINE
script_dir = os . path . dirname ( os . path . realpath ( __file__ ) ) NEW_LINE config_file = os . path . join ( script_dir , ' config . ini ' ) NEW_LINE log_file = os . path . join ( script_dir , ' log . txt ' ) NEW_LINE
def max_string_length ( lst ) : NEW_LINE INDENT max_len = 0 NEW_LINE for item in lst : NEW_LINE INDENT if isinstance ( item , list ) : NEW_LINE INDENT max_len = max ( max_len , max_string_length ( item ) ) NEW_LINE DEDENT else : NEW_LINE INDENT max_len = max ( max_len , len ( item ) ) NEW_LINE DEDENT DEDENT return max_len NEW_LINE DEDENT
def reverse_string ( string ) : NEW_LINE INDENT return string [ : : - 1 ] NEW_LINE DEDENT print ( reverse_string ( " Hello " ) ) NEW_LINE
x = 1.23456 NEW_LINE format ( x , '0.2f ' ) NEW_LINE ' value ▁ is ▁ { :0.3f } ' . format ( x ) NEW_LINE
d = [ { ' a ' : 1 , ' b ' : 2 } , { ' a ' : 3 , ' b ' : 4 } , { ' a ' : 5 , ' b ' : 6 } ] NEW_LINE max ( d , key = lambda x : x [ ' a ' ] ) NEW_LINE
import sys NEW_LINE def replace_char ( filename , old_char , new_char ) : NEW_LINE INDENT with open ( filename , ' r ' ) as f : NEW_LINE INDENT text = f . read ( ) NEW_LINE DEDENT text = text . replace ( old_char , new_char ) NEW_LINE with open ( filename , ' w ' ) as f : NEW_LINE INDENT f . write ( text ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT replace_char ( sys . argv [ 1 ] , sys . argv [ 2 ] , sys . argv [ 3 ] ) NEW_LINE DEDENT
def max_list ( lst , length ) : NEW_LINE INDENT if length == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lst [ : length ] ) NEW_LINE DEDENT DEDENT print ( max_list ( [ 1 , 2 , 3 , 4 , 5 ] , 3 ) ) NEW_LINE print ( max_list ( [ 1 , 2 , 3 , 4 , 5 ] , 0 ) ) NEW_LINE print ( max_list ( [ 1 , 2 , 3 , 4 , 5 ] , 5 ) ) NEW_LINE
my_list [ 0 ] NEW_LINE my_list [ 1 ] NEW_LINE my_list [ 2 ] NEW_LINE my_list [ 3 ] NEW_LINE my_list [ 4 ] NEW_LINE my_list [ 5 ] NEW_LINE my_list [ 6 ] NEW_LINE my_list [ 7 ] NEW_LINE my_list [ 8 ] NEW_LINE my_list [ 9 ] NEW_LINE
def get_keys ( d , value ) : NEW_LINE INDENT return [ k for k , v in d . items ( ) if v == value ] NEW_LINE DEDENT
if not my_string : NEW_LINE INDENT print ( " String ▁ is ▁ empty " ) NEW_LINE DEDENT
def replace_first ( string , old , new ) : NEW_LINE INDENT return new . join ( string . split ( old , 1 ) ) NEW_LINE DEDENT
list1 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE list2 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE list3 = [ x for x in list1 if x not in list2 ] NEW_LINE print ( list3 ) NEW_LINE
import time NEW_LINE time . sleep ( 5 ) NEW_LINE
import matplotlib . pyplot as plt NEW_LINE x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE plt . plot ( x , y ) NEW_LINE plt . legend ( [ ' Legend ' ] , prop = { ' size ' : 20 } ) NEW_LINE plt . show ( ) NEW_LINE
def convert_to_string ( array ) : NEW_LINE INDENT return ' , ' . join ( array ) NEW_LINE DEDENT
import os NEW_LINE print ( os . getcwd ( ) ) NEW_LINE print ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) NEW_LINE
d = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 , ' d ' : 4 , ' e ' : 5 } NEW_LINE sorted_by_value = sorted ( d . items ( ) , key = lambda kv : kv [ 1 ] ) NEW_LINE sorted_by_key = sorted ( d . items ( ) , key = lambda kv : kv [ 0 ] ) NEW_LINE sorted_by_value_then_key = sorted ( d . items ( ) , key = lambda kv : ( kv [ 1 ] , kv [ 0 ] ) ) NEW_LINE
def extract_keys ( lst ) : NEW_LINE INDENT return [ key for d in lst for key in d . keys ( ) ] NEW_LINE DEDENT
def sort_list_of_tuples ( list_of_tuples ) : NEW_LINE INDENT return sorted ( list_of_tuples , key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) NEW_LINE DEDENT
import os NEW_LINE def get_files ( path , extension ) : NEW_LINE INDENT files = [ ] NEW_LINE for file in os . listdir ( path ) : NEW_LINE INDENT if file . endswith ( extension ) : NEW_LINE INDENT files . append ( file ) NEW_LINE DEDENT DEDENT return files NEW_LINE DEDENT
from pyzabbix import ZabbixAPI NEW_LINE zapi = ZabbixAPI ( " http : / / localhost / zabbix " ) NEW_LINE zapi . login ( " Admin " , " zabbix " ) NEW_LINE for h in zapi . host . get ( output = " extend " ) : NEW_LINE INDENT print ( " Host : ▁ % s " % h [ " host " ] ) NEW_LINE for i in zapi . item . get ( hostids = h [ " hostid " ] , output = " extend " ) : NEW_LINE INDENT print ( " ▁ ▁ Item : ▁ % s " % i [ " name " ] ) NEW_LINE for g in zapi . graph . get ( itemids = i [ " itemid " ] , output = " extend " ) : NEW_LINE INDENT print ( " ▁ ▁ ▁ ▁ Graph : ▁ % s " % g [ " name " ] ) NEW_LINE for t in zapi . graphitem . get ( graphids = g [ " graphid " ] , output = " extend " ) : NEW_LINE INDENT print ( " ▁ ▁ ▁ ▁ ▁ ▁ Graph ▁ item : ▁ % s " % t [ " itemid " ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT
def replace_empty_strings ( string ) : NEW_LINE INDENT return string . replace ( " " , " ▁ " ) NEW_LINE DEDENT
def is_number ( s ) : NEW_LINE INDENT try : NEW_LINE INDENT float ( s ) NEW_LINE return True NEW_LINE DEDENT except ValueError : NEW_LINE INDENT pass NEW_LINE DEDENT try : NEW_LINE INDENT import unicodedata NEW_LINE unicodedata . numeric ( s ) NEW_LINE return True NEW_LINE DEDENT except ( TypeError , ValueError ) : NEW_LINE INDENT pass NEW_LINE DEDENT return False NEW_LINE DEDENT
import re NEW_LINE def extract_float ( string ) : NEW_LINE INDENT return float ( re . findall ( r ' [ - + ] ? \d * \ . \d + | \d + ' , string ) [ 0 ] ) NEW_LINE DEDENT extract_float ( ' $ 123.45' ) NEW_LINE
import sqlite3 NEW_LINE conn = sqlite3 . connect ( ' example . db ' ) NEW_LINE c = conn . cursor ( ) NEW_LINE c . execute ( " SELECT ▁ * ▁ FROM ▁ stocks " ) NEW_LINE print ( c . description ) NEW_LINE
def get_indexes ( lst ) : NEW_LINE INDENT return [ i for i , x in enumerate ( lst ) if x ] NEW_LINE DEDENT
import random NEW_LINE random . seed ( 0 ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT print ( random . randint ( 0 , 10 ) ) NEW_LINE DEDENT
import random NEW_LINE def get_random_item ( model ) : NEW_LINE INDENT count = model . objects . count ( ) NEW_LINE random_index = random . randint ( 0 , count - 1 ) NEW_LINE return model . objects . all ( ) [ random_index ] NEW_LINE DEDENT
def switch_chars ( string ) : NEW_LINE INDENT if len ( string ) < 2 : NEW_LINE INDENT return string NEW_LINE DEDENT else : NEW_LINE INDENT return string [ 1 ] + string [ 0 ] + switch_chars ( string [ 2 : ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import doctest NEW_LINE doctest . testmod ( ) NEW_LINE DEDENT
s = set ( [ 1 , 2 , 3 ] ) NEW_LINE s . pop ( ) NEW_LINE print ( s ) NEW_LINE
def unicode_to_str ( unicode_string ) : NEW_LINE INDENT return unicode_string . encode ( ' utf - 8' ) NEW_LINE DEDENT
import numpy as np NEW_LINE a = np . array ( [ 1 , 2 , 3 ] ) NEW_LINE print ( a ) NEW_LINE b = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ) NEW_LINE print ( b ) NEW_LINE c = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] , dtype = np . float64 ) NEW_LINE print ( c ) NEW_LINE d = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] , dtype = np . complex ) NEW_LINE print ( d ) NEW_LINE e = np . zeros ( ( 3 , 4 ) ) NEW_LINE print ( e ) NEW_LINE f = np . ones ( ( 2 , 3 , 4 ) , dtype = np . int16 ) NEW_LINE print ( f ) NEW_LINE g = np . empty ( ( 2 , 3 ) ) NEW_LINE print ( g ) NEW_LINE h = np . arange ( 10 , 30 , 5 ) NEW_LINE print ( h ) NEW_LINE i = np . arange ( 0 , 2 , 0.3 ) NEW_LINE print ( i ) NEW_LINE j = np . linspace ( 0 , 2 , 9 ) NEW_LINE print ( j ) NEW_LINE
import re NEW_LINE def repl ( m ) : NEW_LINE INDENT return ' { } ▁ { } ' . format ( m . group ( 1 ) , m . group ( 2 ) ) NEW_LINE DEDENT re . sub ( r ' ( \w + ) ▁ ( \w + ) ' , repl , ' hello ▁ world ' ) NEW_LINE
d = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 , ' d ' : 4 , ' e ' : 5 } NEW_LINE d = { k : v for k , v in d . items ( ) if v >= 3 } NEW_LINE d = { k : v for k , v in d . items ( ) if v < 3 } NEW_LINE
def replace_single_quote ( string ) : NEW_LINE INDENT return string . replace ( " ' " , " " ) NEW_LINE DEDENT
def find_element ( lst , elem ) : NEW_LINE INDENT for i in range ( len ( lst ) ) : NEW_LINE INDENT if lst [ i ] [ 0 ] == elem : NEW_LINE INDENT return lst [ i ] [ 1 ] NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT
def slice_list ( l , n ) : NEW_LINE INDENT return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ] NEW_LINE DEDENT
def add_tuple ( tuple_list , tuple_to_add ) : NEW_LINE INDENT tuple_list . append ( tuple_to_add ) NEW_LINE return tuple_list NEW_LINE DEDENT
import hashlib NEW_LINE h = hashlib . md5 ( ) NEW_LINE h . update ( " Hello ▁ World " ) NEW_LINE digest = h . digest ( ) NEW_LINE key = Key ( bucket , digest ) NEW_LINE key . set_contents_from_string ( " Hello ▁ World " ) NEW_LINE
def max_length ( list_of_lists ) : NEW_LINE INDENT max_lengths = [ ] NEW_LINE for i in range ( len ( list_of_lists [ 0 ] ) ) : NEW_LINE INDENT max_lengths . append ( max ( [ len ( str ( row [ i ] ) ) for row in list_of_lists ] ) ) NEW_LINE DEDENT return max_lengths NEW_LINE DEDENT def print_table ( list_of_lists ) : NEW_LINE INDENT max_lengths = max_length ( list_of_lists ) NEW_LINE for row in list_of_lists : NEW_LINE INDENT for i in range ( len ( row ) ) : NEW_LINE INDENT print ( str ( row [ i ] ) . ljust ( max_lengths [ i ] ) , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT print_table ( [ [ ' apples ' , ' oranges ' , ' cherries ' , ' banana ' ] , [ ' Alice ' , ' Bob ' , ' Carol ' , ' David ' ] , [ ' dogs ' , ' cats ' , ' moose ' , ' goose ' ] ] ) NEW_LINE
import datetime NEW_LINE today = datetime . date . today ( ) NEW_LINE six_months = datetime . timedelta ( days = 180 ) NEW_LINE six_months_from_now = today + six_months NEW_LINE print ( six_months_from_now ) NEW_LINE
import numpy as np NEW_LINE a = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , np . nan ] , [ 7 , 8 , 9 ] ] ) NEW_LINE a [ ~ np . isnan ( a ) . any ( axis = 1 ) ] NEW_LINE
from django . db . models import F NEW_LINE Model . objects . order_by ( F ( ' one _ to _ one _ model _ _ name ' ) ) NEW_LINE
list_of_lists_of_lists = [ [ [ 1 , 2 ] , [ 3 , 4 ] ] , [ [ 5 , 6 ] , [ 7 , 8 ] ] ] NEW_LINE sum ( [ item [ 1 ] for item in [ item for item in list_of_lists_of_lists ] ] ) NEW_LINE
for i , v in enumerate ( [ ' tic ' , ' tac ' , ' toe ' ] ) : NEW_LINE INDENT print ( i , v ) NEW_LINE DEDENT
def remove_duplicates ( string ) : NEW_LINE INDENT return ' ' . join ( set ( string ) ) NEW_LINE DEDENT print ( remove_duplicates ( ' abcdabcd ' ) ) NEW_LINE
import re NEW_LINE def match_all_but ( string ) : NEW_LINE INDENT return re . compile ( r ' ^ ( ? : ( ? ! { } ) . ) * $ ' . format ( string ) ) NEW_LINE DEDENT
import datetime NEW_LINE def sort_dates ( dates ) : NEW_LINE INDENT return sorted ( dates , key = lambda x : datetime . datetime . strptime ( x , ' % m / % d / % Y ' ) ) NEW_LINE DEDENT
import numpy as np NEW_LINE A = np . matrix ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE A . tolist ( ) NEW_LINE
def coalesce ( s ) : NEW_LINE INDENT return ' ' . join ( c for c , _ in itertools . groupby ( s ) ) NEW_LINE DEDENT
import numpy as np NEW_LINE a = np . array ( [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ) NEW_LINE print ( a [ 0 , 1 ] ) NEW_LINE print ( a [ 1 , 2 ] ) NEW_LINE print ( a [ 2 , 0 ] ) NEW_LINE
from google . appengine . api import app_identity NEW_LINE from google . appengine . api import urlfetch NEW_LINE import json NEW_LINE import urllib NEW_LINE def upload_file ( file_name , file_content ) : NEW_LINE INDENT bucket_name = app_identity . get_default_gcs_bucket_name ( ) NEW_LINE url = ' https : / / www . googleapis . com / upload / storage / v1 / b / ' + bucket_name + ' / o ? uploadType = media & name = ' + file_name NEW_LINE headers = { ' Content - Type ' : ' application / octet - stream ' } NEW_LINE result = urlfetch . fetch ( url = url , payload = file_content , method = urlfetch . POST , headers = headers ) NEW_LINE if result . status_code == 200 : NEW_LINE INDENT return json . loads ( result . content ) NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def sort_list ( lst ) : NEW_LINE INDENT return sorted ( lst , key = lambda x : int ( filter ( str . isdigit , x ) ) ) NEW_LINE DEDENT print sort_list ( [ '1' , '2' , '10' , '20' , '100' , '200' , '1000' , '2000' ] ) NEW_LINE print sort_list ( [ '1' , '2' , '10' , '20' , '100' , '200' , '1000' , '2000' , ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' , ' g ' , ' h ' ] ) NEW_LINE print sort_list ( [ '1' , '2' , '10' , '20' , '100' , '200' , '1000' , '2000' , ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' , ' g ' , ' h ' , '1a ' , '2b ' , '10c ' , '20d ' , '100e ' , '200f ' , '1000g ' , '2000h ' ] ) NEW_LINE print sort_list ( [ '1' , '2' , '10' , '20' , '100' , '200' , '1000' , '2000' , ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' , ' g ' , ' h ' , '1a ' , '2b ' , '10c ' , '20d ' , '100e ' , '200f ' , '1000g ' , '2000h ' , '1a1' , '2b2' , '10c10' , '20d20' , '100e100' , '200f200' , '1000g1000' , '2000h2000' ] ) NEW_LINE
import matplotlib . pyplot as plt NEW_LINE plt . figure ( figsize = ( 8 , 6 ) , dpi = 80 ) NEW_LINE plt . subplot ( 1 , 1 , 1 ) NEW_LINE X = np . linspace ( - np . pi , np . pi , 256 , endpoint = True ) NEW_LINE C , S = np . cos ( X ) , np . sin ( X ) NEW_LINE plt . plot ( X , C , color = " blue " , linewidth = 1.0 , linestyle = " - " ) NEW_LINE plt . plot ( X , S , color = " green " , linewidth = 1.0 , linestyle = " - " ) NEW_LINE plt . xlim ( - 4.0 , 4.0 ) NEW_LINE plt . xticks ( np . linspace ( - 4 , 4 , 9 , endpoint = True ) ) NEW_LINE plt . ylim ( - 1.0 , 1.0 ) NEW_LINE plt . yticks ( np . linspace ( - 1 , 1 , 5 , endpoint = True ) ) NEW_LINE plt . show ( ) NEW_LINE
def get_list ( request ) : NEW_LINE INDENT list = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE return render ( request , ' list . html ' , { ' list ' : list } ) NEW_LINE DEDENT
from operator import itemgetter NEW_LINE def sort_list_of_dict ( list_of_dict , order ) : NEW_LINE INDENT return sorted ( list_of_dict , key = itemgetter ( * order ) ) NEW_LINE DEDENT
import socket NEW_LINE import struct NEW_LINE def ip2long ( ip ) : NEW_LINE INDENT packedIP = socket . inet_aton ( ip ) NEW_LINE return struct . unpack ( " ! L " , packedIP ) [ 0 ] NEW_LINE DEDENT def long2ip ( ip ) : NEW_LINE INDENT return socket . inet_ntoa ( struct . pack ( ' ! L ' , ip ) ) NEW_LINE DEDENT print ip2long ( '192.168.1.1' ) NEW_LINE print long2ip ( 3232235777 ) NEW_LINE
hex_bytes = [ '0x01' , '0x02' , '0x03' , '0x04' ] NEW_LINE hex_ints = [ int ( h , 16 ) for h in hex_bytes ] NEW_LINE hex_ints NEW_LINE [ 1 , 2 , 3 , 4 ] NEW_LINE
s = u ' \u4e2d\u6587' NEW_LINE s NEW_LINE s . split ( ) NEW_LINE [ u ' \u4e2d\u6587' ] NEW_LINE list ( s ) NEW_LINE [ u ' \u4e2d ' , u ' \u6587' ] NEW_LINE
def decrypt ( encrypted_string , key ) : NEW_LINE INDENT encrypted_bytes = encrypted_string . decode ( ' utf - 8' ) NEW_LINE decrypted_bytes = decrypt_bytes ( encrypted_bytes , key ) NEW_LINE decrypted_string = decrypted_bytes . decode ( ' utf - 8' ) NEW_LINE return decrypted_string NEW_LINE DEDENT
I ' m ▁ trying ▁ to ▁ create ▁ a ▁ MITM ▁ proxy ▁ over ▁ SSL . ▁ I ' m using the following code : NEW_LINE < code > import socket NEW_LINE import ssl NEW_LINE def main ( ) : NEW_LINE INDENT context = ssl . create_default_context ( ssl . Purpose . CLIENT_AUTH ) NEW_LINE context . load_cert_chain ( certfile = " cert . pem " , keyfile = " key . pem " ) NEW_LINE bindsocket = socket . socket ( ) NEW_LINE bindsocket . bind ( ( ' ' , 443 ) ) NEW_LINE bindsocket . listen ( 5 ) NEW_LINE while True : NEW_LINE INDENT newsocket , fromaddr = bindsocket . accept ( ) NEW_LINE conn = context . wrap_socket ( newsocket , server_side = True ) NEW_LINE try : NEW_LINE INDENT deal_with_client ( conn ) NEW_LINE DEDENT finally : NEW_LINE INDENT conn . shutdown ( socket . SHUT_RDWR ) NEW_LINE conn . close ( ) NEW_LINE DEDENT DEDENT DEDENT def deal_with_client ( conn ) : NEW_LINE INDENT data = conn . recv ( 1024 ) NEW_LINE print ( data ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT < / code > NEW_LINE I ' m using the following command to generate the certificate : NEW_LINE < code > openssl req - x509 - newkey rsa : 4096 - keyout key . pem - out cert . pem - days 365 - nodes NEW_LINE < / code > NEW_LINE I ' m using the following command to connect to the proxy : NEW_LINE < code > curl - - proxy https : // localhost : 443 https : // www . google . com NEW_LINE < / code > NEW_LINE The problem is that the < code > wrap_socket < / code > call hangs . I ' ve tried using < code > context . check_hostname = False < / code > and < code > context . verify_mode = ssl . CERT_NONE < / code > but it still hangs . NEW_LINE I ' ve also tried using < code > context . verify_mode = ssl . CERT_REQUIRED < / code > and < code > context . check_hostname = True < / code > but it still hangs . NEW_LINE I ' ve also tried using < code > context . verify_mode = ssl . CERT_REQUIRED < / code > and < code > context . check_hostname = False < / code > but it still hangs . NEW_LINE I ' ve also tried using < code > context . NEW_LINE
def replace_empty_string_with_zero ( string ) : NEW_LINE INDENT return ' , ' . join ( str ( int ( x ) if x else 0 ) for x in string . split ( ' , ' ) ) NEW_LINE DEDENT
numbers = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE def squared ( num ) : NEW_LINE INDENT return num ** 2 NEW_LINE DEDENT squared_numbers = [ squared ( num ) for num in numbers ] NEW_LINE print ( squared_numbers ) NEW_LINE
import lxml . html NEW_LINE html = ''' STRNEWLINE < div > STRNEWLINE ▁ ▁ ▁ ▁ < ul > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 0 " > < a ▁ href = " link1 . html " > first ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 1 " > < a ▁ href = " link2 . html " > second ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - inactive " > < a ▁ href = " link3 . html " > third ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 1 " > < a ▁ href = " link4 . html " > fourth ▁ item < / a > < / li > STRNEWLINE ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ < li ▁ class = " item - 0 " > < a ▁ href = " link5 . html " > fifth ▁ item < / a > STRNEWLINE ▁ ▁ ▁ ▁ ▁ < / ul > STRNEWLINE ▁ < / div > STRNEWLINE ''' NEW_LINE selector = lxml . html . fromstring ( html ) NEW_LINE result = selector . xpath ( ' / / li ' ) NEW_LINE print ( result ) NEW_LINE result = selector . xpath ( ' / / li [ @ class = " item - 0 " ] ' ) NEW_LINE print ( result ) NEW_LINE result = selector . xpath ( ' / / li / a / @ href ' ) NEW_LINE print ( result ) NEW_LINE result = selector . xpath ( ' / / li [ @ class = " item - 0 " ] / a / @ href ' ) NEW_LINE print ( result ) NEW_LINE result = selector . xpath ( ' / / li [ @ class = " item - 0 " ▁ or ▁ @ class = " item - 1 " ] / a / @ href ' ) NEW_LINE print ( result ) NEW_LINE
def first_last_n ( lst , n ) : NEW_LINE INDENT return lst [ : n ] + lst [ - n : ] NEW_LINE DEDENT
import requests NEW_LINE from bs4 import BeautifulSoup NEW_LINE url = ' https : / / www . nytimes . com / ' NEW_LINE r = requests . get ( url ) NEW_LINE r_html = r . text NEW_LINE soup = BeautifulSoup ( r_html , " html . parser " ) NEW_LINE for tag in soup . find_all ( class_ = " story - heading " ) : NEW_LINE INDENT if tag . a : NEW_LINE INDENT print ( tag . a . text . replace ( " \n " , " ▁ " ) . strip ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( tag . contents [ 0 ] . strip ( ) ) NEW_LINE DEDENT DEDENT
def sort_pos_neg ( lst ) : NEW_LINE INDENT return sorted ( lst , key = lambda x : ( x < 0 , abs ( x ) ) ) NEW_LINE DEDENT
def contains ( string , substring ) : NEW_LINE INDENT return substring in string NEW_LINE DEDENT
s = ' \u00e9' NEW_LINE s NEW_LINE s . encode ( ' utf - 8' ) NEW_LINE s . encode ( ' utf - 8' ) . decode ( ' utf - 8' ) NEW_LINE
import matplotlib . pyplot as plt NEW_LINE import numpy as np NEW_LINE x = np . linspace ( 0 , 10 , 100 ) NEW_LINE plt . plot ( x , x , label = ' linear ' ) NEW_LINE plt . legend ( ) NEW_LINE plt . title ( ' Linear ▁ vs . ▁ Quadratic ▁ progression ' ) NEW_LINE plt . xlabel ( ' Input ' ) NEW_LINE plt . ylabel ( ' Output ' ) NEW_LINE plt . grid ( True ) NEW_LINE plt . xticks ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ) NEW_LINE plt . yticks ( [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ) NEW_LINE plt . tick_params ( axis = ' both ' , which = ' major ' , labelsize = 14 ) NEW_LINE plt . legend ( prop = { ' size ' : 14 } ) NEW_LINE plt . title ( ' Linear ▁ vs . ▁ Quadratic ▁ progression ' , fontsize = 20 ) NEW_LINE plt . xlabel ( ' Input ' , fontsize = 14 ) NEW_LINE plt . ylabel ( ' Output ' , fontsize = 14 ) NEW_LINE plt . show ( ) NEW_LINE
import numpy as np NEW_LINE def mag_sq ( x , y , z ) : NEW_LINE INDENT return x * x + y * y + z * z NEW_LINE DEDENT def mag_sq_numpy ( x , y , z ) : NEW_LINE INDENT return np . sum ( x * x + y * y + z * z ) NEW_LINE DEDENT
import re NEW_LINE def find_dict_items ( d , substr ) : NEW_LINE INDENT return { k : v for k , v in d . items ( ) if re . search ( substr , k ) } NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 , ' d ' : 4 , ' e ' : 5 } NEW_LINE print ( find_dict_items ( d , ' a ' ) ) NEW_LINE print ( find_dict_items ( d , ' b ' ) ) NEW_LINE print ( find_dict_items ( d , ' c ' ) ) NEW_LINE print ( find_dict_items ( d , ' d ' ) ) NEW_LINE print ( find_dict_items ( d , ' e ' ) ) NEW_LINE print ( find_dict_items ( d , ' f ' ) ) NEW_LINE DEDENT ` ` ` NEW_LINE ` ` ` shell NEW_LINE $ . / find_dict_items . py NEW_LINE { ' a ' : 1 } NEW_LINE { ' b ' : 2 } NEW_LINE { ' c ' : 3 } NEW_LINE { ' d ' : 4 } NEW_LINE { ' e ' : 5 } NEW_LINE { } NEW_LINE
def sort_list ( list_of_tuples ) : NEW_LINE INDENT return sorted ( list_of_tuples , key = lambda x : x [ 1 ] + x [ 2 ] ) NEW_LINE DEDENT
def sort_by_keys ( lst , * keys ) : NEW_LINE INDENT if len ( keys ) == 1 : NEW_LINE INDENT return sorted ( lst , key = lambda x : x [ keys [ 0 ] ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return sorted ( lst , key = lambda x : [ x [ key ] for key in keys ] ) NEW_LINE DEDENT DEDENT
def check_value_exist ( list , value ) : NEW_LINE INDENT if value in list : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT list = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE value = 3 NEW_LINE print ( check_value_exist ( list , value ) ) NEW_LINE
import datetime NEW_LINE def convert_date_to_day_of_week ( date_string ) : NEW_LINE INDENT date_object = datetime . datetime . strptime ( date_string , ' % Y - % m - % d ' ) NEW_LINE return date_object . strftime ( ' % A ' ) NEW_LINE DEDENT convert_date_to_day_of_week ( '2018-01-01' ) NEW_LINE
my_list = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE my_list = [ x for x in my_list if x % 2 == 0 ] NEW_LINE print ( my_list ) NEW_LINE
def reverse_list ( l ) : NEW_LINE INDENT return l [ : : - 1 ] NEW_LINE DEDENT
def limit_sentences ( text , max_sentences ) : NEW_LINE INDENT sentences = text . split ( ' . ' ) NEW_LINE if len ( sentences ) > max_sentences : NEW_LINE INDENT return ' . ' . join ( sentences [ : max_sentences ] ) + ' . ' NEW_LINE DEDENT else : NEW_LINE INDENT return text NEW_LINE DEDENT DEDENT limit_sentences ( ' This ▁ is ▁ a ▁ sentence . ▁ This ▁ is ▁ another ▁ sentence . ▁ This ▁ is ▁ a ▁ third ▁ sentence . ' , 2 ) NEW_LINE
def get_size ( l ) : NEW_LINE INDENT return len ( l ) NEW_LINE DEDENT
import tkinter as tk NEW_LINE root = tk . Tk ( ) NEW_LINE root . geometry ( "500x500" ) NEW_LINE root . mainloop ( ) NEW_LINE
test_str = " geeksforgeeks " NEW_LINE print ( " The ▁ original ▁ string ▁ is ▁ : ▁ " + str ( test_str ) ) NEW_LINE res = test_str [ : : 2 ] NEW_LINE print ( " The ▁ alternate ▁ characters ▁ of ▁ string ▁ are ▁ : ▁ " + str ( res ) ) NEW_LINE test_str = " geeksforgeeks " NEW_LINE print ( " The ▁ original ▁ string ▁ is ▁ : ▁ " + str ( test_str ) ) NEW_LINE res = " " NEW_LINE for i in range ( 0 , len ( test_str ) , 2 ) : NEW_LINE INDENT res += test_str [ i ] NEW_LINE DEDENT print ( " The ▁ alternate ▁ characters ▁ of ▁ string ▁ are ▁ : ▁ " + str ( res ) ) NEW_LINE test_str = " geeksforgeeks " NEW_LINE print ( " The ▁ original ▁ string ▁ is ▁ : ▁ " + str ( test_str ) ) NEW_LINE res = [ test_str [ i ] for i in range ( 0 , len ( test_str ) , 2 ) ] NEW_LINE print ( " The ▁ alternate ▁ characters ▁ of ▁ string ▁ are ▁ : ▁ " + str ( res ) ) NEW_LINE test_str = " geeksforgeeks " NEW_LINE print ( " The ▁ original ▁ string ▁ is ▁ : ▁ " + str ( test_str ) ) NEW_LINE res = filter ( lambda x : test_str . index ( x ) % 2 == 0 , test_str ) NEW_LINE print ( " The ▁ alternate ▁ characters ▁ of ▁ string ▁ are ▁ : ▁ " + str ( res ) ) NEW_LINE
def flatten ( l ) : NEW_LINE INDENT return [ item for sublist in l for item in sublist ] NEW_LINE DEDENT
def extract_values ( obj , key ) : NEW_LINE INDENT arr = [ ] NEW_LINE def extract ( obj , arr , key ) : NEW_LINE INDENT if isinstance ( obj , dict ) : NEW_LINE INDENT for k , v in obj . items ( ) : NEW_LINE INDENT if isinstance ( v , ( dict , list ) ) : NEW_LINE INDENT extract ( v , arr , key ) NEW_LINE DEDENT elif k == key : NEW_LINE INDENT arr . append ( v ) NEW_LINE DEDENT DEDENT DEDENT elif isinstance ( obj , list ) : NEW_LINE INDENT for item in obj : NEW_LINE INDENT extract ( item , arr , key ) NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT results = extract ( obj , arr , key ) NEW_LINE return results NEW_LINE DEDENT
def sum_second_value ( lst ) : NEW_LINE INDENT return sum ( map ( lambda x : x [ 1 ] , lst ) ) NEW_LINE DEDENT
list_of_dicts = [ { ' name ' : ' John ' , ' age ' : 20 } , { ' name ' : ' Mary ' , ' age ' : 25 } ] NEW_LINE [ d [ ' name ' ] for d in list_of_dicts ] NEW_LINE
from PIL import Image NEW_LINE im = Image . open ( " image . png " ) NEW_LINE if im . mode == " RGBA " : NEW_LINE INDENT im = im . convert ( " RGB " ) NEW_LINE DEDENT im . save ( " image . jpg " ) NEW_LINE
def check_if_all_in ( tup , lst ) : NEW_LINE INDENT return all ( x in lst for x in tup ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE def merge_dicts ( dicts ) : NEW_LINE INDENT result = defaultdict ( list ) NEW_LINE for d in dicts : NEW_LINE INDENT for k , v in d . items ( ) : NEW_LINE INDENT result [ k ] . append ( v ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
import re NEW_LINE def is_valid_IP ( strng ) : NEW_LINE INDENT return bool ( re . match ( r ' ^ ( ( [ 1-9 ] ? \d | 1\d\d | 2[0-4 ] \d | 25[0-5 ] ) ( \ . ( ? ! $ ) | $ ) ) { 4 } $ ' , strng ) ) NEW_LINE DEDENT
from PyQt5 . QtWidgets import QApplication , QWidget , QPushButton NEW_LINE from PyQt5 . QtGui import QColor NEW_LINE from PyQt5 . QtCore import Qt NEW_LINE import sys NEW_LINE class Example ( QWidget ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT super ( ) . __init__ ( ) NEW_LINE self . initUI ( ) NEW_LINE DEDENT def initUI ( self ) : NEW_LINE INDENT self . setGeometry ( 300 , 300 , 300 , 300 ) NEW_LINE self . setWindowTitle ( ' QPushButton ' ) NEW_LINE self . btn = QPushButton ( ' Button ' , self ) NEW_LINE self . btn . setStyleSheet ( ' background - color : ▁ red ; ▁ color : ▁ white ' ) NEW_LINE self . btn . resize ( self . btn . sizeHint ( ) ) NEW_LINE self . btn . move ( 50 , 50 ) NEW_LINE self . show ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT app = QApplication ( sys . argv ) NEW_LINE ex = Example ( ) NEW_LINE sys . exit ( app . exec_ ( ) ) NEW_LINE DEDENT
l = [ '1' , '2' , '3' ] NEW_LINE l = [ int ( i ) for i in l ] NEW_LINE
import matplotlib . pyplot as plt NEW_LINE x = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE y = [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 , 20 ] NEW_LINE plt . scatter ( x , y , s = 100 ) NEW_LINE plt . show ( ) NEW_LINE
s = " Hello , ▁ World ! \n " NEW_LINE s . rstrip ( ) NEW_LINE
def combinate ( set , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return [ [ ] ] NEW_LINE DEDENT else : NEW_LINE INDENT return [ x + [ y ] for x in combinate ( set , n - 1 ) for y in set if y not in x ] NEW_LINE DEDENT DEDENT
def list_to_hex_string ( l ) : NEW_LINE INDENT return ' ' . join ( map ( lambda x : ' % 02x ' % x , l ) ) NEW_LINE DEDENT
import datetime NEW_LINE date_string = "01/01/17 ▁ 12:10:03.234567" NEW_LINE date_dt = datetime . datetime . strptime ( date_string , " % d / % m / % y ▁ % H : % M : % S . % f " ) NEW_LINE print ( date_dt ) NEW_LINE
def find_closest ( L , target ) : NEW_LINE INDENT low = 0 NEW_LINE high = len ( L ) - 1 NEW_LINE while low < high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if target < L [ mid ] : NEW_LINE INDENT high = mid NEW_LINE DEDENT elif target > L [ mid ] : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT L = [ 1 , 2 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE target = 3 NEW_LINE print ( find_closest ( L , target ) ) NEW_LINE
my_list = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE print ( my_list ) NEW_LINE print ( my_list [ 0 ] ) NEW_LINE print ( my_list [ - 1 ] ) NEW_LINE print ( my_list [ - 2 ] ) NEW_LINE print ( my_list [ 0 : 3 ] ) NEW_LINE print ( my_list [ - 3 : ] ) NEW_LINE print ( my_list [ 2 : ] ) NEW_LINE print ( my_list [ : - 2 ] ) NEW_LINE print ( my_list [ : - 2 ] + my_list [ : - 2 ] [ : : - 1 ] ) NEW_LINE print ( my_list [ : : - 1 ] ) NEW_LINE print ( my_list [ : : - 2 ] ) NEW_LINE print ( my_list [ - 2 : : - 2 ] ) NEW_LINE print ( my_list [ - 2 : 0 : - 2 ] ) NEW_LINE print ( my_list [ - 3 : 0 : - 2 ] ) NEW_LINE print ( my_list [ - 4 : 0 : - 2 ] ) NEW_LINE print ( my_list [ - 5 : 0 : - 2 ] ) NEW_LINE print ( my_list [ - 6 : 0 : - 2 ] ) NEW_LINE print ( my_list [ - 7 : 0 : - 2 ] ) NEW_LINE
import re NEW_LINE def extract_first_two_characters ( string ) : NEW_LINE INDENT return re . findall ( r ' ^ \w { 2 } ' , string ) NEW_LINE DEDENT print ( extract_first_two_characters ( ' Python ' ) ) NEW_LINE print ( extract_first_two_characters ( ' Py ' ) ) NEW_LINE print ( extract_first_two_characters ( ' Java ' ) ) NEW_LINE
def to_lowercase ( s ) : NEW_LINE INDENT return s . lower ( ) NEW_LINE DEDENT
from flask import Flask , request NEW_LINE app = Flask ( __name__ ) NEW_LINE @ app . route ( ' / ' ) NEW_LINE def index ( ) : NEW_LINE INDENT return ' Index ▁ Page ' NEW_LINE DEDENT @ app . route ( ' / hello ' ) NEW_LINE def hello ( ) : NEW_LINE INDENT return ' Hello , ▁ World ' NEW_LINE DEDENT @ app . route ( ' / user / < username > ' ) NEW_LINE def show_user_profile ( username ) : NEW_LINE INDENT return ' User ▁ % s ' % username NEW_LINE DEDENT @ app . route ( ' / post / < int : post _ id > ' ) NEW_LINE def show_post ( post_id ) : NEW_LINE INDENT return ' Post ▁ % d ' % post_id NEW_LINE DEDENT @ app . route ( ' / path / < path : subpath > ' ) NEW_LINE def show_subpath ( subpath ) : NEW_LINE INDENT return ' Subpath ▁ % s ' % subpath NEW_LINE DEDENT @ app . route ( ' / projects / ' ) NEW_LINE def projects ( ) : NEW_LINE INDENT return ' The ▁ project ▁ page ' NEW_LINE DEDENT @ app . route ( ' / about ' ) NEW_LINE def about ( ) : NEW_LINE INDENT return ' The ▁ about ▁ page ' NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT app . run ( ) NEW_LINE DEDENT
def rgb_to_hex ( rgb ) : NEW_LINE INDENT return ' # % 02x % 02x % 02x ' % rgb NEW_LINE DEDENT def hex_to_rgb ( value ) : NEW_LINE INDENT value = value . lstrip ( ' # ' ) NEW_LINE lv = len ( value ) NEW_LINE return tuple ( int ( value [ i : i + lv // 3 ] , 16 ) for i in range ( 0 , lv , lv // 3 ) ) NEW_LINE DEDENT
import os NEW_LINE def is_descendant ( parent , child ) : NEW_LINE INDENT parent = os . path . abspath ( parent ) NEW_LINE child = os . path . abspath ( child ) NEW_LINE return child . startswith ( parent ) NEW_LINE DEDENT
import cv2 NEW_LINE import numpy as np NEW_LINE img = cv2 . imread ( ' lena . jpg ' , 0 ) NEW_LINE cv2 . imshow ( ' image ' , img ) NEW_LINE cv2 . waitKey ( 0 ) NEW_LINE cv2 . destroyAllWindows ( ) NEW_LINE
import os NEW_LINE def convert_line_endings ( file , in_encoding , out_encoding ) : NEW_LINE INDENT content = ' ' NEW_LINE outsize = 0 NEW_LINE with open ( file , ' rb ' ) as infile : NEW_LINE INDENT content = infile . read ( ) NEW_LINE outsize = len ( content ) NEW_LINE content = content . replace ( b ' \n ' , b ' \n ' ) NEW_LINE content = content . replace ( b ' ' , b ' \n ' ) NEW_LINE content = content . replace ( b ' \n ' , b ' \n ' ) NEW_LINE DEDENT with open ( file , ' wb ' ) as output : NEW_LINE INDENT for line in content . splitlines ( True ) : NEW_LINE INDENT outsize += len ( line ) - 1 NEW_LINE output . write ( line ) NEW_LINE DEDENT DEDENT print ( " Done . ▁ Saved ▁ % s ▁ bytes . " % ( len ( content ) - outsize ) ) NEW_LINE DEDENT convert_line_endings ( ' file . txt ' , ' utf - 8' , ' utf - 8' ) NEW_LINE
def string_to_list ( string ) : NEW_LINE INDENT return [ int ( x ) for x in string . split ( ) ] NEW_LINE DEDENT
import pygame NEW_LINE pygame . init ( ) NEW_LINE infoObject = pygame . display . Info ( ) NEW_LINE print ( infoObject . current_w ) NEW_LINE print ( infoObject . current_h ) NEW_LINE
def closest ( lst , K ) : NEW_LINE INDENT return lst [ min ( range ( len ( lst ) ) , key = lambda i : abs ( lst [ i ] - K ) ) ] NEW_LINE DEDENT lst = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE K = 5 NEW_LINE print ( closest ( lst , K ) ) NEW_LINE
def lookup ( name , scope ) : NEW_LINE INDENT if name in scope : NEW_LINE INDENT return scope [ name ] NEW_LINE DEDENT elif scope . get ( ' parent ' ) : NEW_LINE INDENT return lookup ( name , scope [ ' parent ' ] ) NEW_LINE DEDENT else : NEW_LINE INDENT raise NameError ( name ) NEW_LINE DEDENT DEDENT
import re NEW_LINE with open ( ' file . txt ' , ' r ' ) as f : NEW_LINE INDENT for line in f : NEW_LINE INDENT if re . search ( r ' $ ' , line ) : NEW_LINE INDENT print ( ' DOS ▁ line ▁ break ▁ found ! ' ) NEW_LINE DEDENT DEDENT DEDENT
