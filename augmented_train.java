class Main { static int gcd ( int a , int b ) { while ( b != 0 ) { int t = b ; b = a % b ; a = t ; } return a ; } public static void main ( String [ ] args ) { int n = args . length == 1 ? Integer . parseInt ( args [ 0 ] ) : 3 ; int s = 0 ; for ( int x = 1 ; x <= n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { s += gcd ( x , y ) ; } } System . out . println ( s ) ; } }
class HundredDoors { public static void main ( String [ ] args ) { boolean [ ] doors = new boolean [ 101 ] ; for ( int i = 1 ; i < doors . length ; i ++ ) { for ( int j = i ; j < doors . length ; j += i ) { doors [ j ] = ! doors [ j ] ; } } for ( int i = 1 ; i < doors . length ; i ++ ) { if ( doors [ i ] ) { System . out . printf ( " Door ▁ % d ▁ is ▁ open . % n " , i ) ; } } } }
private static boolean playRandom ( int n ) { List < Integer > secretList = IntStream . range ( 0 , n ) . boxed ( ) . collect ( Collectors . toList ( ) ) ; Collections . shuffle ( secretList ) ; prisoner : for ( Integer i : secretList ) { List < Integer > trialList = IntStream . range ( 0 , n ) . boxed ( ) . collect ( Collectors . toList ( ) ) ; Collections . shuffle ( trialList ) ; for ( int j = 0 ; j < trialList . size ( ) / 2 ; ++ j ) { if ( Objects . equals ( trialList . get ( j ) , i ) ) { continue prisoner ; } } return false ; } return true ; }
private static boolean playOptimal ( int n ) { List < Integer > secretList = IntStream . range ( 0 , n ) . boxed ( ) . collect ( Collectors . toList ( ) ) ; Collections . shuffle ( secretList ) ; prisoner : for ( int i = 0 ; i < secretList . size ( ) ; ++ i ) { int prev = i ; for ( int j = 0 ; j < secretList . size ( ) / 2 ; ++ j ) { if ( secretList . get ( prev ) == i ) { continue prisoner ; } prev = secretList . get ( prev ) ; } return false ; } return true ; }
package fifteenpuzzle ; import java . awt . * ; import java . awt . event . * ; import java . util . Random ; import javax . swing . * ; class FifteenPuzzle extends JPanel { private final int side = 4 ; private final int numTiles = side * side - 1 ; private final Random rand = new Random ( ) ; private final int [ ] tiles = new int [ numTiles + 1 ] ; private final int tileSize ; private int blankPos ; private final int margin ; private final int gridSize ; private boolean gameOver ; private FifteenPuzzle ( ) { final int dim = 640 ; margin = 80 ; tileSize = ( dim - 2 * margin ) / side ; gridSize = tileSize * side ; setPreferredSize ( new Dimension ( dim , dim + margin ) ) ; setBackground ( Color . WHITE ) ; setForeground ( new Color ( 0x6495ED ) ) ; setFont ( new Font ( " SansSerif " , Font . BOLD , 60 ) ) ; gameOver = true ; addMouseListener ( new MouseAdapter ( ) { @ Override public void mousePressed ( MouseEvent e ) { if ( gameOver ) { newGame ( ) ; } else { int ex = e . getX ( ) - margin ; int ey = e . getY ( ) - margin ; if ( ex < 0 || ex > gridSize || ey < 0 || ey > gridSize ) { return ; } int c1 = ex / tileSize ; int r1 = ey / tileSize ; int c2 = blankPos % side ; int r2 = blankPos / side ; int clickPos = r1 * side + c1 ; int dir = 0 ; if ( c1 == c2 && Math . abs ( r1 - r2 ) > 0 ) { dir = ( r1 - r2 ) > 0 ? 4 : - 4 ; } else if ( r1 == r2 && Math . abs ( c1 - c2 ) > 0 ) { dir = ( c1 - c2 ) > 0 ? 1 : - 1 ; } if ( dir != 0 ) { do { int newBlankPos = blankPos + dir ; tiles [ blankPos ] = tiles [ newBlankPos ] ; blankPos = newBlankPos ; } while ( blankPos != clickPos ) ; tiles [ blankPos ] = 0 ; } gameOver = isSolved ( ) ; } repaint ( ) ; } } ) ; newGame ( ) ; } private void newGame ( ) { do { reset ( ) ; shuffle ( ) ; } while ( ! isSolvable ( ) ) ; gameOver = false ; } private void reset ( ) { for ( int i = 0 ; i < tiles . length ; i ++ ) { tiles [ i ] = ( i + 1 ) % tiles . length ; } blankPos = tiles . length - 1 ; } private void shuffle ( ) { int n = numTiles ; while ( n > 1 ) { int r = rand . nextInt ( n -- ) ; int tmp = tiles [ r ] ; tiles [ r ] = tiles [ n ] ; tiles [ n ] = tmp ; } } private boolean isSolvable ( ) { int countInversions = 0 ; for ( int i = 0 ; i < numTiles ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( tiles [ j ] > tiles [ i ] ) { countInversions ++ ; } } } return countInversions % 2 == 0 ; } private boolean isSolved ( ) { if ( tiles [ tiles . length - 1 ] != 0 ) { return false ; } for ( int i = numTiles - 1 ; i >= 0 ; i -- ) { if ( tiles [ i ] != i + 1 ) { return false ; } } return true ; } private void drawGrid ( Graphics2D g ) { for ( int i = 0 ; i < tiles . length ; i ++ ) { int r = i / side ; int c = i % side ; int x = margin + c * tileSize ; int y = margin + r * tileSize ; if ( tiles [ i ] == 0 ) { if ( gameOver ) { g . setColor ( Color . GREEN ) ; drawCenteredString ( g , " \u2713" , x , y ) ; } continue ; } g . setColor ( getForeground ( ) ) ; g . fillRoundRect ( x , y , tileSize , tileSize , 25 , 25 ) ; g . setColor ( Color . blue . darker ( ) ) ; g . drawRoundRect ( x , y , tileSize , tileSize , 25 , 25 ) ; g . setColor ( Color . WHITE ) ; drawCenteredString ( g , String . valueOf ( tiles [ i ] ) , x , y ) ; } } private void drawStartMessage ( Graphics2D g ) { if ( gameOver ) { g . setFont ( getFont ( ) . deriveFont ( Font . BOLD , 18 ) ) ; g . setColor ( getForeground ( ) ) ; String s = " click ▁ to ▁ start ▁ a ▁ new ▁ game " ; int x = ( getWidth ( ) - g . getFontMetrics ( ) . stringWidth ( s ) ) / 2 ; int y = getHeight ( ) - margin ; g . drawString ( s , x , y ) ; } } private void drawCenteredString ( Graphics2D g , String s , int x , int y ) { FontMetrics fm = g . getFontMetrics ( ) ; int asc = fm . getAscent ( ) ; int des = fm . getDescent ( ) ; x = x + ( tileSize - fm . stringWidth ( s ) ) / 2 ; y = y + ( asc + ( tileSize - ( asc + des ) ) / 2 ) ; g . drawString ( s , x , y ) ; } @ Override public void paintComponent ( Graphics gg ) { super . paintComponent ( gg ) ; Graphics2D g = ( Graphics2D ) gg ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; drawGrid ( g ) ; drawStartMessage ( g ) ; } public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> { JFrame f = new JFrame ( ) ; f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; f . setTitle ( " Fifteen ▁ Puzzle " ) ; f . setResizable ( false ) ; f . add ( new FifteenPuzzle ( ) , BorderLayout . CENTER ) ; f . pack ( ) ; f . setLocationRelativeTo ( null ) ; f . setVisible ( true ) ; } ) ; } }
public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> { JFrame f = new JFrame ( ) ; f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; f . setTitle ( "2048" ) ; f . setResizable ( true ) ; f . add ( new Game2048 ( ) , BorderLayout . CENTER ) ; f . pack ( ) ; f . setLocationRelativeTo ( null ) ; f . setVisible ( true ) ; } ) ; }
public static void main ( String [ ] args ) { int [ ] digits = randomDigits ( ) ; Scanner in = new Scanner ( System . in ) ; System . out . print ( " Make ▁ 24 ▁ using ▁ these ▁ digits : ▁ " ) ; System . out . println ( Arrays . toString ( digits ) ) ; System . out . print ( " > ▁ " ) ; Stack < Float > s = new Stack < > ( ) ; long total = 0 ; for ( char c : in . nextLine ( ) . toCharArray ( ) ) { if ( '0' <= c && c <= '9' ) { int d = c - '0' ; total += ( 1 << ( d * 5 ) ) ; s . push ( ( float ) d ) ; } else if ( " + / - * " . indexOf ( c ) != - 1 ) { s . push ( applyOperator ( s . pop ( ) , s . pop ( ) , c ) ) ; } } if ( tallyDigits ( digits ) != total ) System . out . print ( " Not ▁ the ▁ same ▁ digits . ▁ " ) ; else if ( Math . abs ( 24 - s . peek ( ) ) < 0.001F ) System . out . println ( " Correct ! " ) ; else System . out . print ( " Not ▁ correct . " ) ; }
public static void main ( String [ ] args ) { new Game24Player ( ) . play ( ) ; }
static List < BigInteger > cumu ( int n ) { List < List < BigInteger > > cache = new ArrayList < > ( ) ; cache . add ( asList ( BigInteger . ONE ) ) ; for ( int L = cache . size ( ) ; L < n + 1 ; L ++ ) { List < BigInteger > r = new ArrayList < > ( ) ; r . add ( BigInteger . ZERO ) ; for ( int x = 1 ; x < L + 1 ; x ++ ) r . add ( r . get ( r . size ( ) - 1 ) . add ( cache . get ( L - x ) . get ( min ( x , L - x ) ) ) ) ; cache . add ( r ) ; } return cache . get ( n ) ; }
static List < BigInteger > row ( int n ) { List < BigInteger > r = cumu ( n ) ; return range ( 0 , n ) . mapToObj ( i -> r . get ( i + 1 ) . subtract ( r . get ( i ) ) ) . collect ( toList ( ) ) ; }
import java . text . MessageFormat ; public class Beer { static String bottles ( int n ) { return MessageFormat . format ( " { 0 , choice , 0 # No ▁ more ▁ bottles | 1 # One ▁ bottle | 2 # { 0 } ▁ bottles } ▁ of ▁ beer " , n ) ; } public static void main ( String [ ] args ) { String bottles = bottles ( 99 ) ; for ( int n = 99 ; n > 0 ; ) { System . out . println ( bottles + " ▁ on ▁ the ▁ wall " ) ; System . out . println ( bottles ) ; System . out . println ( " Take ▁ one ▁ down , ▁ pass ▁ it ▁ around " ) ; bottles = bottles ( -- n ) ; System . out . println ( bottles + " ▁ on ▁ the ▁ wall " ) ; System . out . println ( ) ; } } }
import java . util . Scanner ; public class Sum2 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; System . out . println ( in . nextInt ( ) + in . nextInt ( ) ) ; } }
public static boolean canMakeWord ( String word , List < String > blocks ) { if ( word . isEmpty ( ) ) return true ; char c = word . charAt ( 0 ) ; for ( int i = 0 ; i < blocks . size ( ) ; i ++ ) { String b = blocks . get ( i ) ; if ( b . charAt ( 0 ) != c && b . charAt ( 1 ) != c ) continue ; Collections . swap ( blocks , 0 , i ) ; if ( canMakeWord ( word . substring ( 1 ) , blocks . subList ( 1 , blocks . size ( ) ) ) ) return true ; Collections . swap ( blocks , 0 , i ) ; } return false ; }
public abstract class Abs { public abstract int method1 ( double value ) ; protected abstract int method2 ( String name ) ; int add ( int a , int b ) { return a + b ; } }
import java . io . IOException ; import org . apache . directory . api . ldap . model . exception . LdapException ; import org . apache . directory . ldap . client . api . LdapConnection ; import org . apache . directory . ldap . client . api . LdapNetworkConnection ; public class LdapConnectionDemo { public static void main ( String [ ] args ) throws LdapException , IOException { try ( LdapConnection connection = new LdapNetworkConnection ( " localhost " , 10389 ) ) { connection . bind ( ) ; connection . unBind ( ) ; } } }
import java . io . IOException ; import org . apache . directory . api . ldap . model . cursor . CursorException ; import org . apache . directory . api . ldap . model . cursor . EntryCursor ; import org . apache . directory . api . ldap . model . entry . Entry ; import org . apache . directory . api . ldap . model . exception . LdapException ; import org . apache . directory . api . ldap . model . message . SearchScope ; import org . apache . directory . ldap . client . api . LdapConnection ; import org . apache . directory . ldap . client . api . LdapNetworkConnection ; public class LdapSearchDemo { public static void main ( String [ ] args ) throws IOException , LdapException , CursorException { new LdapSearchDemo ( ) . demonstrateSearch ( ) ; } private void demonstrateSearch ( ) throws IOException , LdapException , CursorException { try ( LdapConnection conn = new LdapNetworkConnection ( " localhost " , 11389 ) ) { conn . bind ( " uid = admin , ou = system " , " * * * * * * * * " ) ; search ( conn , " * mil * " ) ; conn . unBind ( ) ; } } private void search ( LdapConnection connection , String uid ) throws LdapException , CursorException { String baseDn = " ou = users , o = mojo " ; String filter = " ( & ( objectClass = person ) ( & ( uid = " + uid + " ) ) ) " ; SearchScope scope = SearchScope . SUBTREE ; String [ ] attributes = { " dn " , " cn " , " sn " , " uid " } ; int ksearch = 0 ; EntryCursor cursor = connection . search ( baseDn , filter , scope , attributes ) ; while ( cursor . next ( ) ) { ksearch ++ ; Entry entry = cursor . get ( ) ; System . out . printf ( " Search ▁ entry ▁ % d ▁ = ▁ % s % n " , ksearch , entry ) ; } } }
public class Integrator { public interface Function { double apply ( double timeSinceStartInSeconds ) ; } private final long start ; private volatile boolean running ; private Function func ; private double t0 ; private double v0 ; private double sum ; public Integrator ( Function func ) { this . start = System . nanoTime ( ) ; setFunc ( func ) ; new Thread ( this :: integrate ) . start ( ) ; } public void setFunc ( Function func ) { this . func = func ; v0 = func . apply ( 0.0 ) ; t0 = 0 ; } public double getOutput ( ) { return sum ; } public void stop ( ) { running = false ; } private void integrate ( ) { running = true ; while ( running ) { try { Thread . sleep ( 1 ) ; update ( ) ; } catch ( InterruptedException e ) { return ; } } } private void update ( ) { double t1 = ( System . nanoTime ( ) - start ) / 1.0e9 ; double v1 = func . apply ( t1 ) ; double rect = ( t1 - t0 ) * ( v0 + v1 ) / 2 ; this . sum += rect ; t0 = t1 ; v0 = v1 ; } public static void main ( String [ ] args ) throws InterruptedException { Integrator integrator = new Integrator ( t -> Math . sin ( Math . PI * t ) ) ; Thread . sleep ( 2000 ) ; integrator . setFunc ( t -> 0.0 ) ; Thread . sleep ( 500 ) ; integrator . stop ( ) ; System . out . println ( integrator . getOutput ( ) ) ; } }
private static int [ ] prepend ( int n , int [ ] seq ) { int [ ] result = new int [ seq . length + 1 ] ; result [ 0 ] = n ; System . arraycopy ( seq , 0 , result , 1 , seq . length ) ; return result ; }
static boolean isPrime ( int n ) { int counter = 1 ; if ( n < 2 || ( n != 2 && n % 2 == 0 ) || ( n != 3 && n % 3 == 0 ) ) { return false ; } while ( counter * 6 - 1 <= Math . sqrt ( n ) ) { if ( n % ( counter * 6 - 1 ) == 0 || n % ( counter * 6 + 1 ) == 0 ) { return false ; } else { counter ++ ; } } return true ; }
static int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n /= 10 ; } return sum ; }
public static void main ( String [ ] args ) { int additive_primes = 0 ; for ( int i = 2 ; i < 500 ; i ++ ) { if ( isPrime ( i ) && isPrime ( digitSum ( i ) ) ) { additive_primes ++ ; System . out . print ( i + " ▁ " ) ; } } System . out . print ( " \n Found ▁ " + additive_primes + " ▁ additive ▁ primes ▁ less ▁ than ▁ 500" ) ; }
julia > x = [ 1 , 2 , 3 ] julia > ptr = pointer_from_objref ( x ) Ptr { Void } @ 0x000000010282e4a0 julia > unsafe_pointer_to_objref ( ptr ) 3 - element Array { Int64 , 1 } : 1 2 3
private static double rho ( double a ) { return Math . exp ( - a / 8500.0 ) ; }
private static double height ( double a , double z , double d ) { double aa = RE + a ; double hh = Math . sqrt ( aa * aa + d * d - 2.0 * d * aa * Math . cos ( Math . toRadians ( 180 - z ) ) ) ; return hh - RE ; }
private static double columnDensity ( double a , double z ) { double sum = 0.0 , d = 0.0 ; while ( d < FIN ) { double delta = Math . max ( DD * d , DD ) ; sum += rho ( height ( a , z , d + 0.5 * delta ) ) * delta ; d += delta ; } return sum ; }
private static double airmass ( double a , double z ) { return columnDensity ( a , z ) / columnDensity ( a , 0.0 ) ; }
static boolean aliquot ( long n , int maxLen , long maxTerm ) { List < Long > s = new ArrayList < > ( maxLen ) ; s . add ( n ) ; long newN = n ; while ( s . size ( ) <= maxLen && newN < maxTerm ) { newN = properDivsSum ( s . get ( s . size ( ) - 1 ) ) ; if ( s . contains ( newN ) ) { if ( s . get ( 0 ) == newN ) { switch ( s . size ( ) ) { case 1 : return report ( " Perfect " , s ) ; case 2 : return report ( " Amicable " , s ) ; default : return report ( " Sociable ▁ of ▁ length ▁ " + s . size ( ) , s ) ; } } else if ( s . get ( s . size ( ) - 1 ) == newN ) { return report ( " Aspiring " , s ) ; } else return report ( " Cyclic ▁ back ▁ to ▁ " + newN , s ) ; } else { s . add ( newN ) ; if ( newN == 0 ) return report ( " Terminating " , s ) ; } } return report ( " Non - terminating " , s ) ; }
import java . io . * ; import java . util . * ; public class AlternadeWords { public static void main ( String [ ] args ) { try { Set < String > dictionary = new TreeSet < > ( ) ; try ( BufferedReader reader = new BufferedReader ( new FileReader ( " unixdict . txt " ) ) ) { String line ; while ( ( line = reader . readLine ( ) ) != null ) dictionary . add ( line ) ; } StringBuilder word1 = new StringBuilder ( ) ; StringBuilder word2 = new StringBuilder ( ) ; for ( String word : dictionary ) { int length = word . length ( ) ; if ( length < 6 ) continue ; word1 . setLength ( 0 ) ; word2 . setLength ( 0 ) ; for ( int i = 0 ; i < length ; i += 2 ) { word1 . append ( word . charAt ( i ) ) ; if ( i + 1 < length ) word2 . append ( word . charAt ( i + 1 ) ) ; } String w1 = word1 . toString ( ) ; String w2 = word2 . toString ( ) ; if ( dictionary . contains ( w1 ) && dictionary . contains ( w2 ) ) System . out . printf ( " % -10s % -6s % s \n " , word , w1 , w2 ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
private static boolean isDeranged ( String word1 , String word2 ) { for ( int i = 0 ; i < word1 . length ( ) ; i ++ ) { if ( word1 . charAt ( i ) == word2 . charAt ( i ) ) { return false ; } } return true ; }
import java . awt . event . MouseAdapter ; import java . awt . event . MouseEvent ; import java . awt . event . WindowAdapter ; import java . awt . event . WindowEvent ; import java . util . Timer ; import java . util . TimerTask ; import javax . swing . JFrame ; import javax . swing . JLabel ; import javax . swing . WindowConstants ; public class Rotate { private static class State { private final String text = " Hello ▁ World ! ▁ " ; private int startIndex = 0 ; private boolean rotateRight = true ; } public static void main ( String [ ] args ) { State state = new State ( ) ; JLabel label = new JLabel ( state . text ) ; label . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( MouseEvent event ) { state . rotateRight = ! state . rotateRight ; } } ) ; TimerTask task = new TimerTask ( ) { public void run ( ) { int delta = state . rotateRight ? 1 : - 1 ; state . startIndex = ( state . startIndex + state . text . length ( ) + delta ) % state . text . length ( ) ; label . setText ( rotate ( state . text , state . startIndex ) ) ; } } ; Timer timer = new Timer ( false ) ; timer . schedule ( task , 0 , 500 ) ; JFrame rot = new JFrame ( ) ; rot . setDefaultCloseOperation ( WindowConstants . DISPOSE_ON_CLOSE ) ; rot . add ( label ) ; rot . pack ( ) ; rot . setLocationRelativeTo ( null ) ; rot . addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosed ( WindowEvent e ) { timer . cancel ( ) ; } } ) ; rot . setVisible ( true ) ; } private static String rotate ( String text , int startIdx ) { char [ ] rotated = new char [ text . length ( ) ] ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { rotated [ i ] = text . charAt ( ( i + startIdx ) % text . length ( ) ) ; } return String . valueOf ( rotated ) ; } }
public class DigitalFilter { private static double [ ] filter ( double [ ] a , double [ ] b , double [ ] signal ) { double [ ] result = new double [ signal . length ] ; for ( int i = 0 ; i < signal . length ; ++ i ) { double tmp = 0.0 ; for ( int j = 0 ; j < b . length ; ++ j ) { if ( i - j < 0 ) continue ; tmp += b [ j ] * signal [ i - j ] ; } for ( int j = 1 ; j < a . length ; ++ j ) { if ( i - j < 0 ) continue ; tmp -= a [ j ] * result [ i - j ] ; } tmp /= a [ 0 ] ; result [ i ] = tmp ; } return result ; } public static void main ( String [ ] args ) { double [ ] a = new double [ ] { 1.00000000 , - 2.77555756e-16 , 3.33333333e-01 , - 1.85037171e-17 } ; double [ ] b = new double [ ] { 0.16666667 , 0.5 , 0.5 , 0.16666667 } ; double [ ] signal = new double [ ] { - 0.917843918645 , 0.141984778794 , 1.20536903482 , 0.190286794412 , - 0.662370894973 , - 1.00700480494 , - 0.404707073677 , 0.800482325044 , 0.743500089861 , 1.01090520172 , 0.741527555207 , 0.277841675195 , 0.400833448236 , - 0.2085993586 , - 0.172842103641 , - 0.134316096293 , 0.0259303398477 , 0.490105989562 , 0.549391221511 , 0.9047198589 } ; double [ ] result = filter ( a , b , signal ) ; for ( int i = 0 ; i < result . length ; ++ i ) { System . out . printf ( " % ▁ . 8f " , result [ i ] ) ; System . out . print ( ( i + 1 ) % 5 != 0 ? " , ▁ " : " \n " ) ; } } }
public class Approximate { private static boolean approxEquals ( double value , double other , double epsilon ) { return Math . abs ( value - other ) < epsilon ; } private static void test ( double a , double b ) { double epsilon = 1e-18 ; System . out . printf ( " % f , ▁ % f ▁ = > ▁ % s \n " , a , b , approxEquals ( a , b , epsilon ) ) ; } public static void main ( String [ ] args ) { test ( 100000000000000.01 , 100000000000000.011 ) ; test ( 100.01 , 100.011 ) ; test ( 10000000000000.001 / 10000.0 , 1000000000.0000001000 ) ; test ( 0.001 , 0.0010000001 ) ; test ( 0.000000000000000000000101 , 0.0 ) ; test ( Math . sqrt ( 2.0 ) * Math . sqrt ( 2.0 ) , 2.0 ) ; test ( - Math . sqrt ( 2.0 ) * Math . sqrt ( 2.0 ) , - 2.0 ) ; test ( 3.14159265358979323846 , 3.14159265358979324 ) ; } }
import java . awt . * ; import static java . lang . Math . * ; import javax . swing . * ; public class ArchimedeanSpiral extends JPanel { public ArchimedeanSpiral ( ) { setPreferredSize ( new Dimension ( 640 , 640 ) ) ; setBackground ( Color . white ) ; } void drawGrid ( Graphics2D g ) { g . setColor ( new Color ( 0xEEEEEE ) ) ; g . setStroke ( new BasicStroke ( 2 ) ) ; double angle = toRadians ( 45 ) ; int w = getWidth ( ) ; int center = w / 2 ; int margin = 10 ; int numRings = 8 ; int spacing = ( w - 2 * margin ) / ( numRings * 2 ) ; for ( int i = 0 ; i < numRings ; i ++ ) { int pos = margin + i * spacing ; int size = w - ( 2 * margin + i * 2 * spacing ) ; g . drawOval ( pos , pos , size , size ) ; double ia = i * angle ; int x2 = center + ( int ) ( cos ( ia ) * ( w - 2 * margin ) / 2 ) ; int y2 = center - ( int ) ( sin ( ia ) * ( w - 2 * margin ) / 2 ) ; g . drawLine ( center , center , x2 , y2 ) ; } } void drawSpiral ( Graphics2D g ) { g . setStroke ( new BasicStroke ( 2 ) ) ; g . setColor ( Color . orange ) ; double degrees = toRadians ( 0.1 ) ; double center = getWidth ( ) / 2 ; double end = 360 * 2 * 10 * degrees ; double a = 0 ; double b = 20 ; double c = 1 ; for ( double theta = 0 ; theta < end ; theta += degrees ) { double r = a + b * pow ( theta , 1 / c ) ; double x = r * cos ( theta ) ; double y = r * sin ( theta ) ; plot ( g , ( int ) ( center + x ) , ( int ) ( center - y ) ) ; } } void plot ( Graphics2D g , int x , int y ) { g . drawOval ( x , y , 1 , 1 ) ; } @ Override public void paintComponent ( Graphics gg ) { super . paintComponent ( gg ) ; Graphics2D g = ( Graphics2D ) gg ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; drawGrid ( g ) ; drawSpiral ( g ) ; } public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> { JFrame f = new JFrame ( ) ; f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; f . setTitle ( " Archimedean ▁ Spiral " ) ; f . setResizable ( false ) ; f . add ( new ArchimedeanSpiral ( ) , BorderLayout . CENTER ) ; f . pack ( ) ; f . setLocationRelativeTo ( null ) ; f . setVisible ( true ) ; } ) ; } }
private static Freq cumulativeFreq ( Freq freq ) { long total = 0 ; Freq cf = new Freq ( ) ; for ( int i = 0 ; i < 256 ; ++ i ) { char c = ( char ) i ; Long v = freq . get ( c ) ; if ( v != null ) { cf . put ( c , total ) ; total += v ; } } return cf ; }
import java . util . Stack ; public class ArithmeticEvaluation { public interface Expression { BigRational eval ( ) ; } public enum Parentheses { LEFT } public enum BinaryOperator { ADD ( ' + ' , 1 ) , SUB ( ' - ' , 1 ) , MUL ( ' * ' , 2 ) , DIV ( ' / ' , 2 ) ; public final char symbol ; public final int precedence ; BinaryOperator ( char symbol , int precedence ) { this . symbol = symbol ; this . precedence = precedence ; } public BigRational eval ( BigRational leftValue , BigRational rightValue ) { switch ( this ) { case ADD : return leftValue . add ( rightValue ) ; case SUB : return leftValue . subtract ( rightValue ) ; case MUL : return leftValue . multiply ( rightValue ) ; case DIV : return leftValue . divide ( rightValue ) ; } throw new IllegalStateException ( ) ; } public static BinaryOperator forSymbol ( char symbol ) { for ( BinaryOperator operator : values ( ) ) { if ( operator . symbol == symbol ) { return operator ; } } throw new IllegalArgumentException ( String . valueOf ( symbol ) ) ; } } public static class Number implements Expression { private final BigRational number ; public Number ( BigRational number ) { this . number = number ; } @ Override public BigRational eval ( ) { return number ; } @ Override public String toString ( ) { return number . toString ( ) ; } } public static class BinaryExpression implements Expression { public final Expression leftOperand ; public final BinaryOperator operator ; public final Expression rightOperand ; public BinaryExpression ( Expression leftOperand , BinaryOperator operator , Expression rightOperand ) { this . leftOperand = leftOperand ; this . operator = operator ; this . rightOperand = rightOperand ; } @ Override public BigRational eval ( ) { BigRational leftValue = leftOperand . eval ( ) ; BigRational rightValue = rightOperand . eval ( ) ; return operator . eval ( leftValue , rightValue ) ; } @ Override public String toString ( ) { return " ( " + leftOperand + " ▁ " + operator . symbol + " ▁ " + rightOperand + " ) " ; } } private static void createNewOperand ( BinaryOperator operator , Stack < Expression > operands ) { Expression rightOperand = operands . pop ( ) ; Expression leftOperand = operands . pop ( ) ; operands . push ( new BinaryExpression ( leftOperand , operator , rightOperand ) ) ; } public static Expression parse ( String input ) { int curIndex = 0 ; boolean afterOperand = false ; Stack < Expression > operands = new Stack < > ( ) ; Stack < Object > operators = new Stack < > ( ) ; while ( curIndex < input . length ( ) ) { int startIndex = curIndex ; char c = input . charAt ( curIndex ++ ) ; if ( Character . isWhitespace ( c ) ) continue ; if ( afterOperand ) { if ( c == ' ) ' ) { Object operator ; while ( ! operators . isEmpty ( ) && ( ( operator = operators . pop ( ) ) != Parentheses . LEFT ) ) createNewOperand ( ( BinaryOperator ) operator , operands ) ; continue ; } afterOperand = false ; BinaryOperator operator = BinaryOperator . forSymbol ( c ) ; while ( ! operators . isEmpty ( ) && ( operators . peek ( ) != Parentheses . LEFT ) && ( ( ( BinaryOperator ) operators . peek ( ) ) . precedence >= operator . precedence ) ) createNewOperand ( ( BinaryOperator ) operators . pop ( ) , operands ) ; operators . push ( operator ) ; continue ; } if ( c == ' ( ' ) { operators . push ( Parentheses . LEFT ) ; continue ; } afterOperand = true ; while ( curIndex < input . length ( ) ) { c = input . charAt ( curIndex ) ; if ( ( ( c < '0' ) || ( c > '9' ) ) && ( c != ' . ' ) ) break ; curIndex ++ ; } operands . push ( new Number ( BigRational . valueOf ( input . substring ( startIndex , curIndex ) ) ) ) ; } while ( ! operators . isEmpty ( ) ) { Object operator = operators . pop ( ) ; if ( operator == Parentheses . LEFT ) throw new IllegalArgumentException ( ) ; createNewOperand ( ( BinaryOperator ) operator , operands ) ; } Expression expression = operands . pop ( ) ; if ( ! operands . isEmpty ( ) ) throw new IllegalArgumentException ( ) ; return expression ; } public static void main ( String [ ] args ) { String [ ] testExpressions = { "2 + 3" , "2 + 3/4" , "2*3-4" , "2 * ( 3 + 4 ) + 5/6" , "2 ▁ * ▁ ( 3 ▁ + ▁ ( 4 ▁ * ▁ 5 ▁ + ▁ ( 6 ▁ * ▁ 7 ) ▁ * ▁ 8 ) ▁ - ▁ 9 ) ▁ * ▁ 10" , "2 * - 3 - - 4 + - .25" } ; for ( String testExpression : testExpressions ) { Expression expression = parse ( testExpression ) ; System . out . printf ( " Input : ▁ \" % s \" , ▁ AST : ▁ \" % s \" , ▁ value = % s % n " , testExpression , expression , expression . eval ( ) ) ; } } }
public static double agm ( double a , double g ) { double a1 = a ; double g1 = g ; while ( Math . abs ( a1 - g1 ) >= 1.0e-14 ) { double arith = ( a1 + g1 ) / 2.0 ; double geom = Math . sqrt ( a1 * g1 ) ; a1 = arith ; g1 = geom ; } return a1 ; }
import java . math . BigDecimal ; import java . math . MathContext ; import java . util . Objects ; public class Calculate_Pi { private static final MathContext con1024 = new MathContext ( 1024 ) ; private static final BigDecimal bigTwo = new BigDecimal ( 2 ) ; private static final BigDecimal bigFour = new BigDecimal ( 4 ) ; private static BigDecimal bigSqrt ( BigDecimal bd , MathContext con ) { BigDecimal x0 = BigDecimal . ZERO ; BigDecimal x1 = BigDecimal . valueOf ( Math . sqrt ( bd . doubleValue ( ) ) ) ; while ( ! Objects . equals ( x0 , x1 ) ) { x0 = x1 ; x1 = bd . divide ( x0 , con ) . add ( x0 ) . divide ( bigTwo , con ) ; } return x1 ; } public static void main ( String [ ] args ) { BigDecimal a = BigDecimal . ONE ; BigDecimal g = a . divide ( bigSqrt ( bigTwo , con1024 ) , con1024 ) ; BigDecimal t ; BigDecimal sum = BigDecimal . ZERO ; BigDecimal pow = bigTwo ; while ( ! Objects . equals ( a , g ) ) { t = a . add ( g ) . divide ( bigTwo , con1024 ) ; g = bigSqrt ( a . multiply ( g ) , con1024 ) ; a = t ; pow = pow . multiply ( bigTwo ) ; sum = sum . add ( a . multiply ( a ) . subtract ( g . multiply ( g ) ) . multiply ( pow ) ) ; } BigDecimal pi = bigFour . multiply ( a . multiply ( a ) ) . divide ( BigDecimal . ONE . subtract ( sum ) , con1024 ) ; System . out . println ( pi ) ; } }
import java . util . Scanner ; public class IntegerArithmetic { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int sum = a + b ; int difference = a - b ; int product = a * b ; int division = a / b ; int remainder = a % b ; System . out . println ( " a ▁ + ▁ b ▁ = ▁ " + sum ) ; System . out . println ( " a ▁ - ▁ b ▁ = ▁ " + difference ) ; System . out . println ( " a ▁ * ▁ b ▁ = ▁ " + product ) ; System . out . println ( " quotient ▁ of ▁ a ▁ / ▁ b ▁ = ▁ " + division ) ; System . out . println ( " remainder ▁ of ▁ a ▁ / ▁ b ▁ = ▁ " + remainder ) ; } }
public class BigRationalFindPerfectNumbers { public static void main ( String [ ] args ) { int MAX_NUM = 1 << 19 ; System . out . println ( " Searching ▁ for ▁ perfect ▁ numbers ▁ in ▁ the ▁ range ▁ [ 1 , ▁ " + ( MAX_NUM - 1 ) + " ] " ) ; BigRational TWO = BigRational . valueOf ( 2 ) ; for ( int i = 1 ; i < MAX_NUM ; i ++ ) { BigRational reciprocalSum = BigRational . ONE ; if ( i > 1 ) reciprocalSum = reciprocalSum . add ( BigRational . valueOf ( i ) . reciprocal ( ) ) ; int maxDivisor = ( int ) Math . sqrt ( i ) ; if ( maxDivisor >= i ) maxDivisor -- ; for ( int divisor = 2 ; divisor <= maxDivisor ; divisor ++ ) { if ( i % divisor == 0 ) { reciprocalSum = reciprocalSum . add ( BigRational . valueOf ( divisor ) . reciprocal ( ) ) ; int dividend = i / divisor ; if ( divisor != dividend ) reciprocalSum = reciprocalSum . add ( BigRational . valueOf ( dividend ) . reciprocal ( ) ) ; } } if ( reciprocalSum . equals ( TWO ) ) System . out . println ( String . valueOf ( i ) + " ▁ is ▁ a ▁ perfect ▁ number " ) ; } } }
public static Object [ ] concat ( Object [ ] arr1 , Object [ ] arr2 ) { Object [ ] res = new Object [ arr1 . length + arr2 . length ] ; System . arraycopy ( arr1 , 0 , res , 0 , arr1 . length ) ; System . arraycopy ( arr2 , 0 , res , arr1 . length , arr2 . length ) ; return res ; }
int [ ] array = new int [ 10 ] ; array [ 0 ] = 42 ; System . out . println ( array [ 3 ] ) ;
module Adder exports add2 function add2 ( x ) return x + 2 end end module LogAspectAdder exports add2 using Adder const logio = [ stdout ] function log ( s , io = logio [ 1 ] ) println ( io , now ( ) , " ▁ " , s ) end function add2 ( x ) log ( " added ▁ 2 ▁ to ▁ $ x " ) Adder . add2 ( x ) end end
public class Assertions { public static void main ( String [ ] args ) { int a = 13 ; assert a == 42 ; assert a == 42 : " Error ▁ message " ; } }
Map < String , Integer > map = new HashMap < String , Integer > ( ) ; map . put ( " foo " , 5 ) ; map . put ( " bar " , 10 ) ; map . put ( " baz " , 15 ) ; map . put ( " foo " , 6 ) ;
Map < String , Integer > map = new HashMap < String , Integer > ( ) ; map . put ( " hello " , 1 ) ; map . put ( " world " , 2 ) ; map . put ( " ! " , 3 ) ; for ( Map . Entry < String , Integer > e : map . entrySet ( ) ) { String key = e . getKey ( ) ; Integer value = e . getValue ( ) ; System . out . println ( " key ▁ = ▁ " + key + " , ▁ value ▁ = ▁ " + value ) ; } for ( String key : map . keySet ( ) ) { System . out . println ( " key ▁ = ▁ " + key ) ; } for ( Integer value : map . values ( ) ) { System . out . println ( " value ▁ = ▁ " + value ) ; }
import java . util . * ; class MergeMaps { public static void main ( String [ ] args ) { Map < String , Object > base = new HashMap < > ( ) ; base . put ( " name " , " Rocket ▁ Skates " ) ; base . put ( " price " , 12.75 ) ; base . put ( " color " , " yellow " ) ; Map < String , Object > update = new HashMap < > ( ) ; update . put ( " price " , 15.25 ) ; update . put ( " color " , " red " ) ; update . put ( " year " , 1974 ) ; Map < String , Object > result = new HashMap < > ( base ) ; result . putAll ( update ) ; System . out . println ( result ) ; } }
private static void equalize ( Buckets buckets ) { ThreadLocalRandom rnd = ThreadLocalRandom . current ( ) ; while ( true ) { int srcIndex = rnd . nextInt ( NUM_BUCKETS ) ; int dstIndex = rnd . nextInt ( NUM_BUCKETS ) ; int amount = ( buckets . getBucket ( srcIndex ) - buckets . getBucket ( dstIndex ) ) / 2 ; if ( amount >= 0 ) buckets . transfer ( srcIndex , dstIndex , amount ) ; } }
import com . sun . javafx . application . PlatformImpl ; import java . io . File ; import java . util . Scanner ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import javafx . scene . media . Media ; import javafx . scene . media . MediaPlayer ; public class AudioAlarm { public static void main ( String [ ] args ) throws InterruptedException { Scanner input = new Scanner ( System . in ) ; System . out . print ( " Enter ▁ a ▁ number ▁ of ▁ seconds : ▁ " ) ; int seconds = Integer . parseInt ( input . nextLine ( ) ) ; System . out . print ( " Enter ▁ a ▁ filename ▁ ( must ▁ end ▁ with ▁ . mp3 ▁ or ▁ . wav ) : ▁ " ) ; String audio = input . nextLine ( ) ; TimeUnit . SECONDS . sleep ( seconds ) ; Media media = new Media ( new File ( audio ) . toURI ( ) . toString ( ) ) ; AtomicBoolean stop = new AtomicBoolean ( ) ; Runnable onEnd = ( ) -> stop . set ( true ) ; PlatformImpl . startup ( ( ) -> { } ) ; MediaPlayer player = new MediaPlayer ( media ) ; player . setOnEndOfMedia ( onEnd ) ; player . setOnError ( onEnd ) ; player . setOnHalted ( onEnd ) ; player . play ( ) ; while ( ! stop . get ( ) ) { Thread . sleep ( 100 ) ; } System . exit ( 0 ) ; } }
private static double analytical ( int n ) { double [ ] factorial = new double [ n + 1 ] ; double [ ] powers = new double [ n + 1 ] ; powers [ 0 ] = 1.0 ; factorial [ 0 ] = 1.0 ; for ( int i = 1 ; i <= n ; i ++ ) { factorial [ i ] = factorial [ i - 1 ] * i ; powers [ i ] = powers [ i - 1 ] * n ; } double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += factorial [ n ] / factorial [ n - i ] / powers [ i ] ; } return sum ; }
static double meanAngle ( double [ ] angles ) { int len = angles . length ; double sinSum = 0.0 ; for ( int i = 0 ; i < len ; i ++ ) { sinSum += Math . sin ( angles [ i ] * Math . PI / 180.0 ) ; } double cosSum = 0.0 ; for ( int i = 0 ; i < len ; i ++ ) { cosSum += Math . cos ( angles [ i ] * Math . PI / 180.0 ) ; } return Math . atan2 ( sinSum / len , cosSum / len ) * 180.0 / Math . PI ; }
import java . awt . * ; import java . awt . image . BufferedImage ; import javax . swing . * ; public class BarnsleyFern extends JPanel { BufferedImage img ; public BarnsleyFern ( ) { final int dim = 640 ; setPreferredSize ( new Dimension ( dim , dim ) ) ; setBackground ( Color . white ) ; img = new BufferedImage ( dim , dim , BufferedImage . TYPE_INT_ARGB ) ; createFern ( dim , dim ) ; } void createFern ( int w , int h ) { double x = 0 ; double y = 0 ; for ( int i = 0 ; i < 200_000 ; i ++ ) { double tmpx , tmpy ; double r = Math . random ( ) ; if ( r <= 0.01 ) { tmpx = 0 ; tmpy = 0.16 * y ; } else if ( r <= 0.08 ) { tmpx = 0.2 * x - 0.26 * y ; tmpy = 0.23 * x + 0.22 * y + 1.6 ; } else if ( r <= 0.15 ) { tmpx = - 0.15 * x + 0.28 * y ; tmpy = 0.26 * x + 0.24 * y + 0.44 ; } else { tmpx = 0.85 * x + 0.04 * y ; tmpy = - 0.04 * x + 0.85 * y + 1.6 ; } x = tmpx ; y = tmpy ; img . setRGB ( ( int ) Math . round ( w / 2 + x * w / 11 ) , ( int ) Math . round ( h - y * h / 11 ) , 0xFF32CD32 ) ; } } @ Override public void paintComponent ( Graphics gg ) { super . paintComponent ( gg ) ; Graphics2D g = ( Graphics2D ) gg ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . drawImage ( img , 0 , 0 , null ) ; } public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> { JFrame f = new JFrame ( ) ; f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; f . setTitle ( " Barnsley ▁ Fern " ) ; f . setResizable ( false ) ; f . add ( new BarnsleyFern ( ) , BorderLayout . CENTER ) ; f . pack ( ) ; f . setLocationRelativeTo ( null ) ; f . setVisible ( true ) ; } ) ; } }
import java . nio . charset . StandardCharsets ; import java . util . Base64 ; public class Decode { public static void main ( String [ ] args ) { String data = " VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g = " ; Base64 . Decoder decoder = Base64 . getDecoder ( ) ; byte [ ] decoded = decoder . decode ( data ) ; String decodedStr = new String ( decoded , StandardCharsets . UTF_8 ) ; System . out . println ( decodedStr ) ; } }
import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; import java . net . URLConnection ; import java . util . Arrays ; public class Base64 { private static final char [ ] alpha = " ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 + / " . toCharArray ( ) ; static String base64 ( InputStream is ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; int blocks = 0 ; while ( true ) { int c0 = is . read ( ) ; if ( c0 == - 1 ) break ; int c1 = is . read ( ) ; int c2 = is . read ( ) ; int block = ( ( c0 & 0xFF ) << 16 ) | ( ( Math . max ( c1 , 0 ) & 0xFF ) << 8 ) | ( Math . max ( c2 , 0 ) & 0xFF ) ; sb . append ( alpha [ block >> 18 & 63 ] ) ; sb . append ( alpha [ block >> 12 & 63 ] ) ; sb . append ( c1 == - 1 ? ' = ' : alpha [ block >> 6 & 63 ] ) ; sb . append ( c2 == - 1 ? ' = ' : alpha [ block & 63 ] ) ; if ( ++ blocks == 19 ) { blocks = 0 ; sb . append ( ' \n ' ) ; } } if ( blocks > 0 ) sb . append ( ' \n ' ) ; return sb . toString ( ) ; } private static void assertBase64 ( String expected , byte [ ] bytes ) throws IOException { String actual = base64 ( new ByteArrayInputStream ( bytes ) ) ; if ( ! actual . equals ( expected ) ) { throw new IllegalStateException ( String . format ( " Expected ▁ % s ▁ for ▁ % s , ▁ but ▁ got ▁ % s . " , expected , Arrays . toString ( bytes ) , actual ) ) ; } } private static void testBase64 ( ) throws IOException { assertBase64 ( " " , new byte [ ] { } ) ; assertBase64 ( " AA = = \n " , new byte [ ] { 0 } ) ; assertBase64 ( " AAA = \n " , new byte [ ] { 0 , 0 } ) ; assertBase64 ( " AAAA \n " , new byte [ ] { 0 , 0 , 0 } ) ; assertBase64 ( " AAAAAA = = \n " , new byte [ ] { 0 , 0 , 0 , 0 } ) ; assertBase64 ( " / w = = \n " , new byte [ ] { - 1 } ) ; assertBase64 ( " // 8 = \n " , new byte [ ] { - 1 , - 1 } ) ; assertBase64 ( " // // \n " , new byte [ ] { - 1 , - 1 , - 1 } ) ; assertBase64 ( " // // / w = = \n " , new byte [ ] { - 1 , - 1 , - 1 , - 1 } ) ; } public static void main ( String [ ] args ) throws IOException { testBase64 ( ) ; URLConnection conn = new URL ( " http : // rosettacode . org / favicon . ico " ) . openConnection ( ) ; conn . addRequestProperty ( " User - Agent " , " Mozilla " ) ; try ( InputStream is = conn . getInputStream ( ) ) { System . out . println ( base64 ( is ) ) ; } } }
import java . util . ArrayList ; import java . util . List ; public class Bell { private static class BellTriangle { private List < Integer > arr ; BellTriangle ( int n ) { int length = n * ( n + 1 ) / 2 ; arr = new ArrayList < > ( length ) ; for ( int i = 0 ; i < length ; ++ i ) { arr . add ( 0 ) ; } set ( 1 , 0 , 1 ) ; for ( int i = 2 ; i <= n ; ++ i ) { set ( i , 0 , get ( i - 1 , i - 2 ) ) ; for ( int j = 1 ; j < i ; ++ j ) { int value = get ( i , j - 1 ) + get ( i - 1 , j - 1 ) ; set ( i , j , value ) ; } } } private int index ( int row , int col ) { if ( row > 0 && col >= 0 && col < row ) { return row * ( row - 1 ) / 2 + col ; } else { throw new IllegalArgumentException ( ) ; } } public int get ( int row , int col ) { int i = index ( row , col ) ; return arr . get ( i ) ; } public void set ( int row , int col , int value ) { int i = index ( row , col ) ; arr . set ( i , value ) ; } } public static void main ( String [ ] args ) { final int rows = 15 ; BellTriangle bt = new BellTriangle ( rows ) ; System . out . println ( " First ▁ fifteen ▁ Bell ▁ numbers : " ) ; for ( int i = 0 ; i < rows ; ++ i ) { System . out . printf ( " % 2d : ▁ % d \n " , i + 1 , bt . get ( i + 1 , 0 ) ) ; } for ( int i = 1 ; i <= 10 ; ++ i ) { System . out . print ( bt . get ( i , 0 ) ) ; for ( int j = 1 ; j < i ; ++ j ) { System . out . printf ( " , ▁ % d " , bt . get ( i , j ) ) ; } System . out . println ( ) ; } } }
private static int count ( final String s1 , final char [ ] s2 ) { int count = 0 ; for ( int i = 0 ; i < s2 . length ; i ++ ) if ( s1 . charAt ( i ) == s2 [ i ] ) count ++ ; return count ; }
public static String bestShuffle ( final String s1 ) { char [ ] s2 = s1 . toCharArray ( ) ; shuffle ( s2 ) ; for ( int i = 0 ; i < s2 . length ; i ++ ) { if ( s2 [ i ] != s1 . charAt ( i ) ) continue ; for ( int j = 0 ; j < s2 . length ; j ++ ) { if ( s2 [ i ] != s2 [ j ] && s2 [ i ] != s1 . charAt ( j ) && s2 [ j ] != s1 . charAt ( i ) ) { char tmp = s2 [ i ] ; s2 [ i ] = s2 [ j ] ; s2 [ j ] = tmp ; break ; } } } return s1 + " ▁ " + new String ( s2 ) + " ▁ ( " + count ( s1 , s2 ) + " ) " ; }
public static int binarySearch ( int [ ] nums , int check ) { int hi = nums . length - 1 ; int lo = 0 ; while ( hi >= lo ) { int guess = ( lo + hi ) >>> 1 ; if ( nums [ guess ] > check ) { hi = guess - 1 ; } else if ( nums [ guess ] < check ) { lo = guess + 1 ; } else { return guess ; } } return - 1 ; }
static double equalBirthdays ( int nSharers , int groupSize , int nRepetitions ) { Random rand = new Random ( 1 ) ; int eq = 0 ; for ( int i = 0 ; i < nRepetitions ; i ++ ) { int [ ] group = new int [ 365 ] ; for ( int j = 0 ; j < groupSize ; j ++ ) group [ rand . nextInt ( group . length ) ] ++ ; eq += stream ( group ) . anyMatch ( c -> c >= nSharers ) ? 1 : 0 ; } return ( eq * 100.0 ) / nRepetitions ; }
import java . awt . Color ; import java . awt . Graphics ; import java . awt . Image ; import java . awt . image . BufferedImage ; public class BasicBitmapStorage { private final BufferedImage image ; public BasicBitmapStorage ( int width , int height ) { image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; } public void fill ( Color c ) { Graphics g = image . getGraphics ( ) ; g . setColor ( c ) ; g . fillRect ( 0 , 0 , image . getWidth ( ) , image . getHeight ( ) ) ; } public void setPixel ( int x , int y , Color c ) { image . setRGB ( x , y , c . getRGB ( ) ) ; } public Color getPixel ( int x , int y ) { return new Color ( image . getRGB ( x , y ) ) ; } public Image getImage ( ) { return image ; } }
import java . awt . Color ; import java . awt . Dimension ; import java . awt . Graphics ; import javax . swing . JFrame ; import javax . swing . JPanel ; import javax . swing . SwingUtilities ; import javax . swing . WindowConstants ; public class Bresenham { public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( Bresenham :: run ) ; } private static void run ( ) { JFrame f = new JFrame ( ) ; f . setDefaultCloseOperation ( WindowConstants . DISPOSE_ON_CLOSE ) ; f . setTitle ( " Bresenham " ) ; f . getContentPane ( ) . add ( new BresenhamPanel ( ) ) ; f . pack ( ) ; f . setLocationRelativeTo ( null ) ; f . setVisible ( true ) ; } } class BresenhamPanel extends JPanel { private final int pixelSize = 10 ; BresenhamPanel ( ) { setPreferredSize ( new Dimension ( 600 , 500 ) ) ; setBackground ( Color . WHITE ) ; } @ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; int w = ( getWidth ( ) - 1 ) / pixelSize ; int h = ( getHeight ( ) - 1 ) / pixelSize ; int maxX = ( w - 1 ) / 2 ; int maxY = ( h - 1 ) / 2 ; int x1 = - maxX , x2 = maxX * - 2 / 3 , x3 = maxX * 2 / 3 , x4 = maxX ; int y1 = - maxY , y2 = maxY * - 2 / 3 , y3 = maxY * 2 / 3 , y4 = maxY ; drawLine ( g , 0 , 0 , x3 , y1 ) ; drawLine ( g , 0 , 0 , x4 , y2 ) ; drawLine ( g , 0 , 0 , x4 , y3 ) ; drawLine ( g , 0 , 0 , x3 , y4 ) ; drawLine ( g , 0 , 0 , x2 , y4 ) ; drawLine ( g , 0 , 0 , x1 , y3 ) ; drawLine ( g , 0 , 0 , x1 , y2 ) ; drawLine ( g , 0 , 0 , x2 , y1 ) ; } private void plot ( Graphics g , int x , int y ) { int w = ( getWidth ( ) - 1 ) / pixelSize ; int h = ( getHeight ( ) - 1 ) / pixelSize ; int maxX = ( w - 1 ) / 2 ; int maxY = ( h - 1 ) / 2 ; int borderX = getWidth ( ) - ( ( 2 * maxX + 1 ) * pixelSize + 1 ) ; int borderY = getHeight ( ) - ( ( 2 * maxY + 1 ) * pixelSize + 1 ) ; int left = ( x + maxX ) * pixelSize + borderX / 2 ; int top = ( y + maxY ) * pixelSize + borderY / 2 ; g . setColor ( Color . black ) ; g . drawOval ( left , top , pixelSize , pixelSize ) ; } private void drawLine ( Graphics g , int x1 , int y1 , int x2 , int y2 ) { int d = 0 ; int dx = Math . abs ( x2 - x1 ) ; int dy = Math . abs ( y2 - y1 ) ; int dx2 = 2 * dx ; int dy2 = 2 * dy ; int ix = x1 < x2 ? 1 : - 1 ; int iy = y1 < y2 ? 1 : - 1 ; int x = x1 ; int y = y1 ; if ( dx >= dy ) { while ( true ) { plot ( g , x , y ) ; if ( x == x2 ) break ; x += ix ; d += dy2 ; if ( d > dx ) { y += iy ; d -= dx2 ; } } } else { while ( true ) { plot ( g , x , y ) ; if ( y == y2 ) break ; y += iy ; d += dx2 ; if ( d > dy ) { x += ix ; d -= dy2 ; } } } } }
import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import javax . imageio . ImageIO ; public enum ImageProcessing { ; public static void main ( String [ ] args ) throws IOException { BufferedImage img = ImageIO . read ( new File ( " example . png " ) ) ; BufferedImage bwimg = toBlackAndWhite ( img ) ; ImageIO . write ( bwimg , " png " , new File ( " example - bw . png " ) ) ; } private static int luminance ( int rgb ) { int r = ( rgb >> 16 ) & 0xFF ; int g = ( rgb >> 8 ) & 0xFF ; int b = rgb & 0xFF ; return ( r + b + g ) / 3 ; } private static BufferedImage toBlackAndWhite ( BufferedImage img ) { int width = img . getWidth ( ) ; int height = img . getHeight ( ) ; int [ ] histo = computeHistogram ( img ) ; int median = getMedian ( width * height , histo ) ; BufferedImage bwimg = new BufferedImage ( width , height , img . getType ( ) ) ; for ( int y = 0 ; y < height ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { bwimg . setRGB ( x , y , luminance ( img . getRGB ( x , y ) ) >= median ? 0xFFFFFFFF : 0xFF000000 ) ; } } return bwimg ; } private static int [ ] computeHistogram ( BufferedImage img ) { int width = img . getWidth ( ) ; int height = img . getHeight ( ) ; int [ ] histo = new int [ 256 ] ; for ( int y = 0 ; y < height ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { histo [ luminance ( img . getRGB ( x , y ) ) ] ++ ; } } return histo ; } private static int getMedian ( int total , int [ ] histo ) { int median = 0 ; int sum = 0 ; for ( int i = 0 ; i < histo . length && sum + histo [ i ] < total / 2 ; i ++ ) { sum += histo [ i ] ; median ++ ; } return median ; } }
import java . awt . Color ; public class MidPointCircle { private BasicBitmapStorage image ; public MidPointCircle ( final int imageWidth , final int imageHeight ) { this . image = new BasicBitmapStorage ( imageWidth , imageHeight ) ; } private void drawCircle ( final int centerX , final int centerY , final int radius ) { int d = ( 5 - r * 4 ) / 4 ; int x = 0 ; int y = radius ; Color circleColor = Color . white ; do { image . setPixel ( centerX + x , centerY + y , circleColor ) ; image . setPixel ( centerX + x , centerY - y , circleColor ) ; image . setPixel ( centerX - x , centerY + y , circleColor ) ; image . setPixel ( centerX - x , centerY - y , circleColor ) ; image . setPixel ( centerX + y , centerY + x , circleColor ) ; image . setPixel ( centerX + y , centerY - x , circleColor ) ; image . setPixel ( centerX - y , centerY + x , circleColor ) ; image . setPixel ( centerX - y , centerY - x , circleColor ) ; if ( d < 0 ) { d += 2 * x + 1 ; } else { d += 2 * ( x - y ) + 1 ; y -- ; } x ++ ; } while ( x <= y ) ; } }
import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . charset . StandardCharsets ; public class PPMWriter { public void bitmapToPPM ( File file , BasicBitmapStorage bitmap ) throws IOException { file . delete ( ) ; try ( var os = new FileOutputStream ( file , true ) ; var bw = new BufferedOutputStream ( os ) ) { var header = String . format ( " P6 \n % d ▁ % d \n 255 \n " , bitmap . getWidth ( ) , bitmap . getHeight ( ) ) ; bw . write ( header . getBytes ( StandardCharsets . US_ASCII ) ) ; for ( var y = 0 ; y < bitmap . getHeight ( ) ; y ++ ) { for ( var x = 0 ; x < bitmap . getWidth ( ) ; x ++ ) { var pixel = bitmap . getPixel ( x , y ) ; bw . write ( pixel . getRed ( ) ) ; bw . write ( pixel . getGreen ( ) ) ; bw . write ( pixel . getBlue ( ) ) ; } } } } }
public static void main ( String [ ] args ) { for ( String kind : List . of ( " " , " odd ▁ " , " prime ▁ " ) ) { boolean quiet = false ; int bigLim = 99_999 ; int limit = 20 ; System . out . printf ( " First ▁ % d ▁ % sBrazilian ▁ numbers : \n " , limit , kind ) ; int c = 0 ; int n = 7 ; while ( c < bigLim ) { if ( isBrazilian ( n ) ) { if ( ! quiet ) System . out . printf ( " % d ▁ " , n ) ; if ( ++ c == limit ) { System . out . println ( " \n " ) ; quiet = true ; } } if ( quiet && ! " " . equals ( kind ) ) continue ; switch ( kind ) { case " " : n ++ ; break ; case " odd ▁ " : n += 2 ; break ; case " prime ▁ " : do { n += 2 ; } while ( ! isPrime ( n ) ) ; break ; default : throw new AssertionError ( " Oops " ) ; } } if ( " " . equals ( kind ) ) { System . out . printf ( " The ▁ % dth ▁ Brazilian ▁ number ▁ is : ▁ % d \n \n " , bigLim + 1 , n ) ; } } }
import java . util . InputMismatchException ; import java . util . Random ; import java . util . Scanner ; public class BullsAndCows { public static void main ( String [ ] args ) { Random gen = new Random ( ) ; int target ; while ( hasDupes ( target = ( gen . nextInt ( 9000 ) + 1000 ) ) ) ; String targetStr = target + " " ; boolean guessed = false ; Scanner input = new Scanner ( System . in ) ; int guesses = 0 ; do { int bulls = 0 ; int cows = 0 ; System . out . print ( " Guess ▁ a ▁ 4 - digit ▁ number ▁ with ▁ no ▁ duplicate ▁ digits : ▁ " ) ; int guess ; try { guess = input . nextInt ( ) ; if ( hasDupes ( guess ) || guess < 1000 ) continue ; } catch ( InputMismatchException e ) { continue ; } guesses ++ ; String guessStr = guess + " " ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( guessStr . charAt ( i ) == targetStr . charAt ( i ) ) { bulls ++ ; } else if ( targetStr . contains ( guessStr . charAt ( i ) + " " ) ) { cows ++ ; } } if ( bulls == 4 ) { guessed = true ; } else { System . out . println ( cows + " ▁ Cows ▁ and ▁ " + bulls + " ▁ Bulls . " ) ; } } while ( ! guessed ) ; System . out . println ( " You ▁ won ▁ after ▁ " + guesses + " ▁ guesses ! " ) ; } public static boolean hasDupes ( int num ) { boolean [ ] digs = new boolean [ 10 ] ; while ( num > 0 ) { if ( digs [ num % 10 ] ) return true ; digs [ num % 10 ] = true ; num /= 10 ; } return false ; } }
private static String bwt ( String s ) { if ( s . contains ( STX ) || s . contains ( ETX ) ) { throw new IllegalArgumentException ( " String ▁ cannot ▁ contain ▁ STX ▁ or ▁ ETX " ) ; } String ss = STX + s + ETX ; List < String > table = new ArrayList < > ( ) ; for ( int i = 0 ; i < ss . length ( ) ; i ++ ) { String before = ss . substring ( i ) ; String after = ss . substring ( 0 , i ) ; table . add ( before + after ) ; } table . sort ( String :: compareTo ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String str : table ) { sb . append ( str . charAt ( str . length ( ) - 1 ) ) ; } return sb . toString ( ) ; }
private static String ibwt ( String r ) { int len = r . length ( ) ; List < String > table = new ArrayList < > ( ) ; for ( int i = 0 ; i < len ; ++ i ) { table . add ( " " ) ; } for ( int j = 0 ; j < len ; ++ j ) { for ( int i = 0 ; i < len ; ++ i ) { table . set ( i , r . charAt ( i ) + table . get ( i ) ) ; } table . sort ( String :: compareTo ) ; } for ( String row : table ) { if ( row . endsWith ( ETX ) ) { return row . substring ( 1 , len - 1 ) ; } } return " " ; }
public class CalculateE { public static final double EPSILON = 1.0e-15 ; public static void main ( String [ ] args ) { long fact = 1 ; double e = 2.0 ; int n = 2 ; double e0 ; do { e0 = e ; fact *= n ++ ; e += 1.0 / fact ; } while ( Math . abs ( e - e0 ) >= EPSILON ) ; System . out . printf ( " e ▁ =   % .15f \n " , e ) ; } }
public class JNIDemo { static { System . loadLibrary ( " JNIDemo " ) ; } public static void main ( String [ ] args ) { System . out . println ( callStrdup ( " Hello ▁ World ! " ) ) ; } private static native String callStrdup ( String s ) ; }
import java . util . Collections ; import java . util . Random ; public class TrySort { static boolean useC ; static { try { System . loadLibrary ( " TrySort " ) ; useC = true ; } catch ( UnsatisfiedLinkError e ) { useC = false ; } } static native void sortInC ( int [ ] ary ) ; static class IntList extends java . util . AbstractList < Integer > { int [ ] ary ; IntList ( int [ ] ary ) { this . ary = ary ; } public Integer get ( int i ) { return ary [ i ] ; } public Integer set ( int i , Integer j ) { Integer o = ary [ i ] ; ary [ i ] = j ; return o ; } public int size ( ) { return ary . length ; } } static class ReverseAbsCmp implements java . util . Comparator < Integer > { public int compare ( Integer pa , Integer pb ) { int a = pa > 0 ? - pa : pa ; int b = pb > 0 ? - pb : pb ; return a < b ? - 1 : a > b ? 1 : 0 ; } } static void sortInJava ( int [ ] ary ) { Collections . sort ( new IntList ( ary ) , new ReverseAbsCmp ( ) ) ; } public static void main ( String [ ] args ) { int [ ] ary = new int [ 1000000 ] ; Random rng = new Random ( ) ; for ( int i = 0 ; i < ary . length ; i ++ ) ary [ i ] = rng . nextInt ( ) ; if ( useC ) { System . out . print ( " Sorting ▁ in ▁ C . . . ▁ ▁ " ) ; sortInC ( ary ) ; } else { System . out . print ( " Missing ▁ library ▁ for ▁ C ! ▁ ▁ Sorting ▁ in ▁ Java . . . ▁ ▁ " ) ; sortInJava ( ary ) ; } for ( int i = 0 ; i < ary . length - 1 ; i ++ ) { int a = ary [ i ] ; int b = ary [ i + 1 ] ; if ( ( a > 0 ? - a : a ) > ( b > 0 ? - b : b ) ) { System . out . println ( " * BUG ▁ IN ▁ SORT * " ) ; System . exit ( 1 ) ; } } System . out . println ( " ok " ) ; } }
import java . text . MessageFormat ; import java . text . ParseException ; public class CanonicalizeCIDR { public static void main ( String [ ] args ) { for ( String test : TESTS ) { try { CIDR cidr = new CIDR ( test ) ; System . out . printf ( " % -18s ▁ - > ▁ % s \n " , test , cidr . toString ( ) ) ; } catch ( Exception ex ) { System . err . printf ( " Error ▁ parsing ▁ ' % s ' : ▁ % s \n " , test , ex . getLocalizedMessage ( ) ) ; } } } private static class CIDR { private CIDR ( int address , int maskLength ) { this . address = address ; this . maskLength = maskLength ; } private CIDR ( String str ) throws Exception { Object [ ] args = new MessageFormat ( FORMAT ) . parse ( str ) ; int address = 0 ; for ( int i = 0 ; i < 4 ; ++ i ) { int a = ( ( Number ) args [ i ] ) . intValue ( ) ; if ( a < 0 || a > 255 ) throw new Exception ( " Invalid ▁ IP ▁ address " ) ; address <<= 8 ; address += a ; } int maskLength = ( ( Number ) args [ 4 ] ) . intValue ( ) ; if ( maskLength < 1 || maskLength > 32 ) throw new Exception ( " Invalid ▁ mask ▁ length " ) ; int mask = ~ ( ( 1 << ( 32 - maskLength ) ) - 1 ) ; this . address = address & mask ; this . maskLength = maskLength ; } public String toString ( ) { int address = this . address ; int d = address & 0xFF ; address >>= 8 ; int c = address & 0xFF ; address >>= 8 ; int b = address & 0xFF ; address >>= 8 ; int a = address & 0xFF ; Object [ ] args = { a , b , c , d , maskLength } ; return new MessageFormat ( FORMAT ) . format ( args ) ; } private int address ; private int maskLength ; private static final String FORMAT = " { 0 , number , integer } . { 1 , number , integer } . { 2 , number , integer } . { 3 , number , integer } / { 4 , number , integer } " ; } ; private static final String [ ] TESTS = { "87.70.141.1/22" , "36.18.154.103/12" , "62.62.197.11/29" , "67.137.119.181/4" , "161.214.74.21/24" , "184.232.176.184/18" } ; }
public class App { private static final int WIDTH = 81 ; private static final int HEIGHT = 5 ; private static char [ ] [ ] lines ; static { lines = new char [ HEIGHT ] [ WIDTH ] ; for ( int i = 0 ; i < HEIGHT ; i ++ ) { for ( int j = 0 ; j < WIDTH ; j ++ ) { lines [ i ] [ j ] = ' * ' ; } } } private static void cantor ( int start , int len , int index ) { int seg = len / 3 ; if ( seg == 0 ) return ; for ( int i = index ; i < HEIGHT ; i ++ ) { for ( int j = start + seg ; j < start + seg * 2 ; j ++ ) { lines [ i ] [ j ] = ' ▁ ' ; } } cantor ( start , seg , index + 1 ) ; cantor ( start + seg * 2 , seg , index + 1 ) ; } public static void main ( String [ ] args ) { cantor ( 0 , WIDTH , 1 ) ; for ( int i = 0 ; i < HEIGHT ; i ++ ) { for ( int j = 0 ; j < WIDTH ; j ++ ) { System . out . print ( lines [ i ] [ j ] ) ; } System . out . println ( ) ; } } }
public static void main ( String [ ] args ) { String plainText = " WELLDONEISBETTERTHANWELLSAID " ; System . out . printf ( " The ▁ original ▁ plaintext ▁ is  : ▁ % s \n " , plainText ) ; System . out . println ( " \n The ▁ left ▁ and ▁ right ▁ alphabets ▁ after ▁ each ▁ permutation ▁ during ▁ encryption ▁ are : " ) ; String cipherText = exec ( plainText , Mode . ENCRYPT , true ) ; System . out . printf ( " \n The ▁ cipher ▁ text ▁ is  : ▁ % s \n " , cipherText ) ; String plainText2 = exec ( cipherText , Mode . DECRYPT ) ; System . out . printf ( " \n The ▁ recovered ▁ plaintext ▁ is  : ▁ % s \n " , plainText2 ) ; }
public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> { JFrame f = new JFrame ( ) ; f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; f . setTitle ( " Chaos ▁ Game " ) ; f . setResizable ( false ) ; f . add ( new ChaosGame ( ) , BorderLayout . CENTER ) ; f . pack ( ) ; f . setLocationRelativeTo ( null ) ; f . setVisible ( true ) ; } ) ; }
public class Foo { public static void main ( String [ ] args ) { System . out . println ( ( int ) ' a ' ) ; System . out . println ( ( char ) 97 ) ; } }
import java . io . File ; public class FileExistsTest { public static boolean isFileExists ( String filename ) { boolean exists = new File ( filename ) . exists ( ) ; return exists ; } public static void test ( String type , String filename ) { System . out . println ( " The ▁ following ▁ " + type + " ▁ called ▁ " + filename + ( isFileExists ( filename ) ? " ▁ exists . " : " ▁ not ▁ exists . " ) ) ; } public static void main ( String args [ ] ) { test ( " file " , " input . txt " ) ; test ( " file " , File . separator + " input . txt " ) ; test ( " directory " , " docs " ) ; test ( " directory " , File . separator + " docs " + File . separator ) ; } }
public static void main ( String [ ] args ) { List < Birthday > choices = List . of ( new Birthday ( Month . MAY , 15 ) , new Birthday ( Month . MAY , 16 ) , new Birthday ( Month . MAY , 19 ) , new Birthday ( Month . JUNE , 17 ) , new Birthday ( Month . JUNE , 18 ) , new Birthday ( Month . JULY , 14 ) , new Birthday ( Month . JULY , 16 ) , new Birthday ( Month . AUGUST , 14 ) , new Birthday ( Month . AUGUST , 15 ) , new Birthday ( Month . AUGUST , 17 ) ) ; System . out . printf ( " There ▁ are ▁ % d ▁ candidates ▁ remaining . \n " , choices . size ( ) ) ; Set < Month > uniqueMonths = choices . stream ( ) . collect ( Collectors . groupingBy ( Birthday :: getDay ) ) . values ( ) . stream ( ) . filter ( g -> g . size ( ) == 1 ) . flatMap ( Collection :: stream ) . map ( Birthday :: getMonth ) . collect ( Collectors . toSet ( ) ) ; List < Birthday > f1List = choices . stream ( ) . filter ( birthday -> ! uniqueMonths . contains ( birthday . month ) ) . collect ( Collectors . toList ( ) ) ; System . out . printf ( " There ▁ are ▁ % d ▁ candidates ▁ remaining . \n " , f1List . size ( ) ) ; List < Birthday > f2List = f1List . stream ( ) . collect ( Collectors . groupingBy ( Birthday :: getDay ) ) . values ( ) . stream ( ) . filter ( g -> g . size ( ) == 1 ) . flatMap ( Collection :: stream ) . collect ( Collectors . toList ( ) ) ; System . out . printf ( " There ▁ are ▁ % d ▁ candidates ▁ remaining . \n " , f2List . size ( ) ) ; List < Birthday > f3List = f2List . stream ( ) . collect ( Collectors . groupingBy ( Birthday :: getMonth ) ) . values ( ) . stream ( ) . filter ( g -> g . size ( ) == 1 ) . flatMap ( Collection :: stream ) . collect ( Collectors . toList ( ) ) ; System . out . printf ( " There ▁ are ▁ % d ▁ candidates ▁ remaining . \n " , f3List . size ( ) ) ; if ( f3List . size ( ) == 1 ) { System . out . printf ( " Cheryl ' s ▁ birthday ▁ is ▁ % s \n " , f3List . get ( 0 ) ) ; } else { System . out . println ( " No ▁ unique ▁ choice ▁ found " ) ; } }
public static int chineseRemainder ( int [ ] n , int [ ] a ) { int prod = stream ( n ) . reduce ( 1 , ( i , j ) -> i * j ) ; int p , sm = 0 ; for ( int i = 0 ; i < n . length ; i ++ ) { p = prod / n [ i ] ; sm += a [ i ] * mulInv ( p , n [ i ] ) * p ; } return sm % prod ; }
private static int mulInv ( int a , int b ) { int b0 = b ; int x0 = 0 ; int x1 = 1 ; if ( b == 1 ) return 1 ; while ( a > 1 ) { int q = a / b ; int amb = a % b ; a = b ; b = amb ; int xqx = x1 - q * x0 ; x1 = x0 ; x0 = xqx ; } if ( x1 < 0 ) x1 += b0 ; return x1 ; }
import java . util . Arrays ; public class Cholesky { public static double [ ] [ ] chol ( double [ ] [ ] a ) { int m = a . length ; double [ ] [ ] l = new double [ m ] [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { for ( int k = 0 ; k < ( i + 1 ) ; k ++ ) { double sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) { sum += l [ i ] [ j ] * l [ k ] [ j ] ; } l [ i ] [ k ] = ( i == k ) ? Math . sqrt ( a [ i ] [ i ] - sum ) : ( 1.0 / l [ k ] [ k ] * ( a [ i ] [ k ] - sum ) ) ; } } return l ; } public static void main ( String [ ] args ) { double [ ] [ ] test1 = { { 25 , 15 , - 5 } , { 15 , 18 , 0 } , { - 5 , 0 , 11 } } ; System . out . println ( Arrays . deepToString ( chol ( test1 ) ) ) ; double [ ] [ ] test2 = { { 18 , 22 , 54 , 42 } , { 22 , 70 , 86 , 62 } , { 54 , 86 , 174 , 134 } , { 42 , 62 , 134 , 106 } } ; System . out . println ( Arrays . deepToString ( chol ( test2 ) ) ) ; } }
public static int chowla ( int n ) { if ( n < 0 ) throw new IllegalArgumentException ( " n ▁ is ▁ not ▁ positive " ) ; int sum = 0 ; for ( int i = 2 , j ; i * i <= n ; i ++ ) if ( n % i == 0 ) sum += i + ( i == ( j = n / i ) ? 0 : j ) ; return sum ; }
public static void main ( String [ ] args ) { ChurchNum zero = zero ( ) ; ChurchNum three = next ( next ( next ( zero ) ) ) ; ChurchNum four = next ( next ( next ( next ( zero ) ) ) ) ; System . out . println ( "3 + 4 = " + toInt ( plus ( three ) . apply ( four ) ) ) ; System . out . println ( "4 + 3 = " + toInt ( plus ( four ) . apply ( three ) ) ) ; System . out . println ( "3*4 = " + toInt ( mult ( three ) . apply ( four ) ) ) ; System . out . println ( "4*3 = " + toInt ( mult ( four ) . apply ( three ) ) ) ; System . out . println ( "3 ^ 4 = " + toInt ( pow ( four ) . apply ( three ) ) ) ; System . out . println ( "4 ^ 3 = " + toInt ( pow ( three ) . apply ( four ) ) ) ; System . out . println ( " ▁ ▁ 8 = " + toInt ( toChurchNum ( 8 ) ) ) ; }
private static boolean isPrime ( int n ) { if ( n < 2 ) return false ; if ( n % 2 == 0 ) return n == 2 ; if ( n % 3 == 0 ) return n == 3 ; for ( int p = 5 ; p * p <= n ; p += 4 ) { if ( n % p == 0 ) return false ; p += 2 ; if ( n % p == 0 ) return false ; } return true ; }
public static void main ( String [ ] args ) { System . out . println ( " First ▁ 19 ▁ circular ▁ primes : " ) ; int p = 2 ; for ( int count = 0 ; count < 19 ; ++ p ) { if ( isCircularPrime ( p ) ) { if ( count > 0 ) System . out . print ( " , ▁ " ) ; System . out . print ( p ) ; ++ count ; } } System . out . println ( ) ; System . out . println ( " Next ▁ 4 ▁ circular ▁ primes : " ) ; int repunit = 1 , digits = 1 ; for ( ; repunit < p ; ++ digits ) repunit = 10 * repunit + 1 ; BigInteger bignum = BigInteger . valueOf ( repunit ) ; for ( int count = 0 ; count < 4 ; ) { if ( bignum . isProbablePrime ( 15 ) ) { if ( count > 0 ) System . out . print ( " , ▁ " ) ; System . out . printf ( " R ( % d ) " , digits ) ; ++ count ; } ++ digits ; bignum = bignum . multiply ( BigInteger . TEN ) ; bignum = bignum . add ( BigInteger . ONE ) ; } System . out . println ( ) ; testRepunit ( 5003 ) ; testRepunit ( 9887 ) ; testRepunit ( 15073 ) ; testRepunit ( 25031 ) ; }
public class MyClass { private int variable ; public MyClass ( ) { } public void someMethod ( ) { this . variable = 1 ; } }
import java . util . function . Supplier ; import java . util . ArrayList ; public class ValueCapture { public static void main ( String [ ] args ) { ArrayList < Supplier < Integer > > funcs = new ArrayList < > ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int j = i ; funcs . add ( ( ) -> j * j ) ; } Supplier < Integer > foo = funcs . get ( 3 ) ; System . out . println ( foo . get ( ) ) ; } }
List arrayList = new ArrayList ( ) ; arrayList . add ( new Integer ( 0 ) ) ; arrayList . add ( 0 ) ; List < Integer > myarrlist = new ArrayList < Integer > ( ) ; int sum ; for ( int i = 0 ; i < 10 ; i ++ ) { myarrlist . add ( i ) ; }
import java . awt . * ; import javax . swing . * ; public class ColorWheel { public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { ColorWheelFrame frame = new ColorWheelFrame ( ) ; frame . setVisible ( true ) ; } } ) ; } private static class ColorWheelFrame extends JFrame { private ColorWheelFrame ( ) { super ( " Color ▁ Wheel " ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; getContentPane ( ) . add ( new ColorWheelPanel ( ) ) ; pack ( ) ; } } private static class ColorWheelPanel extends JComponent { private ColorWheelPanel ( ) { setPreferredSize ( new Dimension ( 400 , 400 ) ) ; } public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; int w = getWidth ( ) ; int h = getHeight ( ) ; int margin = 10 ; int radius = ( Math . min ( w , h ) - 2 * margin ) / 2 ; int cx = w / 2 ; int cy = h / 2 ; float [ ] dist = { 0.F , 1.0F } ; g2 . setColor ( Color . BLACK ) ; g2 . fillRect ( 0 , 0 , w , h ) ; for ( int angle = 0 ; angle < 360 ; ++ angle ) { Color color = hsvToRgb ( angle , 1.0 , 1.0 ) ; Color [ ] colors = { Color . WHITE , color } ; RadialGradientPaint paint = new RadialGradientPaint ( cx , cy , radius , dist , colors ) ; g2 . setPaint ( paint ) ; g2 . fillArc ( cx - radius , cy - radius , radius * 2 , radius * 2 , angle , 1 ) ; } } } private static Color hsvToRgb ( int h , double s , double v ) { double hp = h / 60.0 ; double c = s * v ; double x = c * ( 1 - Math . abs ( hp % 2.0 - 1 ) ) ; double m = v - c ; double r = 0 , g = 0 , b = 0 ; if ( hp <= 1 ) { r = c ; g = x ; } else if ( hp <= 2 ) { r = x ; g = c ; } else if ( hp <= 3 ) { g = c ; b = x ; } else if ( hp <= 4 ) { g = x ; b = c ; } else if ( hp <= 5 ) { r = x ; b = c ; } else { r = c ; b = x ; } r += m ; g += m ; b += m ; return new Color ( ( int ) ( r * 255 ) , ( int ) ( g * 255 ) , ( int ) ( b * 255 ) ) ; } }
import java . awt . Color ; import java . awt . Graphics ; import javax . swing . JFrame ; public class ColorFrame extends JFrame { public ColorFrame ( int width , int height ) { this . setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; this . setSize ( width , height ) ; this . setVisible ( true ) ; } @ Override public void paint ( Graphics g ) { Color [ ] colors = { Color . black , Color . red , Color . green , Color . blue , Color . pink , Color . CYAN , Color . yellow , Color . white } ; for ( int i = 0 ; i < colors . length ; i ++ ) { g . setColor ( colors [ i ] ) ; g . fillRect ( this . getWidth ( ) / colors . length * i , 0 , this . getWidth ( ) / colors . length , this . getHeight ( ) ) ; } } public static void main ( String args [ ] ) { new ColorFrame ( 200 , 200 ) ; } }
import java . awt . * ; import static java . awt . Color . * ; import javax . swing . * ; public class ColourPinstripeDisplay extends JPanel { final static Color [ ] palette = { black , red , green , blue , magenta , cyan , yellow , white } ; final int bands = 4 ; public ColourPinstripeDisplay ( ) { setPreferredSize ( new Dimension ( 900 , 600 ) ) ; } @ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; int h = getHeight ( ) ; for ( int b = 1 ; b <= bands ; b ++ ) { for ( int x = 0 , colIndex = 0 ; x < getWidth ( ) ; x += b , colIndex ++ ) { g . setColor ( palette [ colIndex % palette . length ] ) ; g . fillRect ( x , ( b - 1 ) * ( h / bands ) , x + b , b * ( h / bands ) ) ; } } } public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> { JFrame f = new JFrame ( ) ; f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; f . setTitle ( " ColourPinstripeDisplay " ) ; f . add ( new ColourPinstripeDisplay ( ) , BorderLayout . CENTER ) ; f . pack ( ) ; f . setLocationRelativeTo ( null ) ; f . setVisible ( true ) ; } ) ; } }
public class Arguments { public static void main ( String [ ] args ) { System . out . println ( " There ▁ are ▁ " + args . length + " ▁ arguments ▁ given . " ) ; for ( int i = 0 ; i < args . length ; i ++ ) System . out . println ( " The ▁ argument ▁ # " + ( i + 1 ) + " ▁ is ▁ " + args [ i ] + " ▁ and ▁ is ▁ at ▁ index ▁ " + i ) ; } }
static void commatize ( String s , int start , int step , String ins ) { if ( start < 0 || start > s . length ( ) || step < 1 || step > s . length ( ) ) return ; Matcher m = Pattern . compile ( " ( [1-9 ] [ 0-9 ] * ) " ) . matcher ( s . substring ( start ) ) ; StringBuffer result = new StringBuffer ( s . substring ( 0 , start ) ) ; if ( m . find ( ) ) { StringBuilder sb = new StringBuilder ( m . group ( 1 ) ) . reverse ( ) ; for ( int i = step ; i < sb . length ( ) ; i += step ) sb . insert ( i ++ , ins ) ; m . appendReplacement ( result , sb . reverse ( ) . toString ( ) ) ; } System . out . println ( m . appendTail ( result ) ) ; }

import java . util . Arrays ; public class CompareListOfStrings { public static void main ( String [ ] args ) { String [ ] [ ] arr = { { " AA " , " AA " , " AA " , " AA " } , { " AA " , " ACB " , " BB " , " CC " } } ; for ( String [ ] a : arr ) { System . out . println ( Arrays . toString ( a ) ) ; System . out . println ( Arrays . stream ( a ) . distinct ( ) . count ( ) < 2 ) ; System . out . println ( Arrays . equals ( Arrays . stream ( a ) . distinct ( ) . sorted ( ) . toArray ( ) , a ) ) ; } } }
package stringlensort ; import java . io . PrintStream ; import java . util . Arrays ; import java . util . Comparator ; public class ReportStringLengths { public static void main ( String [ ] args ) { String [ ] list = { " abcd " , "123456789" , " abcdef " , "1234567" } ; String [ ] strings = args . length > 0 ? args : list ; compareAndReportStringsLength ( strings ) ; } public static void compareAndReportStringsLength ( String [ ] strings ) { compareAndReportStringsLength ( strings , System . out ) ; } public static void compareAndReportStringsLength ( String [ ] strings , PrintStream stream ) { if ( strings . length > 0 ) { strings = strings . clone ( ) ; final String QUOTE = " \" " ; Arrays . sort ( strings , Comparator . comparing ( String :: length ) ) ; int min = strings [ 0 ] . length ( ) ; int max = strings [ strings . length - 1 ] . length ( ) ; for ( int i = strings . length - 1 ; i >= 0 ; i -- ) { int length = strings [ i ] . length ( ) ; String predicate ; if ( length == max ) { predicate = " is ▁ the ▁ longest ▁ string " ; } else if ( length == min ) { predicate = " is ▁ the ▁ shortest ▁ string " ; } else { predicate = " is ▁ neither ▁ the ▁ longest ▁ nor ▁ the ▁ shortest ▁ string " ; } stream . println ( QUOTE + strings [ i ] + QUOTE + " ▁ has ▁ length ▁ " + length + " ▁ and ▁ " + predicate ) ; } } } }
static int hole ( ) { int t = code . length ; emit_word ( 0 ) ; return t ; }
static void error ( int line , int pos , String msg ) { if ( line > 0 && pos > 0 ) { System . out . printf ( " % s ▁ in ▁ line ▁ % d , ▁ pos ▁ % d \n " , msg , line , pos ) ; } else { System . out . println ( msg ) ; } System . exit ( 1 ) ; }
static void error ( int line , int pos , String msg ) { if ( line > 0 && pos > 0 ) { System . out . printf ( " % s ▁ in ▁ line ▁ % d , ▁ pos ▁ % d \n " , msg , line , pos ) ; } else { System . out . println ( msg ) ; } System . exit ( 1 ) ; }
public class Point { public int x , y ; public Point ( ) { this ( 0 ) ; } public Point ( int x0 ) { this ( x0 , 0 ) ; } public Point ( int x0 , int y0 ) { x = x0 ; y = y0 ; } public static void main ( String args [ ] ) { Point point = new Point ( 1 , 2 ) ; System . out . println ( " x ▁ = ▁ " + point . x ) ; System . out . println ( " y ▁ = ▁ " + point . y ) ; } }
public static void main ( String [ ] args ) { CyclicBarrier barrier = new CyclicBarrier ( 3 ) ; new Thread ( new DelayedMessagePrinter ( barrier , " Enjoy " ) ) . start ( ) ; new Thread ( new DelayedMessagePrinter ( barrier , " Rosetta " ) ) . start ( ) ; new Thread ( new DelayedMessagePrinter ( barrier , " Code " ) ) . start ( ) ; }
if ( s . equals ( " Hello ▁ World " ) ) { foo ( ) ; } else if ( s . equals ( " Bye ▁ World " ) ) bar ( ) ; else { deusEx ( ) ; }
import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . stream . Collectors ; import static java . util . Collections . emptyList ; public class ConvexHull { private static class Point implements Comparable < Point > { private int x , y ; public Point ( int x , int y ) { this . x = x ; this . y = y ; } @ Override public int compareTo ( Point o ) { return Integer . compare ( x , o . x ) ; } @ Override public String toString ( ) { return String . format ( " ( % d , ▁ % d ) " , x , y ) ; } } private static List < Point > convexHull ( List < Point > p ) { if ( p . isEmpty ( ) ) return emptyList ( ) ; p . sort ( Point :: compareTo ) ; List < Point > h = new ArrayList < > ( ) ; for ( Point pt : p ) { while ( h . size ( ) >= 2 && ! ccw ( h . get ( h . size ( ) - 2 ) , h . get ( h . size ( ) - 1 ) , pt ) ) { h . remove ( h . size ( ) - 1 ) ; } h . add ( pt ) ; } int t = h . size ( ) + 1 ; for ( int i = p . size ( ) - 1 ; i >= 0 ; i -- ) { Point pt = p . get ( i ) ; while ( h . size ( ) >= t && ! ccw ( h . get ( h . size ( ) - 2 ) , h . get ( h . size ( ) - 1 ) , pt ) ) { h . remove ( h . size ( ) - 1 ) ; } h . add ( pt ) ; } h . remove ( h . size ( ) - 1 ) ; return h ; } private static boolean ccw ( Point a , Point b , Point c ) { return ( ( b . x - a . x ) * ( c . y - a . y ) ) > ( ( b . y - a . y ) * ( c . x - a . x ) ) ; } public static void main ( String [ ] args ) { List < Point > points = Arrays . asList ( new Point ( 16 , 3 ) , new Point ( 12 , 17 ) , new Point ( 0 , 6 ) , new Point ( - 4 , - 6 ) , new Point ( 16 , 6 ) , new Point ( 16 , - 7 ) , new Point ( 16 , - 3 ) , new Point ( 17 , - 4 ) , new Point ( 5 , 19 ) , new Point ( 19 , - 8 ) , new Point ( 3 , 16 ) , new Point ( 12 , 13 ) , new Point ( 3 , - 4 ) , new Point ( 17 , 5 ) , new Point ( - 3 , 15 ) , new Point ( - 3 , - 9 ) , new Point ( 0 , 11 ) , new Point ( - 9 , - 3 ) , new Point ( - 4 , - 2 ) , new Point ( 12 , 10 ) ) ; List < Point > hull = convexHull ( points ) ; System . out . printf ( " Convex ▁ Hull : ▁ % s \n " , hull ) ; } }
public class GameOfLife { public static void main ( String [ ] args ) { String [ ] dish = { " _ # _ " , " _ # _ " , " _ # _ " , } ; int gens = 3 ; for ( int i = 0 ; i < gens ; i ++ ) { System . out . println ( " Generation ▁ " + i + " : " ) ; print ( dish ) ; dish = life ( dish ) ; } } public static String [ ] life ( String [ ] dish ) { String [ ] newGen = new String [ dish . length ] ; for ( int row = 0 ; row < dish . length ; row ++ ) { newGen [ row ] = " " ; for ( int i = 0 ; i < dish [ row ] . length ( ) ; i ++ ) { String above = " " ; String same = " " ; String below = " " ; if ( i == 0 ) { above = ( row == 0 ) ? null : dish [ row - 1 ] . substring ( i , i + 2 ) ; same = dish [ row ] . substring ( i + 1 , i + 2 ) ; below = ( row == dish . length - 1 ) ? null : dish [ row + 1 ] . substring ( i , i + 2 ) ; } else if ( i == dish [ row ] . length ( ) - 1 ) { above = ( row == 0 ) ? null : dish [ row - 1 ] . substring ( i - 1 , i + 1 ) ; same = dish [ row ] . substring ( i - 1 , i ) ; below = ( row == dish . length - 1 ) ? null : dish [ row + 1 ] . substring ( i - 1 , i + 1 ) ; } else { above = ( row == 0 ) ? null : dish [ row - 1 ] . substring ( i - 1 , i + 2 ) ; same = dish [ row ] . substring ( i - 1 , i ) + dish [ row ] . substring ( i + 1 , i + 2 ) ; below = ( row == dish . length - 1 ) ? null : dish [ row + 1 ] . substring ( i - 1 , i + 2 ) ; } int neighbors = getNeighbors ( above , same , below ) ; if ( neighbors < 2 || neighbors > 3 ) { newGen [ row ] += " _ " ; } else if ( neighbors == 3 ) { newGen [ row ] += " # " ; } else { newGen [ row ] += dish [ row ] . charAt ( i ) ; } } } return newGen ; } public static int getNeighbors ( String above , String same , String below ) { int ans = 0 ; if ( above != null ) { for ( char x : above . toCharArray ( ) ) { if ( x == ' # ' ) ans ++ ; } } for ( char x : same . toCharArray ( ) ) { if ( x == ' # ' ) ans ++ ; } if ( below != null ) { for ( char x : below . toCharArray ( ) ) { if ( x == ' # ' ) ans ++ ; } } return ans ; } public static void print ( String [ ] dish ) { for ( String s : dish ) { System . out . println ( s ) ; } } }
import java . util . Scanner ; public class CopyStdinToStdout { public static void main ( String [ ] args ) { try ( Scanner scanner = new Scanner ( System . in ) ; ) { String s ; while ( ( s = scanner . nextLine ( ) ) . compareTo ( " " ) != 0 ) { System . out . println ( s ) ; } } } }
public class Count { public static void main ( String [ ] args ) { for ( int i = 0 ; i >= 0 ; i ++ ) { System . out . println ( Integer . toOctalString ( i ) ) ; } } }
import java . util . Arrays ; import java . math . BigInteger ; class CountTheCoins { private static BigInteger countChanges ( int amount , int [ ] coins ) { final int n = coins . length ; int cycle = 0 ; for ( int c : coins ) if ( c <= amount && c >= cycle ) cycle = c + 1 ; cycle *= n ; BigInteger [ ] table = new BigInteger [ cycle ] ; Arrays . fill ( table , 0 , n , BigInteger . ONE ) ; Arrays . fill ( table , n , cycle , BigInteger . ZERO ) ; int pos = n ; for ( int s = 1 ; s <= amount ; s ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 && pos >= cycle ) pos = 0 ; if ( coins [ i ] <= s ) { final int q = pos - ( coins [ i ] * n ) ; table [ pos ] = ( q >= 0 ) ? table [ q ] : table [ q + cycle ] ; } if ( i != 0 ) table [ pos ] = table [ pos ] . add ( table [ pos - 1 ] ) ; pos ++ ; } } return table [ pos - 1 ] ; } public static void main ( String [ ] args ) { final int [ ] [ ] coinsUsEu = { { 100 , 50 , 25 , 10 , 5 , 1 } , { 200 , 100 , 50 , 20 , 10 , 5 , 2 , 1 } } ; for ( int [ ] coins : coinsUsEu ) { System . out . println ( countChanges ( 100 , Arrays . copyOfRange ( coins , 2 , coins . length ) ) ) ; System . out . println ( countChanges ( 100000 , coins ) ) ; System . out . println ( countChanges ( 1000000 , coins ) ) ; System . out . println ( countChanges ( 10000000 , coins ) + " \n " ) ; } } }
import java . io . * ; public class CreateFileTest { public static void main ( String args [ ] ) { try { new File ( " output . txt " ) . createNewFile ( ) ; new File ( File . separator + " output . txt " ) . createNewFile ( ) ; new File ( " docs " ) . mkdir ( ) ; new File ( File . separator + " docs " ) . mkdir ( ) ; } catch ( IOException e ) { System . err . println ( e . getMessage ( ) ) ; } } }
import java . util . Scanner ; public class twoDimArray { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int nbr1 = in . nextInt ( ) ; int nbr2 = in . nextInt ( ) ; double [ ] [ ] array = new double [ nbr1 ] [ nbr2 ] ; array [ 0 ] [ 0 ] = 42.0 ; System . out . println ( " The ▁ number ▁ at ▁ place ▁ [ 0 ▁ 0 ] ▁ is ▁ " + array [ 0 ] [ 0 ] ) ; } }
import java . io . * ; import java . awt . Point ; import java . util . HashMap ; import java . util . Scanner ; public class CSV { private HashMap < Point , String > _map = new HashMap < Point , String > ( ) ; private int _cols ; private int _rows ; public void open ( File file ) throws FileNotFoundException , IOException { open ( file , ' , ' ) ; } public void open ( File file , char delimiter ) throws FileNotFoundException , IOException { Scanner scanner = new Scanner ( file ) ; scanner . useDelimiter ( Character . toString ( delimiter ) ) ; clear ( ) ; while ( scanner . hasNextLine ( ) ) { String [ ] values = scanner . nextLine ( ) . split ( Character . toString ( delimiter ) ) ; int col = 0 ; for ( String value : values ) { _map . put ( new Point ( col , _rows ) , value ) ; _cols = Math . max ( _cols , ++ col ) ; } _rows ++ ; } scanner . close ( ) ; } public void save ( File file ) throws IOException { save ( file , ' , ' ) ; } public void save ( File file , char delimiter ) throws IOException { FileWriter fw = new FileWriter ( file ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; for ( int row = 0 ; row < _rows ; row ++ ) { for ( int col = 0 ; col < _cols ; col ++ ) { Point key = new Point ( col , row ) ; if ( _map . containsKey ( key ) ) { bw . write ( _map . get ( key ) ) ; } if ( ( col + 1 ) < _cols ) { bw . write ( delimiter ) ; } } bw . newLine ( ) ; } bw . flush ( ) ; bw . close ( ) ; } public String get ( int col , int row ) { String val = " " ; Point key = new Point ( col , row ) ; if ( _map . containsKey ( key ) ) { val = _map . get ( key ) ; } return val ; } public void put ( int col , int row , String value ) { _map . put ( new Point ( col , row ) , value ) ; _cols = Math . max ( _cols , col + 1 ) ; _rows = Math . max ( _rows , row + 1 ) ; } public void clear ( ) { _map . clear ( ) ; _cols = 0 ; _rows = 0 ; } public int rows ( ) { return _rows ; } public int cols ( ) { return _cols ; } public static void main ( String [ ] args ) { try { CSV csv = new CSV ( ) ; csv . open ( new File ( " test _ in . csv " ) ) ; csv . put ( 0 , 0 , " Column0" ) ; csv . put ( 1 , 1 , "100" ) ; csv . put ( 2 , 2 , "200" ) ; csv . put ( 3 , 3 , "300" ) ; csv . put ( 4 , 4 , "400" ) ; csv . save ( new File ( " test _ out . csv " ) ) ; } catch ( Exception e ) { } } }
public class CubanPrimes { private static int MAX = 1_400_000 ; private static boolean [ ] primes = new boolean [ MAX ] ; public static void main ( String [ ] args ) { preCompute ( ) ; cubanPrime ( 200 , true ) ; for ( int i = 1 ; i <= 5 ; i ++ ) { int max = ( int ) Math . pow ( 10 , i ) ; System . out . printf ( " % , d - th ▁ cuban ▁ prime ▁ =   % , d % n " , max , cubanPrime ( max , false ) ) ; } } private static long cubanPrime ( int n , boolean display ) { int count = 0 ; long result = 0 ; for ( long i = 0 ; count < n ; i ++ ) { long test = 1l + 3 * i * ( i + 1 ) ; if ( isPrime ( test ) ) { count ++ ; result = test ; if ( display ) { System . out . printf ( " % 10s % s " , String . format ( " % , d " , test ) , count % 10 == 0 ? " \n " : " " ) ; } } } return result ; } private static boolean isPrime ( long n ) { if ( n < MAX ) { return primes [ ( int ) n ] ; } int max = ( int ) Math . sqrt ( n ) ; for ( int i = 3 ; i <= max ; i ++ ) { if ( primes [ i ] && n % i == 0 ) { return false ; } } return true ; } private static final void preCompute ( ) { for ( int i = 2 ; i < MAX ; i ++ ) { primes [ i ] = true ; } for ( int i = 2 ; i < MAX ; i ++ ) { if ( primes [ i ] ) { for ( int j = 2 * i ; j < MAX ; j += i ) { primes [ j ] = false ; } } } } }
import java . math . * ; import java . util . * ; public class Currency { final static String taxrate = "7.65" ; enum MenuItem { Hamburger ( "5.50" ) , Milkshake ( "2.86" ) ; private MenuItem ( String p ) { price = new BigDecimal ( p ) ; } public final BigDecimal price ; } public static void main ( String [ ] args ) { Locale . setDefault ( Locale . ENGLISH ) ; MathContext mc = MathContext . DECIMAL128 ; Map < MenuItem , BigDecimal > order = new HashMap < > ( ) ; order . put ( MenuItem . Hamburger , new BigDecimal ( "4000000000000000" ) ) ; order . put ( MenuItem . Milkshake , new BigDecimal ( "2" ) ) ; BigDecimal subtotal = BigDecimal . ZERO ; for ( MenuItem it : order . keySet ( ) ) subtotal = subtotal . add ( it . price . multiply ( order . get ( it ) , mc ) ) ; BigDecimal tax = new BigDecimal ( taxrate , mc ) ; tax = tax . divide ( new BigDecimal ( "100" ) , mc ) ; tax = subtotal . multiply ( tax , mc ) ; System . out . printf ( " Subtotal : ▁ % 20.2f % n " , subtotal ) ; System . out . printf ( " ▁ ▁ ▁ ▁ ▁ Tax : ▁ % 20.2f % n " , tax ) ; System . out . printf ( " ▁ ▁ ▁ Total : ▁ % 20.2f % n " , subtotal . add ( tax ) ) ; } }
static void brent ( IntUnaryOperator f , int x0 ) { int cycleLength ; int hare = x0 ; FOUND : for ( int power = 1 ; ; power *= 2 ) { int tortoise = hare ; for ( int i = 1 ; i <= power ; i ++ ) { hare = f . applyAsInt ( hare ) ; if ( tortoise == hare ) { cycleLength = i ; break FOUND ; } } } hare = x0 ; for ( int i = 0 ; i < cycleLength ; i ++ ) hare = f . applyAsInt ( hare ) ; int cycleStart = 0 ; for ( int tortoise = x0 ; tortoise != hare ; cycleStart ++ ) { tortoise = f . applyAsInt ( tortoise ) ; hare = f . applyAsInt ( hare ) ; } printResult ( x0 , f , cycleLength , cycleStart ) ; }
private static boolean damm ( String s ) { int interim = 0 ; for ( char c : s . toCharArray ( ) ) interim = table [ interim ] [ c - '0' ] ; return interim == 0 ; }
import java . util . Calendar ; import java . util . GregorianCalendar ; import java . text . DateFormatSymbols ; import java . text . DateFormat ; public class Dates { public static void main ( String [ ] args ) { Calendar now = new GregorianCalendar ( ) ; DateFormatSymbols symbols = new DateFormatSymbols ( ) ; System . out . println ( now . get ( Calendar . YEAR ) + " - " + ( now . get ( Calendar . MONTH ) + 1 ) + " - " + now . get ( Calendar . DATE ) ) ; System . out . print ( symbols . getWeekdays ( ) [ now . get ( Calendar . DAY_OF_WEEK ) ] + " , ▁ " ) ; System . out . print ( symbols . getMonths ( ) [ now . get ( Calendar . MONTH ) ] + " ▁ " ) ; System . out . println ( now . get ( Calendar . DATE ) + " , ▁ " + now . get ( Calendar . YEAR ) ) ; } }
import java . time . * ; import java . time . format . * ; class Main { public static void main ( String args [ ] ) { String dateStr = " March ▁ 7 ▁ 2009 ▁ 7:30pm ▁ EST " ; DateTimeFormatter df = new DateTimeFormatterBuilder ( ) . parseCaseInsensitive ( ) . appendPattern ( " MMMM ▁ d ▁ yyyy ▁ h : mma ▁ zzz " ) . toFormatter ( ) ; ZonedDateTime after12Hours = ZonedDateTime . parse ( dateStr , df ) . plusHours ( 12 ) ; System . out . println ( " Date : ▁ " + dateStr ) ; System . out . println ( " + 12h : ▁ " + after12Hours . format ( df ) ) ; ZonedDateTime after12HoursInCentralEuropeTime = after12Hours . withZoneSameInstant ( ZoneId . of ( " CET " ) ) ; System . out . println ( " + 12h ▁ ( in ▁ Central ▁ Europe ) : ▁ " + after12HoursInCentralEuropeTime . format ( df ) ) ; } }
import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class Yuletide { public static void main ( String [ ] args ) { for ( int i = 2008 ; i <= 2121 ; i ++ ) { Calendar cal = new GregorianCalendar ( i , Calendar . DECEMBER , 25 ) ; if ( cal . get ( Calendar . DAY_OF_WEEK ) == Calendar . SUNDAY ) { System . out . println ( cal . getTime ( ) ) ; } } } }
private static String deBruijn ( int k , int n ) { byte [ ] a = new byte [ k * n ] ; Arrays . fill ( a , ( byte ) 0 ) ; List < Byte > seq = new ArrayList < > ( ) ; BiConsumer < Integer , Integer > db = recurse ( ( t , p , f ) -> { if ( t > n ) { if ( n % p == 0 ) { for ( int i = 1 ; i < p + 1 ; ++ i ) { seq . add ( a [ i ] ) ; } } } else { a [ t ] = a [ t - p ] ; f . apply ( t + 1 , p , f ) ; int j = a [ t - p ] + 1 ; while ( j < k ) { a [ t ] = ( byte ) ( j & 0xFF ) ; f . apply ( t + 1 , t , f ) ; j ++ ; } } } ) ; db . accept ( 1 , 1 ) ; StringBuilder sb = new StringBuilder ( ) ; for ( Byte i : seq ) { sb . append ( "0123456789" . charAt ( i ) ) ; } sb . append ( sb . subSequence ( 0 , n - 1 ) ) ; return sb . toString ( ) ; }
private static void validate ( String db ) { int le = db . length ( ) ; int [ ] found = new int [ 10_000 ] ; Arrays . fill ( found , 0 ) ; List < String > errs = new ArrayList < > ( ) ; for ( int i = 0 ; i < le - 3 ; ++ i ) { String s = db . substring ( i , i + 4 ) ; if ( allDigits ( s ) ) { int n = Integer . parseInt ( s ) ; found [ n ] ++ ; } } for ( int i = 0 ; i < 10_000 ; ++ i ) { if ( found [ i ] == 0 ) { errs . add ( String . format ( " ▁ ▁ ▁ ▁ PIN ▁ number ▁ % d ▁ is ▁ missing " , i ) ) ; } else if ( found [ i ] > 1 ) { errs . add ( String . format ( " ▁ ▁ ▁ ▁ PIN ▁ number ▁ % d ▁ occurs ▁ % d ▁ times " , i , found [ i ] ) ) ; } } if ( errs . isEmpty ( ) ) { System . out . println ( " ▁ ▁ ▁ ▁ No ▁ errors ▁ found " ) ; } else { String pl = ( errs . size ( ) == 1 ) ? " " : " s " ; System . out . printf ( " ▁ ▁ % d ▁ error % s ▁ found : \n " , errs . size ( ) , pl ) ; errs . forEach ( System . out :: println ) ; } }
import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; public class DeepCopy { public static void main ( String [ ] args ) { Person p1 = new Person ( " Clark " , " Kent " , new Address ( "1 ▁ World ▁ Center " , " Metropolis " , " NY " , "010101" ) ) ; Person p2 = p1 ; System . out . printf ( " Demonstrate ▁ shallow ▁ copy . ▁ ▁ Both ▁ are ▁ the ▁ same ▁ object . % n " ) ; System . out . printf ( " Person ▁ p1 ▁ = ▁ % s % n " , p1 ) ; System . out . printf ( " Person ▁ p2 ▁ = ▁ % s % n " , p2 ) ; System . out . printf ( " Set ▁ city ▁ on ▁ person ▁ 2 . ▁ ▁ City ▁ on ▁ both ▁ objects ▁ is ▁ changed . % n " ) ; p2 . getAddress ( ) . setCity ( " New ▁ York " ) ; System . out . printf ( " Person ▁ p1 ▁ = ▁ % s % n " , p1 ) ; System . out . printf ( " Person ▁ p2 ▁ = ▁ % s % n " , p2 ) ; p1 = new Person ( " Clark " , " Kent " , new Address ( "1 ▁ World ▁ Center " , " Metropolis " , " NY " , "010101" ) ) ; p2 = new Person ( p1 ) ; System . out . printf ( " % nDemonstrate ▁ copy ▁ constructor . ▁ ▁ Object ▁ p2 ▁ is ▁ a ▁ deep ▁ copy ▁ of ▁ p1 . % n " ) ; System . out . printf ( " Person ▁ p1 ▁ = ▁ % s % n " , p1 ) ; System . out . printf ( " Person ▁ p2 ▁ = ▁ % s % n " , p2 ) ; System . out . printf ( " Set ▁ city ▁ on ▁ person ▁ 2 . ▁ ▁ City ▁ on ▁ objects ▁ is ▁ different . % n " ) ; p2 . getAddress ( ) . setCity ( " New ▁ York " ) ; System . out . printf ( " Person ▁ p1 ▁ = ▁ % s % n " , p1 ) ; System . out . printf ( " Person ▁ p2 ▁ = ▁ % s % n " , p2 ) ; p2 = ( Person ) deepCopy ( p1 ) ; System . out . printf ( " % nDemonstrate ▁ serialization . ▁ ▁ Object ▁ p2 ▁ is ▁ a ▁ deep ▁ copy ▁ of ▁ p1 . % n " ) ; System . out . printf ( " Person ▁ p1 ▁ = ▁ % s % n " , p1 ) ; System . out . printf ( " Person ▁ p2 ▁ = ▁ % s % n " , p2 ) ; System . out . printf ( " Set ▁ city ▁ on ▁ person ▁ 2 . ▁ ▁ City ▁ on ▁ objects ▁ is ▁ different . % n " ) ; p2 . getAddress ( ) . setCity ( " New ▁ York " ) ; System . out . printf ( " Person ▁ p1 ▁ = ▁ % s % n " , p1 ) ; System . out . printf ( " Person ▁ p2 ▁ = ▁ % s % n " , p2 ) ; p2 = ( Person ) p1 . clone ( ) ; System . out . printf ( " % nDemonstrate ▁ cloning . ▁ ▁ Object ▁ p2 ▁ is ▁ a ▁ deep ▁ copy ▁ of ▁ p1 . % n " ) ; System . out . printf ( " Person ▁ p1 ▁ = ▁ % s % n " , p1 ) ; System . out . printf ( " Person ▁ p2 ▁ = ▁ % s % n " , p2 ) ; System . out . printf ( " Set ▁ city ▁ on ▁ person ▁ 2 . ▁ ▁ City ▁ on ▁ objects ▁ is ▁ different . % n " ) ; p2 . getAddress ( ) . setCity ( " New ▁ York " ) ; System . out . printf ( " Person ▁ p1 ▁ = ▁ % s % n " , p1 ) ; System . out . printf ( " Person ▁ p2 ▁ = ▁ % s % n " , p2 ) ; } private static Object deepCopy ( Object object ) { try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; ObjectOutputStream outputStrm = new ObjectOutputStream ( outputStream ) ; outputStrm . writeObject ( object ) ; ByteArrayInputStream inputStream = new ByteArrayInputStream ( outputStream . toByteArray ( ) ) ; ObjectInputStream objInputStream = new ObjectInputStream ( inputStream ) ; return objInputStream . readObject ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } } public static class Address implements Serializable , Cloneable { private static final long serialVersionUID = - 7073778041809445593L ; private String street ; private String city ; private String state ; private String postalCode ; public String getStreet ( ) { return street ; } public String getCity ( ) { return city ; } public void setCity ( String city ) { this . city = city ; } public String getState ( ) { return state ; } public String getPostalCode ( ) { return postalCode ; } @ Override public String toString ( ) { return " [ street = " + street + " , ▁ city = " + city + " , ▁ state = " + state + " , ▁ code = " + postalCode + " ] " ; } public Address ( String s , String c , String st , String p ) { street = s ; city = c ; state = st ; postalCode = p ; } public Address ( Address add ) { street = add . street ; city = add . city ; state = add . state ; postalCode = add . postalCode ; } @ Override public Object clone ( ) { return new Address ( this ) ; } } public static class Person implements Serializable , Cloneable { private static final long serialVersionUID = - 521810583786595050L ; private String firstName ; private String lastName ; private Address address ; public String getFirstName ( ) { return firstName ; } public String getLastName ( ) { return lastName ; } public Address getAddress ( ) { return address ; } @ Override public String toString ( ) { return " [ first ▁ name = " + firstName + " , ▁ last ▁ name = " + lastName + " , ▁ address = " + address + " ] " ; } public Person ( String fn , String ln , Address add ) { firstName = fn ; lastName = ln ; address = add ; } public Person ( Person person ) { firstName = person . firstName ; lastName = person . lastName ; address = new Address ( person . address ) ; } @ Override public Object clone ( ) { return new Person ( this ) ; } } }
interface Thingable { String thing ( ) ; } class Delegator { public Thingable delegate ; public String operation ( ) { if ( delegate == null ) return " default ▁ implementation " ; else return delegate . thing ( ) ; } } class Delegate implements Thingable { public String thing ( ) { return " delegate ▁ implementation " ; } } public class DelegateExample { public static void main ( String [ ] args ) { Delegator a = new Delegator ( ) ; assert a . operation ( ) . equals ( " default ▁ implementation " ) ; Delegate d = new Delegate ( ) ; a . delegate = d ; assert a . operation ( ) . equals ( " delegate ▁ implementation " ) ; a . delegate = new Thingable ( ) { public String thing ( ) { return " anonymous ▁ delegate ▁ implementation " ; } } ; assert a . operation ( ) . equals ( " anonymous ▁ delegate ▁ implementation " ) ; } }
import java . io . File ; public class FileDeleteTest { public static boolean deleteFile ( String filename ) { boolean exists = new File ( filename ) . delete ( ) ; return exists ; } public static void test ( String type , String filename ) { System . out . println ( " The ▁ following ▁ " + type + " ▁ called ▁ " + filename + ( deleteFile ( filename ) ? " ▁ was ▁ deleted . " : " ▁ could ▁ not ▁ be ▁ deleted . " ) ) ; } public static void main ( String args [ ] ) { test ( " file " , " input . txt " ) ; test ( " file " , File . seperator + " input . txt " ) ; test ( " directory " , " docs " ) ; test ( " directory " , File . seperator + " docs " + File . seperator ) ; } }
static double [ ] funnel ( double [ ] input , BiFunction < Double , Double , Double > rule ) { double x = 0 ; double [ ] result = new double [ input . length ] ; for ( int i = 0 ; i < input . length ; i ++ ) { double rx = x + input [ i ] ; x = rule . apply ( x , input [ i ] ) ; result [ i ] = rx ; } return result ; }
static double mean ( double [ ] xs ) { return Arrays . stream ( xs ) . sum ( ) / xs . length ; }
public static double perm ( double [ ] [ ] a ) { if ( a . length == 1 ) { return a [ 0 ] [ 0 ] ; } else { double sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { sum += a [ 0 ] [ i ] * perm ( minor ( a , 0 , i ) ) ; } return sum ; } }
public static double det ( double [ ] [ ] a ) { if ( a . length == 1 ) { return a [ 0 ] [ 0 ] ; } else { int sign = 1 ; double sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { sum += sign * a [ 0 ] [ i ] * det ( minor ( a , 0 , i ) ) ; sign *= - 1 ; } return sum ; } }
public static void main ( String [ ] args ) { String [ ] tests = { " " , " ▁ ▁ ▁ " , "2" , "333" , " . 55" , " tttTTT " , "4444 ▁ 444k " } ; for ( String s : tests ) analyze ( s ) ; }
public static void main ( String [ ] args ) { System . out . printf ( " % -40s ▁ ▁ % 2s ▁ ▁ % 10s ▁ ▁ % 8s ▁ ▁ % s ▁ ▁ % s % n " , " String " , " Length " , " All ▁ Unique " , "1st ▁ Diff " , " Hex " , " Positions " ) ; System . out . printf ( " % -40s ▁ ▁ % 2s ▁ ▁ % 10s ▁ ▁ % 8s ▁ ▁ % s ▁ ▁ % s % n " , " - - - - - - - - - - - - - - - - - - - - - - - - " , " - - - - - - " , " - - - - - - - - - - " , " - - - - - - - - " , " - - - " , " - - - - - - - - - " ) ; for ( String s : new String [ ] { " " , " . " , " abcABC " , " XYZ ▁ ZYX " , "1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ " } ) { processString ( s ) ; } }
import java . io . * ; import java . util . * ; public class Dijkstra { private static final Graph . Edge [ ] GRAPH = { new Graph . Edge ( " a " , " b " , 7 ) , new Graph . Edge ( " a " , " c " , 9 ) , new Graph . Edge ( " a " , " f " , 14 ) , new Graph . Edge ( " b " , " c " , 10 ) , new Graph . Edge ( " b " , " d " , 15 ) , new Graph . Edge ( " c " , " d " , 11 ) , new Graph . Edge ( " c " , " f " , 2 ) , new Graph . Edge ( " d " , " e " , 6 ) , new Graph . Edge ( " e " , " f " , 9 ) , } ; private static final String START = " a " ; private static final String END = " e " ; public static void main ( String [ ] args ) { Graph g = new Graph ( GRAPH ) ; g . dijkstra ( START ) ; g . printPath ( END ) ; } } class Graph { private final Map < String , Vertex > graph ; public static class Edge { public final String v1 , v2 ; public final int dist ; public Edge ( String v1 , String v2 , int dist ) { this . v1 = v1 ; this . v2 = v2 ; this . dist = dist ; } } public static class Vertex implements Comparable < Vertex > { public final String name ; public int dist = Integer . MAX_VALUE ; public Vertex previous = null ; public final Map < Vertex , Integer > neighbours = new HashMap < > ( ) ; public Vertex ( String name ) { this . name = name ; } private void printPath ( ) { if ( this == this . previous ) { System . out . printf ( " % s " , this . name ) ; } else if ( this . previous == null ) { System . out . printf ( " % s ( unreached ) " , this . name ) ; } else { this . previous . printPath ( ) ; System . out . printf ( " ▁ - > ▁ % s ( % d ) " , this . name , this . dist ) ; } } public int compareTo ( Vertex other ) { if ( dist == other . dist ) return name . compareTo ( other . name ) ; return Integer . compare ( dist , other . dist ) ; } @ Override public String toString ( ) { return " ( " + name + " , ▁ " + dist + " ) " ; } } public Graph ( Edge [ ] edges ) { graph = new HashMap < > ( edges . length ) ; for ( Edge e : edges ) { if ( ! graph . containsKey ( e . v1 ) ) graph . put ( e . v1 , new Vertex ( e . v1 ) ) ; if ( ! graph . containsKey ( e . v2 ) ) graph . put ( e . v2 , new Vertex ( e . v2 ) ) ; } for ( Edge e : edges ) { graph . get ( e . v1 ) . neighbours . put ( graph . get ( e . v2 ) , e . dist ) ; } } public void dijkstra ( String startName ) { if ( ! graph . containsKey ( startName ) ) { System . err . printf ( " Graph ▁ doesn ' t ▁ contain ▁ start ▁ vertex ▁ \" % s \" \n " , startName ) ; return ; } final Vertex source = graph . get ( startName ) ; NavigableSet < Vertex > q = new TreeSet < > ( ) ; for ( Vertex v : graph . values ( ) ) { v . previous = v == source ? source : null ; v . dist = v == source ? 0 : Integer . MAX_VALUE ; q . add ( v ) ; } dijkstra ( q ) ; } private void dijkstra ( final NavigableSet < Vertex > q ) { Vertex u , v ; while ( ! q . isEmpty ( ) ) { u = q . pollFirst ( ) ; if ( u . dist == Integer . MAX_VALUE ) break ; for ( Map . Entry < Vertex , Integer > a : u . neighbours . entrySet ( ) ) { v = a . getKey ( ) ; final int alternateDist = u . dist + a . getValue ( ) ; if ( alternateDist < v . dist ) { q . remove ( v ) ; v . dist = alternateDist ; v . previous = u ; q . add ( v ) ; } } } } public void printPath ( String endName ) { if ( ! graph . containsKey ( endName ) ) { System . err . printf ( " Graph ▁ doesn ' t ▁ contain ▁ end ▁ vertex ▁ \" % s \" \n " , endName ) ; return ; } graph . get ( endName ) . printPath ( ) ; System . out . println ( ) ; } public void printAllPaths ( ) { for ( Vertex v : graph . values ( ) ) { v . printPath ( ) ; System . out . println ( ) ; } } }
public static void main ( String [ ] args ) { System . out . println ( diversityTheorem ( 49.0 , new double [ ] { 48.0 , 47.0 , 51.0 } ) ) ; System . out . println ( diversityTheorem ( 49.0 , new double [ ] { 48.0 , 47.0 , 51.0 , 42.0 } ) ) ; }
public class Doc { private String field ; public int method ( long num ) throws BadException { } }
import java . util . LinkedList ; public class DoublyLinkedList { public static void main ( String [ ] args ) { LinkedList < String > list = new LinkedList < String > ( ) ; list . addFirst ( " Add ▁ First " ) ; list . addLast ( " Add ▁ Last ▁ 1" ) ; list . addLast ( " Add ▁ Last ▁ 2" ) ; list . addLast ( " Add ▁ Last ▁ 1" ) ; traverseList ( list ) ; list . removeFirstOccurrence ( " Add ▁ Last ▁ 1" ) ; traverseList ( list ) ; } private static void traverseList ( LinkedList < String > list ) { System . out . println ( " Traverse ▁ List : " ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . printf ( " Element ▁ number ▁ % d ▁ - ▁ Element ▁ value ▁ = ▁ ' % s ' % n " , i , list . get ( i ) ) ; } System . out . println ( ) ; } }
public class Node < T > { private T element ; private Node < T > next , prev ; public Node < T > ( ) { next = prev = element = null ; } public Node < T > ( Node < T > n , Node < T > p , T elem ) { next = n ; prev = p ; element = elem ; } public void setNext ( Node < T > n ) { next = n ; } public Node < T > getNext ( ) { return next ; } public void setElem ( T elem ) { element = elem ; } public T getElem ( ) { return element ; } public void setNext ( Node < T > n ) { next = n ; } public Node < T > setPrev ( Node < T > p ) { prev = p ; } public getPrev ( ) { return prev ; } }
package com . rosettacode ; import java . util . LinkedList ; import java . util . stream . Collectors ; import java . util . stream . IntStream ; public class DoubleLinkedListTraversing { public static void main ( String [ ] args ) { final LinkedList < String > doubleLinkedList = IntStream . range ( 1 , 10 ) . mapToObj ( String :: valueOf ) . collect ( Collectors . toCollection ( LinkedList :: new ) ) ; doubleLinkedList . iterator ( ) . forEachRemaining ( System . out :: print ) ; System . out . println ( ) ; doubleLinkedList . descendingIterator ( ) . forEachRemaining ( System . out :: print ) ; } }
import java . awt . Color ; import java . awt . Graphics ; import javax . swing . JFrame ; public class DrawAPixel extends JFrame { public DrawAPixel ( ) { super ( " Red ▁ Pixel " ) ; setSize ( 320 , 240 ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setVisible ( true ) ; } @ Override public void paint ( Graphics g ) { g . setColor ( new Color ( 255 , 0 , 0 ) ) ; g . drawRect ( 100 , 100 , 1 , 1 ) ; } public static void main ( String [ ] args ) { new DrawAPixel ( ) ; } }
import java . awt . * ; import java . awt . event . ActionEvent ; import static java . lang . Math . * ; import javax . swing . * ; public class RotatingCube extends JPanel { double [ ] [ ] nodes = { { - 1 , - 1 , - 1 } , { - 1 , - 1 , 1 } , { - 1 , 1 , - 1 } , { - 1 , 1 , 1 } , { 1 , - 1 , - 1 } , { 1 , - 1 , 1 } , { 1 , 1 , - 1 } , { 1 , 1 , 1 } } ; int [ ] [ ] edges = { { 0 , 1 } , { 1 , 3 } , { 3 , 2 } , { 2 , 0 } , { 4 , 5 } , { 5 , 7 } , { 7 , 6 } , { 6 , 4 } , { 0 , 4 } , { 1 , 5 } , { 2 , 6 } , { 3 , 7 } } ; public RotatingCube ( ) { setPreferredSize ( new Dimension ( 640 , 640 ) ) ; setBackground ( Color . white ) ; scale ( 100 ) ; rotateCube ( PI / 4 , atan ( sqrt ( 2 ) ) ) ; new Timer ( 17 , ( ActionEvent e ) -> { rotateCube ( PI / 180 , 0 ) ; repaint ( ) ; } ) . start ( ) ; } final void scale ( double s ) { for ( double [ ] node : nodes ) { node [ 0 ] *= s ; node [ 1 ] *= s ; node [ 2 ] *= s ; } } final void rotateCube ( double angleX , double angleY ) { double sinX = sin ( angleX ) ; double cosX = cos ( angleX ) ; double sinY = sin ( angleY ) ; double cosY = cos ( angleY ) ; for ( double [ ] node : nodes ) { double x = node [ 0 ] ; double y = node [ 1 ] ; double z = node [ 2 ] ; node [ 0 ] = x * cosX - z * sinX ; node [ 2 ] = z * cosX + x * sinX ; z = node [ 2 ] ; node [ 1 ] = y * cosY - z * sinY ; node [ 2 ] = z * cosY + y * sinY ; } } void drawCube ( Graphics2D g ) { g . translate ( getWidth ( ) / 2 , getHeight ( ) / 2 ) ; for ( int [ ] edge : edges ) { double [ ] xy1 = nodes [ edge [ 0 ] ] ; double [ ] xy2 = nodes [ edge [ 1 ] ] ; g . drawLine ( ( int ) round ( xy1 [ 0 ] ) , ( int ) round ( xy1 [ 1 ] ) , ( int ) round ( xy2 [ 0 ] ) , ( int ) round ( xy2 [ 1 ] ) ) ; } for ( double [ ] node : nodes ) g . fillOval ( ( int ) round ( node [ 0 ] ) - 4 , ( int ) round ( node [ 1 ] ) - 4 , 8 , 8 ) ; } @ Override public void paintComponent ( Graphics gg ) { super . paintComponent ( gg ) ; Graphics2D g = ( Graphics2D ) gg ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; drawCube ( g ) ; } public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> { JFrame f = new JFrame ( ) ; f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; f . setTitle ( " Rotating ▁ Cube " ) ; f . setResizable ( false ) ; f . add ( new RotatingCube ( ) , BorderLayout . CENTER ) ; f . pack ( ) ; f . setLocationRelativeTo ( null ) ; f . setVisible ( true ) ; } ) ; } }
private static void normalize ( double [ ] v ) { double len = Math . sqrt ( v [ 0 ] * v [ 0 ] + v [ 1 ] * v [ 1 ] + v [ 2 ] * v [ 2 ] ) ; v [ 0 ] /= len ; v [ 1 ] /= len ; v [ 2 ] /= len ; }
private static double dot ( double [ ] x , double [ ] y ) { double d = x [ 0 ] * y [ 0 ] + x [ 1 ] * y [ 1 ] + x [ 2 ] * y [ 2 ] ; return d < 0 ? - d : 0 ; }
public static void drawSphere ( double R , double k , double ambient ) { double [ ] vec = new double [ 3 ] ; for ( int i = ( int ) Math . floor ( - R ) ; i <= ( int ) Math . ceil ( R ) ; i ++ ) { double x = i + .5 ; for ( int j = ( int ) Math . floor ( - 2 * R ) ; j <= ( int ) Math . ceil ( 2 * R ) ; j ++ ) { double y = j / 2. + .5 ; if ( x * x + y * y <= R * R ) { vec [ 0 ] = x ; vec [ 1 ] = y ; vec [ 2 ] = Math . sqrt ( R * R - x * x - y * y ) ; normalize ( vec ) ; double b = Math . pow ( dot ( light , vec ) , k ) + ambient ; int intensity = ( b <= 0 ) ? shades . length - 2 : ( int ) Math . max ( ( 1 - b ) * ( shades . length - 1 ) , 0 ) ; System . out . print ( shades [ intensity ] ) ; } else System . out . print ( ' ▁ ' ) ; } System . out . println ( ) ; } }
public static void main ( String [ ] args ) { DutchColors [ ] balls = new DutchColors [ 12 ] ; DutchColors [ ] values = DutchColors . values ( ) ; Random rand = new Random ( ) ; for ( int i = 0 ; i < balls . length ; i ++ ) balls [ i ] = values [ rand . nextInt ( values . length ) ] ; System . out . println ( " Before : ▁ " + Arrays . toString ( balls ) ) ; Arrays . sort ( balls ) ; System . out . println ( " After : ▁ ▁ " + Arrays . toString ( balls ) ) ; boolean sorted = true ; for ( int i = 1 ; i < balls . length ; i ++ ) { if ( balls [ i - 1 ] . compareTo ( balls [ i ] ) > 0 ) { sorted = false ; break ; } } System . out . println ( " Correctly ▁ sorted : ▁ " + sorted ) ; }
import java . util . HashMap ; import java . util . Map ; public class PrimeGaps { private Map < Integer , Integer > gapStarts = new HashMap < > ( ) ; private int lastPrime ; private PrimeGenerator primeGenerator = new PrimeGenerator ( 1000 , 500000 ) ; public static void main ( String [ ] args ) { final int limit = 100000000 ; PrimeGaps pg = new PrimeGaps ( ) ; for ( int pm = 10 , gap1 = 2 ; ; ) { int start1 = pg . findGapStart ( gap1 ) ; int gap2 = gap1 + 2 ; int start2 = pg . findGapStart ( gap2 ) ; int diff = start2 > start1 ? start2 - start1 : start1 - start2 ; if ( diff > pm ) { System . out . printf ( " Earliest ▁ difference ▁ >   % , d ▁ between ▁ adjacent ▁ prime ▁ gap ▁ starting ▁ primes : \n " + " Gap  % , d ▁ starts ▁ at  % , d , ▁ gap  % , d ▁ starts ▁ at  % , d , ▁ difference ▁ is  % , d . \n \n " , pm , gap1 , start1 , gap2 , start2 , diff ) ; if ( pm == limit ) break ; pm *= 10 ; } else { gap1 = gap2 ; } } } private int findGapStart ( int gap ) { Integer start = gapStarts . get ( gap ) ; if ( start != null ) return start ; for ( ; ; ) { int prev = lastPrime ; lastPrime = primeGenerator . nextPrime ( ) ; int diff = lastPrime - prev ; gapStarts . putIfAbsent ( diff , prev ) ; if ( diff == gap ) return prev ; } } }
import java . util . List ; public class Main { private static class Range { int start ; int end ; boolean print ; public Range ( int s , int e , boolean p ) { start = s ; end = e ; print = p ; } } public static void main ( String [ ] args ) { List < Range > rgs = List . of ( new Range ( 2 , 1000 , true ) , new Range ( 1000 , 4000 , true ) , new Range ( 2 , 10_000 , false ) , new Range ( 2 , 100_000 , false ) , new Range ( 2 , 1_000_000 , false ) , new Range ( 2 , 10_000_000 , false ) , new Range ( 2 , 100_000_000 , false ) , new Range ( 2 , 1_000_000_000 , false ) ) ; for ( Range rg : rgs ) { if ( rg . start == 2 ) { System . out . printf ( " eban ▁ numbers ▁ up ▁ to ▁ and ▁ including ▁ % d \n " , rg . end ) ; } else { System . out . printf ( " eban ▁ numbers ▁ between ▁ % d ▁ and ▁ % d \n " , rg . start , rg . end ) ; } int count = 0 ; for ( int i = rg . start ; i <= rg . end ; ++ i ) { int b = i / 1_000_000_000 ; int r = i % 1_000_000_000 ; int m = r / 1_000_000 ; r = i % 1_000_000 ; int t = r / 1_000 ; r %= 1_000 ; if ( m >= 30 && m <= 66 ) m %= 10 ; if ( t >= 30 && t <= 66 ) t %= 10 ; if ( r >= 30 && r <= 66 ) r %= 10 ; if ( b == 0 || b == 2 || b == 4 || b == 6 ) { if ( m == 0 || m == 2 || m == 4 || m == 6 ) { if ( t == 0 || t == 2 || t == 4 || t == 6 ) { if ( r == 0 || r == 2 || r == 4 || r == 6 ) { if ( rg . print ) System . out . printf ( " % d ▁ " , i ) ; count ++ ; } } } } } if ( rg . print ) { System . out . println ( ) ; } System . out . printf ( " count ▁ = ▁ % d \n \n " , count ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . net . ServerSocket ; import java . net . Socket ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; public class EchoServer { public static void main ( String [ ] args ) throws IOException { try ( ServerSocket listener = new ServerSocket ( 12321 ) ) { while ( true ) { Socket conn = listener . accept ( ) ; Thread clientThread = new Thread ( ( ) -> handleClient ( conn ) ) ; clientThread . start ( ) ; } } } private static void handleClient ( Socket connArg ) { Charset utf8 = StandardCharsets . UTF_8 ; try ( Socket conn = connArg ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( conn . getInputStream ( ) , utf8 ) ) ; PrintWriter out = new PrintWriter ( new OutputStreamWriter ( conn . getOutputStream ( ) , utf8 ) , true ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { out . println ( line ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class Eertree { public static void main ( String [ ] args ) { List < Node > tree = eertree ( " eertree " ) ; List < String > result = subPalindromes ( tree ) ; System . out . println ( result ) ; } private static class Node { int length ; Map < Character , Integer > edges = new HashMap < > ( ) ; int suffix ; public Node ( int length ) { this . length = length ; } public Node ( int length , Map < Character , Integer > edges , int suffix ) { this . length = length ; this . edges = edges != null ? edges : new HashMap < > ( ) ; this . suffix = suffix ; } } private static final int EVEN_ROOT = 0 ; private static final int ODD_ROOT = 1 ; private static List < Node > eertree ( String s ) { List < Node > tree = new ArrayList < > ( ) ; tree . add ( new Node ( 0 , null , ODD_ROOT ) ) ; tree . add ( new Node ( - 1 , null , ODD_ROOT ) ) ; int suffix = ODD_ROOT ; int n , k ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { char c = s . charAt ( i ) ; for ( n = suffix ; ; n = tree . get ( n ) . suffix ) { k = tree . get ( n ) . length ; int b = i - k - 1 ; if ( b >= 0 && s . charAt ( b ) == c ) { break ; } } if ( tree . get ( n ) . edges . containsKey ( c ) ) { suffix = tree . get ( n ) . edges . get ( c ) ; continue ; } suffix = tree . size ( ) ; tree . add ( new Node ( k + 2 ) ) ; tree . get ( n ) . edges . put ( c , suffix ) ; if ( tree . get ( suffix ) . length == 1 ) { tree . get ( suffix ) . suffix = 0 ; continue ; } while ( true ) { n = tree . get ( n ) . suffix ; int b = i - tree . get ( n ) . length - 1 ; if ( b >= 0 && s . charAt ( b ) == c ) { break ; } } tree . get ( suffix ) . suffix = tree . get ( n ) . edges . get ( c ) ; } return tree ; } private static List < String > subPalindromes ( List < Node > tree ) { List < String > s = new ArrayList < > ( ) ; subPalindromes_children ( 0 , " " , tree , s ) ; for ( Map . Entry < Character , Integer > cm : tree . get ( 1 ) . edges . entrySet ( ) ) { String ct = String . valueOf ( cm . getKey ( ) ) ; s . add ( ct ) ; subPalindromes_children ( cm . getValue ( ) , ct , tree , s ) ; } return s ; } private static void subPalindromes_children ( final int n , final String p , final List < Node > tree , List < String > s ) { for ( Map . Entry < Character , Integer > cm : tree . get ( n ) . edges . entrySet ( ) ) { Character c = cm . getKey ( ) ; Integer m = cm . getValue ( ) ; String pl = c + p + c ; s . add ( pl ) ; subPalindromes_children ( m , pl , tree , s ) ; } } }
static Pt fromY ( double y ) { return new Pt ( cbrt ( pow ( y , 2 ) - bCoeff ) , y ) ; }
import java . nio . file . Paths ; public static boolean isEmptyDir ( String dirName ) { return Paths . get ( dirName ) . toFile ( ) . listFiles ( ) . length == 0 ; }
public class EmptyApplet extends java . applet . Applet { @ Override public void init ( ) { } }
System . getenv ( " HOME " ) System . getenv ( )
private static int fitness ( String trial ) { int retVal = 0 ; for ( int i = 0 ; i < trial . length ( ) ; i ++ ) { if ( trial . charAt ( i ) == target . charAt ( i ) ) retVal ++ ; } return retVal ; }
private static String mutate ( String parent , double rate ) { String retVal = " " ; for ( int i = 0 ; i < parent . length ( ) ; i ++ ) { retVal += ( rand . nextDouble ( ) <= rate ) ? possibilities [ rand . nextInt ( possibilities . length ) ] : parent . charAt ( i ) ; } return retVal ; }
public class MyException extends Exception { } public class MyRuntimeException extends RuntimeException { }
public static void foo ( ) throws U1 { for ( int i = 0 ; i <= 1 ; i ++ ) { try { bar ( i ) ; } catch ( U0 e ) { System . out . println ( " Function ▁ foo ▁ caught ▁ exception ▁ U0" ) ; } } }
import java . util . Scanner ; import java . io . * ; public class Program { public static void main ( String [ ] args ) { try { Process p = Runtime . getRuntime ( ) . exec ( " cmd ▁ / C ▁ dir " ) ; Scanner sc = new Scanner ( p . getInputStream ( ) ) ; while ( sc . hasNext ( ) ) System . out . println ( sc . nextLine ( ) ) ; } catch ( IOException e ) { System . out . println ( e . getMessage ( ) ) ; } } }
public class Exp { public static void main ( String [ ] args ) { System . out . println ( pow ( 2 , 30 ) ) ; System . out . println ( pow ( 2.0 , 30 ) ) ; System . out . println ( pow ( 2.0 , - 2 ) ) ; } public static double pow ( double base , int exp ) { if ( exp < 0 ) return 1 / pow ( base , - exp ) ; double ans = 1.0 ; for ( ; exp > 0 ; -- exp ) ans *= base ; return ans ; } }
public class If2 { public static void if2 ( boolean firstCondition , boolean secondCondition , Runnable bothTrue , Runnable firstTrue , Runnable secondTrue , Runnable noneTrue ) { if ( firstCondition ) if ( secondCondition ) bothTrue . run ( ) ; else firstTrue . run ( ) ; else if ( secondCondition ) secondTrue . run ( ) ; else noneTrue . run ( ) ; } }
import java . util . * ; public class PrimeGenerator { private int limit_ ; private int index_ = 0 ; private int increment_ ; private int count_ = 0 ; private List < Integer > primes_ = new ArrayList < > ( ) ; private BitSet sieve_ = new BitSet ( ) ; private int sieveLimit_ = 0 ; public PrimeGenerator ( int initialLimit , int increment ) { limit_ = nextOddNumber ( initialLimit ) ; increment_ = increment ; primes_ . add ( 2 ) ; findPrimes ( 3 ) ; } public int nextPrime ( ) { if ( index_ == primes_ . size ( ) ) { if ( Integer . MAX_VALUE - increment_ < limit_ ) return 0 ; int start = limit_ + 2 ; limit_ = nextOddNumber ( limit_ + increment_ ) ; primes_ . clear ( ) ; findPrimes ( start ) ; } ++ count_ ; return primes_ . get ( index_ ++ ) ; } public int count ( ) { return count_ ; } private void findPrimes ( int start ) { index_ = 0 ; int newLimit = sqrt ( limit_ ) ; for ( int p = 3 ; p * p <= newLimit ; p += 2 ) { if ( sieve_ . get ( p / 2 - 1 ) ) continue ; int q = p * Math . max ( p , nextOddNumber ( ( sieveLimit_ + p - 1 ) / p ) ) ; for ( ; q <= newLimit ; q += 2 * p ) sieve_ . set ( q / 2 - 1 , true ) ; } sieveLimit_ = newLimit ; int count = ( limit_ - start ) / 2 + 1 ; BitSet composite = new BitSet ( count ) ; for ( int p = 3 ; p <= newLimit ; p += 2 ) { if ( sieve_ . get ( p / 2 - 1 ) ) continue ; int q = p * Math . max ( p , nextOddNumber ( ( start + p - 1 ) / p ) ) - start ; q /= 2 ; for ( ; q >= 0 && q < count ; q += p ) composite . set ( q , true ) ; } for ( int p = 0 ; p < count ; ++ p ) { if ( ! composite . get ( p ) ) primes_ . add ( p * 2 + start ) ; } } private static int sqrt ( int n ) { return nextOddNumber ( ( int ) Math . sqrt ( n ) ) ; } private static int nextOddNumber ( int n ) { return 1 + 2 * ( n / 2 ) ; } public static void main ( String [ ] args ) { PrimeGenerator pgen = new PrimeGenerator ( 20 , 200000 ) ; System . out . println ( " First ▁ 20 ▁ primes : " ) ; for ( int i = 0 ; i < 20 ; ++ i ) { if ( i > 0 ) System . out . print ( " , ▁ " ) ; System . out . print ( pgen . nextPrime ( ) ) ; } System . out . println ( ) ; System . out . println ( " Primes ▁ between ▁ 100 ▁ and ▁ 150 : " ) ; for ( int i = 0 ; ; ) { int prime = pgen . nextPrime ( ) ; if ( prime > 150 ) break ; if ( prime >= 100 ) { if ( i ++ != 0 ) System . out . print ( " , ▁ " ) ; System . out . print ( prime ) ; } } System . out . println ( ) ; int count = 0 ; for ( ; ; ) { int prime = pgen . nextPrime ( ) ; if ( prime > 8000 ) break ; if ( prime >= 7700 ) ++ count ; } System . out . println ( " Number ▁ of ▁ primes ▁ between ▁ 7700 ▁ and ▁ 8000 : ▁ " + count ) ; int n = 10000 ; for ( ; ; ) { int prime = pgen . nextPrime ( ) ; if ( prime == 0 ) { System . out . println ( " Can ' t ▁ generate ▁ any ▁ more ▁ primes . " ) ; break ; } if ( pgen . count ( ) == n ) { System . out . println ( n + " th ▁ prime : ▁ " + prime ) ; n *= 10 ; } } } }
package programas ; import java . math . BigInteger ; import java . util . InputMismatchException ; import java . util . Scanner ; public class IterativeFactorial { public BigInteger factorial ( BigInteger n ) { if ( n == null ) { throw new IllegalArgumentException ( ) ; } else if ( n . signum ( ) == - 1 ) { throw new IllegalArgumentException ( " Argument ▁ must ▁ be ▁ a ▁ non - negative ▁ integer " ) ; } else { BigInteger factorial = BigInteger . ONE ; for ( BigInteger i = BigInteger . ONE ; i . compareTo ( n ) < 1 ; i = i . add ( BigInteger . ONE ) ) { factorial = factorial . multiply ( i ) ; } return factorial ; } } public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; BigInteger number , result ; boolean error = false ; System . out . println ( " FACTORIAL ▁ OF ▁ A ▁ NUMBER " ) ; do { System . out . println ( " Enter ▁ a ▁ number : " ) ; try { number = scanner . nextBigInteger ( ) ; result = new IterativeFactorial ( ) . factorial ( number ) ; error = false ; System . out . println ( " Factorial ▁ of ▁ " + number + " : ▁ " + result ) ; } catch ( InputMismatchException e ) { error = true ; scanner . nextLine ( ) ; } catch ( IllegalArgumentException e ) { error = true ; scanner . nextLine ( ) ; } } while ( error ) ; scanner . close ( ) ; } }
public class Factorion { public static void main ( String [ ] args ) { System . out . println ( " Base ▁ 9 : " ) ; for ( int i = 1 ; i <= 1499999 ; i ++ ) { String iStri = String . valueOf ( i ) ; int multiplied = operate ( iStri , 9 ) ; if ( multiplied == i ) { System . out . print ( i + " \t " ) ; } } System . out . println ( " \n Base ▁ 10 : " ) ; for ( int i = 1 ; i <= 1499999 ; i ++ ) { String iStri = String . valueOf ( i ) ; int multiplied = operate ( iStri , 10 ) ; if ( multiplied == i ) { System . out . print ( i + " \t " ) ; } } System . out . println ( " \n Base ▁ 11 : " ) ; for ( int i = 1 ; i <= 1499999 ; i ++ ) { String iStri = String . valueOf ( i ) ; int multiplied = operate ( iStri , 11 ) ; if ( multiplied == i ) { System . out . print ( i + " \t " ) ; } } System . out . println ( " \n Base ▁ 12 : " ) ; for ( int i = 1 ; i <= 1499999 ; i ++ ) { String iStri = String . valueOf ( i ) ; int multiplied = operate ( iStri , 12 ) ; if ( multiplied == i ) { System . out . print ( i + " \t " ) ; } } } public static int factorialRec ( int n ) { int result = 1 ; return n == 0 ? result : result * n * factorialRec ( n - 1 ) ; } public static int operate ( String s , int base ) { int sum = 0 ; String strx = fromDeci ( base , Integer . parseInt ( s ) ) ; for ( int i = 0 ; i < strx . length ( ) ; i ++ ) { if ( strx . charAt ( i ) == ' A ' ) { sum += factorialRec ( 10 ) ; } else if ( strx . charAt ( i ) == ' B ' ) { sum += factorialRec ( 11 ) ; } else if ( strx . charAt ( i ) == ' C ' ) { sum += factorialRec ( 12 ) ; } else { sum += factorialRec ( Integer . parseInt ( String . valueOf ( strx . charAt ( i ) ) , base ) ) ; } } return sum ; } static char reVal ( int num ) { if ( num >= 0 && num <= 9 ) return ( char ) ( num + 48 ) ; else return ( char ) ( num - 10 + 65 ) ; } static String fromDeci ( int base , int num ) { StringBuilder s = new StringBuilder ( ) ; while ( num > 0 ) { s . append ( reVal ( num % base ) ) ; num /= base ; } return new String ( new StringBuilder ( s ) . reverse ( ) ) ; } }
public static boolean isPrime ( long n ) { if ( n == 2 ) return true ; if ( ( n < 2 ) || ( ( n & 1 ) == 0 ) ) return false ; long maxFactor = ( long ) Math . sqrt ( ( double ) n ) ; for ( long possibleFactor = 3 ; possibleFactor <= maxFactor ; possibleFactor += 2 ) if ( ( n % possibleFactor ) == 0 ) return false ; return true ; }
static void fft ( Complex [ ] buffer ) { int bits = ( int ) ( log ( buffer . length ) / log ( 2 ) ) ; for ( int j = 1 ; j < buffer . length / 2 ; j ++ ) { int swapPos = bitReverse ( j , bits ) ; Complex temp = buffer [ j ] ; buffer [ j ] = buffer [ swapPos ] ; buffer [ swapPos ] = temp ; } for ( int N = 2 ; N <= buffer . length ; N <<= 1 ) { for ( int i = 0 ; i < buffer . length ; i += N ) { for ( int k = 0 ; k < N / 2 ; k ++ ) { int evenIndex = i + k ; int oddIndex = i + k + ( N / 2 ) ; Complex even = buffer [ evenIndex ] ; Complex odd = buffer [ oddIndex ] ; double term = ( - 2 * PI * k ) / ( double ) N ; Complex exp = ( new Complex ( cos ( term ) , sin ( term ) ) . mult ( odd ) ) ; buffer [ evenIndex ] = even . add ( exp ) ; buffer [ oddIndex ] = even . sub ( exp ) ; } } } }
public static void main ( String [ ] args ) { for ( int i = 0 ; i <= 9 ; ++ i ) { Frac [ ] coeffs = faulhaberTriangle ( i ) ; for ( Frac coeff : coeffs ) { System . out . printf ( " % 5s ▁ ▁ " , coeff ) ; } System . out . println ( ) ; } System . out . println ( ) ; int k = 17 ; Frac [ ] cc = faulhaberTriangle ( k ) ; int n = 1000 ; BigDecimal nn = BigDecimal . valueOf ( n ) ; BigDecimal np = BigDecimal . ONE ; BigDecimal sum = BigDecimal . ZERO ; for ( Frac c : cc ) { np = np . multiply ( nn ) ; sum = sum . add ( np . multiply ( c . toBigDecimal ( ) ) ) ; } System . out . println ( sum . toBigInteger ( ) ) ; }
public class Feigenbaum { public static void main ( String [ ] args ) { int max_it = 13 ; int max_it_j = 10 ; double a1 = 1.0 ; double a2 = 0.0 ; double d1 = 3.2 ; double a ; System . out . println ( " ▁ i ▁ ▁ ▁ ▁ ▁ ▁ ▁ d " ) ; for ( int i = 2 ; i <= max_it ; i ++ ) { a = a1 + ( a1 - a2 ) / d1 ; for ( int j = 0 ; j < max_it_j ; j ++ ) { double x = 0.0 ; double y = 0.0 ; for ( int k = 0 ; k < 1 << i ; k ++ ) { y = 1.0 - 2.0 * y * x ; x = a - x * x ; } a -= x / y ; } double d = ( a1 - a2 ) / ( a - a1 ) ; System . out . printf ( " % 2d ▁ ▁ ▁   % .8f \n " , i , d ) ; d1 = d ; a2 = a1 ; a1 = a ; } } }
public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> { JFrame f = new JFrame ( ) ; f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; f . setTitle ( " Fibonacci ▁ Word ▁ Fractal " ) ; f . setResizable ( false ) ; f . add ( new FibonacciWordFractal ( 23 ) , BorderLayout . CENTER ) ; f . pack ( ) ; f . setLocationRelativeTo ( null ) ; f . setVisible ( true ) ; } ) ; }
import java . io . * ; public class FileIODemo { public static void main ( String [ ] args ) { try { FileInputStream in = new FileInputStream ( " input . txt " ) ; FileOutputStream out = new FileOutputStream ( " ouput . txt " ) ; int c ; while ( ( c = in . read ( ) ) != - 1 ) { out . write ( c ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
import java . io . File ; import java . util . Date ; public class FileModificationTimeTest { public static void test ( String type , File file ) { long t = file . lastModified ( ) ; System . out . println ( " The ▁ following ▁ " + type + " ▁ called ▁ " + file . getPath ( ) + ( t == 0 ? " ▁ does ▁ not ▁ exist . " : " ▁ was ▁ modified ▁ at ▁ " + new Date ( t ) . toString ( ) ) ) ; System . out . println ( " The ▁ following ▁ " + type + " ▁ called ▁ " + file . getPath ( ) + ( ! file . setLastModified ( System . currentTimeMillis ( ) ) ? " ▁ does ▁ not ▁ exist . " : " ▁ was ▁ modified ▁ to ▁ current ▁ time . " ) ) ; System . out . println ( " The ▁ following ▁ " + type + " ▁ called ▁ " + file . getPath ( ) + ( ! file . setLastModified ( t ) ? " ▁ does ▁ not ▁ exist . " : " ▁ was ▁ modified ▁ to ▁ previous ▁ time . " ) ) ; } public static void main ( String args [ ] ) { test ( " file " , new File ( " output . txt " ) ) ; test ( " directory " , new File ( " docs " ) ) ; } }
import java . io . File ; public class FileSize { public static void main ( String [ ] args ) { System . out . println ( " input . txt ▁   : ▁ " + new File ( " input . txt " ) . length ( ) + " ▁ bytes " ) ; System . out . println ( " / input . txt  : ▁ " + new File ( " / input . txt " ) . length ( ) + " ▁ bytes " ) ; } }
int [ ] array = { 1 , 2 , 3 , 4 , 5 } ; List < Integer > evensList = new ArrayList < Integer > ( ) ; for ( int i : array ) { if ( i % 2 == 0 ) evensList . add ( i ) ; } int [ ] evens = evensList . toArray ( new int [ 0 ] ) ;
public class RecursionTest { private static void recurse ( int i ) { try { recurse ( i + 1 ) ; } catch ( StackOverflowError e ) { System . out . print ( " Recursion ▁ depth ▁ on ▁ this ▁ system ▁ is ▁ " + i + " . " ) ; } } public static void main ( String [ ] args ) { recurse ( 0 ) ; } }
import java . util . Scanner ; public class LastSunday { static final String [ ] months = { " January " , " February " , " March " , " April " , " May " , " June " , " July " , " August " , " September " , " October " , " November " , " December " } ; public static int [ ] findLastSunday ( int year ) { boolean isLeap = isLeapYear ( year ) ; int [ ] days = { 31 , isLeap ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; int [ ] lastDay = new int [ 12 ] ; for ( int m = 0 ; i < 12 ; i ++ ) { int d ; for ( d = days [ m ] ; getWeekDay ( year , m , d ) != 0 ; d -- ) ; lastDay [ m ] = d ; } return lastDay ; } private static boolean isLeapYear ( int year ) { if ( year % 4 == 0 ) { if ( year % 100 != 0 ) return true ; else if ( year % 400 == 0 ) return true ; } return false ; } private static int getWeekDay ( int y , int m , int d ) { int f = y + d + 3 * m - 1 ; m ++ ; if ( m < 3 ) y -- ; else f -= ( int ) ( 0.4 * m + 2.3 ) ; f += ( int ) ( y / 4 ) - ( int ) ( ( y / 100 + 1 ) * 0.75 ) ; f %= 7 ; return f ; } private static void display ( int year , int [ ] lastDay ) { System . out . println ( " \n YEAR : ▁ " + year ) ; for ( int m = 0 ; i < 12 ; i ++ ) System . out . println ( months [ m ] + " : ▁ " + lastDay [ m ] ) ; } public static void main ( String [ ] args ) throws Exception { System . out . print ( " Enter ▁ year : ▁ " ) ; Scanner s = new Scanner ( System . in ) ; int y = Integer . parseInt ( s . next ( ) ) ; int [ ] lastDay = findLastSunday ( y ) ; display ( y , lastDay ) ; s . close ( ) ; } }
import java . util . ArrayList ; import com . google . common . base . Joiner ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Lists ; public class FindMissingPermutation { public static void main ( String [ ] args ) { Joiner joiner = Joiner . on ( " " ) . skipNulls ( ) ; ImmutableSet < String > s = ImmutableSet . of ( " ABCD " , " CABD " , " ACDB " , " DACB " , " BCDA " , " ACBD " , " ADCB " , " CDAB " , " DABC " , " BCAD " , " CADB " , " CDBA " , " CBAD " , " ABDC " , " ADBC " , " BDCA " , " DCBA " , " BACD " , " BADC " , " BDAC " , " CBDA " , " DBCA " , " DCAB " ) ; for ( ArrayList < Character > cs : Utils . Permutations ( Lists . newArrayList ( ' A ' , ' B ' , ' C ' , ' D ' ) ) ) if ( ! s . contains ( joiner . join ( cs ) ) ) System . out . println ( joiner . join ( cs ) ) ; } }
public static void main ( String [ ] args ) { System . out . println ( " base ▁ inc ▁ id ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ root ▁ ▁ ▁ ▁ square ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ test ▁ count ▁ ▁ ▁ ▁ time ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ total " ) ; st0 = System . nanoTime ( ) ; for ( base = 2 ; base < 28 ; ++ base ) { doOne ( ) ; } }
public static int p ( int l , int n ) { int test = 0 ; double log = Math . log ( 2 ) / Math . log ( 10 ) ; int factor = 1 ; int loop = l ; while ( loop > 10 ) { factor *= 10 ; loop /= 10 ; } while ( n > 0 ) { test ++ ; int val = ( int ) ( factor * Math . pow ( 10 , test * log % 1 ) ) ; if ( val == l ) { n -- ; } } return test ; }
static double [ ] fivenum ( double [ ] x ) { for ( Double d : x ) { if ( d . isNaN ( ) ) throw new IllegalArgumentException ( " Unable ▁ to ▁ deal ▁ with ▁ arrays ▁ containing ▁ NaN " ) ; } double [ ] result = new double [ 5 ] ; Arrays . sort ( x ) ; result [ 0 ] = x [ 0 ] ; result [ 2 ] = median ( x , 0 , x . length - 1 ) ; result [ 4 ] = x [ x . length - 1 ] ; int m = x . length / 2 ; int lowerEnd = ( x . length % 2 == 1 ) ? m : m - 1 ; result [ 1 ] = median ( x , 0 , lowerEnd ) ; result [ 3 ] = median ( x , m , x . length - 1 ) ; return result ; }
public class FizzBuzz { public static void main ( String [ ] args ) { for ( int number = 1 ; number <= 100 ; number ++ ) { if ( number % 15 == 0 ) { System . out . println ( " FizzBuzz " ) ; } else if ( number % 3 == 0 ) { System . out . println ( " Fizz " ) ; } else if ( number % 5 == 0 ) { System . out . println ( " Buzz " ) ; } else { System . out . println ( number ) ; } } } }
switch ( xx ) { case 1 : case 2 : ... break ; case 4 : ... break ; case 5 : ... break ; default : break ; } for ( int i = 0 ; i < 10 ; ++ i ) { ... if ( some_condition ) { break ; } ... } _Time_ : do { for ( int i = 0 ; i < 10 ; ++ i ) { ... if ( some_condition ) { break _Time_ ; } ... } ... } while ( thisCondition ) ;
static void floydWarshall ( int [ ] [ ] weights , int numVertices ) { double [ ] [ ] dist = new double [ numVertices ] [ numVertices ] ; for ( double [ ] row : dist ) Arrays . fill ( row , Double . POSITIVE_INFINITY ) ; for ( int [ ] w : weights ) dist [ w [ 0 ] - 1 ] [ w [ 1 ] - 1 ] = w [ 2 ] ; int [ ] [ ] next = new int [ numVertices ] [ numVertices ] ; for ( int i = 0 ; i < next . length ; i ++ ) { for ( int j = 0 ; j < next . length ; j ++ ) if ( i != j ) next [ i ] [ j ] = j + 1 ; } for ( int k = 0 ; k < numVertices ; k ++ ) for ( int i = 0 ; i < numVertices ; i ++ ) for ( int j = 0 ; j < numVertices ; j ++ ) if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) { dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; next [ i ] [ j ] = next [ i ] [ k ] ; } printResult ( dist , next ) ; }
import java . io . IOException ; import java . io . InputStreamReader ; import java . io . BufferedReader ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; public class RFork { public static void main ( String [ ] args ) { ProcessBuilder pb ; Process pp ; List < String > command ; Map < String , String > env ; BufferedReader ir ; String currentuser ; String line ; try { command = Arrays . asList ( " " ) ; pb = new ProcessBuilder ( command ) ; env = pb . environment ( ) ; currentuser = env . get ( " USER " ) ; command = Arrays . asList ( " ps " , " - f " , " - U " , currentuser ) ; pb . command ( command ) ; pp = pb . start ( ) ; ir = new BufferedReader ( new InputStreamReader ( pp . getInputStream ( ) ) ) ; line = " Output ▁ of ▁ running ▁ " + command . toString ( ) + " ▁ is : " ; do { System . out . println ( line ) ; } while ( ( line = ir . readLine ( ) ) != null ) ; } catch ( IOException iox ) { iox . printStackTrace ( ) ; } return ; } }
public class Printing { public static void main ( String [ ] args ) { double value = 7.125 ; System . out . printf ( " % 09.3f " , value ) ; System . out . println ( String . format ( " % 09.3f " , value ) ) ; } }
static List < Point > translateToOrigin ( List < Point > poly ) { final Point min = findMinima ( poly ) ; poly . replaceAll ( p -> new Point ( p . x - min . x , p . y - min . y ) ) ; return poly ; }
static List < List < Point > > rotationsAndReflections ( List < Point > poly ) { List < List < Point > > lst = new ArrayList < > ( ) ; lst . add ( poly ) ; for ( Function < Point , Point > t : transforms ) lst . add ( poly . stream ( ) . map ( t ) . collect ( toList ( ) ) ) ; return lst ; }
static List < Point > newPoints ( List < Point > poly ) { return poly . stream ( ) . flatMap ( p -> neighborhoods ( p ) . stream ( ) ) . filter ( p -> ! poly . contains ( p ) ) . distinct ( ) . collect ( toList ( ) ) ; }
static List < List < Point > > rank ( int n ) { if ( n < 0 ) throw new IllegalArgumentException ( " n ▁ cannot ▁ be ▁ negative " ) ; if ( n < 2 ) { List < List < Point > > r = new ArrayList < > ( ) ; if ( n == 1 ) r . add ( asList ( new Point ( 0 , 0 ) ) ) ; return r ; } return rank ( n - 1 ) . stream ( ) . parallel ( ) . flatMap ( lst -> constructNextRank ( lst ) . stream ( ) ) . distinct ( ) . collect ( toList ( ) ) ; }
import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import org . apache . commons . net . ftp . FTP ; import org . apache . commons . net . ftp . FTPClient ; import org . apache . commons . net . ftp . FTPFile ; import org . apache . commons . net . ftp . FTPReply ; public class FTPconn { public static void main ( String [ ] args ) throws IOException { String server = " ftp . hq . nasa . gov " ; int port = 21 ; String user = " anonymous " ; String pass = " ftptest @ example . com " ; OutputStream output = null ; FTPClient ftpClient = new FTPClient ( ) ; try { ftpClient . connect ( server , port ) ; serverReply ( ftpClient ) ; int replyCode = ftpClient . getReplyCode ( ) ; if ( ! FTPReply . isPositiveCompletion ( replyCode ) ) { System . out . println ( " Failure . ▁ Server ▁ reply ▁ code : ▁ " + replyCode ) ; return ; } serverReply ( ftpClient ) ; if ( ! ftpClient . login ( user , pass ) ) { System . out . println ( " Could ▁ not ▁ login ▁ to ▁ the ▁ server . " ) ; return ; } String dir = " pub / issoutreach / Living ▁ in ▁ Space ▁ Stories ▁ ( MP3 ▁ Files ) / " ; if ( ! ftpClient . changeWorkingDirectory ( dir ) ) { System . out . println ( " Change ▁ directory ▁ failed . " ) ; return ; } ftpClient . enterLocalPassiveMode ( ) ; for ( FTPFile file : ftpClient . listFiles ( ) ) System . out . println ( file ) ; String filename = " Can ▁ People ▁ go ▁ to ▁ Mars . mp3" ; output = new FileOutputStream ( filename ) ; ftpClient . setFileType ( FTP . BINARY_FILE_TYPE ) ; if ( ! ftpClient . retrieveFile ( filename , output ) ) { System . out . println ( " Retrieving ▁ file ▁ failed " ) ; return ; } serverReply ( ftpClient ) ; ftpClient . logout ( ) ; } finally { if ( output != null ) output . close ( ) ; } } private static void serverReply ( FTPClient ftpClient ) { for ( String reply : ftpClient . getReplyStrings ( ) ) { System . out . println ( reply ) ; } } }
public class Compose { public interface Fun < A , B > { B call ( A x ) ; } public static < A , B , C > Fun < A , C > compose ( final Fun < B , C > f , final Fun < A , B > g ) { return new Fun < A , C > ( ) { public C call ( A x ) { return f . call ( g . call ( x ) ) ; } } ; } public static void main ( String [ ] args ) { Fun < Double , Double > sin = new Fun < Double , Double > ( ) { public Double call ( Double x ) { return Math . sin ( x ) ; } } ; Fun < Double , Double > asin = new Fun < Double , Double > ( ) { public Double call ( Double x ) { return Math . asin ( x ) ; } } ; Fun < Double , Double > sin_asin = compose ( sin , asin ) ; System . out . println ( sin_asin . call ( 0.5 ) ) ; } }
public static double multiply ( double a , double b ) { return a * b ; }
public static void main ( final String [ ] args ) { new GaltonBox ( 8 , 200 ) . run ( ) ; }
import java . util . List ; public class GapfulNumbers { private static String commatize ( long n ) { StringBuilder sb = new StringBuilder ( Long . toString ( n ) ) ; int le = sb . length ( ) ; for ( int i = le - 3 ; i >= 1 ; i -= 3 ) { sb . insert ( i , ' , ' ) ; } return sb . toString ( ) ; } public static void main ( String [ ] args ) { List < Long > starts = List . of ( ( long ) 1e2 , ( long ) 1e6 , ( long ) 1e7 , ( long ) 1e9 , ( long ) 7123 ) ; List < Integer > counts = List . of ( 30 , 15 , 15 , 10 , 25 ) ; for ( int i = 0 ; i < starts . size ( ) ; ++ i ) { int count = 0 ; Long j = starts . get ( i ) ; long pow = 100 ; while ( j >= pow * 10 ) { pow *= 10 ; } System . out . printf ( " First ▁ % d ▁ gapful ▁ numbers ▁ starting ▁ at ▁ % s : \n " , counts . get ( i ) , commatize ( starts . get ( i ) ) ) ; while ( count < counts . get ( i ) ) { long fl = ( j / pow ) * 10 + ( j % 10 ) ; if ( j % fl == 0 ) { System . out . printf ( " % d ▁ " , j ) ; count ++ ; } j ++ ; if ( j >= 10 * pow ) { pow *= 10 ; } } System . out . println ( ' \n ' ) ; } } }
import java . util . Random ; public class GaussJordan { public static void main ( String [ ] args ) { int rows = 5 ; Matrix m = new Matrix ( rows , rows ) ; Random r = new Random ( ) ; for ( int row = 0 ; row < rows ; ++ row ) { for ( int column = 0 ; column < rows ; ++ column ) m . set ( row , column , r . nextDouble ( ) ) ; } System . out . println ( " Matrix : " ) ; m . print ( ) ; System . out . println ( " Inverse : " ) ; Matrix inv = m . inverse ( ) ; inv . print ( ) ; System . out . println ( " Product ▁ of ▁ matrix ▁ and ▁ inverse : " ) ; Matrix . product ( m , inv ) . print ( ) ; } }
public class LowerAscii { public static void main ( String [ ] args ) { StringBuilder sb = new StringBuilder ( 26 ) ; for ( char ch = ' a ' ; ch <= ' z ' ; ch ++ ) sb . append ( ch ) ; System . out . printf ( " lower ▁ ascii : ▁ % s , ▁ length : ▁ % s " , sb , sb . length ( ) ) ; } }
static void placeKings ( char [ ] [ ] grid ) { int r1 , c1 , r2 , c2 ; while ( true ) { r1 = rand . nextInt ( 8 ) ; c1 = rand . nextInt ( 8 ) ; r2 = rand . nextInt ( 8 ) ; c2 = rand . nextInt ( 8 ) ; if ( r1 != r2 && abs ( r1 - r2 ) > 1 && abs ( c1 - c2 ) > 1 ) break ; } grid [ r1 ] [ c1 ] = ' K ' ; grid [ r2 ] [ c2 ] = ' k ' ; }
import java . util . * ; public class RandomShuffle { public static void main ( String [ ] args ) { Random rand = new Random ( ) ; List < Integer > list = new ArrayList < > ( ) ; for ( int j = 1 ; j <= 20 ; ++ j ) list . add ( j ) ; Collections . shuffle ( list , rand ) ; System . out . println ( list ) ; } }
class Pair < T > { T first ; T second ; } public static < T > void swap ( Pair < T > p ) { T temp = p . first ; p . first = p . second ; p . second = temp ; }
private static Vector e ( int n ) { if ( n > 4 ) { throw new IllegalArgumentException ( " n ▁ must ▁ be ▁ less ▁ than ▁ 5" ) ; } Vector result = new Vector ( new double [ 32 ] ) ; result . set ( 1 << n , 1.0 ) ; return result ; }
import java . io . * ; import java . nio . file . * ; public class GloballyReplaceText { public static void main ( String [ ] args ) throws IOException { for ( String fn : new String [ ] { " test1 . txt " , " test2 . txt " } ) { String s = new String ( Files . readAllBytes ( Paths . get ( fn ) ) ) ; s = s . replace ( " Goodbye ▁ London ! " , " Hello ▁ New ▁ York ! " ) ; try ( FileWriter fw = new FileWriter ( fn ) ) { fw . write ( s ) ; } } } }
# ! / usr / bin / perl use strict ; # https : use warnings ; use List : : Util qw ( first shuffle ) ; my $pat = qr / [ atjqk2 - 9 ] / ; # ranks my $deck = join '', shuffle map { my $rank = $_; map "$rank$_", qw( S H C D ) } qw ( a t j q k ) , 2 . . 9 ; my $mebooks = my $youbooks = 0 ; my $me = substr $deck , 0 , 2 * 9 , ''; my $mepicks = join '', $me =~ /$pat/g; arrange ( $me ) ; $mebooks ++ while $me = ~ s / ( $pat ) . \ 1. \ 1. \ 1. my $you = substr $deck , 0 , 2 * 9 , ''; my $youpicks = join '', $you =~ /$pat/g; arrange ( $you ) ; $youbooks ++ while $you = ~ s / ( $pat ) . \ 1. \ 1. \ 1. while ( $mebooks + $youbooks < 13 ) { play ( \ $you , \ $youbooks , \ $youpicks , \ $me , \ $mebooks , 1 ) ; $mebooks + $youbooks == 13 and last ; play ( \ $me , \ $mebooks , \ $mepicks , \ $you , \ $youbooks , 0 ) ; } print " me ▁ $ mebooks ▁ you ▁ $ youbooks \n " ; sub arrange { $_ [ 0 ] = join '', sort $_[0] =~ /../g } sub human { my $have = shift = ~ s / ( $pat ) . \ K ( ? ! \ 1 ) / / gr ; local $ | = 1 ; my $pick ; do { print " You ▁ have ▁ $ have , ▁ enter ▁ request : ▁ " ; ( $pick ) = lc ( < STDIN > ) = ~ / $pat / g ; } until $pick and $have = ~ / $pick / ; return $pick ; } sub play { my ( $me , $mb , $lastpicks , $you , $yb , $human ) = @ _ ; my $more = 1 ; while ( arrange ( $$me ) , $more and $$mb + $$yb < 13 ) { # use Data : : Dump ' dd ' ; dd \ @ _ , " deck ▁ $ deck " ; if ( $$me = ~ s / ( $pat ) . \ 1. \ 1. \ 1. { print " book ▁ of ▁ $ & \n " ; $$mb ++ ; } elsif ( $$me ) { my $pick = $human ? do { human ( $$me ) } : do { my % picks ; $picks { $_ } ++ for my @ picks = $$me = ~ / $pat / g ; my $pick = first { $picks { $_ } } split ( print " pick ▁ $ pick \n " ; $$lastpicks = ~ s / $pick $$lastpicks . = $pick ; $pick ; } ; if ( $$you = ~ s / ( ? : $pick . ) + { $$me . = $ & ; } else { print " GO ▁ FISH  ! ! \n " ; $$me . = substr $deck , 0 , 2 , ''; $more = 0 ; } } elsif ( $deck ) { $$me . = substr $deck , 0 , 2 , ''; } else { $more = 0 ; } } arrange ( $$me ) ; }
public static long grayEncode ( long n ) { return n ^ ( n >>> 1 ) ; }
public static long grayDecode ( long n ) { long p = n ; while ( ( n >>>= 1 ) != 0 ) p ^= n ; return p ; }
void convertToGrayscale ( final BufferedImage image ) { for ( int i = 0 ; i < image . getWidth ( ) ; i ++ ) { for ( int j = 0 ; j < image . getHeight ( ) ; j ++ ) { int color = image . getRGB ( i , j ) ; int alpha = ( color >> 24 ) & 255 ; int red = ( color >> 16 ) & 255 ; int green = ( color >> 8 ) & 255 ; int blue = ( color ) & 255 ; final int lum = ( int ) ( 0.2126 * red + 0.7152 * green + 0.0722 * blue ) ; alpha = ( alpha << 24 ) ; red = ( lum << 16 ) ; green = ( lum << 8 ) ; blue = lum ; color = alpha + red + green + blue ; image . setRGB ( i , j , color ) ; } } }
public static long gcd ( long a , long b ) { long factor = Math . min ( a , b ) ; for ( long loop = factor ; loop > 1 ; loop -- ) { if ( a % loop == 0 && b % loop == 0 ) { return loop ; } } return 1 ; }
public static float max ( float [ ] values ) throws NoSuchElementException { if ( values . length == 0 ) throw new NoSuchElementException ( ) ; float themax = values [ 0 ] ; for ( int idx = 1 ; idx < values . length ; ++ idx ) { if ( values [ idx ] > themax ) themax = values [ idx ] ; } return themax ; }
import java . util . Scanner ; import java . util . ArrayList ; public class Sub { private static int [ ] indices ; public static void main ( String [ ] args ) { ArrayList < Long > array = new ArrayList < Long > ( ) ; Scanner in = new Scanner ( System . in ) ; while ( in . hasNextLong ( ) ) array . add ( in . nextLong ( ) ) ; long highSum = Long . MIN_VALUE ; ArrayList < Long > highSet = new ArrayList < Long > ( ) ; for ( int subSize = 0 ; subSize <= array . size ( ) ; subSize ++ ) { indices = new int [ subSize ] ; for ( int i = 0 ; i < subSize ; i ++ ) indices [ i ] = i ; do { long sum = 0 ; ArrayList < Long > temp = new ArrayList < Long > ( ) ; for ( long index : indices ) { sum += array . get ( index ) ; temp . add ( array . get ( index ) ) ; } if ( sum > highSum ) { highSet = temp ; highSum = sum ; } } while ( nextIndices ( array ) ) ; } System . out . println ( " Sum : ▁ " + highSum + " \n Set : ▁ " + highSet ) ; } private static boolean nextIndices ( ArrayList < Long > a ) { for ( int i = indices . length - 1 ; i >= 0 ; -- i ) { indices [ i ] ++ ; for ( int j = i + 1 ; j < indices . length ; ++ j ) { indices [ j ] = indices [ j - 1 ] + 1 ; } if ( indices [ indices . length - 1 ] < a . size ( ) ) { return true ; } } return false ; } }
import javax . swing . * ; import java . awt . * ; public class Greybars extends JFrame { private int width ; private int height ; public Greybars ( ) { super ( " grey ▁ bars ▁ example ! " ) ; width = 640 ; height = 320 ; setSize ( width , height ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setVisible ( true ) ; } public void paint ( Graphics g ) { int run = 0 ; double colorcomp = 0.0 ; for ( int columncount = 8 ; columncount < 128 ; columncount *= 2 ) { double colorgap = 255.0 / ( columncount - 1 ) ; int columnwidth = width / columncount ; int columnheight = height / 4 ; if ( run % 2 == 0 ) colorcomp = 0.0 ; else { colorcomp = 255.0 ; colorgap *= - 1.0 ; } int ystart = 0 + columnheight * run ; int xstart = 0 ; for ( int i = 0 ; i < columncount ; i ++ ) { int icolor = ( int ) Math . round ( colorcomp ) ; Color nextColor = new Color ( icolor , icolor , icolor ) ; g . setColor ( nextColor ) ; g . fillRect ( xstart , ystart , columnwidth , columnheight ) ; xstart += columnwidth ; colorcomp += colorgap ; } run ++ ; } } public static void main ( String [ ] args ) { Greybars gb = new Greybars ( ) ; } }
public class Guessing { public static void main ( String [ ] args ) throws NumberFormatException { int n = ( int ) ( Math . random ( ) * 10 + 1 ) ; System . out . print ( " Guess ▁ the ▁ number ▁ between ▁ 1 ▁ and ▁ 10 : ▁ " ) ; while ( Integer . parseInt ( System . console ( ) . readLine ( ) ) != n ) { System . out . print ( " Wrong ! ▁ Guess ▁ again : ▁ " ) ; } System . out . println ( " Well ▁ guessed ! " ) ; } }
import java . util . AbstractList ; import java . util . Collections ; import java . util . Scanner ; public class GuessNumber { public static final int LOWER = 0 , UPPER = 100 ; public static void main ( String [ ] args ) { System . out . printf ( " Instructions : \n " + " Think ▁ of ▁ integer ▁ number ▁ from ▁ % d ▁ ( inclusive ) ▁ to ▁ % d ▁ ( exclusive ) ▁ and \n " + " I ▁ will ▁ guess ▁ it . ▁ After ▁ each ▁ guess , ▁ you ▁ respond ▁ with ▁ L , ▁ H , ▁ or ▁ C ▁ depending \n " + " on ▁ if ▁ my ▁ guess ▁ was ▁ too ▁ low , ▁ too ▁ high , ▁ or ▁ correct . \n " , LOWER , UPPER ) ; int result = Collections . binarySearch ( new AbstractList < Integer > ( ) { private final Scanner in = new Scanner ( System . in ) ; public int size ( ) { return UPPER - LOWER ; } public Integer get ( int i ) { System . out . printf ( " My ▁ guess ▁ is : ▁ % d . ▁ Is ▁ it ▁ too ▁ high , ▁ too ▁ low , ▁ or ▁ correct ? ▁ ( H / L / C ) ▁ " , LOWER + i ) ; String s = in . nextLine ( ) ; assert s . length ( ) > 0 ; switch ( Character . toLowerCase ( s . charAt ( 0 ) ) ) { case ' l ' : return - 1 ; case ' h ' : return 1 ; case ' c ' : return 0 ; } return - 1 ; } } , 0 ) ; if ( result < 0 ) System . out . println ( " That ▁ is ▁ impossible . " ) ; else System . out . printf ( " Your ▁ number ▁ is ▁ % d . \n " , result ) ; } }
import java . util . Random ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; Random random = new Random ( ) ; long from = 1 ; long to = 100 ; int randomNumber = random . nextInt ( to - from + 1 ) + from ; int guessedNumber = 0 ; System . out . printf ( " The ▁ number ▁ is ▁ between ▁ % d ▁ and ▁ % d . \n " , from , to ) ; do { System . out . print ( " Guess ▁ what ▁ the ▁ number ▁ is : ▁ " ) ; guessedNumber = scan . nextInt ( ) ; if ( guessedNumber > randomNumber ) System . out . println ( " Your ▁ guess ▁ is ▁ too ▁ high ! " ) ; else if ( guessedNumber < randomNumber ) System . out . println ( " Your ▁ guess ▁ is ▁ too ▁ low ! " ) ; else System . out . println ( " You ▁ got ▁ it ! " ) ; } while ( guessedNumber != randomNumber ) ; } }
public static void main ( String [ ] args ) { new Interact ( ) . setVisible ( true ) ; }
import java . awt . * ; import javax . swing . JFrame ; public class Test extends JFrame { public static void main ( String [ ] args ) { new Test ( ) ; } Test ( ) { Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; Dimension screenSize = toolkit . getScreenSize ( ) ; System . out . println ( " Physical ▁ screen ▁ size : ▁ " + screenSize ) ; Insets insets = toolkit . getScreenInsets ( getGraphicsConfiguration ( ) ) ; System . out . println ( " Insets : ▁ " + insets ) ; screenSize . width -= ( insets . left + insets . right ) ; screenSize . height -= ( insets . top + insets . bottom ) ; System . out . println ( " Max ▁ available : ▁ " + screenSize ) ; } }
import sun . misc . Signal ; import sun . misc . SignalHandler ; public class ExampleSignalHandler { public static void main ( String ... args ) throws InterruptedException { final long start = System . nanoTime ( ) ; Signal . handle ( new Signal ( " INT " ) , new SignalHandler ( ) { public void handle ( Signal sig ) { System . out . format ( " \n Program ▁ execution ▁ took ▁ % f ▁ seconds \n " , ( System . nanoTime ( ) - start ) / 1e9f ) ; System . exit ( 0 ) ; } } ) ; int counter = 0 ; while ( true ) { System . out . println ( counter ++ ) ; Thread . sleep ( 500 ) ; } } }
import java . util . HashMap ; public static void main ( String [ ] args ) { String [ ] keys = { " a " , " b " , " c " } ; int [ ] vals = { 1 , 2 , 3 } ; HashMap < String , Integer > hash = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < keys . length ; i ++ ) { hash . put ( keys [ i ] , vals [ i ] ) ; } }
import javax . swing . * ; import java . awt . * ; public class OutputSwing { public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { JOptionPane . showMessageDialog ( null , " Goodbye , ▁ World ! " ) ; JFrame frame = new JFrame ( " Goodbye , ▁ World ! " ) ; JTextArea text = new JTextArea ( " Goodbye , ▁ World ! " ) ; JButton button = new JButton ( " Goodbye , ▁ World ! " ) ; frame . setLayout ( new FlowLayout ( ) ) ; frame . add ( button ) ; frame . add ( text ) ; frame . pack ( ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; } } ) ; } }
import java . io . FileWriter ; import java . io . IOException ; public class LinePrinter { public static void main ( String [ ] args ) { try { FileWriter lp0 = new FileWriter ( " / dev / lp0" ) ; lp0 . write ( " Hello ▁ World ! " ) ; lp0 . close ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } } }
javac - version
public class HelloWorld { public static void main ( String [ ] args ) { System . out . print ( " Goodbye , ▁ World ! " ) ; } }
public class Err { public static void main ( String [ ] args ) { System . err . println ( " Goodbye , ▁ World ! " ) ; } }
public class HelloWorld { public static void main ( String [ ] args ) { System . out . println ( " Hello ▁ world ! " ) ; } }
public static void main ( String ... args ) { for ( int order = 1 ; order <= 5 ; order ++ ) { int n = ( 1 << order ) ; List < Point > points = getPointsForCurve ( n ) ; System . out . println ( " Hilbert ▁ curve , ▁ order = " + order ) ; List < String > lines = drawCurve ( points , n ) ; for ( String line : lines ) { System . out . println ( line ) ; } System . out . println ( ) ; } return ; }
public static int ffr ( int n ) { return getSequence ( n , 0 ) . get ( n - 1 ) . intValue ( ) ; }
public static int ffs ( int n ) { return getSequence ( 0 , n ) . get ( n - 1 ) . intValue ( ) ; }
public static int Q ( int n ) { nUses [ n ] ++ ; if ( q . containsKey ( n ) ) { return q . get ( n ) ; } int ans = Q ( n - Q ( n - 1 ) ) + Q ( n - Q ( n - 2 ) ) ; q . put ( n , ans ) ; return ans ; }
import java . util . Scanner ; public class Sundial { public static void main ( String [ ] args ) { double lat , slat , lng , ref ; Scanner sc = new Scanner ( System . in ) ; System . out . print ( " Enter ▁ latitude : ▁ " ) ; lat = sc . nextDouble ( ) ; System . out . print ( " Enter ▁ longitude : ▁ " ) ; lng = sc . nextDouble ( ) ; System . out . print ( " Enter ▁ legal ▁ meridian : ▁ " ) ; ref = sc . nextDouble ( ) ; System . out . println ( ) ; slat = Math . sin ( Math . toRadians ( lat ) ) ; System . out . printf ( " sine ▁ of ▁ latitude :   % .3f \n " , slat ) ; System . out . printf ( " diff ▁ longitude :   % .3f \n \n " , lng - ref ) ; System . out . printf ( " Hour , ▁ sun ▁ hour ▁ angle , ▁ dial ▁ hour ▁ line ▁ angle ▁ from ▁ 6am ▁ to ▁ 6pm \n " ) ; for ( int h = - 6 ; h <= 6 ; h ++ ) { double hla , hra , hraRad ; hra = 15.0 * h ; hra = hra - lng + ref ; hraRad = Math . toRadians ( hra ) ; hla = Math . toDegrees ( Math . atan2 ( Math . sin ( hraRad ) * Math . sin ( Math . toRadians ( lat ) ) , Math . cos ( hraRad ) ) ) ; System . out . printf ( " HR = ▁ % 3d ; ▁ ▁ \t ▁ ▁ HRA = % 7.3f ; ▁ ▁ \t ▁ ▁ HLA = ▁ % 7.3f \n " , h , hra , hla ) ; } } }
import java . net . * ; class DiscoverHostName { public static void main ( final String [ ] args ) { try { System . out . println ( InetAddress . getLocalHost ( ) . getHostName ( ) ) ; } catch ( UnknownHostException e ) { } } }
import java . net . URI ; import java . net . http . HttpClient ; import java . net . http . HttpRequest ; import java . net . http . HttpResponse ; import java . nio . charset . Charset ; public class Main { public static void main ( String [ ] args ) { var request = HttpRequest . newBuilder ( URI . create ( " https : // www . rosettacode . org " ) ) . GET ( ) . build ( ) ; HttpClient . newHttpClient ( ) . sendAsync ( request , HttpResponse . BodyHandlers . ofString ( Charset . defaultCharset ( ) ) ) . thenApply ( HttpResponse :: body ) . thenAccept ( System . out :: println ) . join ( ) ; } }
URL url = new URL ( " https : // sourceforge . net " ) ; HttpsURLConnection connection = ( HttpsURLConnection ) url . openConnection ( ) ; Scanner scanner = new Scanner ( connection . getInputStream ( ) ) ; while ( scanner . hasNext ( ) ) { System . out . println ( scanner . next ( ) ) ; }
public static void main ( String [ ] args ) { System . out . println ( " First ▁ 50 ▁ humble ▁ numbers : " ) ; System . out . println ( Arrays . toString ( humble ( 50 ) ) ) ; Map < Integer , Integer > lengthCountMap = new HashMap < > ( ) ; BigInteger [ ] seq = humble ( 1_000_000 ) ; for ( int i = 0 ; i < seq . length ; i ++ ) { BigInteger humbleNumber = seq [ i ] ; int len = humbleNumber . toString ( ) . length ( ) ; lengthCountMap . merge ( len , 1 , ( v1 , v2 ) -> v1 + v2 ) ; } List < Integer > sorted = new ArrayList < > ( lengthCountMap . keySet ( ) ) ; Collections . sort ( sorted ) ; System . out . printf ( " Length ▁ ▁ Count % n " ) ; for ( Integer len : sorted ) { System . out . printf ( " ▁ ▁ ▁ ▁ % 2s ▁ ▁ % 5s % n " , len , lengthCountMap . get ( len ) ) ; } }
public class PrintIdentityMatrix { public static void main ( String [ ] args ) { int n = 5 ; int [ ] [ ] array = new int [ n ] [ n ] ; IntStream . range ( 0 , n ) . forEach ( i -> array [ i ] [ i ] = 1 ) ; Arrays . stream ( array ) . map ( ( int [ ] a ) -> Arrays . toString ( a ) ) . forEach ( System . out :: println ) ; } }
import java . util . function . IntPredicate ; import java . util . stream . IntStream ; public class Test { public static void main ( String [ ] args ) throws Exception { print ( " Java ▁ Identifier ▁ start : ▁ ▁ ▁ ▁ ▁ " , 0 , 0x10FFFF , 72 , Character :: isJavaIdentifierStart , " % c " ) ; print ( " Java ▁ Identifier ▁ part : ▁ ▁ ▁ ▁ ▁ ▁ " , 0 , 0x10FFFF , 25 , Character :: isJavaIdentifierPart , " [ % d ] " ) ; print ( " Identifier ▁ ignorable : ▁ ▁ ▁ ▁ ▁ ▁ " , 0 , 0x10FFFF , 25 , Character :: isIdentifierIgnorable , " [ % d ] " ) ; print ( " Unicode ▁ Identifier ▁ start : ▁ ▁ " , 0 , 0x10FFFF , 72 , Character :: isUnicodeIdentifierStart , " % c " ) ; print ( " Unicode ▁ Identifier ▁ part  : ▁ ▁ " , 0 , 0x10FFFF , 25 , Character :: isUnicodeIdentifierPart , " [ % d ] " ) ; } static void print ( String msg , int start , int end , int limit , IntPredicate p , String fmt ) { System . out . print ( msg ) ; IntStream . rangeClosed ( start , end ) . filter ( p ) . limit ( limit ) . forEach ( cp -> System . out . printf ( fmt , cp ) ) ; System . out . println ( " . . . " ) ; } }
import java . util . stream . IntStream ; public class Letters { public static void main ( String [ ] args ) throws Exception { System . out . print ( " Upper ▁ case : ▁ " ) ; IntStream . rangeClosed ( 0 , 0x10FFFF ) . filter ( Character :: isUpperCase ) . limit ( 72 ) . forEach ( n -> System . out . printf ( " % c " , n ) ) ; System . out . println ( " . . . " ) ; System . out . print ( " Lower ▁ case : ▁ " ) ; IntStream . rangeClosed ( 0 , 0x10FFFF ) . filter ( Character :: isLowerCase ) . limit ( 72 ) . forEach ( n -> System . out . printf ( " % c " , n ) ) ; System . out . println ( " . . . " ) ; } }
import java . awt . image . * ; import java . io . File ; import java . io . IOException ; import javax . imageio . * ; public class ImageConvolution { public static class ArrayData { public final int [ ] dataArray ; public final int width ; public final int height ; public ArrayData ( int width , int height ) { this ( new int [ width * height ] , width , height ) ; } public ArrayData ( int [ ] dataArray , int width , int height ) { this . dataArray = dataArray ; this . width = width ; this . height = height ; } public int get ( int x , int y ) { return dataArray [ y * width + x ] ; } public void set ( int x , int y , int value ) { dataArray [ y * width + x ] = value ; } } private static int bound ( int value , int endIndex ) { if ( value < 0 ) return 0 ; if ( value < endIndex ) return value ; return endIndex - 1 ; } public static ArrayData convolute ( ArrayData inputData , ArrayData kernel , int kernelDivisor ) { int inputWidth = inputData . width ; int inputHeight = inputData . height ; int kernelWidth = kernel . width ; int kernelHeight = kernel . height ; if ( ( kernelWidth <= 0 ) || ( ( kernelWidth & 1 ) != 1 ) ) throw new IllegalArgumentException ( " Kernel ▁ must ▁ have ▁ odd ▁ width " ) ; if ( ( kernelHeight <= 0 ) || ( ( kernelHeight & 1 ) != 1 ) ) throw new IllegalArgumentException ( " Kernel ▁ must ▁ have ▁ odd ▁ height " ) ; int kernelWidthRadius = kernelWidth >>> 1 ; int kernelHeightRadius = kernelHeight >>> 1 ; ArrayData outputData = new ArrayData ( inputWidth , inputHeight ) ; for ( int i = inputWidth - 1 ; i >= 0 ; i -- ) { for ( int j = inputHeight - 1 ; j >= 0 ; j -- ) { double newValue = 0.0 ; for ( int kw = kernelWidth - 1 ; kw >= 0 ; kw -- ) for ( int kh = kernelHeight - 1 ; kh >= 0 ; kh -- ) newValue += kernel . get ( kw , kh ) * inputData . get ( bound ( i + kw - kernelWidthRadius , inputWidth ) , bound ( j + kh - kernelHeightRadius , inputHeight ) ) ; outputData . set ( i , j , ( int ) Math . round ( newValue / kernelDivisor ) ) ; } } return outputData ; } public static ArrayData [ ] getArrayDatasFromImage ( String filename ) throws IOException { BufferedImage inputImage = ImageIO . read ( new File ( filename ) ) ; int width = inputImage . getWidth ( ) ; int height = inputImage . getHeight ( ) ; int [ ] rgbData = inputImage . getRGB ( 0 , 0 , width , height , null , 0 , width ) ; ArrayData reds = new ArrayData ( width , height ) ; ArrayData greens = new ArrayData ( width , height ) ; ArrayData blues = new ArrayData ( width , height ) ; for ( int y = 0 ; y < height ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { int rgbValue = rgbData [ y * width + x ] ; reds . set ( x , y , ( rgbValue >>> 16 ) & 0xFF ) ; greens . set ( x , y , ( rgbValue >>> 8 ) & 0xFF ) ; blues . set ( x , y , rgbValue & 0xFF ) ; } } return new ArrayData [ ] { reds , greens , blues } ; } public static void writeOutputImage ( String filename , ArrayData [ ] redGreenBlue ) throws IOException { ArrayData reds = redGreenBlue [ 0 ] ; ArrayData greens = redGreenBlue [ 1 ] ; ArrayData blues = redGreenBlue [ 2 ] ; BufferedImage outputImage = new BufferedImage ( reds . width , reds . height , BufferedImage . TYPE_INT_ARGB ) ; for ( int y = 0 ; y < reds . height ; y ++ ) { for ( int x = 0 ; x < reds . width ; x ++ ) { int red = bound ( reds . get ( x , y ) , 256 ) ; int green = bound ( greens . get ( x , y ) , 256 ) ; int blue = bound ( blues . get ( x , y ) , 256 ) ; outputImage . setRGB ( x , y , ( red << 16 ) | ( green << 8 ) | blue | - 0x01000000 ) ; } } ImageIO . write ( outputImage , " PNG " , new File ( filename ) ) ; return ; } public static void main ( String [ ] args ) throws IOException { int kernelWidth = Integer . parseInt ( args [ 2 ] ) ; int kernelHeight = Integer . parseInt ( args [ 3 ] ) ; int kernelDivisor = Integer . parseInt ( args [ 4 ] ) ; System . out . println ( " Kernel ▁ size : ▁ " + kernelWidth + " x " + kernelHeight + " , ▁ divisor = " + kernelDivisor ) ; int y = 5 ; ArrayData kernel = new ArrayData ( kernelWidth , kernelHeight ) ; for ( int i = 0 ; i < kernelHeight ; i ++ ) { System . out . print ( " [ " ) ; for ( int j = 0 ; j < kernelWidth ; j ++ ) { kernel . set ( j , i , Integer . parseInt ( args [ y ++ ] ) ) ; System . out . print ( " ▁ " + kernel . get ( j , i ) + " ▁ " ) ; } System . out . println ( " ] " ) ; } ArrayData [ ] dataArrays = getArrayDatasFromImage ( args [ 0 ] ) ; for ( int i = 0 ; i < dataArrays . length ; i ++ ) dataArrays [ i ] = convolute ( dataArrays [ i ] , kernel , kernelDivisor ) ; writeOutputImage ( args [ 1 ] , dataArrays ) ; return ; } }
public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { ImageNoise i = new ImageNoise ( ) ; } } ) ; }
public class ImplicitTypeConversion { public static void main ( String ... args ) { System . out . println ( " Primitive ▁ conversions " ) ; byte by = - 1 ; short sh = by ; int in = sh ; long lo = in ; System . out . println ( " byte ▁ value ▁ ▁ ▁ ▁ - 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ to ▁ 3 ▁ integral ▁ types : ▁ ▁ " + lo ) ; float fl = 0.1f ; double db = fl ; System . out . println ( " float ▁ value ▁ ▁ ▁ 0.1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ to ▁ double : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " + db ) ; int in2 = - 1 ; float fl2 = in2 ; double db2 = fl2 ; System . out . println ( " int ▁ value ▁ ▁ ▁ ▁ ▁ - 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ to ▁ float ▁ and ▁ double : ▁ ▁ " + db2 ) ; int in3 = Integer . MAX_VALUE ; float fl3 = in3 ; double db3 = fl3 ; System . out . println ( " int ▁ value ▁ ▁ ▁ ▁ ▁ " + Integer . MAX_VALUE + " ▁ to ▁ float ▁ and ▁ double : ▁ ▁ " + db3 ) ; char ch = ' a ' ; int in4 = ch ; double db4 = in4 ; System . out . println ( " char ▁ value ▁ ▁ ▁ ▁ ' " + ch + " ' ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ to ▁ int ▁ and ▁ double : ▁ ▁ ▁ ▁ " + db4 ) ; System . out . println ( ) ; System . out . println ( " Boxing ▁ and ▁ unboxing " ) ; Integer in5 = - 1 ; int in6 = in5 ; System . out . println ( " int ▁ ▁ value ▁ ▁ ▁ ▁ - 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ to ▁ Integer ▁ and ▁ int : ▁ ▁ ▁ " + in6 ) ; Double db5 = 0.1 ; double db6 = db5 ; System . out . println ( " double ▁ value ▁ ▁ 0.1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ to ▁ Double ▁ and ▁ double : ▁ " + db6 ) ; } }
public class Class1 extends Class2 { }
String s = "12345" ; s = String . valueOf ( Integer . parseInt ( s ) + 1 ) ;
static BigInteger rank ( int [ ] x ) { String s = stream ( x ) . mapToObj ( String :: valueOf ) . collect ( joining ( " F " ) ) ; return new BigInteger ( s , 16 ) ; }
public interface Camera { }
public class Animal { }
import java . io . InputStream ; import java . util . Scanner ; public class InputLoop { public static void main ( String args [ ] ) { InputStream source = System . in ; Scanner in = new Scanner ( source ) ; while ( in . hasNext ( ) ) { String input = in . next ( ) ; System . out . println ( input ) ; } } }
public static void doStuff ( String word ) { System . out . println ( word ) ; }
public static int doStuff ( int a , int b ) { int sum = a + b ; return sum ; }
import java . io . * ; public class compInt { public static void main ( String [ ] args ) { try { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int nbr1 = Integer . parseInt ( in . readLine ( ) ) ; int nbr2 = Integer . parseInt ( in . readLine ( ) ) ; if ( nbr1 < nbr2 ) System . out . println ( nbr1 + " ▁ is ▁ less ▁ than ▁ " + nbr2 ) ; if ( nbr1 > nbr2 ) System . out . println ( nbr1 + " ▁ is ▁ greater ▁ than ▁ " + nbr2 ) ; if ( nbr1 == nbr2 ) System . out . println ( nbr1 + " ▁ is ▁ equal ▁ to ▁ " + nbr2 ) ; } catch ( IOException e ) { } } }
public class Count { public static void main ( String [ ] args ) { for ( long i = 1 ; ; i ++ ) System . out . println ( i ) ; } }
v as $x
private static BigInteger isqrt ( BigInteger x ) { if ( x . compareTo ( BigInteger . ZERO ) < 0 ) { throw new IllegalArgumentException ( " Argument ▁ cannot ▁ be ▁ negative " ) ; } var q = BigInteger . ONE ; while ( q . compareTo ( x ) <= 0 ) { q = q . shiftLeft ( 2 ) ; } var z = x ; var r = BigInteger . ZERO ; while ( q . compareTo ( BigInteger . ONE ) > 0 ) { q = q . shiftRight ( 2 ) ; var t = z ; t = t . subtract ( r ) ; t = t . subtract ( q ) ; r = r . shiftRight ( 1 ) ; if ( t . compareTo ( BigInteger . ZERO ) >= 0 ) { z = t ; r = r . add ( q ) ; } } return r ; }
public static double jaro ( String s , String t ) { int s_len = s . length ( ) ; int t_len = t . length ( ) ; if ( s_len == 0 && t_len == 0 ) return 1 ; int match_distance = Integer . max ( s_len , t_len ) / 2 - 1 ; boolean [ ] s_matches = new boolean [ s_len ] ; boolean [ ] t_matches = new boolean [ t_len ] ; int matches = 0 ; int transpositions = 0 ; for ( int i = 0 ; i < s_len ; i ++ ) { int start = Integer . max ( 0 , i - match_distance ) ; int end = Integer . min ( i + match_distance + 1 , t_len ) ; for ( int j = start ; j < end ; j ++ ) { if ( t_matches [ j ] ) continue ; if ( s . charAt ( i ) != t . charAt ( j ) ) continue ; s_matches [ i ] = true ; t_matches [ j ] = true ; matches ++ ; break ; } } if ( matches == 0 ) return 0 ; int k = 0 ; for ( int i = 0 ; i < s_len ; i ++ ) { if ( ! s_matches [ i ] ) continue ; while ( ! t_matches [ k ] ) k ++ ; if ( s . charAt ( i ) != t . charAt ( k ) ) transpositions ++ ; k ++ ; } return ( ( ( double ) matches / s_len ) + ( ( double ) matches / t_len ) + ( ( ( double ) matches - transpositions / 2.0 ) / matches ) ) / 3.0 ; }
public static void main ( String [ ] args ) { System . out . println ( jaro ( " MARTHA " , " MARHTA " ) ) ; System . out . println ( jaro ( " DIXON " , " DICKSONX " ) ) ; System . out . println ( jaro ( " JELLYFISH " , " SMELLYFISH " ) ) ; }
private static double jaroWinklerDistance ( String string1 , String string2 ) { int len1 = string1 . length ( ) ; int len2 = string2 . length ( ) ; if ( len1 < len2 ) { String s = string1 ; string1 = string2 ; string2 = s ; int tmp = len1 ; len1 = len2 ; len2 = tmp ; } if ( len2 == 0 ) return len1 == 0 ? 0.0 : 1.0 ; int delta = Math . max ( 1 , len1 / 2 ) - 1 ; boolean [ ] flag = new boolean [ len2 ] ; Arrays . fill ( flag , false ) ; char [ ] ch1Match = new char [ len1 ] ; int matches = 0 ; for ( int i = 0 ; i < len1 ; ++ i ) { char ch1 = string1 . charAt ( i ) ; for ( int j = 0 ; j < len2 ; ++ j ) { char ch2 = string2 . charAt ( j ) ; if ( j <= i + delta && j + delta >= i && ch1 == ch2 && ! flag [ j ] ) { flag [ j ] = true ; ch1Match [ matches ++ ] = ch1 ; break ; } } } if ( matches == 0 ) return 1.0 ; int transpositions = 0 ; for ( int i = 0 , j = 0 ; j < len2 ; ++ j ) { if ( flag [ j ] ) { if ( string2 . charAt ( j ) != ch1Match [ i ] ) ++ transpositions ; ++ i ; } } double m = matches ; double jaro = ( m / len1 + m / len2 + ( m - transpositions / 2.0 ) / m ) / 3.0 ; int commonPrefix = 0 ; len2 = Math . min ( 4 , len2 ) ; for ( int i = 0 ; i < len2 ; ++ i ) { if ( string1 . charAt ( i ) == string2 . charAt ( i ) ) ++ commonPrefix ; } return 1.0 - ( jaro + commonPrefix * 0.1 * ( 1.0 - jaro ) ) ; }
private static List < StringDistance > withinDistance ( List < String > words , double maxDistance , String string , int max ) { List < StringDistance > result = new ArrayList < > ( ) ; for ( String word : words ) { double distance = jaroWinklerDistance ( word , string ) ; if ( distance <= maxDistance ) result . add ( new StringDistance ( word , distance ) ) ; } Collections . sort ( result ) ; if ( result . size ( ) > max ) result = result . subList ( 0 , max ) ; return result ; }
import javax . swing . * ; import java . awt . * ; import java . awt . image . BufferedImage ; public class JuliaSet extends JPanel { private static final int MAX_ITERATIONS = 300 ; private static final double ZOOM = 1 ; private static final double CX = - 0.7 ; private static final double CY = 0.27015 ; private static final double MOVE_X = 0 ; private static final double MOVE_Y = 0 ; public JuliaSet ( ) { setPreferredSize ( new Dimension ( 800 , 600 ) ) ; setBackground ( Color . white ) ; } void drawJuliaSet ( Graphics2D g ) { int w = getWidth ( ) ; int h = getHeight ( ) ; BufferedImage image = new BufferedImage ( w , h , BufferedImage . TYPE_INT_RGB ) ; for ( int x = 0 ; x < w ; x ++ ) { for ( int y = 0 ; y < h ; y ++ ) { double zx = 1.5 * ( x - w / 2 ) / ( 0.5 * ZOOM * w ) + MOVE_X ; double zy = ( y - h / 2 ) / ( 0.5 * ZOOM * h ) + MOVE_Y ; float i = MAX_ITERATIONS ; while ( zx * zx + zy * zy < 4 && i > 0 ) { double tmp = zx * zx - zy * zy + CX ; zy = 2.0 * zx * zy + CY ; zx = tmp ; i -- ; } int c = Color . HSBtoRGB ( ( MAX_ITERATIONS / i ) % 1 , 1 , i > 0 ? 1 : 0 ) ; image . setRGB ( x , y , c ) ; } } g . drawImage ( image , 0 , 0 , null ) ; } @ Override public void paintComponent ( Graphics gg ) { super . paintComponent ( gg ) ; Graphics2D g = ( Graphics2D ) gg ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; drawJuliaSet ( g ) ; } public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> { JFrame f = new JFrame ( ) ; f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; f . setTitle ( " Julia ▁ Set " ) ; f . setResizable ( false ) ; f . add ( new JuliaSet ( ) , BorderLayout . CENTER ) ; f . pack ( ) ; f . setLocationRelativeTo ( null ) ; f . setVisible ( true ) ; } ) ; } }
loop1 : while ( x != 0 ) { loop2 : for ( int i = 0 ; i < 10 ; i ++ ) { loop3 : do { if ( ) { continue loop1 ; } if ( ) { break loop2 ; } } while ( y < 10 ) ; } }
public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> { Test f = new Test ( ) ; f . setFocusable ( true ) ; f . setVisible ( true ) ; } ) ; }
package hu . pj . alg . test ; import hu . pj . alg . ContinuousKnapsack ; import hu . pj . obj . Item ; import java . util . * ; import java . text . * ; public class ContinousKnapsackForRobber { final private double tolerance = 0.0005 ; public ContinousKnapsackForRobber ( ) { ContinuousKnapsack cok = new ContinuousKnapsack ( 15 ) ; cok . add ( " beef " , 3.8 , 36 ) ; cok . add ( " pork " , 5.4 , 43 ) ; cok . add ( " ham " , 3.6 , 90 ) ; cok . add ( " greaves " , 2.4 , 45 ) ; cok . add ( " flitch " , 4.0 , 30 ) ; cok . add ( " brawn " , 2.5 , 56 ) ; cok . add ( " welt " , 3.7 , 67 ) ; cok . add ( " salami " , 3.0 , 95 ) ; cok . add ( " sausage " , 5.9 , 98 ) ; List < Item > itemList = cok . calcSolution ( ) ; if ( cok . isCalculated ( ) ) { NumberFormat nf = NumberFormat . getInstance ( ) ; System . out . println ( " Maximal ▁ weight ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + nf . format ( cok . getMaxWeight ( ) ) + " ▁ kg " ) ; System . out . println ( " Total ▁ weight ▁ of ▁ solution ▁ = ▁ " + nf . format ( cok . getSolutionWeight ( ) ) + " ▁ kg " ) ; System . out . println ( " Total ▁ value ▁ ( profit ) ▁ ▁ ▁ ▁ ▁ = ▁ " + nf . format ( cok . getProfit ( ) ) ) ; System . out . println ( ) ; System . out . println ( " You ▁ can ▁ carry ▁ the ▁ following ▁ materials ▁ " + " in ▁ the ▁ knapsack : " ) ; for ( Item item : itemList ) { if ( item . getInKnapsack ( ) > tolerance ) { System . out . format ( " % 1 $ - 10s ▁ % 2 $ - 15s ▁ % 3 $ - 15s ▁ \n " , nf . format ( item . getInKnapsack ( ) ) + " ▁ kg ▁ " , item . getName ( ) , " ( value ▁ = ▁ " + nf . format ( item . getInKnapsack ( ) * ( item . getValue ( ) / item . getWeight ( ) ) ) + " ) " ) ; } } } else { System . out . println ( " The ▁ problem ▁ is ▁ not ▁ solved . ▁ " + " Maybe ▁ you ▁ gave ▁ wrong ▁ data . " ) ; } } public static void main ( String [ ] args ) { new ContinousKnapsackForRobber ( ) ; } }
package hu . pj . alg ; import hu . pj . obj . Item ; import java . text . * ; public class UnboundedKnapsack { protected Item [ ] items = { new Item ( " panacea " , 3000 , 0.3 , 0.025 ) , new Item ( " ichor " , 1800 , 0.2 , 0.015 ) , new Item ( " gold " , 2500 , 2.0 , 0.002 ) } ; protected final int n = items . length ; protected Item sack = new Item ( " sack " , 0 , 25.0 , 0.250 ) ; protected Item best = new Item ( " best " , 0 , 0.0 , 0.000 ) ; protected int [ ] maxIt = new int [ n ] ; protected int [ ] iIt = new int [ n ] ; protected int [ ] bestAm = new int [ n ] ; public UnboundedKnapsack ( ) { for ( int i = 0 ; i < n ; i ++ ) { maxIt [ i ] = Math . min ( ( int ) ( sack . getWeight ( ) / items [ i ] . getWeight ( ) ) , ( int ) ( sack . getVolume ( ) / items [ i ] . getVolume ( ) ) ) ; } calcWithRecursion ( 0 ) ; NumberFormat nf = NumberFormat . getInstance ( ) ; System . out . println ( " Maximum ▁ value ▁ achievable ▁ is : ▁ " + best . getValue ( ) ) ; System . out . print ( " This ▁ is ▁ achieved ▁ by ▁ carrying ▁ ( one ▁ solution ) : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( bestAm [ i ] + " ▁ " + items [ i ] . getName ( ) + " , ▁ " ) ; } System . out . println ( ) ; System . out . println ( " The ▁ weight ▁ to ▁ carry ▁ is : ▁ " + nf . format ( best . getWeight ( ) ) + " ▁ ▁ ▁ and ▁ the ▁ volume ▁ used ▁ is : ▁ " + nf . format ( best . getVolume ( ) ) ) ; } public void calcWithRecursion ( int item ) { for ( int i = 0 ; i <= maxIt [ item ] ; i ++ ) { iIt [ item ] = i ; if ( item < n - 1 ) { calcWithRecursion ( item + 1 ) ; } else { int currVal = 0 ; double currWei = 0.0 ; double currVol = 0.0 ; for ( int j = 0 ; j < n ; j ++ ) { currVal += iIt [ j ] * items [ j ] . getValue ( ) ; currWei += iIt [ j ] * items [ j ] . getWeight ( ) ; currVol += iIt [ j ] * items [ j ] . getVolume ( ) ; } if ( currVal > best . getValue ( ) && currWei <= sack . getWeight ( ) && currVol <= sack . getVolume ( ) ) { best . setValue ( currVal ) ; best . setWeight ( currWei ) ; best . setVolume ( currVol ) ; for ( int j = 0 ; j < n ; j ++ ) bestAm [ j ] = iIt [ j ] ; } } } } public static void main ( String [ ] args ) { new UnboundedKnapsack ( ) ; } }
private static List < Integer > path ( int n ) { if ( n == 0 ) return new ArrayList < > ( ) ; while ( ! p . containsKey ( n ) ) { List < Integer > q = new ArrayList < > ( ) ; for ( Integer x : lvl . get ( 0 ) ) { for ( Integer y : path ( x ) ) { if ( p . containsKey ( x + y ) ) break ; p . put ( x + y , x ) ; q . add ( x + y ) ; } } lvl . get ( 0 ) . clear ( ) ; lvl . get ( 0 ) . addAll ( q ) ; } List < Integer > temp = path ( p . get ( n ) ) ; temp . add ( n ) ; return temp ; }
private static BigDecimal treePow ( double x , int n ) { Map < Integer , BigDecimal > r = new HashMap < > ( ) ; r . put ( 0 , BigDecimal . ONE ) ; r . put ( 1 , BigDecimal . valueOf ( x ) ) ; int p = 0 ; for ( Integer i : path ( n ) ) { r . put ( i , r . get ( i - p ) . multiply ( r . get ( p ) ) ) ; p = i ; } return r . get ( n ) ; }
private static void showPow ( double x , int n , boolean isIntegral ) { System . out . printf ( " % d : ▁ % s \n " , n , path ( n ) ) ; String f = isIntegral ? " % .0f " : " % f " ; System . out . printf ( f , x ) ; System . out . printf ( " ▁ ^ ▁ % d ▁ = ▁ " , n ) ; System . out . printf ( f , treePow ( x , n ) ) ; System . out . println ( " \n " ) ; }
private static int [ ] kolakoski ( final int [ ] self , int len ) { Crutch c = new Crutch ( len ) ; int k = 0 ; while ( c . i < len ) { c . s [ c . i ] = nextInCycle ( self , k ) ; if ( c . s [ k ] > 1 ) { c . repeat ( c . s [ k ] - 1 ) ; } if ( ++ c . i == len ) return c . s ; k ++ ; } return c . s ; }
private static List < Integer > kosaraju ( List < List < Integer > > g ) { int size = g . size ( ) ; boolean [ ] vis = new boolean [ size ] ; int [ ] l = new int [ size ] ; AtomicInteger x = new AtomicInteger ( size ) ; List < List < Integer > > t = new ArrayList < > ( ) ; for ( int i = 0 ; i < size ; ++ i ) { t . add ( new ArrayList < > ( ) ) ; } Recursive < IntConsumer > visit = new Recursive < > ( ) ; visit . func = ( int u ) -> { if ( ! vis [ u ] ) { vis [ u ] = true ; for ( Integer v : g . get ( u ) ) { visit . func . accept ( v ) ; t . get ( v ) . add ( u ) ; } int xval = x . decrementAndGet ( ) ; l [ xval ] = u ; } } ; for ( int i = 0 ; i < size ; ++ i ) { visit . func . accept ( i ) ; } int [ ] c = new int [ size ] ; Recursive < BiConsumer < Integer , Integer > > assign = new Recursive < > ( ) ; assign . func = ( Integer u , Integer root ) -> { if ( vis [ u ] ) { vis [ u ] = false ; c [ u ] = root ; for ( Integer v : t . get ( u ) ) { assign . func . accept ( v , root ) ; } } } ; for ( int u : l ) { assign . func . accept ( u , u ) ; } return Arrays . stream ( c ) . boxed ( ) . collect ( Collectors . toList ( ) ) ; }
public static void main ( String args [ ] ) { int i = 98764321 ; boolean isUnique = true ; boolean canBeDivided = true ; while ( i > 0 ) { s = String . valueOf ( i ) ; isUnique = uniqueDigits ( i ) ; if ( isUnique ) { canBeDivided = testNumber ( i ) ; if ( canBeDivided ) { System . out . println ( " Number ▁ found : ▁ " + i ) ; i = 0 ; } } i -- ; } }
import java . util . GregorianCalendar ; import java . text . MessageFormat ; public class Leapyear { public static void main ( String [ ] argv ) { int [ ] yrs = { 1800 , 1900 , 1994 , 1998 , 1999 , 2000 , 2001 , 2004 , 2100 } ; GregorianCalendar cal = new GregorianCalendar ( ) ; for ( int year : yrs ) { System . err . println ( MessageFormat . format ( " The ▁ year ▁ { 0 , number , # } ▁ is ▁ leaper : ▁ { 1 } ▁ / ▁ { 2 } . " , year , cal . isLeapYear ( year ) , isLeapYear ( year ) ) ) ; } } public static boolean isLeapYear ( int year ) { return ( year % 100 == 0 ) ? ( year % 400 == 0 ) : ( year % 4 == 0 ) ; } }
private static List < Integer > leonardo ( int n , int l0 , int l1 , int add ) { Integer [ ] leo = new Integer [ n ] ; leo [ 0 ] = l0 ; leo [ 1 ] = l1 ; for ( int i = 2 ; i < n ; i ++ ) { leo [ i ] = leo [ i - 1 ] + leo [ i - 2 ] + add ; } return Arrays . asList ( leo ) ; }
import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . text . NumberFormat ; import java . time . Duration ; import java . util . Timer ; import java . util . TimerTask ; public class Main { public static void main ( String [ ] args ) throws FileNotFoundException { final var period = Duration . ofSeconds ( 1 ) ; new Timer ( ) . schedule ( new CpuUtilizationTask ( ) , 0 , period . toMillis ( ) ) ; } static class CpuUtilizationTask extends TimerTask { private final String STAT_FILE_HEADER = " cpu ▁ ▁ " ; private final NumberFormat percentFormatter ; private final RandomAccessFile statPointer ; long previousIdleTime = 0 , previousTotalTime = 0 ; public CpuUtilizationTask ( ) throws FileNotFoundException { this . percentFormatter = NumberFormat . getPercentInstance ( ) ; percentFormatter . setMaximumFractionDigits ( 2 ) ; var statFile = new File ( " / proc / stat " ) ; this . statPointer = new RandomAccessFile ( statFile , " r " ) ; } @ Override public void run ( ) { try { var values = statPointer . readLine ( ) . substring ( STAT_FILE_HEADER . length ( ) ) . split ( " ▁ " ) ; var idleTime = Long . parseUnsignedLong ( values [ 3 ] ) ; var totalTime = 0L ; for ( String value : values ) { totalTime += Long . parseUnsignedLong ( value ) ; } var idleTimeDelta = idleTime - previousIdleTime ; var totalTimeDelta = totalTime - previousTotalTime ; var utilization = 1 - ( ( double ) idleTimeDelta ) / totalTimeDelta ; System . out . println ( percentFormatter . format ( utilization ) ) ; previousIdleTime = idleTime ; previousTotalTime = totalTime ; statPointer . seek ( 0 ) ; } catch ( IOException ioException ) { ioException . printStackTrace ( ) ; } } } }
import java . util . Arrays ; import java . util . List ; import static java . util . function . Function . identity ; import static java . util . stream . Collectors . toList ; import static java . util . stream . IntStream . range ; public interface PythagComp { static void main ( String ... args ) { System . out . println ( run ( 20 ) ) ; } static List < List < Integer > > run ( int n ) { return range ( 1 , n ) . mapToObj ( x -> range ( x , n ) . mapToObj ( y -> range ( y , n ) . mapToObj ( z -> new Integer [ ] { x , y , z } ) ) ) . flatMap ( identity ( ) ) . flatMap ( identity ( ) ) . filter ( a -> a [ 0 ] * a [ 0 ] + a [ 1 ] * a [ 1 ] == a [ 2 ] * a [ 2 ] ) . map ( Arrays :: asList ) . collect ( toList ( ) ) ; } }
1. 1.0 2432311.7567374 1.234E-10 1.234e-10 758832d 728832f 1.0f 758832D 728832F 1.0F 1 / 2. 1 / 2
char a = ' a ' ; String b = " abc " ; char doubleQuote = ' " ' ; char singleQuote = ' \' ' ; String singleQuotes = " ' ' " ; String doubleQuotes = " \" \" " ;
private static double f ( double r ) { var sq = 0.0 ; var len = ACTUAL . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { var eri = Math . exp ( r * i ) ; var guess = ( N0 * eri ) / ( 1.0 + N0 * ( eri - 1.0 ) / K ) ; var diff = guess - ACTUAL . get ( i ) ; sq += diff * diff ; } return sq ; }
public class LongMult { private static byte [ ] stringToDigits ( String num ) { byte [ ] result = new byte [ num . length ( ) ] ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { char c = num . charAt ( i ) ; if ( c < '0' || c > '9' ) { throw new IllegalArgumentException ( " Invalid ▁ digit ▁ " + c + " ▁ found ▁ at ▁ position ▁ " + i ) ; } result [ num . length ( ) - 1 - i ] = ( byte ) ( c - '0' ) ; } return result ; } public static String longMult ( String num1 , String num2 ) { byte [ ] left = stringToDigits ( num1 ) ; byte [ ] right = stringToDigits ( num2 ) ; byte [ ] result = new byte [ left . length + right . length ] ; for ( int rightPos = 0 ; rightPos < right . length ; rightPos ++ ) { byte rightDigit = right [ rightPos ] ; byte temp = 0 ; for ( int leftPos = 0 ; leftPos < left . length ; leftPos ++ ) { temp += result [ leftPos + rightPos ] ; temp += rightDigit * left [ leftPos ] ; result [ leftPos + rightPos ] = ( byte ) ( temp % 10 ) ; temp /= 10 ; } int destPos = rightPos + left . length ; while ( temp != 0 ) { temp += result [ destPos ] & 0xFFFFFFFFL ; result [ destPos ] = ( byte ) ( temp % 10 ) ; temp /= 10 ; destPos ++ ; } } StringBuilder stringResultBuilder = new StringBuilder ( result . length ) ; for ( int i = result . length - 1 ; i >= 0 ; i -- ) { byte digit = result [ i ] ; if ( digit != 0 || stringResultBuilder . length ( ) > 0 ) { stringResultBuilder . append ( ( char ) ( digit + '0' ) ) ; } } return stringResultBuilder . toString ( ) ; } public static void main ( String [ ] args ) { System . out . println ( longMult ( "18446744073709551616" , "18446744073709551616" ) ) ; } }
private static void sieve ( int limit , List < Integer > primes ) { boolean [ ] c = new boolean [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) c [ i ] = false ; int p = 3 , n = 0 ; int p2 = p * p ; while ( p2 <= limit ) { for ( int i = p2 ; i <= limit ; i += 2 * p ) c [ i ] = true ; do p += 2 ; while ( c [ p ] ) ; p2 = p * p ; } for ( int i = 3 ; i <= limit ; i += 2 ) if ( ! c [ i ] ) primes . add ( i ) ; }
public static void main ( String [ ] args ) { System . out . printf ( " Long ▁ years ▁ this ▁ century : % n " ) ; for ( int year = 2000 ; year < 2100 ; year ++ ) { if ( longYear ( year ) ) { System . out . print ( year + " ▁ ▁ " ) ; } } }
public static String lcp ( String ... list ) { if ( list == null ) return " " ; String ret = " " ; int idx = 0 ; while ( true ) { char thisLetter = 0 ; for ( String word : list ) { if ( idx == word . length ( ) ) { return ret ; } if ( thisLetter == 0 ) { thisLetter = word . charAt ( idx ) ; } if ( thisLetter != word . charAt ( idx ) ) { return ret ; } } ret += thisLetter ; idx ++ ; } }
public class LongestCommonSubstring { public static void main ( String [ ] args ) { System . out . println ( lcs ( " testing123testing " , " thisisatest " ) ) ; System . out . println ( lcs ( " test " , " thisisatest " ) ) ; System . out . println ( lcs ( " testing " , " sting " ) ) ; System . out . println ( lcs ( " testing " , " thisisasting " ) ) ; } static String lcs ( String a , String b ) { if ( a . length ( ) > b . length ( ) ) return lcs ( b , a ) ; String res = " " ; for ( int ai = 0 ; ai < a . length ( ) ; ai ++ ) { for ( int len = a . length ( ) - ai ; len > 0 ; len -- ) { for ( int bi = 0 ; bi <= b . length ( ) - len ; bi ++ ) { if ( a . regionMatches ( ai , b , bi , len ) && len > res . length ( ) ) { res = a . substring ( ai , ai + len ) ; } } } } return res ; } }
public static void main ( String [ ] args ) { var tests = List . of ( List . of ( " baabababc " , " baabc " , " bbbabc " ) , List . of ( " baabababc " , " baabc " , " bbbazc " ) , List . of ( " Sunday " , " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " ) , List . of ( " longest " , " common " , " suffix " ) , List . of ( " suffix " ) , List . of ( " " ) ) ; for ( List < String > test : tests ) { System . out . printf ( " % s ▁ - > ▁ ` % s ` \n " , test , lcs ( test ) ) ; } }
static boolean longer ( String a , String b ) { try { String dummy = a . substring ( b . length ( ) ) ; } catch ( StringIndexOutOfBoundsException e ) { return true ; } return false ; }
import java . util . Random ; Random rand = new Random ( ) ; while ( true ) { int a = rand . nextInt ( 20 ) ; System . out . println ( a ) ; if ( a == 10 ) break ; int b = rand . nextInt ( 20 ) ; System . out . println ( b ) ; }
for ( int i = 1 ; i <= 10 ; i ++ ) { System . out . print ( i ) ; if ( i % 5 == 0 ) { System . out . println ( ) ; continue ; } System . out . print ( " , ▁ " ) ; }
int val = 0 ; do { val ++ ; System . out . println ( val ) ; } while ( val % 6 != 0 ) ;
for ( int i = 10 ; i >= 0 ; i -- ) { System . out . println ( i ) ; }
for ( int i = 2 ; i <= 8 ; i += 2 ) { System . out . print ( i + " , ▁ " ) ; } System . out . println ( " who ▁ do ▁ we ▁ appreciate ? " ) ;
for ( int i = 0 ; i < 5 ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { System . out . print ( " * " ) ; } System . out . println ( ) ; }
Iterable < Type > collect ; ... for ( Type i : collect ) { System . out . println ( i ) ; }
while ( true ) { System . out . println ( " SPAM " ) ; }
public static void main ( String [ ] args ) { for ( int i = 1 ; ; i ++ ) { System . out . print ( i ) ; if ( i == 10 ) break ; System . out . print ( " , ▁ " ) ; } System . out . println ( ) ; }
import java . util . Random ; public class NestedLoopTest { public static final Random gen = new Random ( ) ; public static void main ( String [ ] args ) { int [ ] [ ] a = new int [ 10 ] [ 10 ] ; for ( int i = 0 ; i < a . length ; i ++ ) for ( int j = 0 ; j < a [ i ] . length ; j ++ ) a [ i ] [ j ] = gen . nextInt ( 20 ) + 1 ; Outer : for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < a [ i ] . length ; j ++ ) { System . out . print ( " ▁ " + a [ i ] [ j ] ) ; if ( a [ i ] [ j ] == 20 ) break Outer ; } System . out . println ( ) ; } System . out . println ( ) ; } }
int i = 1024 ; while ( i > 0 ) { System . out . println ( i ) ; i >>= 1 ; }
import java . util . ArrayList ; import java . util . List ; public class LoopsWrongRanges { public static void main ( String [ ] args ) { runTest ( new LoopTest ( - 2 , 2 , 1 , " Normal " ) ) ; runTest ( new LoopTest ( - 2 , 2 , 0 , " Zero ▁ increment " ) ) ; runTest ( new LoopTest ( - 2 , 2 , - 1 , " Increments ▁ away ▁ from ▁ stop ▁ value " ) ) ; runTest ( new LoopTest ( - 2 , 2 , 10 , " First ▁ increment ▁ is ▁ beyond ▁ stop ▁ value " ) ) ; runTest ( new LoopTest ( 2 , - 2 , 1 , " Start ▁ more ▁ than ▁ stop : ▁ positive ▁ increment " ) ) ; runTest ( new LoopTest ( 2 , 2 , 1 , " Start ▁ equal ▁ stop : ▁ positive ▁ increment " ) ) ; runTest ( new LoopTest ( 2 , 2 , - 1 , " Start ▁ equal ▁ stop : ▁ negative ▁ increment " ) ) ; runTest ( new LoopTest ( 2 , 2 , 0 , " Start ▁ equal ▁ stop : ▁ zero ▁ increment " ) ) ; runTest ( new LoopTest ( 0 , 0 , 0 , " Start ▁ equal ▁ stop ▁ equal ▁ zero : ▁ zero ▁ increment " ) ) ; } private static void runTest ( LoopTest loopTest ) { List < Integer > values = new ArrayList < > ( ) ; for ( int i = loopTest . start ; i <= loopTest . stop ; i += loopTest . increment ) { values . add ( i ) ; if ( values . size ( ) >= 10 ) { break ; } } System . out . printf ( " % -45s ▁ % s % s % n " , loopTest . comment , values , values . size ( ) == 10 ? " ▁ ( loops ▁ forever ) " : " " ) ; } private static class LoopTest { int start ; int stop ; int increment ; String comment ; public LoopTest ( int start , int stop , int increment , String comment ) { this . start = start ; this . stop = stop ; this . increment = increment ; this . comment = comment ; } } }
public static boolean isPrime ( int p ) { if ( p == 2 ) return true ; else if ( p <= 1 || p % 2 == 0 ) return false ; else { int to = ( int ) Math . sqrt ( p ) ; for ( int i = 3 ; i <= to ; i += 2 ) if ( p % i == 0 ) return false ; return true ; } }
public static boolean isMersennePrime ( int p ) { if ( p == 2 ) return true ; else { BigInteger m_p = BigInteger . ONE . shiftLeft ( p ) . subtract ( BigInteger . ONE ) ; BigInteger s = BigInteger . valueOf ( 4 ) ; for ( int i = 3 ; i <= p ; i ++ ) s = s . multiply ( s ) . subtract ( BigInteger . valueOf ( 2 ) ) . mod ( m_p ) ; return s . equals ( BigInteger . ZERO ) ; } }
public static List < Integer > compress ( String uncompressed ) { int dictSize = 256 ; Map < String , Integer > dictionary = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < 256 ; i ++ ) dictionary . put ( " " + ( char ) i , i ) ; String w = " " ; List < Integer > result = new ArrayList < Integer > ( ) ; for ( char c : uncompressed . toCharArray ( ) ) { String wc = w + c ; if ( dictionary . containsKey ( wc ) ) w = wc ; else { result . add ( dictionary . get ( w ) ) ; dictionary . put ( wc , dictSize ++ ) ; w = " " + c ; } } if ( ! w . equals ( " " ) ) result . add ( dictionary . get ( w ) ) ; return result ; }
public static String decompress ( List < Integer > compressed ) { int dictSize = 256 ; Map < Integer , String > dictionary = new HashMap < Integer , String > ( ) ; for ( int i = 0 ; i < 256 ; i ++ ) dictionary . put ( i , " " + ( char ) i ) ; String w = " " + ( char ) ( int ) compressed . remove ( 0 ) ; StringBuffer result = new StringBuffer ( w ) ; for ( int k : compressed ) { String entry ; if ( dictionary . containsKey ( k ) ) entry = dictionary . get ( k ) ; else if ( k == dictSize ) entry = w + w . charAt ( 0 ) ; else throw new IllegalArgumentException ( " Bad ▁ compressed ▁ k : ▁ " + k ) ; result . append ( entry ) ; dictionary . put ( dictSize ++ , w + entry . charAt ( 0 ) ) ; w = entry ; } return result . toString ( ) ; }
package com . jamesdonnell . MACVendor ; import java . io . BufferedReader ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . HttpURLConnection ; import java . net . URL ; public class Lookup { private static final String baseURL = " http : // api . macvendors . com / " ; public static void main ( String [ ] args ) { for ( String arguments : args ) System . out . println ( arguments + " : ▁ " + get ( arguments ) ) ; } private static String get ( String macAddress ) { try { StringBuilder result = new StringBuilder ( ) ; URL url = new URL ( baseURL + macAddress ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( " GET " ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( conn . getInputStream ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { result . append ( line ) ; } rd . close ( ) ; return result . toString ( ) ; } catch ( FileNotFoundException e ) { return " N / A " ; } catch ( IOException e ) { return null ; } } }
import java . util . Random ; import java . util . Scanner ; public class MagicEightBall { public static void main ( String [ ] args ) { new MagicEightBall ( ) . run ( ) ; } private static String [ ] ANSWERS = new String [ ] { " It ▁ is ▁ certain . " , " It ▁ is ▁ decidedly ▁ so . " , " Without ▁ a ▁ doubt . " , " Yes ▁ - ▁ definitely . " , " You ▁ may ▁ rely ▁ on ▁ it . " , " As ▁ I ▁ see ▁ it , ▁ yes . " , " Most ▁ likely . " , " Outlook ▁ good . " , " Yes . " , " Signs ▁ point ▁ to ▁ yes . " , " Reply ▁ hazy , ▁ try ▁ again . " , " Ask ▁ again ▁ later . " , " Better ▁ not ▁ tell ▁ you ▁ now . " , " Cannot ▁ predict ▁ now . " , " Concentrate ▁ and ▁ ask ▁ again . " , " Don ' t ▁ count ▁ on ▁ it . " , " My ▁ reply ▁ is ▁ no . " , " My ▁ sources ▁ say ▁ no . " , " Outlook ▁ not ▁ so ▁ good . " , " Very ▁ doubtful . ▁ " } ; public void run ( ) { Random random = new Random ( ) ; System . out . printf ( " Hello . ▁ ▁ The ▁ Magic ▁ 8 ▁ Ball ▁ knows ▁ all . ▁ ▁ Type ▁ your ▁ question . % n % n " ) ; try ( Scanner in = new Scanner ( System . in ) ; ) { System . out . printf ( " ? ▁ ▁ " ) ; while ( ( in . nextLine ( ) ) . length ( ) > 0 ) { System . out . printf ( "8 ▁ Ball ▁ Response : ▁ ▁ % s % n " , ANSWERS [ random . nextInt ( ANSWERS . length ) ] ) ; System . out . printf ( " ? ▁ ▁ " ) ; } } System . out . printf ( " % n8 ▁ Ball ▁ Done . ▁ ▁ Bye . " ) ; } }
import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . nio . file . * ; public class Backup { public static void saveWithBackup ( String filename , String ... data ) throws IOException { Path file = Paths . get ( filename ) . toRealPath ( ) ; File backFile = new File ( filename + " . backup " ) ; if ( ! backFile . exists ( ) ) { backFile . createNewFile ( ) ; } Path back = Paths . get ( filename + " . backup " ) . toRealPath ( ) ; Files . move ( file , back , StandardCopyOption . REPLACE_EXISTING ) ; try ( PrintWriter out = new PrintWriter ( file . toFile ( ) ) ) { for ( int i = 0 ; i < data . length ; i ++ ) { out . print ( data [ i ] ) ; if ( i < data . length - 1 ) { out . println ( ) ; } } } } public static void main ( String [ ] args ) { try { saveWithBackup ( " original . txt " , " fourth " , " fifth " , " sixth " ) ; } catch ( IOException e ) { System . err . println ( e ) ; } } }
static double A ( int k , DoubleSupplier x1 , DoubleSupplier x2 , DoubleSupplier x3 , DoubleSupplier x4 , DoubleSupplier x5 ) { DoubleSupplier B = new DoubleSupplier ( ) { int m = k ; public double getAsDouble ( ) { return A ( -- m , this , x1 , x2 , x3 , x4 ) ; } } ; return k <= 0 ? x4 . getAsDouble ( ) + x5 . getAsDouble ( ) : B . getAsDouble ( ) ; }
import java . util . Arrays ; public class Transpose { public static void main ( String [ ] args ) { double [ ] [ ] m = { { 1 , 1 , 1 , 1 } , { 2 , 4 , 8 , 16 } , { 3 , 9 , 27 , 81 } , { 4 , 16 , 64 , 256 } , { 5 , 25 , 125 , 625 } } ; double [ ] [ ] ans = new double [ m [ 0 ] . length ] [ m . length ] ; for ( int rows = 0 ; rows < m . length ; rows ++ ) { for ( int cols = 0 ; cols < m [ 0 ] . length ; cols ++ ) { ans [ cols ] [ rows ] = m [ rows ] [ cols ] ; } } for ( double [ ] i : ans ) { System . out . println ( Arrays . toString ( i ) ) ; } } }
public static void main ( String [ ] args ) { DiagonalDiagonalMatrix A = new DiagonalDiagonalMatrix ( 7 ) ; System . out . println ( A ) ; }
public static void main ( String [ ] args ) { for ( long base10 : new long [ ] { 4005 , 8017 , 326205 , 886205 , 1000000000 , 1081439556L , 26960840421L , 503491211079L } ) { displayMyan ( BigInteger . valueOf ( base10 ) ) ; System . out . printf ( " % n " ) ; } }
import org . bouncycastle . crypto . digests . MD4Digest ; import org . bouncycastle . util . encoders . Hex ; public class RosettaMD4 { public static void main ( String [ ] argv ) throws Exception { byte [ ] r = " Rosetta ▁ Code " . getBytes ( " US - ASCII " ) ; MD4Digest d = new MD4Digest ( ) ; d . update ( r , 0 , r . length ) ; byte [ ] o = new byte [ d . getDigestSize ( ) ] ; d . doFinal ( o , 0 ) ; Hex . encode ( o , System . out ) ; System . out . println ( ) ; } }
public class CountingSemaphore { private int lockCount = 0 ; private int maxCount ; CountingSemaphore ( int Max ) { maxCount = Max ; } public synchronized void acquire ( ) throws InterruptedException { while ( lockCount >= maxCount ) { wait ( ) ; } lockCount ++ ; } public synchronized void release ( ) { if ( lockCount > 0 ) { lockCount -- ; notifyAll ( ) ; } } public synchronized int getCount ( ) { return lockCount ; } } public class Worker extends Thread { private CountingSemaphore lock ; private int id ; Worker ( CountingSemaphore coordinator , int num ) { lock = coordinator ; id = num ; } Worker ( ) { } public void run ( ) { try { lock . acquire ( ) ; System . out . println ( " Worker ▁ " + id + " ▁ has ▁ acquired ▁ the ▁ lock . " ) ; sleep ( 2000 ) ; } catch ( InterruptedException e ) { } finally { lock . release ( ) ; } } public static void main ( String [ ] args ) { CountingSemaphore lock = new CountingSemaphore ( 3 ) ; Worker crew [ ] ; crew = new Worker [ 5 ] ; for ( int i = 0 ; i < 5 ; i ++ ) { crew [ i ] = new Worker ( lock , i ) ; crew [ i ] . start ( ) ; } } }
class Metronome { double bpm ; int measure , counter ; public Metronome ( double bpm , int measure ) { this . bpm = bpm ; this . measure = measure ; } public void start ( ) { while ( true ) { try { Thread . sleep ( ( long ) ( 1000 * ( 60.0 / bpm ) ) ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } counter ++ ; if ( counter % measure == 0 ) { System . out . println ( " TICK " ) ; } else { System . out . println ( " TOCK " ) ; } } } } public class test { public static void main ( String [ ] args ) { Metronome metronome1 = new Metronome ( 120 , 4 ) ; metronome1 . start ( ) ; } }
private static void mianChowla ( int minIndex , int maxIndex ) { int [ ] sums = new int [ 1 ] ; int [ ] chowla = new int [ maxIndex + 1 ] ; sums [ 0 ] = 2 ; chowla [ 0 ] = 0 ; chowla [ 1 ] = 1 ; if ( minIndex == 1 ) { System . out . printf ( " % d ▁ " , 1 ) ; } int chowlaLength = 1 ; for ( int n = 2 ; n <= maxIndex ; n ++ ) { int test = chowla [ n - 1 ] ; int [ ] sumsNew = Arrays . copyOf ( sums , sums . length + n ) ; int sumNewLength = sums . length ; int savedsSumNewLength = sumNewLength ; boolean found = false ; while ( ! found ) { test ++ ; found = true ; sumNewLength = savedsSumNewLength ; for ( int j = 0 ; j <= chowlaLength ; j ++ ) { int testSum = ( j == 0 ? test : chowla [ j ] ) + test ; boolean duplicate = false ; for ( int k = 0 ; k < sumNewLength ; k ++ ) { if ( sumsNew [ k ] == testSum ) { duplicate = true ; break ; } } if ( ! duplicate ) { sumsNew [ sumNewLength ] = testSum ; sumNewLength ++ ; } else { found = false ; break ; } } } chowla [ n ] = test ; chowlaLength ++ ; sums = sumsNew ; if ( n >= minIndex ) { System . out . printf ( " % d ▁ % s " , chowla [ n ] , ( n == maxIndex ? " \n " : " " ) ) ; } } }
import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class MinimalStepsDownToOne { public static void main ( String [ ] args ) { runTasks ( getFunctions1 ( ) ) ; runTasks ( getFunctions2 ( ) ) ; runTasks ( getFunctions3 ( ) ) ; } private static void runTasks ( List < Function > functions ) { Map < Integer , List < String > > minPath = getInitialMap ( functions , 5 ) ; int max = 10 ; populateMap ( minPath , functions , max ) ; System . out . printf ( " % nWith ▁ functions : ▁ ▁ % s % n " , functions ) ; System . out . printf ( " ▁ ▁ Minimum ▁ steps ▁ to ▁ 1 : % n " ) ; for ( int n = 2 ; n <= max ; n ++ ) { int steps = minPath . get ( n ) . size ( ) ; System . out . printf ( " ▁ ▁ ▁ ▁ % 2d : ▁ % d ▁ step % 1s : ▁ % s % n " , n , steps , steps == 1 ? " " : " s " , minPath . get ( n ) ) ; } displayMaxMin ( minPath , functions , 2000 ) ; displayMaxMin ( minPath , functions , 20000 ) ; displayMaxMin ( minPath , functions , 100000 ) ; } private static void displayMaxMin ( Map < Integer , List < String > > minPath , List < Function > functions , int max ) { populateMap ( minPath , functions , max ) ; List < Integer > maxIntegers = getMaxMin ( minPath , max ) ; int maxSteps = maxIntegers . remove ( 0 ) ; int numCount = maxIntegers . size ( ) ; System . out . printf ( " ▁ ▁ There ▁ % s ▁ % d ▁ number % s ▁ in ▁ the ▁ range ▁ 1 - % d ▁ that ▁ have ▁ maximum ▁ ' minimal ▁ steps ' ▁ of ▁ % d : % n ▁ ▁ ▁ ▁ % s % n " , numCount == 1 ? " is " : " are " , numCount , numCount == 1 ? " " : " s " , max , maxSteps , maxIntegers ) ; } private static List < Integer > getMaxMin ( Map < Integer , List < String > > minPath , int max ) { int maxSteps = Integer . MIN_VALUE ; List < Integer > maxIntegers = new ArrayList < Integer > ( ) ; for ( int n = 2 ; n <= max ; n ++ ) { int len = minPath . get ( n ) . size ( ) ; if ( len > maxSteps ) { maxSteps = len ; maxIntegers . clear ( ) ; maxIntegers . add ( n ) ; } else if ( len == maxSteps ) { maxIntegers . add ( n ) ; } } maxIntegers . add ( 0 , maxSteps ) ; return maxIntegers ; } private static void populateMap ( Map < Integer , List < String > > minPath , List < Function > functions , int max ) { for ( int n = 2 ; n <= max ; n ++ ) { if ( minPath . containsKey ( n ) ) { continue ; } Function minFunction = null ; int minSteps = Integer . MAX_VALUE ; for ( Function f : functions ) { if ( f . actionOk ( n ) ) { int result = f . action ( n ) ; int steps = 1 + minPath . get ( result ) . size ( ) ; if ( steps < minSteps ) { minFunction = f ; minSteps = steps ; } } } int result = minFunction . action ( n ) ; List < String > path = new ArrayList < String > ( ) ; path . add ( minFunction . toString ( n ) ) ; path . addAll ( minPath . get ( result ) ) ; minPath . put ( n , path ) ; } } private static Map < Integer , List < String > > getInitialMap ( List < Function > functions , int max ) { Map < Integer , List < String > > minPath = new HashMap < > ( ) ; for ( int i = 2 ; i <= max ; i ++ ) { for ( Function f : functions ) { if ( f . actionOk ( i ) ) { int result = f . action ( i ) ; if ( result == 1 ) { List < String > path = new ArrayList < String > ( ) ; path . add ( f . toString ( i ) ) ; minPath . put ( i , path ) ; } } } } return minPath ; } private static List < Function > getFunctions3 ( ) { List < Function > functions = new ArrayList < > ( ) ; functions . add ( new Divide2Function ( ) ) ; functions . add ( new Divide3Function ( ) ) ; functions . add ( new Subtract2Function ( ) ) ; functions . add ( new Subtract1Function ( ) ) ; return functions ; } private static List < Function > getFunctions2 ( ) { List < Function > functions = new ArrayList < > ( ) ; functions . add ( new Divide3Function ( ) ) ; functions . add ( new Divide2Function ( ) ) ; functions . add ( new Subtract2Function ( ) ) ; return functions ; } private static List < Function > getFunctions1 ( ) { List < Function > functions = new ArrayList < > ( ) ; functions . add ( new Divide3Function ( ) ) ; functions . add ( new Divide2Function ( ) ) ; functions . add ( new Subtract1Function ( ) ) ; return functions ; } public abstract static class Function { abstract public int action ( int n ) ; abstract public boolean actionOk ( int n ) ; abstract public String toString ( int n ) ; } public static class Divide2Function extends Function { @ Override public int action ( int n ) { return n / 2 ; } @ Override public boolean actionOk ( int n ) { return n % 2 == 0 ; } @ Override public String toString ( int n ) { return " / 2 ▁ - > ▁ " + n / 2 ; } @ Override public String toString ( ) { return " Divisor ▁ 2" ; } } public static class Divide3Function extends Function { @ Override public int action ( int n ) { return n / 3 ; } @ Override public boolean actionOk ( int n ) { return n % 3 == 0 ; } @ Override public String toString ( int n ) { return " / 3 ▁ - > ▁ " + n / 3 ; } @ Override public String toString ( ) { return " Divisor ▁ 3" ; } } public static class Subtract1Function extends Function { @ Override public int action ( int n ) { return n - 1 ; } @ Override public boolean actionOk ( int n ) { return true ; } @ Override public String toString ( int n ) { return " - 1 ▁ - > ▁ " + ( n - 1 ) ; } @ Override public String toString ( ) { return " Subtractor ▁ 1" ; } } public static class Subtract2Function extends Function { @ Override public int action ( int n ) { return n - 2 ; } @ Override public boolean actionOk ( int n ) { return n > 2 ; } @ Override public String toString ( int n ) { return " - 2 ▁ - > ▁ " + ( n - 2 ) ; } @ Override public String toString ( ) { return " Subtractor ▁ 2" ; } } }
private static < T > Ring < T > f ( Ring < T > x ) { return x . pow ( 100 ) . plus ( x ) . plus ( x . one ( ) ) ; }
import java . math . BigInteger ; public class PowMod { public static void main ( String [ ] args ) { BigInteger a = new BigInteger ( "2988348162058574136915891421498819466320163312926952423791023078876139" ) ; BigInteger b = new BigInteger ( "2351399303373464486466122544523690094744975233415544072992656881240319" ) ; BigInteger m = new BigInteger ( "10000000000000000000000000000000000000000" ) ; System . out . println ( a . modPow ( b , m ) ) ; } }
public static int meaningOfLife ( ) { return 42 ; }
import java . math . BigInteger ; public class MontgomeryReduction { private static final BigInteger ZERO = BigInteger . ZERO ; private static final BigInteger ONE = BigInteger . ONE ; private static final BigInteger TWO = BigInteger . valueOf ( 2 ) ; public static class Montgomery { public static final int BASE = 2 ; BigInteger m ; BigInteger rrm ; int n ; public Montgomery ( BigInteger m ) { if ( m . compareTo ( BigInteger . ZERO ) <= 0 || ! m . testBit ( 0 ) ) { throw new IllegalArgumentException ( ) ; } this . m = m ; this . n = m . bitLength ( ) ; this . rrm = ONE . shiftLeft ( n * 2 ) . mod ( m ) ; } public BigInteger reduce ( BigInteger t ) { BigInteger a = t ; for ( int i = 0 ; i < n ; i ++ ) { if ( a . testBit ( 0 ) ) a = a . add ( this . m ) ; a = a . shiftRight ( 1 ) ; } if ( a . compareTo ( m ) >= 0 ) a = a . subtract ( this . m ) ; return a ; } } public static void main ( String [ ] args ) { BigInteger m = new BigInteger ( "750791094644726559640638407699" ) ; BigInteger x1 = new BigInteger ( "540019781128412936473322405310" ) ; BigInteger x2 = new BigInteger ( "515692107665463680305819378593" ) ; Montgomery mont = new Montgomery ( m ) ; BigInteger t1 = x1 . multiply ( mont . rrm ) ; BigInteger t2 = x2 . multiply ( mont . rrm ) ; BigInteger r1 = mont . reduce ( t1 ) ; BigInteger r2 = mont . reduce ( t2 ) ; BigInteger r = ONE . shiftLeft ( mont . n ) ; System . out . printf ( " b  : ▁ ▁ % s \n " , Montgomery . BASE ) ; System . out . printf ( " n  : ▁ ▁ % s \n " , mont . n ) ; System . out . printf ( " r  : ▁ ▁ % s \n " , r ) ; System . out . printf ( " m  : ▁ ▁ % s \n " , mont . m ) ; System . out . printf ( " t1 : ▁ ▁ % s \n " , t1 ) ; System . out . printf ( " t2 : ▁ ▁ % s \n " , t2 ) ; System . out . printf ( " r1 : ▁ ▁ % s \n " , r1 ) ; System . out . printf ( " r2 : ▁ ▁ % s \n " , r2 ) ; System . out . println ( ) ; System . out . printf ( " Original ▁ x1 ▁ ▁ ▁ ▁ ▁ ▁   : ▁ ▁ % s \n " , x1 ) ; System . out . printf ( " Recovered ▁ from ▁ r1  : ▁ ▁ % s \n " , mont . reduce ( r1 ) ) ; System . out . printf ( " Original ▁ x2 ▁ ▁ ▁ ▁ ▁ ▁   : ▁ ▁ % s \n " , x2 ) ; System . out . printf ( " Recovered ▁ from ▁ r2  : ▁ ▁ % s \n " , mont . reduce ( r2 ) ) ; System . out . println ( ) ; System . out . println ( " Montgomery ▁ computation ▁ of ▁ x1 ▁ ^ ▁ x2 ▁ mod ▁ m  : " ) ; BigInteger prod = mont . reduce ( mont . rrm ) ; BigInteger base = mont . reduce ( x1 . multiply ( mont . rrm ) ) ; BigInteger exp = x2 ; while ( exp . bitLength ( ) > 0 ) { if ( exp . testBit ( 0 ) ) prod = mont . reduce ( prod . multiply ( base ) ) ; exp = exp . shiftRight ( 1 ) ; base = mont . reduce ( base . multiply ( base ) ) ; } System . out . println ( mont . reduce ( prod ) ) ; System . out . println ( ) ; System . out . println ( " Library - based ▁ computation ▁ of ▁ x1 ▁ ^ ▁ x2 ▁ mod ▁ m  : " ) ; System . out . println ( x1 . modPow ( x2 , m ) ) ; } }
Foo [ ] foos = new Foo [ n ] ; for ( int i = 0 ; i < foos . length ; i ++ ) foos [ i ] = new Foo ( ) ; Foo [ ] foos_WRONG = new Foo [ n ] ; Arrays . fill ( foos , new Foo ( ) ) ;
public class Main { public static void main ( String [ ] args ) { for ( int i = 0 ; i <= 5000 ; i ++ ) { int val = String . valueOf ( i ) . chars ( ) . map ( x -> ( int ) Math . pow ( x - 48 , x - 48 ) ) . sum ( ) ; if ( i == val ) { System . out . println ( i + " ▁ ( munchausen ) " ) ; } } } }
import java . awt . Color ; import java . awt . Graphics ; import javax . swing . JFrame ; import javax . swing . JPanel ; public class XorPattern extends JFrame { private JPanel xorPanel ; public XorPattern ( ) { xorPanel = new JPanel ( ) { @ Override public void paint ( Graphics g ) { for ( int y = 0 ; y < getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < getWidth ( ) ; x ++ ) { g . setColor ( new Color ( 0 , ( x ^ y ) % 256 , 0 ) ) ; g . drawLine ( x , y , x , y ) ; } } } } ; add ( xorPanel ) ; setSize ( 300 , 300 ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setVisible ( true ) ; } public static void main ( String [ ] args ) { new XorPattern ( ) ; } }
import java . util . concurrent . Semaphore ; public class VolatileClass { public Semaphore mutex = new Semaphore ( 1 ) ; public void needsToBeSynched ( ) { } }
import java . util . HashMap ; import java . util . Map ; public class MutualRecursion { public static void main ( final String args [ ] ) { int max = 20 ; System . out . printf ( " First ▁ % d ▁ values ▁ of ▁ the ▁ Female ▁ sequence : ▁ ▁ % n " , max ) ; for ( int i = 0 ; i < max ; i ++ ) { System . out . printf ( " ▁ ▁ f ( % d ) ▁ = ▁ % d % n " , i , f ( i ) ) ; } System . out . printf ( " First ▁ % d ▁ values ▁ of ▁ the ▁ Male ▁ sequence : ▁ ▁ % n " , max ) ; for ( int i = 0 ; i < 20 ; i ++ ) { System . out . printf ( " ▁ ▁ m ( % d ) ▁ = ▁ % d % n " , i , m ( i ) ) ; } } private static Map < Integer , Integer > F_MAP = new HashMap < > ( ) ; private static int f ( final int n ) { if ( F_MAP . containsKey ( n ) ) { return F_MAP . get ( n ) ; } int fn = n == 0 ? 1 : n - m ( f ( n - 1 ) ) ; F_MAP . put ( n , fn ) ; return fn ; } private static Map < Integer , Integer > M_MAP = new HashMap < > ( ) ; private static int m ( final int n ) { if ( M_MAP . containsKey ( n ) ) { return M_MAP . get ( n ) ; } int mn = n == 0 ? 0 : n - f ( m ( n - 1 ) ) ; M_MAP . put ( n , mn ) ; return mn ; } }
import java . io . IOException ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . Paths ; import java . util . Arrays ; import java . util . List ; public class NBodySim { private static class Vector3D { double x , y , z ; public Vector3D ( double x , double y , double z ) { this . x = x ; this . y = y ; this . z = z ; } public Vector3D plus ( Vector3D rhs ) { return new Vector3D ( x + rhs . x , y + rhs . y , z + rhs . z ) ; } public Vector3D minus ( Vector3D rhs ) { return new Vector3D ( x - rhs . x , y - rhs . y , z - rhs . z ) ; } public Vector3D times ( double s ) { return new Vector3D ( s * x , s * y , s * z ) ; } public double mod ( ) { return Math . sqrt ( x * x + y * y + z * z ) ; } } private static final Vector3D origin = new Vector3D ( 0 , 0 , 0 ) ; private static class NBody { private double gc ; private int bodies ; public final int timeSteps ; private double [ ] masses ; private Vector3D [ ] positions ; private Vector3D [ ] velocities ; private Vector3D [ ] accelerations ; public NBody ( String fileName ) throws IOException { Path path = Paths . get ( fileName ) ; List < String > lines = Files . readAllLines ( path ) ; String [ ] gbt = lines . get ( 0 ) . split ( " ▁ " ) ; gc = Double . parseDouble ( gbt [ 0 ] ) ; bodies = Integer . parseInt ( gbt [ 1 ] ) ; timeSteps = Integer . parseInt ( gbt [ 2 ] ) ; masses = new double [ bodies ] ; positions = new Vector3D [ bodies ] ; Arrays . fill ( positions , origin ) ; velocities = new Vector3D [ bodies ] ; Arrays . fill ( velocities , origin ) ; accelerations = new Vector3D [ bodies ] ; Arrays . fill ( accelerations , origin ) ; for ( int i = 0 ; i < bodies ; ++ i ) { masses [ i ] = Double . parseDouble ( lines . get ( i * 3 + 1 ) ) ; positions [ i ] = decompose ( lines . get ( i * 3 + 2 ) ) ; velocities [ i ] = decompose ( lines . get ( i * 3 + 3 ) ) ; } System . out . printf ( " Contents ▁ of ▁ % s \n " , fileName ) ; for ( String line : lines ) { System . out . println ( line ) ; } System . out . println ( ) ; System . out . print ( " Body ▁ ▁   : ▁ ▁ ▁ ▁ ▁ ▁ x ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ y ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ z ▁ ▁ ▁ ▁ | " ) ; System . out . println ( " ▁ ▁ ▁ ▁ ▁ vx ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ vy ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ vz " ) ; } private Vector3D decompose ( String line ) { String [ ] xyz = line . split ( " ▁ " ) ; double x = Double . parseDouble ( xyz [ 0 ] ) ; double y = Double . parseDouble ( xyz [ 1 ] ) ; double z = Double . parseDouble ( xyz [ 2 ] ) ; return new Vector3D ( x , y , z ) ; } private void resolveCollisions ( ) { for ( int i = 0 ; i < bodies ; ++ i ) { for ( int j = i + 1 ; j < bodies ; ++ j ) { if ( positions [ i ] . x == positions [ j ] . x && positions [ i ] . y == positions [ j ] . y && positions [ i ] . z == positions [ j ] . z ) { Vector3D temp = velocities [ i ] ; velocities [ i ] = velocities [ j ] ; velocities [ j ] = temp ; } } } } private void computeAccelerations ( ) { for ( int i = 0 ; i < bodies ; ++ i ) { accelerations [ i ] = origin ; for ( int j = 0 ; j < bodies ; ++ j ) { if ( i != j ) { double temp = gc * masses [ j ] / Math . pow ( ( positions [ i ] . minus ( positions [ j ] ) ) . mod ( ) , 3 ) ; accelerations [ i ] = accelerations [ i ] . plus ( positions [ j ] . minus ( positions [ i ] ) . times ( temp ) ) ; } } } } private void computeVelocities ( ) { for ( int i = 0 ; i < bodies ; ++ i ) { velocities [ i ] = velocities [ i ] . plus ( accelerations [ i ] ) ; } } private void computePositions ( ) { for ( int i = 0 ; i < bodies ; ++ i ) { positions [ i ] = positions [ i ] . plus ( velocities [ i ] ) . plus ( accelerations [ i ] . times ( 0.5 ) ) ; } } public void simulate ( ) { computeAccelerations ( ) ; computePositions ( ) ; computeVelocities ( ) ; resolveCollisions ( ) ; } public void printResults ( ) { String fmt = " Body ▁ % d  :   % ▁ 8.6f ▁   % ▁ 8.6f ▁   % ▁ 8.6f ▁ |   % ▁ 8.6f ▁   % ▁ 8.6f ▁   % ▁ 8.6f \n " ; for ( int i = 0 ; i < bodies ; ++ i ) { System . out . printf ( fmt , i + 1 , positions [ i ] . x , positions [ i ] . y , positions [ i ] . z , velocities [ i ] . x , velocities [ i ] . y , velocities [ i ] . z ) ; } } } public static void main ( String [ ] args ) throws IOException { String filename = " nbody . txt " ; NBody nb = new NBody ( filename ) ; for ( int i = 0 ; i < nb . timeSteps ; ++ i ) { System . out . printf ( " \n Cycle ▁ % s \n " , i + 1 ) ; nb . simulate ( ) ; nb . printResults ( ) ; } } }
public class NQueens { private static int [ ] b = new int [ 8 ] ; private static int s = 0 ; static boolean unsafe ( int y ) { int x = b [ y ] ; for ( int i = 1 ; i <= y ; i ++ ) { int t = b [ y - i ] ; if ( t == x || t == x - i || t == x + i ) { return true ; } } return false ; } public static void putboard ( ) { System . out . println ( " \n \n Solution ▁ " + ( ++ s ) ) ; for ( int y = 0 ; y < 8 ; y ++ ) { for ( int x = 0 ; x < 8 ; x ++ ) { System . out . print ( ( b [ y ] == x ) ? " | Q " : " | _ " ) ; } System . out . println ( " | " ) ; } } public static void main ( String [ ] args ) { int y = 0 ; b [ 0 ] = - 1 ; while ( y >= 0 ) { do { b [ y ] ++ ; } while ( ( b [ y ] < 8 ) && unsafe ( y ) ) ; if ( b [ y ] < 8 ) { if ( y < 7 ) { b [ ++ y ] = - 1 ; } else { putboard ( ) ; } } else { y -- ; } } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Narcissist { private static final String SOURCE = " import ▁ java . io . BufferedReader ; % nimport ▁ java . io . IOException ; % nimport ▁ java . io . InputStreamReader ; % n % npublic ▁ class ▁ Narcissist ▁ { % n ▁ ▁ ▁ ▁ private ▁ static ▁ final ▁ String ▁ SOURCE ▁ = ▁ % c % s % c ; % n ▁ ▁ ▁ ▁ private ▁ static ▁ final ▁ char ▁ QUOTE ▁ = ▁ 0x22 ; % n % n ▁ ▁ ▁ ▁ public ▁ static ▁ void ▁ main ( String [ ] ▁ args ) ▁ throws ▁ IOException ▁ { % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ BufferedReader ▁ br ▁ = ▁ new ▁ BufferedReader ( new ▁ InputStreamReader ( System . in ) ) ; % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ StringBuilder ▁ sb ▁ = ▁ new ▁ StringBuilder ( ) ; % n % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ while ▁ ( true ) ▁ { % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ String ▁ line ▁ = ▁ br . readLine ( ) ; % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ ( null ▁ = = ▁ line ) ▁ break ; % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ sb . append ( line ) . append ( System . lineSeparator ( ) ) ; % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } % n % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ String ▁ program ▁ = ▁ String . format ( SOURCE , ▁ QUOTE , ▁ SOURCE , ▁ QUOTE , ▁ QUOTE , ▁ QUOTE , ▁ QUOTE , ▁ QUOTE ) ; % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ ( program . equals ( sb . toString ( ) ) ) ▁ { % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ System . out . println ( % caccept % c ) ; % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } ▁ else ▁ { % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ System . out . println ( % creject % c ) ; % n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } % n ▁ ▁ ▁ ▁ } % n } % n " ; private static final char QUOTE = 0x22 ; public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder sb = new StringBuilder ( ) ; while ( true ) { String line = br . readLine ( ) ; if ( null == line ) break ; sb . append ( line ) . append ( System . lineSeparator ( ) ) ; } String program = String . format ( SOURCE , QUOTE , SOURCE , QUOTE , QUOTE , QUOTE , QUOTE , QUOTE ) ; if ( program . equals ( sb . toString ( ) ) ) { System . out . println ( " accept " ) ; } else { System . out . println ( " reject " ) ; } } }
private static int hpo2 ( int n ) { return n & - n ; }
public static long backToTen ( String num , int oldBase ) { return Long . parseLong ( num , oldBase ) ; } public static String tenToBase ( long num , int newBase ) { return Long . toString ( num , newBase ) ; }
import java . util . * ; import static java . util . Arrays . * ; import static java . util . stream . Collectors . toList ; public class NonogramSolver { static String [ ] p1 = { " C ▁ BA ▁ CB ▁ BB ▁ F ▁ AE ▁ F ▁ A ▁ B " , " AB ▁ CA ▁ AE ▁ GA ▁ E ▁ C ▁ D ▁ C " } ; static String [ ] p2 = { " F ▁ CAC ▁ ACAC ▁ CN ▁ AAA ▁ AABB ▁ EBB ▁ EAA ▁ ECCC ▁ HCCC " , " D ▁ D ▁ AE ▁ " + " CD ▁ AE ▁ A ▁ DA ▁ BBB ▁ CC ▁ AAB ▁ BAA ▁ AAB ▁ DA ▁ AAB ▁ AAA ▁ BAB ▁ AAA ▁ CD ▁ BBA ▁ DA " } ; static String [ ] p3 = { " CA ▁ BDA ▁ ACC ▁ BD ▁ CCAC ▁ CBBAC ▁ BBBBB ▁ BAABAA ▁ ABAD ▁ AABB ▁ BBH ▁ " + " BBBD ▁ ABBAAA ▁ CCEA ▁ AACAAB ▁ BCACC ▁ ACBH ▁ DCH ▁ ADBE ▁ ADBB ▁ DBE ▁ ECE ▁ DAA ▁ DB ▁ CC " , " BC ▁ CAC ▁ CBAB ▁ BDD ▁ CDBDE ▁ BEBDF ▁ ADCDFA ▁ DCCFB ▁ DBCFC ▁ ABDBA ▁ BBF ▁ AAF ▁ BADB ▁ DBF ▁ " + " AAAAD ▁ BDG ▁ CEF ▁ CBDB ▁ BBB ▁ FC " } ; static String [ ] p4 = { " E ▁ BCB ▁ BEA ▁ BH ▁ BEK ▁ AABAF ▁ ABAC ▁ BAA ▁ BFB ▁ OD ▁ JH ▁ BADCF ▁ Q ▁ Q ▁ " + " R ▁ AN ▁ AAN ▁ EI ▁ H ▁ G " , " E ▁ CB ▁ BAB ▁ AAA ▁ AAA ▁ AC ▁ BB ▁ ACC ▁ ACCA ▁ AGB ▁ AIA ▁ AJ ▁ AJ ▁ " + " ACE ▁ AH ▁ BAF ▁ CAG ▁ DAG ▁ FAH ▁ FJ ▁ GJ ▁ ADK ▁ ABK ▁ BL ▁ CM " } ; public static void main ( String [ ] args ) { for ( String [ ] puzzleData : new String [ ] [ ] { p1 , p2 , p3 , p4 } ) newPuzzle ( puzzleData ) ; } static void newPuzzle ( String [ ] data ) { String [ ] rowData = data [ 0 ] . split ( " \\ s " ) ; String [ ] colData = data [ 1 ] . split ( " \\ s " ) ; List < List < BitSet > > cols , rows ; rows = getCandidates ( rowData , colData . length ) ; cols = getCandidates ( colData , rowData . length ) ; int numChanged ; do { numChanged = reduceMutual ( cols , rows ) ; if ( numChanged == - 1 ) { System . out . println ( " No ▁ solution " ) ; return ; } } while ( numChanged > 0 ) ; for ( List < BitSet > row : rows ) { for ( int i = 0 ; i < cols . size ( ) ; i ++ ) System . out . print ( row . get ( 0 ) . get ( i ) ? " # ▁ " : " . ▁ " ) ; System . out . println ( ) ; } System . out . println ( ) ; } static List < List < BitSet > > getCandidates ( String [ ] data , int len ) { List < List < BitSet > > result = new ArrayList < > ( ) ; for ( String s : data ) { List < BitSet > lst = new LinkedList < > ( ) ; int sumChars = s . chars ( ) . map ( c -> c - ' A ' + 1 ) . sum ( ) ; List < String > prep = stream ( s . split ( " " ) ) . map ( x -> repeat ( x . charAt ( 0 ) - ' A ' + 1 , "1" ) ) . collect ( toList ( ) ) ; for ( String r : genSequence ( prep , len - sumChars + 1 ) ) { char [ ] bits = r . substring ( 1 ) . toCharArray ( ) ; BitSet bitset = new BitSet ( bits . length ) ; for ( int i = 0 ; i < bits . length ; i ++ ) bitset . set ( i , bits [ i ] == '1' ) ; lst . add ( bitset ) ; } result . add ( lst ) ; } return result ; } static List < String > genSequence ( List < String > ones , int numZeros ) { if ( ones . isEmpty ( ) ) return asList ( repeat ( numZeros , "0" ) ) ; List < String > result = new ArrayList < > ( ) ; for ( int x = 1 ; x < numZeros - ones . size ( ) + 2 ; x ++ ) { List < String > skipOne = ones . stream ( ) . skip ( 1 ) . collect ( toList ( ) ) ; for ( String tail : genSequence ( skipOne , numZeros - x ) ) result . add ( repeat ( x , "0" ) + ones . get ( 0 ) + tail ) ; } return result ; } static String repeat ( int n , String s ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) sb . append ( s ) ; return sb . toString ( ) ; } static int reduceMutual ( List < List < BitSet > > cols , List < List < BitSet > > rows ) { int countRemoved1 = reduce ( cols , rows ) ; if ( countRemoved1 == - 1 ) return - 1 ; int countRemoved2 = reduce ( rows , cols ) ; if ( countRemoved2 == - 1 ) return - 1 ; return countRemoved1 + countRemoved2 ; } static int reduce ( List < List < BitSet > > a , List < List < BitSet > > b ) { int countRemoved = 0 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { BitSet commonOn = new BitSet ( ) ; commonOn . set ( 0 , b . size ( ) ) ; BitSet commonOff = new BitSet ( ) ; for ( BitSet candidate : a . get ( i ) ) { commonOn . and ( candidate ) ; commonOff . or ( candidate ) ; } for ( int j = 0 ; j < b . size ( ) ; j ++ ) { final int fi = i , fj = j ; if ( b . get ( j ) . removeIf ( cnd -> ( commonOn . get ( fj ) && ! cnd . get ( fi ) ) || ( ! commonOff . get ( fj ) && cnd . get ( fi ) ) ) ) countRemoved ++ ; if ( b . get ( j ) . isEmpty ( ) ) return - 1 ; } } return countRemoved ; } }
if ( object == null ) { System . out . println ( " object ▁ is ▁ null " ) ; }
import java . util . List ; import java . util . ArrayList ; import java . util . Scanner ; import java . util . Collections ; public class ReversalGame { private List < Integer > gameList ; public ReversalGame ( ) { initialize ( ) ; } public void play ( ) throws Exception { int i = 0 ; int moveCount = 0 ; Scanner scanner = new Scanner ( System . in ) ; while ( true ) { System . out . println ( gameList ) ; System . out . println ( " Please ▁ enter ▁ a ▁ index ▁ to ▁ reverse ▁ from ▁ 2 ▁ to ▁ 9 . ▁ Enter ▁ 99 ▁ to ▁ quit " ) ; i = scanner . nextInt ( ) ; if ( i == 99 ) { break ; } if ( i < 2 || i > 9 ) { System . out . println ( " Invalid ▁ input " ) ; } else { moveCount ++ ; reverse ( i ) ; if ( isSorted ( ) ) { System . out . println ( " Congratulations ▁ you ▁ solved ▁ this ▁ in ▁ " + moveCount + " ▁ moves ! " ) ; break ; } } } scanner . close ( ) ; } private void reverse ( int position ) { Collections . reverse ( gameList . subList ( 0 , position ) ) ; } private boolean isSorted ( ) { for ( int i = 0 ; i < gameList . size ( ) - 1 ; ++ i ) { if ( gameList . get ( i ) . compareTo ( gameList . get ( i + 1 ) ) > 0 ) { return false ; } } return true ; } private void initialize ( ) { this . gameList = new ArrayList < Integer > ( 9 ) ; for ( int i = 1 ; i < 10 ; ++ i ) { gameList . add ( i ) ; } while ( isSorted ( ) ) { Collections . shuffle ( gameList ) ; } } public static void main ( String [ ] args ) { try { ReversalGame game = new ReversalGame ( ) ; game . play ( ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } }
public static double trapezium ( double a , double b , int n , FPFunction f ) { double range = checkParamsGetRange ( a , b , n ) ; double nFloat = ( double ) n ; double sum = 0.0 ; for ( int i = 1 ; i < n ; i ++ ) { double x = a + range * ( double ) i / nFloat ; sum += f . eval ( x ) ; } sum += ( f . eval ( a ) + f . eval ( b ) ) / 2.0 ; return sum * range / nFloat ; }
public static void main ( String [ ] args ) { Function < Double , Double > f = x -> sin ( x ) ; System . out . printf ( " integrate ▁ sin ( x ) , ▁ x ▁ = ▁ 0 ▁ . . ▁ Pi ▁ = ▁ % 2.12f . ▁ ▁ Function ▁ calls ▁ = ▁ % d % n " , quadratureAdaptiveSimpsons ( f , 0 , Math . PI , 1e-8 ) , functionCount ) ; functionCount = 0 ; System . out . printf ( " integrate ▁ sin ( x ) , ▁ x ▁ = ▁ 0 ▁ . . ▁ 1 ▁ = ▁ % 2.12f . ▁ ▁ Function ▁ calls ▁ = ▁ % d % n " , quadratureAdaptiveSimpsons ( f , 0 , 1 , 1e-8 ) , functionCount ) ; }
import java . io . * ; class Entity implements Serializable { static final long serialVersionUID = 3504465751164822571L ; String name = " Entity " ; public String toString ( ) { return name ; } } class Person extends Entity implements Serializable { static final long serialVersionUID = - 9170445713373959735L ; Person ( ) { name = " Cletus " ; } } public class SerializationTest { public static void main ( String [ ] args ) { Person instance1 = new Person ( ) ; System . out . println ( instance1 ) ; Entity instance2 = new Entity ( ) ; System . out . println ( instance2 ) ; try { ObjectOutput out = new ObjectOutputStream ( new FileOutputStream ( " objects . dat " ) ) ; out . writeObject ( instance1 ) ; out . writeObject ( instance2 ) ; out . close ( ) ; System . out . println ( " Serialized . . . " ) ; } catch ( IOException e ) { System . err . println ( " Something ▁ screwed ▁ up ▁ while ▁ serializing " ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } try { ObjectInput in = new ObjectInputStream ( new FileInputStream ( " objects . dat " ) ) ; Object readObject1 = in . readObject ( ) ; Object readObject2 = in . readObject ( ) ; in . close ( ) ; System . out . println ( " Deserialized . . . " ) ; System . out . println ( readObject1 ) ; System . out . println ( readObject2 ) ; } catch ( IOException e ) { System . err . println ( " Something ▁ screwed ▁ up ▁ while ▁ deserializing " ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } catch ( ClassNotFoundException e ) { System . err . println ( " Unknown ▁ class ▁ for ▁ deserialized ▁ object " ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } } }
import java . io . * ; import java . util . * ; public class OddWords { public static void main ( String [ ] args ) { try { Set < String > dictionary = new TreeSet < > ( ) ; final int minLength = 5 ; String fileName = " unixdict . txt " ; if ( args . length != 0 ) fileName = args [ 0 ] ; try ( BufferedReader reader = new BufferedReader ( new FileReader ( fileName ) ) ) { String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . length ( ) >= minLength ) dictionary . add ( line ) ; } } StringBuilder word1 = new StringBuilder ( ) ; StringBuilder word2 = new StringBuilder ( ) ; List < StringPair > evenWords = new ArrayList < > ( ) ; List < StringPair > oddWords = new ArrayList < > ( ) ; for ( String word : dictionary ) { int length = word . length ( ) ; if ( length < minLength + 2 * ( minLength / 2 ) ) continue ; word1 . setLength ( 0 ) ; word2 . setLength ( 0 ) ; for ( int i = 0 ; i < length ; ++ i ) { if ( ( i & 1 ) == 0 ) word1 . append ( word . charAt ( i ) ) ; else word2 . append ( word . charAt ( i ) ) ; } String oddWord = word1 . toString ( ) ; String evenWord = word2 . toString ( ) ; if ( dictionary . contains ( oddWord ) ) oddWords . add ( new StringPair ( word , oddWord ) ) ; if ( dictionary . contains ( evenWord ) ) evenWords . add ( new StringPair ( word , evenWord ) ) ; } System . out . println ( " Odd ▁ words : " ) ; printWords ( oddWords ) ; System . out . println ( " \n Even ▁ words : " ) ; printWords ( evenWords ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } private static void printWords ( List < StringPair > strings ) { int n = 1 ; for ( StringPair pair : strings ) { System . out . printf ( " % 2d :   % -14s % s \n " , n ++ , pair . string1 , pair . string2 ) ; } } private static class StringPair { private String string1 ; private String string2 ; private StringPair ( String s1 , String s2 ) { string1 = s1 ; string2 = s2 ; } } }
public class OldLadySwallowedAFly { final static String [ ] data = { " _ ha ▁ _ c ▁ _ e ▁ _ p , / Quite ▁ absurd _ f _ p ; _ ` cat , / Fancy ▁ that _ fcat ; _ j ` dog , / What ▁ a ▁ hog " + " _ fdog ; _ l ` pig , / Her ▁ mouth _ qso ▁ big _ fpig ; _ d _ r , / She ▁ just ▁ opened ▁ her ▁ throat _ f _ " + " r ; _ icow , / _ mhow ▁ she _ ga ▁ cow ; _ k _ o , / It _ qrather ▁ wonky _ f _ o ; _ a _ o _ bcow , _ khorse . . " + " . / She ' s ▁ dead , ▁ of ▁ course ! / " , " _ a _ p _ b _ e ▁ " , " / S _ t ▁ " , " ▁ to ▁ catch ▁ the ▁ " , " fly , / Bu " + " t ▁ _ mwhy ▁ s _ t ▁ fly , / Perhaps ▁ she ' ll ▁ die ! // _ ha " , " _ apig _ bdog , _ l ` " , " spider , / Tha " + " t ▁ wr _ nj _ ntickled ▁ inside ▁ her ; _ aspider _ b _ c " , " , ▁ to _ s ▁ a ▁ " , " _ sed ▁ " , " There _ qan " + " ▁ old ▁ lady ▁ who _ g " , " _ a _ r _ bpig , _ d " , " _ acat _ b _ p , _ " , " _ acow _ b _ r , _ i " , " _ adog _ bcat " + " , _ j " , " I ▁ don ' t ▁ know ▁ " , " iggled ▁ and ▁ " , " donkey " , " bird " , " ▁ was ▁ " , " goat " , " ▁ swal " + " low " , " he _ gthe " } ; static boolean oldLady ( String part , boolean s ) { for ( char c : part . toCharArray ( ) ) { if ( s ) s = oldLady ( data [ c - ' _ ' ] , false ) ; else if ( c == ' _ ' ) s = true ; else System . out . print ( c == ' / ' ? ' \n ' : c ) ; } return s ; } public static void main ( String [ ] args ) { oldLady ( data [ 0 ] , false ) ; } }
public class OldRussianMeasures { final static String [ ] keys = { " tochka " , " liniya " , " centimeter " , " diuym " , " vershok " , " piad " , " fut " , " arshin " , " meter " , " sazhen " , " kilometer " , " versta " , " milia " } ; final static double [ ] values = { 0.000254 , 0.00254 , 0.01 , 0.0254 , 0.04445 , 0.1778 , 0.3048 , 0.7112 , 1.0 , 2.1336 , 1000.0 , 1066.8 , 7467.6 } ; public static void main ( String [ ] a ) { if ( a . length == 2 && a [ 0 ] . matches ( " [ + - ] ? \\ d * ( \\ . \\ d + ) ? " ) ) { double inputVal = lookup ( a [ 1 ] ) ; if ( ! Double . isNaN ( inputVal ) ) { double magnitude = Double . parseDouble ( a [ 0 ] ) ; double meters = magnitude * inputVal ; System . out . printf ( " % s ▁ % s ▁ to : ▁ % n % n " , a [ 0 ] , a [ 1 ] ) ; for ( String k : keys ) System . out . printf ( " % 10s : ▁ % g % n " , k , meters / lookup ( k ) ) ; return ; } } System . out . println ( " Please ▁ provide ▁ a ▁ number ▁ and ▁ unit " ) ; } public static double lookup ( String key ) { for ( int i = 0 ; i < keys . length ; i ++ ) if ( keys [ i ] . equals ( key ) ) return values [ i ] ; return Double . NaN ; } }
public static int oneOfN ( int n ) { int choice = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( rand . nextInt ( i + 1 ) == 0 ) choice = i ; } return choice ; }
public class Life { public static void main ( String [ ] args ) throws Exception { String start = " _ # # # _ # # _ # _ # _ # _ # _ _ # _ _ " ; int numGens = 10 ; for ( int i = 0 ; i < numGens ; i ++ ) { System . out . println ( " Generation ▁ " + i + " : ▁ " + start ) ; start = life ( start ) ; } } public static String life ( String lastGen ) { String newGen = " " ; for ( int i = 0 ; i < lastGen . length ( ) ; i ++ ) { int neighbors = 0 ; if ( i == 0 ) { neighbors = lastGen . charAt ( 1 ) == ' # ' ? 1 : 0 ; } else if ( i == lastGen . length ( ) - 1 ) { neighbors = lastGen . charAt ( i - 1 ) == ' # ' ? 1 : 0 ; } else { neighbors = getNeighbors ( lastGen . substring ( i - 1 , i + 2 ) ) ; } if ( neighbors == 0 ) { newGen += " _ " ; } if ( neighbors == 1 ) { newGen += lastGen . charAt ( i ) ; } if ( neighbors == 2 ) { newGen += lastGen . charAt ( i ) == ' # ' ? " _ " : " # " ; } } return newGen ; } public static int getNeighbors ( String group ) { int ans = 0 ; if ( group . charAt ( 0 ) == ' # ' ) ans ++ ; if ( group . charAt ( 2 ) == ' # ' ) ans ++ ; return ans ; } }
public static void main ( String [ ] args ) { String controlName = " AtomicBlonde " ; generatePad ( controlName , 5 , 60 , 65 , 90 ) ; String text = " IT ▁ WAS ▁ THE ▁ BEST ▁ OF ▁ TIMES ▁ IT ▁ WAS ▁ THE ▁ WORST ▁ OF ▁ TIMES " ; String encrypted = parse ( true , controlName , text . replaceAll ( " ▁ " , " " ) ) ; String decrypted = parse ( false , controlName , encrypted ) ; System . out . println ( " Input ▁ ▁ text ▁ ▁ ▁ ▁ = ▁ " + text ) ; System . out . println ( " Encrypted ▁ text ▁ = ▁ " + encrypted ) ; System . out . println ( " Decrypted ▁ text ▁ = ▁ " + decrypted ) ; controlName = " AtomicBlondeCaseSensitive " ; generatePad ( controlName , 5 , 60 , 32 , 126 ) ; text = " It ▁ was ▁ the ▁ best ▁ of ▁ times , ▁ it ▁ was ▁ the ▁ worst ▁ of ▁ times . " ; encrypted = parse ( true , controlName , text ) ; decrypted = parse ( false , controlName , encrypted ) ; System . out . println ( ) ; System . out . println ( " Input ▁ text ▁ ▁ ▁ ▁ ▁ = ▁ " + text ) ; System . out . println ( " Encrypted ▁ text ▁ = ▁ " + encrypted ) ; System . out . println ( " Decrypted ▁ text ▁ = ▁ " + decrypted ) ; }
private static Vector [ ] rotate ( Vector i , Vector j , double alpha ) { return new Vector [ ] { mulAdd ( i , Math . cos ( alpha ) , j , Math . sin ( alpha ) ) , mulAdd ( i , - Math . sin ( alpha ) , j , Math . cos ( alpha ) ) } ; }
import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . LinkedList ; import java . util . List ; public class Ordered { private static boolean isOrderedWord ( String word ) { char [ ] sortedWord = word . toCharArray ( ) ; Arrays . sort ( sortedWord ) ; return word . equals ( new String ( sortedWord ) ) ; } public static void main ( String [ ] args ) throws IOException { List < String > orderedWords = new LinkedList < String > ( ) ; BufferedReader in = new BufferedReader ( new FileReader ( args [ 0 ] ) ) ; while ( in . ready ( ) ) { String word = in . readLine ( ) ; if ( isOrderedWord ( word ) ) orderedWords . add ( word ) ; } in . close ( ) ; Collections . < String > sort ( orderedWords , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { return new Integer ( o2 . length ( ) ) . compareTo ( o1 . length ( ) ) ; } } ) ; int maxLen = orderedWords . get ( 0 ) . length ( ) ; for ( String word : orderedWords ) { if ( word . length ( ) == maxLen ) { System . out . println ( word ) ; } else { break ; } } } }
public static void main ( String [ ] args ) { LocalDate date = LocalDate . of ( 2020 , 2 , 3 ) ; DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( " yyyyMMdd " ) ; DateTimeFormatter formatterDash = DateTimeFormatter . ofPattern ( " yyyy - MM - dd " ) ; System . out . printf ( " First ▁ 15 ▁ palindrome ▁ dates ▁ after ▁ 2020-02-02 ▁ are : % n " ) ; for ( int count = 0 ; count < 15 ; date = date . plusDays ( 1 ) ) { String dateFormatted = date . format ( formatter ) ; if ( dateFormatted . compareTo ( new StringBuilder ( dateFormatted ) . reverse ( ) . toString ( ) ) == 0 ) { count ++ ; System . out . printf ( " date ▁ = ▁ % s % n " , date . format ( formatterDash ) ) ; } } }
public static boolean isGapful ( long n ) { String s = Long . toString ( n ) ; return n % Long . parseLong ( " " + s . charAt ( 0 ) + s . charAt ( s . length ( ) - 1 ) ) == 0 ; }
private static int pancake ( int n ) { int gap = 2 ; int sum = 2 ; int adj = - 1 ; while ( sum < n ) { adj ++ ; gap = 2 * gap - 1 ; sum += gap ; } return n + adj ; }
static void bicenter ( int s ) { if ( ( s & 1 ) == 0 ) { BigInteger tmp = rooted [ s / 2 ] ; tmp = tmp . add ( BigInteger . ONE ) . multiply ( rooted [ s / 2 ] ) ; unrooted [ s ] = unrooted [ s ] . add ( tmp . shiftRight ( 1 ) ) ; } }
public static void main ( String [ ] args ) throws NoSuchAlgorithmException { String [ ] hashes = { "1115dd800feaacefdf481f1f9070374a2a81e27880f187396db67958b207cbad " , "3a7bd3e2360a3d29eea436fcfb7e44c735d117c42d1c1835420b6b9942dd4f1b " , "74e1bb62f8dabb8125a58852b63bdf6eaef667cb56ac7f7cdba6d7305c50a22f " } ; ExecutorService executorService = Executors . newFixedThreadPool ( 3 ) ; for ( String hash : hashes ) { executorService . submit ( new Forcer ( hash ) ) ; } executorService . shutdown ( ) ; }
public static void main ( String ... arguments ) { stream ( NUMBERS ) . unordered ( ) . parallel ( ) . mapToObj ( ParallelCalculations :: minimalPrimeFactor ) . max ( comparing ( a -> a [ 0 ] ) ) . ifPresent ( res -> out . printf ( " % d ▁ has ▁ the ▁ largest ▁ minimum ▁ prime ▁ factor : ▁ % d % n " , res [ 1 ] , res [ 0 ] ) ) ; }
import java . sql . DriverManager ; import java . sql . Connection ; import java . sql . PreparedStatement ; public class DBDemo { private String protocol ; private String dbName ; private String username ; private String password ; PreparedStatement query ; public int setUpAndExecPS ( ) { try { Connection conn = DriverManager . getConnection ( protocol + dbName , username , password ) ; query = conn . prepareStatement ( " UPDATE ▁ players ▁ SET ▁ name ▁ =   ? , ▁ score ▁ =   ? , ▁ active ▁ =   ? ▁ WHERE ▁ jerseyNum ▁ =   ? " ) ; query . setString ( 1 , " Smith , ▁ Steve " ) ; query . setInt ( 2 , 42 ) ; query . setBoolean ( 3 , true ) ; query . setInt ( 4 , 99 ) ; return query . executeUpdate ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return 0 ; } }
import java . util . Arrays ; public class PartialApplication { interface IntegerFunction { int call ( int arg ) ; } static int [ ] fs ( IntegerFunction f , int [ ] s ) { int [ ] r = new int [ s . length ] ; for ( int i = 0 ; i < s . length ; i ++ ) r [ i ] = f . call ( s [ i ] ) ; return r ; } interface SequenceFunction { int [ ] call ( int [ ] arg ) ; } static SequenceFunction fs ( final IntegerFunction f ) { return new SequenceFunction ( ) { public int [ ] call ( int [ ] s ) { return fs ( f , s ) ; } } ; } static IntegerFunction f1 = new IntegerFunction ( ) { public int call ( int i ) { return i * 2 ; } } ; static IntegerFunction f2 = new IntegerFunction ( ) { public int call ( int i ) { return i * i ; } } ; static SequenceFunction fsf1 = fs ( f1 ) ; static SequenceFunction fsf2 = fs ( f2 ) ; public static void main ( String [ ] args ) { int [ ] [ ] sequences = { { 0 , 1 , 2 , 3 } , { 2 , 4 , 6 , 8 } , } ; for ( int [ ] array : sequences ) { System . out . printf ( " array : ▁ % s \n " + " ▁ ▁ fsf1 ( array ) : ▁ % s \n " + " ▁ ▁ fsf2 ( array ) : ▁ % s \n " , Arrays . toString ( array ) , Arrays . toString ( fsf1 . call ( array ) ) , Arrays . toString ( fsf2 . call ( array ) ) ) ; } } }
private static double mccormick ( double [ ] x ) { double a = x [ 0 ] ; double b = x [ 1 ] ; return Math . sin ( a + b ) + ( a - b ) * ( a - b ) + 1.0 + 2.5 * b - 1.5 * a ; }
static List < IntStream > pascalUpp ( int n ) { return pascal ( n , i -> range ( 0 , n ) . map ( j -> binomialCoef ( j , i ) ) ) ; }
static List < IntStream > pascalLow ( int n ) { return pascal ( n , i -> range ( 0 , n ) . map ( j -> binomialCoef ( i , j ) ) ) ; }
static List < IntStream > pascalSym ( int n ) { return pascal ( n , i -> range ( 0 , n ) . map ( j -> binomialCoef ( i + j , i ) ) ) ; }
import java . util . ArrayList ; ... public static void genPyrN ( int rows ) { if ( rows < 0 ) return ; ArrayList < Integer > last = new ArrayList < Integer > ( ) ; last . add ( 1 ) ; System . out . println ( last ) ; for ( int i = 1 ; i <= rows ; ++ i ) { ArrayList < Integer > thisRow = new ArrayList < Integer > ( ) ; thisRow . add ( last . get ( 0 ) ) ; for ( int j = 1 ; j < i ; ++ j ) { thisRow . add ( last . get ( j - 1 ) + last . get ( j ) ) ; } thisRow . add ( last . get ( 0 ) ) ; last = thisRow ; System . out . println ( thisRow ) ; } }
private static boolean place ( int m , int n , List < Position > pBlackQueens , List < Position > pWhiteQueens ) { if ( m == 0 ) { return true ; } boolean placingBlack = true ; for ( int i = 0 ; i < n ; ++ i ) { inner : for ( int j = 0 ; j < n ; ++ j ) { Position pos = new Position ( i , j ) ; for ( Position queen : pBlackQueens ) { if ( pos . equals ( queen ) || ! placingBlack && isAttacking ( queen , pos ) ) { continue inner ; } } for ( Position queen : pWhiteQueens ) { if ( pos . equals ( queen ) || placingBlack && isAttacking ( queen , pos ) ) { continue inner ; } } if ( placingBlack ) { pBlackQueens . add ( pos ) ; placingBlack = false ; } else { pWhiteQueens . add ( pos ) ; if ( place ( m - 1 , n , pBlackQueens , pWhiteQueens ) ) { return true ; } pBlackQueens . remove ( pBlackQueens . size ( ) - 1 ) ; pWhiteQueens . remove ( pWhiteQueens . size ( ) - 1 ) ; placingBlack = true ; } } } if ( ! placingBlack ) { pBlackQueens . remove ( pBlackQueens . size ( ) - 1 ) ; } return false ; }
import java . util . * ; public class PenneysGame { public static void main ( String [ ] args ) { Random rand = new Random ( ) ; String compChoice = " " , playerChoice ; if ( rand . nextBoolean ( ) ) { for ( int i = 0 ; i < 3 ; i ++ ) compChoice += " HT " . charAt ( rand . nextInt ( 2 ) ) ; System . out . printf ( " Computer ▁ chooses ▁ % s % n " , compChoice ) ; playerChoice = prompt ( compChoice ) ; } else { playerChoice = prompt ( compChoice ) ; compChoice = " T " ; if ( playerChoice . charAt ( 1 ) == ' T ' ) compChoice = " H " ; compChoice += playerChoice . substring ( 0 , 2 ) ; System . out . printf ( " Computer ▁ chooses ▁ % s % n " , compChoice ) ; } String tossed = " " ; while ( true ) { tossed += " HT " . charAt ( rand . nextInt ( 2 ) ) ; System . out . printf ( " Tossed ▁ % s % n " , tossed ) ; if ( tossed . endsWith ( playerChoice ) ) { System . out . println ( " You ▁ win ! " ) ; break ; } if ( tossed . endsWith ( compChoice ) ) { System . out . println ( " Computer ▁ wins ! " ) ; break ; } } } private static String prompt ( String otherChoice ) { Scanner sc = new Scanner ( System . in ) ; String s ; do { System . out . print ( " Choose ▁ a ▁ sequence : ▁ " ) ; s = sc . nextLine ( ) . trim ( ) . toUpperCase ( ) ; } while ( ! s . matches ( " [ HT ] { 3 } " ) || s . equals ( otherChoice ) ) ; return s ; } }
import java . awt . * ; import java . awt . geom . Path2D ; import javax . swing . * ; public class Pentagram extends JPanel { final double degrees144 = Math . toRadians ( 144 ) ; public Pentagram ( ) { setPreferredSize ( new Dimension ( 640 , 640 ) ) ; setBackground ( Color . white ) ; } private void drawPentagram ( Graphics2D g , int len , int x , int y , Color fill , Color stroke ) { double angle = 0 ; Path2D p = new Path2D . Float ( ) ; p . moveTo ( x , y ) ; for ( int i = 0 ; i < 5 ; i ++ ) { int x2 = x + ( int ) ( Math . cos ( angle ) * len ) ; int y2 = y + ( int ) ( Math . sin ( - angle ) * len ) ; p . lineTo ( x2 , y2 ) ; x = x2 ; y = y2 ; angle -= degrees144 ; } p . closePath ( ) ; g . setColor ( fill ) ; g . fill ( p ) ; g . setColor ( stroke ) ; g . draw ( p ) ; } @ Override public void paintComponent ( Graphics gg ) { super . paintComponent ( gg ) ; Graphics2D g = ( Graphics2D ) gg ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setStroke ( new BasicStroke ( 5 , BasicStroke . CAP_ROUND , 0 ) ) ; drawPentagram ( g , 500 , 70 , 250 , new Color ( 0x6495ED ) , Color . darkGray ) ; } public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> { JFrame f = new JFrame ( ) ; f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; f . setTitle ( " Pentagram " ) ; f . setResizable ( false ) ; f . add ( new Pentagram ( ) , BorderLayout . CENTER ) ; f . pack ( ) ; f . setLocationRelativeTo ( null ) ; f . setVisible ( true ) ; } ) ; } }
import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import javax . imageio . ImageIO ; public enum ImgDiffPercent { ; public static void main ( String [ ] args ) throws IOException { BufferedImage img1 = ImageIO . read ( new File ( " Lenna50 . jpg " ) ) ; BufferedImage img2 = ImageIO . read ( new File ( " Lenna100 . jpg " ) ) ; double p = getDifferencePercent ( img1 , img2 ) ; System . out . println ( " diff ▁ percent : ▁ " + p ) ; } private static double getDifferencePercent ( BufferedImage img1 , BufferedImage img2 ) { int width = img1 . getWidth ( ) ; int height = img1 . getHeight ( ) ; int width2 = img2 . getWidth ( ) ; int height2 = img2 . getHeight ( ) ; if ( width != width2 || height != height2 ) { throw new IllegalArgumentException ( String . format ( " Images ▁ must ▁ have ▁ the ▁ same ▁ dimensions : ▁ ( % d , % d ) ▁ vs . ▁ ( % d , % d ) " , width , height , width2 , height2 ) ) ; } long diff = 0 ; for ( int y = 0 ; y < height ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { diff += pixelDiff ( img1 . getRGB ( x , y ) , img2 . getRGB ( x , y ) ) ; } } long maxDiff = 3L * 255 * width * height ; return 100.0 * diff / maxDiff ; } private static int pixelDiff ( int rgb1 , int rgb2 ) { int r1 = ( rgb1 >> 16 ) & 0xff ; int g1 = ( rgb1 >> 8 ) & 0xff ; int b1 = rgb1 & 0xff ; int r2 = ( rgb2 >> 16 ) & 0xff ; int g2 = ( rgb2 >> 8 ) & 0xff ; int b2 = rgb2 & 0xff ; return Math . abs ( r1 - r2 ) + Math . abs ( g1 - g2 ) + Math . abs ( b1 - b2 ) ; } }
public static void main ( String [ ] args ) { int [ ] sizes = { 8 , 24 , 52 , 100 , 1020 , 1024 , 10_000 } ; for ( int size : sizes ) System . out . printf ( " % 5d  : ▁ % 5d % n " , size , perfectShuffle ( size ) ) ; }
private static final List < Integer > perfectTotient ( int n ) { int test = 2 ; List < Integer > results = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; test ++ ) { int phiLoop = test ; int sum = 0 ; do { phiLoop = phi [ phiLoop ] ; sum += phiLoop ; } while ( phiLoop > 1 ) ; if ( sum == test ) { i ++ ; results . add ( test ) ; } } return results ; }
static double fade ( double t ) { return t * t * t * ( t * ( t * 6 - 15 ) + 10 ) ; }
static double lerp ( double t , double a , double b ) { return a + t * ( b - a ) ; }
static double grad ( int hash , double x , double y , double z ) { int h = hash & 15 ; double u = h < 8 ? x : y , v = h < 4 ? y : h == 12 || h == 14 ? x : z ; return ( ( h & 1 ) == 0 ? u : - u ) + ( ( h & 2 ) == 0 ? v : - v ) ; }
package org . rosettacode . java ; import java . util . Arrays ; import java . util . stream . IntStream ; public class HeapsAlgorithm { public static void main ( String [ ] args ) { Object [ ] array = IntStream . range ( 0 , 4 ) . boxed ( ) . toArray ( ) ; HeapsAlgorithm algorithm = new HeapsAlgorithm ( ) ; algorithm . recursive ( array ) ; System . out . println ( ) ; algorithm . loop ( array ) ; } void recursive ( Object [ ] array ) { recursive ( array , array . length , true ) ; } void recursive ( Object [ ] array , int n , boolean plus ) { if ( n == 1 ) { output ( array , plus ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { recursive ( array , n - 1 , i == 0 ) ; swap ( array , n % 2 == 0 ? i : 0 , n - 1 ) ; } } } void output ( Object [ ] array , boolean plus ) { System . out . println ( Arrays . toString ( array ) + ( plus ? " ▁ + 1" : " ▁ - 1" ) ) ; } void swap ( Object [ ] array , int a , int b ) { Object o = array [ a ] ; array [ a ] = array [ b ] ; array [ b ] = o ; } void loop ( Object [ ] array ) { loop ( array , array . length ) ; } void loop ( Object [ ] array , int n ) { int [ ] c = new int [ n ] ; output ( array , true ) ; boolean plus = false ; for ( int i = 0 ; i < n ; ) { if ( c [ i ] < i ) { if ( i % 2 == 0 ) { swap ( array , 0 , i ) ; } else { swap ( array , c [ i ] , i ) ; } output ( array , plus ) ; plus = ! plus ; c [ i ] ++ ; i = 0 ; } else { c [ i ] = 0 ; i ++ ; } } } }
public static void main ( String [ ] args ) { char [ ] chars = { ' a ' , ' b ' , ' c ' , ' d ' } ; permute ( chars , 3 , i -> i [ 0 ] == 1 && i [ 1 ] == 1 && i [ 2 ] == 0 ) ; }
public class PermutationGenerator { private int [ ] array ; private int firstNum ; private boolean firstReady = false ; public PermutationGenerator ( int n , int firstNum_ ) { if ( n < 1 ) { throw new IllegalArgumentException ( " The ▁ n ▁ must ▁ be ▁ min . ▁ 1" ) ; } firstNum = firstNum_ ; array = new int [ n ] ; reset ( ) ; } public void reset ( ) { for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = i + firstNum ; } firstReady = false ; } public boolean hasMore ( ) { boolean end = firstReady ; for ( int i = 1 ; i < array . length ; i ++ ) { end = end && array [ i ] < array [ i - 1 ] ; } return ! end ; } public int [ ] getNext ( ) { if ( ! firstReady ) { firstReady = true ; return array ; } int temp ; int j = array . length - 2 ; int k = array . length - 1 ; for ( ; array [ j ] > array [ j + 1 ] ; j -- ) ; for ( ; array [ j ] > array [ k ] ; k -- ) ; temp = array [ k ] ; array [ k ] = array [ j ] ; array [ j ] = temp ; int r = array . length - 1 ; int s = j + 1 ; while ( r > s ) { temp = array [ s ] ; array [ s ++ ] = array [ r ] ; array [ r -- ] = temp ; } return array ; } public static void main ( String [ ] args ) { PermutationGenerator pg = new PermutationGenerator ( 3 , 1 ) ; while ( pg . hasMore ( ) ) { int [ ] temp = pg . getNext ( ) ; for ( int i = 0 ; i < temp . length ; i ++ ) { System . out . print ( temp [ i ] + " ▁ " ) ; } System . out . println ( ) ; } } }
static Object [ ] derangements ( int n , boolean countOnly ) { int [ ] seq = iota ( n ) ; int [ ] ori = Arrays . copyOf ( seq , n ) ; long tot = fact ( n ) ; List < int [ ] > all = new ArrayList < int [ ] > ( ) ; int cnt = n == 0 ? 1 : 0 ; while ( -- tot > 0 ) { int j = n - 2 ; while ( seq [ j ] > seq [ j + 1 ] ) { j -- ; } int k = n - 1 ; while ( seq [ j ] > seq [ k ] ) { k -- ; } swap ( seq , k , j ) ; int r = n - 1 ; int s = j + 1 ; while ( r > s ) { swap ( seq , s , r ) ; r -- ; s ++ ; } j = 0 ; while ( j < n && seq [ j ] != ori [ j ] ) { j ++ ; } if ( j == n ) { if ( countOnly ) { cnt ++ ; } else { all . add ( Arrays . copyOf ( seq , n ) ) ; } } } return new Object [ ] { all , cnt } ; }
static long subfact ( long n ) { if ( 0 <= n && n <= 2 ) { return n != 1 ? 1 : 0 ; } return ( n - 1 ) * ( subfact ( n - 1 ) + subfact ( n - 2 ) ) ; }
import java . util . * ; public class PigDice { public static void main ( String [ ] args ) { final int maxScore = 100 ; final int playerCount = 2 ; final String [ ] yesses = { " y " , " Y " , " " } ; int [ ] safeScore = new int [ 2 ] ; int player = 0 , score = 0 ; Scanner sc = new Scanner ( System . in ) ; Random rnd = new Random ( ) ; while ( true ) { System . out . printf ( " ▁ Player ▁ % d : ▁ ( % d , ▁ % d ) ▁ Rolling ? ▁ ( y / n ) ▁ " , player , safeScore [ player ] , score ) ; if ( safeScore [ player ] + score < maxScore && Arrays . asList ( yesses ) . contains ( sc . nextLine ( ) ) ) { final int rolled = rnd . nextInt ( 6 ) + 1 ; System . out . printf ( " ▁ Rolled ▁ % d \n " , rolled ) ; if ( rolled == 1 ) { System . out . printf ( " ▁ Bust ! ▁ You ▁ lose ▁ % d ▁ but ▁ keep ▁ % d \n \n " , score , safeScore [ player ] ) ; } else { score += rolled ; continue ; } } else { safeScore [ player ] += score ; if ( safeScore [ player ] >= maxScore ) break ; System . out . printf ( " ▁ Sticking ▁ with ▁ % d \n \n " , safeScore [ player ] ) ; } score = 0 ; player = ( player + 1 ) % playerCount ; } System . out . printf ( " \n \n Player ▁ % d ▁ wins ▁ with ▁ a ▁ score ▁ of ▁ % d " , player , safeScore [ player ] ) ; } }
import java . awt . * ; import javax . swing . * ; public class PinstripeDisplay extends JPanel { final int bands = 4 ; public PinstripeDisplay ( ) { setPreferredSize ( new Dimension ( 900 , 600 ) ) ; } @ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; int h = getHeight ( ) ; for ( int b = 1 ; b <= bands ; b ++ ) { for ( int x = 0 , colIndex = 0 ; x < getWidth ( ) ; x += b , colIndex ++ ) { g . setColor ( colIndex % 2 == 0 ? Color . white : Color . black ) ; g . fillRect ( x , ( b - 1 ) * ( h / bands ) , x + b , b * ( h / bands ) ) ; } } } public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { JFrame f = new JFrame ( ) ; f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; f . setTitle ( " PinstripeDisplay " ) ; f . add ( new PinstripeDisplay ( ) , BorderLayout . CENTER ) ; f . pack ( ) ; f . setLocationRelativeTo ( null ) ; f . setVisible ( true ) ; } } ) ; } }
public enum Pip { Two , Three , Four , Five , Six , Seven , Eight , Nine , Ten , Jack , Queen , King , Ace }
class T implements Cloneable { public String name ( ) { return " T " ; } public T copy ( ) { try { return ( T ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } } class S extends T { public String name ( ) { return " S " ; } } public class PolymorphicCopy { public static T copier ( T x ) { return x . copy ( ) ; } public static void main ( String [ ] args ) { T obj1 = new T ( ) ; S obj2 = new S ( ) ; System . out . println ( copier ( obj1 ) . name ( ) ) ; System . out . println ( copier ( obj2 ) . name ( ) ) ; } }
class Point { protected int x , y ; public Point ( ) { this ( 0 ) ; } public Point ( int x ) { this ( x , 0 ) ; } public Point ( int x , int y ) { this . x = x ; this . y = y ; } public Point ( Point p ) { this ( p . x , p . y ) ; } public int getX ( ) { return this . x ; } public int getY ( ) { return this . y ; } public void setX ( int x ) { this . x = x ; } public void setY ( int y ) { this . y = y ; } public void print ( ) { System . out . println ( " Point ▁ x : ▁ " + this . x + " ▁ y : ▁ " + this . y ) ; } } class Circle extends Point { private int r ; public Circle ( Point p ) { this ( p , 0 ) ; } public Circle ( Point p , int r ) { super ( p ) ; this . r = r ; } public Circle ( ) { this ( 0 ) ; } public Circle ( int x ) { this ( x , 0 ) ; } public Circle ( int x , int y ) { this ( x , y , 0 ) ; } public Circle ( int x , int y , int r ) { super ( x , y ) ; this . r = r ; } public Circle ( Circle c ) { this ( c . x , c . y , c . r ) ; } public int getR ( ) { return this . r ; } public void setR ( int r ) { this . r = r ; } public void print ( ) { System . out . println ( " Circle ▁ x : ▁ " + this . x + " ▁ y : ▁ " + this . y + " ▁ r : ▁ " + this . r ) ; } } public class test { public static void main ( String args [ ] ) { Point p = new Point ( ) ; Point c = new Circle ( ) ; p . print ( ) ; c . print ( ) ; } }
import java . util . Arrays ; public class Test { public static void main ( String [ ] args ) { int [ ] N = { 1 , - 12 , 0 , - 42 } ; int [ ] D = { 1 , - 3 } ; System . out . printf ( " % s ▁ / ▁ % s ▁ = ▁ % s " , Arrays . toString ( N ) , Arrays . toString ( D ) , Arrays . deepToString ( extendedSyntheticDivision ( N , D ) ) ) ; } static int [ ] [ ] extendedSyntheticDivision ( int [ ] dividend , int [ ] divisor ) { int [ ] out = dividend . clone ( ) ; int normalizer = divisor [ 0 ] ; for ( int i = 0 ; i < dividend . length - ( divisor . length - 1 ) ; i ++ ) { out [ i ] /= normalizer ; int coef = out [ i ] ; if ( coef != 0 ) { for ( int j = 1 ; j < divisor . length ; j ++ ) out [ i + j ] += - divisor [ j ] * coef ; } } int separator = out . length - ( divisor . length - 1 ) ; return new int [ ] [ ] { Arrays . copyOfRange ( out , 0 , separator ) , Arrays . copyOfRange ( out , separator , out . length ) } ; } }
import java . awt . * ; import java . awt . event . ActionEvent ; import javax . swing . * ; public class PolySpiral extends JPanel { double inc = 0 ; public PolySpiral ( ) { setPreferredSize ( new Dimension ( 640 , 640 ) ) ; setBackground ( Color . white ) ; new Timer ( 40 , ( ActionEvent e ) -> { inc = ( inc + 0.05 ) % 360 ; repaint ( ) ; } ) . start ( ) ; } void drawSpiral ( Graphics2D g , int len , double angleIncrement ) { double x1 = getWidth ( ) / 2 ; double y1 = getHeight ( ) / 2 ; double angle = angleIncrement ; for ( int i = 0 ; i < 150 ; i ++ ) { g . setColor ( Color . getHSBColor ( i / 150f , 1.0f , 1.0f ) ) ; double x2 = x1 + Math . cos ( angle ) * len ; double y2 = y1 - Math . sin ( angle ) * len ; g . drawLine ( ( int ) x1 , ( int ) y1 , ( int ) x2 , ( int ) y2 ) ; x1 = x2 ; y1 = y2 ; len += 3 ; angle = ( angle + angleIncrement ) % ( Math . PI * 2 ) ; } } @ Override public void paintComponent ( Graphics gg ) { super . paintComponent ( gg ) ; Graphics2D g = ( Graphics2D ) gg ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; drawSpiral ( g , 5 , Math . toRadians ( inc ) ) ; } public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> { JFrame f = new JFrame ( ) ; f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; f . setTitle ( " PolySpiral " ) ; f . setResizable ( true ) ; f . add ( new PolySpiral ( ) , BorderLayout . CENTER ) ; f . pack ( ) ; f . setLocationRelativeTo ( null ) ; f . setVisible ( true ) ; } ) ; } }
private static boolean isPractical ( int n ) { int [ ] divisors = properDivisors ( n ) ; for ( int i = 1 ; i < n ; ++ i ) { if ( ! sumOfAnySubset ( i , divisors , divisors . length ) ) return false ; } return true ; }
public static boolean prime ( long a ) { if ( a == 2 ) { return true ; } else if ( a <= 1 || a % 2 == 0 ) { return false ; } long max = ( long ) Math . sqrt ( a ) ; for ( long n = 3 ; n <= max ; n += 2 ) { if ( a % n == 0 ) { return false ; } } return true ; }
public static void main ( String [ ] args ) { BigInteger fiveK = BigInteger . valueOf ( 5_000 ) ; BigInteger bi = BigInteger . valueOf ( 2 ) ; while ( bi . compareTo ( fiveK ) < 0 ) { if ( digitSum ( bi ) == 25 ) { System . out . print ( bi ) ; System . out . print ( " ▁ ▁ " ) ; } bi = bi . nextProbablePrime ( ) ; } System . out . println ( ) ; }
static BigInteger primorial ( int n ) { if ( n == 0 ) return BigInteger . ONE ; BigInteger result = BigInteger . ONE ; for ( int i = 0 ; i < sieveLimit && n > 0 ; i ++ ) { if ( notPrime [ i ] ) continue ; result = result . multiply ( BigInteger . valueOf ( i ) ) ; n -- ; } return result ; }
import java . util . Objects ; public class PrintDebugStatement { private static void printDebug ( String message ) { Objects . requireNonNull ( message ) ; RuntimeException exception = new RuntimeException ( ) ; StackTraceElement [ ] stackTrace = exception . getStackTrace ( ) ; StackTraceElement stackTraceElement = stackTrace [ 1 ] ; String fileName = stackTraceElement . getFileName ( ) ; String className = stackTraceElement . getClassName ( ) ; String methodName = stackTraceElement . getMethodName ( ) ; int lineNumber = stackTraceElement . getLineNumber ( ) ; System . out . printf ( " [ DEBUG ] [ % s ▁ % s . % s # % d ] ▁ % s \n " , fileName , className , methodName , lineNumber , message ) ; } private static void blah ( ) { printDebug ( " Made ▁ It ! " ) ; } public static void main ( String [ ] args ) { printDebug ( " Hello ▁ world . " ) ; blah ( ) ; Runnable oops = ( ) -> printDebug ( " oops " ) ; oops . run ( ) ; } }
public static void main ( String [ ] args ) { String program = System . getProperty ( " sun . java . command " ) . split ( " ▁ " ) [ 0 ] ; System . out . println ( " Program : ▁ " + program ) ; }
if ( problem ) { System . exit ( integerErrorCode ) ; }
public class App { private static long mod ( long x , long y ) { long m = x % y ; if ( m < 0 ) { if ( y < 0 ) { return m - y ; } else { return m + y ; } } return m ; } public static class RNG { private final long [ ] a1 = { 0 , 1403580 , - 810728 } ; private static final long m1 = ( 1L << 32 ) - 209 ; private long [ ] x1 ; private final long [ ] a2 = { 527612 , 0 , - 1370589 } ; private static final long m2 = ( 1L << 32 ) - 22853 ; private long [ ] x2 ; private static final long d = m1 + 1 ; public void seed ( long state ) { x1 = new long [ ] { state , 0 , 0 } ; x2 = new long [ ] { state , 0 , 0 } ; } public long nextInt ( ) { long x1i = mod ( a1 [ 0 ] * x1 [ 0 ] + a1 [ 1 ] * x1 [ 1 ] + a1 [ 2 ] * x1 [ 2 ] , m1 ) ; long x2i = mod ( a2 [ 0 ] * x2 [ 0 ] + a2 [ 1 ] * x2 [ 1 ] + a2 [ 2 ] * x2 [ 2 ] , m2 ) ; long z = mod ( x1i - x2i , m1 ) ; x1 = new long [ ] { x1i , x1 [ 0 ] , x1 [ 1 ] } ; x2 = new long [ ] { x2i , x2 [ 0 ] , x2 [ 1 ] } ; return z + 1 ; } public double nextFloat ( ) { return 1.0 * nextInt ( ) / d ; } } public static void main ( String [ ] args ) { RNG rng = new RNG ( ) ; rng . seed ( 1234567 ) ; System . out . println ( rng . nextInt ( ) ) ; System . out . println ( rng . nextInt ( ) ) ; System . out . println ( rng . nextInt ( ) ) ; System . out . println ( rng . nextInt ( ) ) ; System . out . println ( rng . nextInt ( ) ) ; System . out . println ( ) ; int [ ] counts = { 0 , 0 , 0 , 0 , 0 } ; rng . seed ( 987654321 ) ; for ( int i = 0 ; i < 100_000 ; i ++ ) { int value = ( int ) Math . floor ( rng . nextFloat ( ) * 5.0 ) ; counts [ value ] ++ ; } for ( int i = 0 ; i < counts . length ; i ++ ) { System . out . printf ( " % d : ▁ % d % n " , i , counts [ i ] ) ; } } }
public class PCG32 { private static final long N = 6364136223846793005L ; private long state = 0x853c49e6748fea9bL ; private long inc = 0xda3e39cb94b95bdbL ; public void seed ( long seedState , long seedSequence ) { state = 0 ; inc = ( seedSequence << 1 ) | 1 ; nextInt ( ) ; state = state + seedState ; nextInt ( ) ; } public int nextInt ( ) { long old = state ; state = old * N + inc ; int shifted = ( int ) ( ( ( old >>> 18 ) ^ old ) >>> 27 ) ; int rot = ( int ) ( old >>> 59 ) ; return ( shifted >>> rot ) | ( shifted << ( ( ~ rot + 1 ) & 31 ) ) ; } public double nextFloat ( ) { var u = Integer . toUnsignedLong ( nextInt ( ) ) ; return ( double ) u / ( 1L << 32 ) ; } public static void main ( String [ ] args ) { var r = new PCG32 ( ) ; r . seed ( 42 , 54 ) ; System . out . println ( Integer . toUnsignedString ( r . nextInt ( ) ) ) ; System . out . println ( Integer . toUnsignedString ( r . nextInt ( ) ) ) ; System . out . println ( Integer . toUnsignedString ( r . nextInt ( ) ) ) ; System . out . println ( Integer . toUnsignedString ( r . nextInt ( ) ) ) ; System . out . println ( Integer . toUnsignedString ( r . nextInt ( ) ) ) ; System . out . println ( ) ; int [ ] counts = { 0 , 0 , 0 , 0 , 0 } ; r . seed ( 987654321 , 1 ) ; for ( int i = 0 ; i < 100_000 ; i ++ ) { int j = ( int ) Math . floor ( r . nextFloat ( ) * 5.0 ) ; counts [ j ] ++ ; } System . out . println ( " The ▁ counts ▁ for ▁ 100,000 ▁ repetitions ▁ are : " ) ; for ( int i = 0 ; i < counts . length ; i ++ ) { System . out . printf ( " ▁ ▁ % d  : ▁ % d \n " , i , counts [ i ] ) ; } } }
public class XorShiftStar { private static final long MAGIC = Long . parseUnsignedLong ( "2545F4914F6CDD1D " , 16 ) ; private long state ; public void seed ( long num ) { state = num ; } public int nextInt ( ) { long x ; int answer ; x = state ; x = x ^ ( x >>> 12 ) ; x = x ^ ( x << 25 ) ; x = x ^ ( x >>> 27 ) ; state = x ; answer = ( int ) ( ( x * MAGIC ) >> 32 ) ; return answer ; } public float nextFloat ( ) { return ( float ) Integer . toUnsignedLong ( nextInt ( ) ) / ( 1L << 32 ) ; } public static void main ( String [ ] args ) { var rng = new XorShiftStar ( ) ; rng . seed ( 1234567 ) ; System . out . println ( Integer . toUnsignedString ( rng . nextInt ( ) ) ) ; System . out . println ( Integer . toUnsignedString ( rng . nextInt ( ) ) ) ; System . out . println ( Integer . toUnsignedString ( rng . nextInt ( ) ) ) ; System . out . println ( Integer . toUnsignedString ( rng . nextInt ( ) ) ) ; System . out . println ( Integer . toUnsignedString ( rng . nextInt ( ) ) ) ; System . out . println ( ) ; int [ ] counts = { 0 , 0 , 0 , 0 , 0 } ; rng . seed ( 987654321 ) ; for ( int i = 0 ; i < 100_000 ; i ++ ) { int j = ( int ) Math . floor ( rng . nextFloat ( ) * 5.0 ) ; counts [ j ] ++ ; } for ( int i = 0 ; i < counts . length ; i ++ ) { System . out . printf ( " % d : ▁ % d \n " , i , counts [ i ] ) ; } } }
public class Queue < E > { Node < E > head = null , tail = null ; static class Node < E > { E value ; Node < E > next ; Node ( E value , Node < E > next ) { this . value = value ; this . next = next ; } } public Queue ( ) { } public void enqueue ( E value ) { Node < E > newNode = new Node < E > ( value , null ) ; if ( empty ( ) ) { head = newNode ; } else { tail . next = newNode ; } tail = newNode ; } public E dequeue ( ) throws java . util . NoSuchElementException { if ( empty ( ) ) { throw new java . util . NoSuchElementException ( " No ▁ more ▁ elements . " ) ; } E retVal = head . value ; head = head . next ; return retVal ; } public boolean empty ( ) { return head == null ; } }
import java . util . LinkedList ; import java . util . Queue ; ... Queue < Integer > queue = new LinkedList < Integer > ( ) ; System . out . println ( queue . isEmpty ( ) ) ; queue . add ( 1 ) ; queue . add ( 2 ) ; queue . add ( 3 ) ; System . out . println ( queue ) ; System . out . println ( queue . remove ( ) ) ; System . out . println ( queue ) ; System . out . println ( queue . isEmpty ( ) ) ;
private static < E extends Comparable < ? super E > > int partition ( E [ ] arr , int left , int right , int pivot ) { E pivotVal = arr [ pivot ] ; swap ( arr , pivot , right ) ; int storeIndex = left ; for ( int i = left ; i < right ; i ++ ) { if ( arr [ i ] . compareTo ( pivotVal ) < 0 ) { swap ( arr , i , storeIndex ) ; storeIndex ++ ; } } swap ( arr , right , storeIndex ) ; return storeIndex ; }
private static < E extends Comparable < ? super E > > E select ( E [ ] arr , int n ) { int left = 0 ; int right = arr . length - 1 ; Random rand = new Random ( ) ; while ( right >= left ) { int pivotIndex = partition ( arr , left , right , rand . nextInt ( right - left + 1 ) + left ) ; if ( pivotIndex == n ) { return arr [ pivotIndex ] ; } else if ( pivotIndex < n ) { left = pivotIndex + 1 ; } else { right = pivotIndex - 1 ; } } return null ; }
private static < E extends Comparable < ? super E > > E select ( E [ ] arr , int n ) { int left = 0 ; int right = arr . length - 1 ; Random rand = new Random ( ) ; while ( right >= left ) { int pivotIndex = partition ( arr , left , right , rand . nextInt ( right - left + 1 ) + left ) ; if ( pivotIndex == n ) { return arr [ pivotIndex ] ; } else if ( pivotIndex < n ) { left = pivotIndex + 1 ; } else { right = pivotIndex - 1 ; } } return null ; }
class S { public static void main ( String [ ] a ) { String s = " class ▁ S { public ▁ static ▁ void ▁ main ( String [ ] a ) { String ▁ s = ; char ▁ c = 34 ; System . out . println ( s . substring ( 0,52 ) + c + s + c + s . substring ( 52 ) ) ; } } " ; char c = 34 ; System . out . println ( s . substring ( 0 , 52 ) + c + s + c + s . substring ( 52 ) ) ; } }
import java . math . BigDecimal ; import java . math . MathContext ; import java . util . Arrays ; import java . util . List ; public class RamanujanConstant { public static void main ( String [ ] args ) { System . out . printf ( " Ramanujan ' s ▁ Constant ▁ to ▁ 100 ▁ digits ▁ = ▁ % s % n % n " , ramanujanConstant ( 163 , 100 ) ) ; System . out . printf ( " Heegner ▁ numbers ▁ yielding ▁ ' almost ' ▁ integers : % n " ) ; List < Integer > heegnerNumbers = Arrays . asList ( 19 , 43 , 67 , 163 ) ; List < Integer > heegnerVals = Arrays . asList ( 96 , 960 , 5280 , 640320 ) ; for ( int i = 0 ; i < heegnerNumbers . size ( ) ; i ++ ) { int heegnerNumber = heegnerNumbers . get ( i ) ; int heegnerVal = heegnerVals . get ( i ) ; BigDecimal integer = BigDecimal . valueOf ( heegnerVal ) . pow ( 3 ) . add ( BigDecimal . valueOf ( 744 ) ) ; BigDecimal compute = ramanujanConstant ( heegnerNumber , 50 ) ; System . out . printf ( " % 3d  : ▁ % 50s ▁ ~ ▁ % 18s ▁ ( diff ▁ ~ ▁ % s ) % n " , heegnerNumber , compute , integer , integer . subtract ( compute , new MathContext ( 30 ) ) . toPlainString ( ) ) ; } } public static BigDecimal ramanujanConstant ( int sqrt , int digits ) { MathContext mc = new MathContext ( digits + 5 ) ; return bigE ( bigPi ( mc ) . multiply ( bigSquareRoot ( BigDecimal . valueOf ( sqrt ) , mc ) , mc ) , mc ) . round ( new MathContext ( digits ) ) ; } public static BigDecimal bigE ( BigDecimal exponent , MathContext mc ) { BigDecimal e = BigDecimal . ONE ; BigDecimal ak = e ; int k = 0 ; BigDecimal min = BigDecimal . ONE . divide ( BigDecimal . TEN . pow ( mc . getPrecision ( ) ) ) ; while ( true ) { k ++ ; ak = ak . multiply ( exponent ) . divide ( BigDecimal . valueOf ( k ) , mc ) ; e = e . add ( ak , mc ) ; if ( ak . compareTo ( min ) < 0 ) { break ; } } return e ; } public static BigDecimal bigPi ( MathContext mc ) { int k = 0 ; BigDecimal ak = BigDecimal . ONE ; BigDecimal a = ak ; BigDecimal b = BigDecimal . ZERO ; BigDecimal c = BigDecimal . valueOf ( 640320 ) ; BigDecimal c3 = c . pow ( 3 ) ; double digitePerTerm = Math . log10 ( c . pow ( 3 ) . divide ( BigDecimal . valueOf ( 24 ) , mc ) . doubleValue ( ) ) - Math . log10 ( 72 ) ; double digits = 0 ; while ( digits < mc . getPrecision ( ) ) { k ++ ; digits += digitePerTerm ; BigDecimal top = BigDecimal . valueOf ( - 24 ) . multiply ( BigDecimal . valueOf ( 6 * k - 5 ) ) . multiply ( BigDecimal . valueOf ( 2 * k - 1 ) ) . multiply ( BigDecimal . valueOf ( 6 * k - 1 ) ) ; BigDecimal term = top . divide ( BigDecimal . valueOf ( k * k * k ) . multiply ( c3 ) , mc ) ; ak = ak . multiply ( term , mc ) ; a = a . add ( ak , mc ) ; b = b . add ( BigDecimal . valueOf ( k ) . multiply ( ak , mc ) , mc ) ; } BigDecimal total = BigDecimal . valueOf ( 13591409 ) . multiply ( a , mc ) . add ( BigDecimal . valueOf ( 545140134 ) . multiply ( b , mc ) , mc ) ; return BigDecimal . valueOf ( 426880 ) . multiply ( bigSquareRoot ( BigDecimal . valueOf ( 10005 ) , mc ) , mc ) . divide ( total , mc ) ; } public static BigDecimal bigSquareRoot ( BigDecimal squareDecimal , MathContext mc ) { double sqrt = Math . sqrt ( squareDecimal . doubleValue ( ) ) ; BigDecimal x0 = new BigDecimal ( sqrt , mc ) ; BigDecimal two = BigDecimal . valueOf ( 2 ) ; while ( true ) { BigDecimal x1 = x0 . subtract ( x0 . multiply ( x0 , mc ) . subtract ( squareDecimal ) . divide ( two . multiply ( x0 , mc ) , mc ) , mc ) ; String x1String = x1 . toPlainString ( ) ; String x0String = x0 . toPlainString ( ) ; if ( x1String . substring ( 0 , x1String . length ( ) - 1 ) . compareTo ( x0String . substring ( 0 , x0String . length ( ) - 1 ) ) == 0 ) { break ; } x0 = x1 ; } return x0 ; } }
import javafx . util . Pair ; import java . util . ArrayList ; import java . util . List ; public class LineSimplification { private static class Point extends Pair < Double , Double > { Point ( Double key , Double value ) { super ( key , value ) ; } @ Override public String toString ( ) { return String . format ( " ( % f , ▁ % f ) " , getKey ( ) , getValue ( ) ) ; } } private static double perpendicularDistance ( Point pt , Point lineStart , Point lineEnd ) { double dx = lineEnd . getKey ( ) - lineStart . getKey ( ) ; double dy = lineEnd . getValue ( ) - lineStart . getValue ( ) ; double mag = Math . hypot ( dx , dy ) ; if ( mag > 0.0 ) { dx /= mag ; dy /= mag ; } double pvx = pt . getKey ( ) - lineStart . getKey ( ) ; double pvy = pt . getValue ( ) - lineStart . getValue ( ) ; double pvdot = dx * pvx + dy * pvy ; double ax = pvx - pvdot * dx ; double ay = pvy - pvdot * dy ; return Math . hypot ( ax , ay ) ; } private static void ramerDouglasPeucker ( List < Point > pointList , double epsilon , List < Point > out ) { if ( pointList . size ( ) < 2 ) throw new IllegalArgumentException ( " Not ▁ enough ▁ points ▁ to ▁ simplify " ) ; double dmax = 0.0 ; int index = 0 ; int end = pointList . size ( ) - 1 ; for ( int i = 1 ; i < end ; ++ i ) { double d = perpendicularDistance ( pointList . get ( i ) , pointList . get ( 0 ) , pointList . get ( end ) ) ; if ( d > dmax ) { index = i ; dmax = d ; } } if ( dmax > epsilon ) { List < Point > recResults1 = new ArrayList < > ( ) ; List < Point > recResults2 = new ArrayList < > ( ) ; List < Point > firstLine = pointList . subList ( 0 , index + 1 ) ; List < Point > lastLine = pointList . subList ( index , pointList . size ( ) ) ; ramerDouglasPeucker ( firstLine , epsilon , recResults1 ) ; ramerDouglasPeucker ( lastLine , epsilon , recResults2 ) ; out . addAll ( recResults1 . subList ( 0 , recResults1 . size ( ) - 1 ) ) ; out . addAll ( recResults2 ) ; if ( out . size ( ) < 2 ) throw new RuntimeException ( " Problem ▁ assembling ▁ output " ) ; } else { out . clear ( ) ; out . add ( pointList . get ( 0 ) ) ; out . add ( pointList . get ( pointList . size ( ) - 1 ) ) ; } } public static void main ( String [ ] args ) { List < Point > pointList = List . of ( new Point ( 0.0 , 0.0 ) , new Point ( 1.0 , 0.1 ) , new Point ( 2.0 , - 0.1 ) , new Point ( 3.0 , 5.0 ) , new Point ( 4.0 , 6.0 ) , new Point ( 5.0 , 7.0 ) , new Point ( 6.0 , 8.1 ) , new Point ( 7.0 , 9.0 ) , new Point ( 8.0 , 9.0 ) , new Point ( 9.0 , 9.0 ) ) ; List < Point > pointListOut = new ArrayList < > ( ) ; ramerDouglasPeucker ( pointList , 1.0 , pointListOut ) ; System . out . println ( " Points ▁ remaining ▁ after ▁ simplification : " ) ; pointListOut . forEach ( System . out :: println ) ; } }
import java . security . SecureRandom ; public class RandomExample { public static void main ( String [ ] args ) { SecureRandom rng = new SecureRandom ( ) ; System . out . println ( rng . nextInt ( ) ) ; } }
setrand ( 3 ) random ( 6 ) + 1 \\ chosen by fair dice roll . \\ guaranteed to the random .
private static List < Range > consolidate ( List < Range > ranges ) { List < Range > consolidated = new ArrayList < > ( ) ; Collections . sort ( ranges , new RangeSorter ( ) ) ; for ( Range inRange : ranges ) { Range r = null ; Range conRange = null ; for ( Range conRangeLoop : consolidated ) { r = inRange . consolidate ( conRangeLoop ) ; if ( r != null ) { conRange = conRangeLoop ; break ; } } if ( r == null ) { consolidated . add ( inRange ) ; } else { consolidated . remove ( conRange ) ; consolidated . add ( r ) ; } } Collections . sort ( consolidated , new RangeSorter ( ) ) ; return consolidated ; }

import java . io . BufferedReader ; import java . io . FileReader ; public class ReadFileByLines { private static void processLine ( int lineNo , String line ) { } public static void main ( String [ ] args ) { for ( String filename : args ) { BufferedReader br = null ; FileReader fr = null ; try { fr = new FileReader ( filename ) ; br = new BufferedReader ( fr ) ; String line ; int lineNo = 0 ; while ( ( line = br . readLine ( ) ) != null ) { processLine ( ++ lineNo , line ) ; } } catch ( Exception x ) { x . printStackTrace ( ) ; } finally { if ( fr != null ) { try { br . close ( ) ; } catch ( Exception ignoreMe ) { } try { fr . close ( ) ; } catch ( Exception ignoreMe ) { } } } } } }
package linenbr7 ; import java . io . * ; public class LineNbr7 { public static void main ( String [ ] args ) throws Exception { File f = new File ( args [ 0 ] ) ; if ( ! f . isFile ( ) || ! f . canRead ( ) ) throw new IOException ( " can ' t ▁ read ▁ " + args [ 0 ] ) ; BufferedReader br = new BufferedReader ( new FileReader ( f ) ) ; try ( LineNumberReader lnr = new LineNumberReader ( br ) ) { String line = null ; int lnum = 0 ; while ( ( line = lnr . readLine ( ) ) != null && ( lnum = lnr . getLineNumber ( ) ) < 7 ) { } switch ( lnum ) { case 0 : System . out . println ( " the ▁ file ▁ has ▁ zero ▁ length " ) ; break ; case 7 : boolean empty = " " . equals ( line ) ; System . out . println ( " line ▁ 7 : ▁ " + ( empty ? " empty " : line ) ) ; break ; default : System . out . println ( " the ▁ file ▁ has ▁ only ▁ " + lnum + " ▁ line ( s ) " ) ; } } } }
import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; public class ReadFile { public static void main ( String [ ] args ) throws IOException { String fileContents = readEntireFile ( " . / foo . txt " ) ; } private static String readEntireFile ( String filename ) throws IOException { FileReader in = new FileReader ( filename ) ; StringBuilder contents = new StringBuilder ( ) ; char [ ] buffer = new char [ 4096 ] ; int read = 0 ; do { contents . append ( buffer , 0 , read ) ; read = in . read ( buffer ) ; } while ( read >= 0 ) ; in . close ( ) ; return contents . toString ( ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . HashMap ; import java . util . LinkedList ; import java . util . Map ; public class ReadlineInterface { private static LinkedList < String > histArr = new LinkedList < > ( ) ; private static void hist ( ) { if ( histArr . isEmpty ( ) ) { System . out . println ( " No ▁ history " ) ; } else { histArr . forEach ( cmd -> System . out . printf ( " ▁ - ▁ % s \n " , cmd ) ) ; } class Crutch { } histArr . add ( Crutch . class . getEnclosingMethod ( ) . getName ( ) ) ; } private static void hello ( ) { System . out . println ( " Hello ▁ World ! " ) ; class Crutch { } histArr . add ( Crutch . class . getEnclosingMethod ( ) . getName ( ) ) ; } private static void help ( ) { System . out . println ( " Available ▁ commands : " ) ; System . out . println ( " ▁ ▁ hello " ) ; System . out . println ( " ▁ ▁ hist " ) ; System . out . println ( " ▁ ▁ exit " ) ; System . out . println ( " ▁ ▁ help " ) ; class Crutch { } histArr . add ( Crutch . class . getEnclosingMethod ( ) . getName ( ) ) ; } public static void main ( String [ ] args ) throws IOException { Map < String , Runnable > cmdMap = new HashMap < > ( ) ; cmdMap . put ( " help " , ReadlineInterface :: help ) ; cmdMap . put ( " hist " , ReadlineInterface :: hist ) ; cmdMap . put ( " hello " , ReadlineInterface :: hello ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . println ( " Enter ▁ a ▁ command , ▁ type ▁ help ▁ for ▁ a ▁ listing . " ) ; while ( true ) { System . out . print ( " > " ) ; String line = in . readLine ( ) ; if ( " exit " . equals ( line ) ) { break ; } cmdMap . getOrDefault ( line , ReadlineInterface :: help ) . run ( ) ; } } }
Math . E ; Math . PI ; Math . sqrt ( x ) ; Math . log ( x ) ; Math . exp ( x ) ; Math . abs ( x ) ; Math . floor ( x ) ; Math . ceil ( x ) ; Math . pow ( x , y ) ;
import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; public class RecamanSequence { public static void main ( String [ ] args ) { List < Integer > a = new ArrayList < > ( ) ; a . add ( 0 ) ; Set < Integer > used = new HashSet < > ( ) ; used . add ( 0 ) ; Set < Integer > used1000 = new HashSet < > ( ) ; used1000 . add ( 0 ) ; boolean foundDup = false ; int n = 1 ; while ( n <= 15 || ! foundDup || used1000 . size ( ) < 1001 ) { int next = a . get ( n - 1 ) - n ; if ( next < 1 || used . contains ( next ) ) { next += 2 * n ; } boolean alreadyUsed = used . contains ( next ) ; a . add ( next ) ; if ( ! alreadyUsed ) { used . add ( next ) ; if ( 0 <= next && next <= 1000 ) { used1000 . add ( next ) ; } } if ( n == 14 ) { System . out . printf ( " The ▁ first ▁ 15 ▁ terms ▁ of ▁ the ▁ Recaman ▁ sequence ▁ are  : ▁ % s \n " , a ) ; } if ( ! foundDup && alreadyUsed ) { System . out . printf ( " The ▁ first ▁ duplicate ▁ term ▁ is ▁ a [ % d ] ▁ = ▁ % d \n " , n , next ) ; foundDup = true ; } if ( used1000 . size ( ) == 1001 ) { System . out . printf ( " Terms ▁ up ▁ to ▁ a [ % d ] ▁ are ▁ needed ▁ to ▁ generate ▁ 0 ▁ to ▁ 1000 \n " , n ) ; } n ++ ; } } }
public class ReflectionGetSource { public static void main ( String [ ] args ) { new ReflectionGetSource ( ) . method1 ( ) ; } public ReflectionGetSource ( ) { } public void method1 ( ) { method2 ( ) ; } public void method2 ( ) { method3 ( ) ; } public void method3 ( ) { Throwable t = new Throwable ( ) ; for ( StackTraceElement ste : t . getStackTrace ( ) ) { System . out . printf ( " File ▁ Name ▁ ▁ ▁ = ▁ % s % n " , ste . getFileName ( ) ) ; System . out . printf ( " Class ▁ Name ▁ ▁ = ▁ % s % n " , ste . getClassName ( ) ) ; System . out . printf ( " Method ▁ Name ▁ = ▁ % s % n " , ste . getMethodName ( ) ) ; System . out . printf ( " Line ▁ number ▁ = ▁ % s % n % n " , ste . getLineNumber ( ) ) ; } } }
import java . lang . reflect . Field ; public class ListFields { public int examplePublicField = 42 ; private boolean examplePrivateField = true ; public static void main ( String [ ] args ) throws IllegalAccessException { ListFields obj = new ListFields ( ) ; Class clazz = obj . getClass ( ) ; System . out . println ( " All ▁ public ▁ fields ▁ ( including ▁ inherited ) : " ) ; for ( Field f : clazz . getFields ( ) ) { System . out . printf ( " % s\t % s \n " , f , f . get ( obj ) ) ; } System . out . println ( ) ; System . out . println ( " All ▁ declared ▁ fields ▁ ( excluding ▁ inherited ) : " ) ; for ( Field f : clazz . getDeclaredFields ( ) ) { System . out . printf ( " % s\t % s \n " , f , f . get ( obj ) ) ; } } }
String str = " I ▁ am ▁ a ▁ string " ; if ( str . matches ( " . * string " ) ) { System . out . println ( " ends ▁ with ▁ ' string ' " ) ; }
import java . util . * ; class Test { public static void main ( String [ ] args ) { Object [ ] data = { 1 , 1 , 2 , 2 , 3 , 3 , 3 , " a " , " a " , " b " , " b " , " c " , " d " } ; Set < Object > uniqueSet = new HashSet < Object > ( Arrays . asList ( data ) ) ; for ( Object o : uniqueSet ) System . out . printf ( " % s ▁ " , o ) ; } }
import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; public class RemoveLines { public static void main ( String [ ] args ) { String filename = " foobar . txt " ; int startline = 1 ; int numlines = 2 ; RemoveLines now = new RemoveLines ( ) ; now . delete ( filename , startline , numlines ) ; } void delete ( String filename , int startline , int numlines ) { try { BufferedReader br = new BufferedReader ( new FileReader ( filename ) ) ; StringBuffer sb = new StringBuffer ( " " ) ; int linenumber = 1 ; String line ; while ( ( line = br . readLine ( ) ) != null ) { if ( linenumber < startline || linenumber >= startline + numlines ) sb . append ( line + " \n " ) ; linenumber ++ ; } if ( startline + numlines > linenumber ) System . out . println ( " End ▁ of ▁ file ▁ reached . " ) ; br . close ( ) ; FileWriter fw = new FileWriter ( new File ( filename ) ) ; fw . write ( sb . toString ( ) ) ; fw . close ( ) ; } catch ( Exception e ) { System . out . println ( " Something ▁ went ▁ horribly ▁ wrong : ▁ " + e . getMessage ( ) ) ; } } }
import java . io . File ; public class FileRenameTest { public static boolean renameFile ( String oldname , String newname ) { File file = new File ( oldname ) ; File file2 = new File ( newname ) ; boolean success = file . renameTo ( file2 ) ; return success ; } public static void test ( String type , String oldname , String newname ) { System . out . println ( " The ▁ following ▁ " + type + " ▁ called ▁ " + oldname + ( renameFile ( oldname , newname ) ? " ▁ was ▁ renamed ▁ as ▁ " : " ▁ could ▁ not ▁ be ▁ renamed ▁ into ▁ " ) + newname + " . " ) ; } public static void main ( String args [ ] ) { test ( " file " , " input . txt " , " output . txt " ) ; test ( " file " , File . separator + " input . txt " , File . separator + " output . txt " ) ; test ( " directory " , " docs " , " mydocs " ) ; test ( " directory " , File . separator + " docs " + File . separator , File . separator + " mydocs " + File . separator ) ; } }
public static String repeat ( String str , int times ) { StringBuilder sb = new StringBuilder ( str . length ( ) * times ) ; for ( int i = 0 ; i < times ; i ++ ) sb . append ( str ) ; return sb . toString ( ) ; } public static void main ( String [ ] args ) { System . out . println ( repeat ( " ha " , 5 ) ) ; }
static void repeat ( int n , Consumer < Integer > fun ) { IntStream . range ( 0 , n ) . forEach ( i -> fun . accept ( i + 1 ) ) ; }
private static void setBoundary ( List < List < Node > > m ) { m . get ( 1 ) . get ( 1 ) . v = 1.0 ; m . get ( 1 ) . get ( 1 ) . fixed = 1 ; m . get ( 6 ) . get ( 7 ) . v = - 1.0 ; m . get ( 6 ) . get ( 7 ) . fixed = - 1 ; }
public static String reverseString ( String s ) { return new StringBuffer ( s ) . reverse ( ) . toString ( ) ; }
public class ReverseWords { static final String [ ] lines = { " ▁ - - - - - - - - - - - ▁ Ice ▁ and ▁ Fire ▁ - - - - - - - - - - - ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ fire , ▁ in ▁ end ▁ will ▁ world ▁ the ▁ say ▁ Some ▁ " , " ▁ ice . ▁ in ▁ say ▁ Some ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ desire ▁ of ▁ tasted ▁ I ' ve ▁ what ▁ From ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ fire . ▁ favor ▁ who ▁ those ▁ with ▁ hold ▁ I ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ . . . ▁ elided ▁ paragraph ▁ last ▁ . . . ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ Frost ▁ Robert ▁ - - - - - - - - - - - - - - - - - - - - - - - ▁ " } ; public static void main ( String [ ] args ) { for ( String line : lines ) { String [ ] words = line . split ( " \\ s " ) ; for ( int i = words . length - 1 ; i >= 0 ; i -- ) System . out . printf ( " % s ▁ " , words [ i ] ) ; System . out . println ( ) ; } } }
import java . util . Arrays ; import java . util . EnumMap ; import java . util . List ; import java . util . Map ; import java . util . Scanner ; import java . util . Random ; public class RPS { public enum Item { ROCK , PAPER , SCISSORS , ; public List < Item > losesToList ; public boolean losesTo ( Item other ) { return losesToList . contains ( other ) ; } static { SCISSORS . losesToList = Arrays . asList ( ROCK ) ; ROCK . losesToList = Arrays . asList ( PAPER ) ; PAPER . losesToList = Arrays . asList ( SCISSORS ) ; } } public final Map < Item , Integer > counts = new EnumMap < Item , Integer > ( Item . class ) { { for ( Item item : Item . values ( ) ) put ( item , 1 ) ; } } ; private int totalThrows = Item . values ( ) . length ; public static void main ( String [ ] args ) { RPS rps = new RPS ( ) ; rps . run ( ) ; } public void run ( ) { Scanner in = new Scanner ( System . in ) ; System . out . print ( " Make ▁ your ▁ choice : ▁ " ) ; while ( in . hasNextLine ( ) ) { Item aiChoice = getAIChoice ( ) ; String input = in . nextLine ( ) ; Item choice ; try { choice = Item . valueOf ( input . toUpperCase ( ) ) ; } catch ( IllegalArgumentException ex ) { System . out . println ( " Invalid ▁ choice " ) ; continue ; } counts . put ( choice , counts . get ( choice ) + 1 ) ; totalThrows ++ ; System . out . println ( " Computer ▁ chose : ▁ " + aiChoice ) ; if ( aiChoice == choice ) { System . out . println ( " Tie ! " ) ; } else if ( aiChoice . losesTo ( choice ) ) { System . out . println ( " You ▁ chose . . . wisely . ▁ You ▁ win ! " ) ; } else { System . out . println ( " You ▁ chose . . . poorly . ▁ You ▁ lose ! " ) ; } System . out . print ( " Make ▁ your ▁ choice : ▁ " ) ; } } private static final Random rng = new Random ( ) ; private Item getAIChoice ( ) { int rand = rng . nextInt ( totalThrows ) ; for ( Map . Entry < Item , Integer > entry : counts . entrySet ( ) ) { Item item = entry . getKey ( ) ; int count = entry . getValue ( ) ; if ( rand < count ) { List < Item > losesTo = item . losesToList ; return losesTo . get ( rng . nextInt ( losesTo . size ( ) ) ) ; } rand -= count ; } return null ; } }
public class RN { enum Numeral { I ( 1 ) , IV ( 4 ) , V ( 5 ) , IX ( 9 ) , X ( 10 ) , XL ( 40 ) , L ( 50 ) , XC ( 90 ) , C ( 100 ) , CD ( 400 ) , D ( 500 ) , CM ( 900 ) , M ( 1000 ) ; int weight ; Numeral ( int weight ) { this . weight = weight ; } } ; public static String roman ( long n ) { if ( n <= 0 ) { throw new IllegalArgumentException ( ) ; } StringBuilder buf = new StringBuilder ( ) ; final Numeral [ ] values = Numeral . values ( ) ; for ( int i = values . length - 1 ; i >= 0 ; i -- ) { while ( n >= values [ i ] . weight ) { buf . append ( values [ i ] ) ; n -= values [ i ] . weight ; } } return buf . toString ( ) ; } public static void test ( long n ) { System . out . println ( n + " ▁ = ▁ " + roman ( n ) ) ; } public static void main ( String [ ] args ) { test ( 1999 ) ; test ( 25 ) ; test ( 944 ) ; test ( 0 ) ; } }
public class Roots { public interface Function { public double f ( double x ) ; } private static int sign ( double x ) { return ( x < 0.0 ) ? - 1 : ( x > 0.0 ) ? 1 : 0 ; } public static void printRoots ( Function f , double lowerBound , double upperBound , double step ) { double x = lowerBound , ox = x ; double y = f . f ( x ) , oy = y ; int s = sign ( y ) , os = s ; for ( ; x <= upperBound ; x += step ) { s = sign ( y = f . f ( x ) ) ; if ( s == 0 ) { System . out . println ( x ) ; } else if ( s != os ) { double dx = x - ox ; double dy = y - oy ; double cx = x - dx * ( y / dy ) ; System . out . println ( " ~ " + cx ) ; } ox = x ; oy = y ; os = s ; } } public static void main ( String [ ] args ) { Function poly = new Function ( ) { public double f ( double x ) { return x * x * x - 3 * x * x + 2 * x ; } } ; printRoots ( poly , - 1.0 , 4 , 0.002 ) ; } }
public class Roots { public interface Function { public double f ( double x ) ; } private static int sign ( double x ) { return ( x < 0.0 ) ? - 1 : ( x > 0.0 ) ? 1 : 0 ; } public static void printRoots ( Function f , double lowerBound , double upperBound , double step ) { double x = lowerBound , ox = x ; double y = f . f ( x ) , oy = y ; int s = sign ( y ) , os = s ; for ( ; x <= upperBound ; x += step ) { s = sign ( y = f . f ( x ) ) ; if ( s == 0 ) { System . out . println ( x ) ; } else if ( s != os ) { double dx = x - ox ; double dy = y - oy ; double cx = x - dx * ( y / dy ) ; System . out . println ( " ~ " + cx ) ; } ox = x ; oy = y ; os = s ; } } public static void main ( String [ ] args ) { Function poly = new Function ( ) { public double f ( double x ) { return x * x * x - 3 * x * x + 2 * x ; } } ; printRoots ( poly , - 1.0 , 4 , 0.002 ) ; } }
import java . util . ArrayList ; import ScreenScrape ; public class CountProgramExamples { private static final String baseURL = " http : // rosettacode . org / wiki / " ; private static final String rootURL = " http : // www . rosettacode . org / w / " + " api . php ? action = query & list = categorymembers " + " & cmtitle = Category : Programming _ Tasks & cmlimit = 500 & format = xml " ; private static final String taskBegin = " title = \" " ; private static final String taskEnd = " \" " ; private static final String exmplBegin = " < span ▁ class = \" tocnumber \" > " ; private static final String exmplEnd = " < / span > " ; private static final String editBegin = " < span ▁ class = \" editsection \" > " ; public static void main ( String [ ] args ) { int exTotal = 0 ; try { ArrayList < String > tasks = new ArrayList < String > ( ) ; ScreenScrape ss = new ScreenScrape ( ) ; String rootPage = ss . read ( rootURL ) ; while ( rootPage . contains ( taskBegin ) ) { rootPage = rootPage . substring ( rootPage . indexOf ( taskBegin ) + taskBegin . length ( ) ) ; String title = rootPage . substring ( 0 , rootPage . indexOf ( taskEnd ) ) ; if ( ! title . contains ( " Category : " ) ) { tasks . add ( title ) ; } rootPage = rootPage . substring ( rootPage . indexOf ( taskEnd ) ) ; } for ( String task : tasks ) { String title = task . replaceAll ( " & #039 ; " , " ' " ) ; String taskPage = ss . read ( baseURL + title . replaceAll ( " ▁ " , " _ " ) ) ; int exSubTot ; if ( taskPage . contains ( exmplBegin ) ) { int startPos = taskPage . lastIndexOf ( exmplBegin ) + exmplBegin . length ( ) ; String countStr = taskPage . substring ( startPos , taskPage . indexOf ( exmplEnd , startPos ) ) ; exSubTot = Integer . parseInt ( countStr . contains ( " . " ) ? countStr . substring ( 0 , countStr . indexOf ( " . " ) ) : countStr ) ; } else { exSubTot = 0 ; while ( taskPage . contains ( editBegin ) ) { taskPage = taskPage . substring ( taskPage . indexOf ( editBegin ) + editBegin . length ( ) ) ; exSubTot ++ ; } } exTotal += exSubTot ; System . out . println ( title + " : ▁ " + exSubTot + " ▁ examples . " ) ; } System . out . println ( " \n Total : ▁ " + exTotal + " ▁ examples . " ) ; } catch ( Exception e ) { System . out . println ( title ) ; System . out . println ( startPos + " : " + taskPage . indexOf ( exmplEnd , startPos ) ) ; System . out . println ( taskPage ) ; e . printStackTrace ( System . out ) ; } } }
import java . net . URL ; import java . net . URLConnection ; import java . io . * ; import java . util . * ; public class GetRCLanguages { private static class LanguageComparator implements Comparator < String > { public int compare ( String a , String b ) { int result = ( b . charAt ( 0 ) - a . charAt ( 0 ) ) ; if ( result == 0 ) { result = a . compareTo ( b ) ; } return result ; } } private static String after ( String text , int marker ) { String result = " " ; int pos = text . indexOf ( marker ) ; if ( pos >= 0 ) { result = text . substring ( pos + 1 ) ; } return result ; } public static void parseContent ( String path , String [ ] gcmcontinue , ArrayList < String > languageList ) { try { URL url = new URL ( path ) ; URLConnection rc = url . openConnection ( ) ; rc . setRequestProperty ( " User - Agent " , " " ) ; BufferedReader bfr = new BufferedReader ( new InputStreamReader ( rc . getInputStream ( ) ) ) ; gcmcontinue [ 0 ] = " " ; String languageName = " ? " ; String line = bfr . readLine ( ) ; while ( line != null ) { line = line . trim ( ) ; if ( line . startsWith ( " [ title ] " ) ) { languageName = after ( line , ' : ' ) . trim ( ) ; } else if ( line . startsWith ( " [ pages ] " ) ) { String pageCount = after ( line , ' > ' ) . trim ( ) ; if ( pageCount . compareTo ( " Array " ) != 0 ) { languageList . add ( ( ( char ) Integer . parseInt ( pageCount ) ) + languageName ) ; languageName = " ? " ; } } else if ( line . startsWith ( " [ gcmcontinue ] " ) ) { gcmcontinue [ 0 ] = after ( line , ' > ' ) . trim ( ) ; } line = bfr . readLine ( ) ; } bfr . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static void main ( String [ ] args ) { ArrayList < String > languageList = new ArrayList < String > ( 1000 ) ; String [ ] gcmcontinue = new String [ 1 ] ; gcmcontinue [ 0 ] = " " ; do { String path = ( " http : // www . rosettacode . org / mw / api . php ? action = query " + " & generator = categorymembers " + " & gcmtitle = Category : Programming % 20Languages " + " & gcmlimit = 500" + ( gcmcontinue [ 0 ] . compareTo ( " " ) == 0 ? " " : ( " & gcmcontinue = " + gcmcontinue [ 0 ] ) ) + " & prop = categoryinfo " + " & format = txt " ) ; parseContent ( path , gcmcontinue , languageList ) ; } while ( gcmcontinue [ 0 ] . compareTo ( " " ) != 0 ) ; String [ ] languages = languageList . toArray ( new String [ ] { } ) ; Arrays . sort ( languages , new LanguageComparator ( ) ) ; int lastTie = - 1 ; int lastCount = - 1 ; for ( int lPos = 0 ; lPos < languages . length ; lPos ++ ) { int count = ( int ) ( languages [ lPos ] . charAt ( 0 ) ) ; System . out . format ( " % 4d : ▁ % 4d : ▁ % s \n " , 1 + ( count == lastCount ? lastTie : lPos ) , count , languages [ lPos ] . substring ( 1 ) ) ; if ( count != lastCount ) { lastTie = lPos ; lastCount = count ; } } } }
import java . util . List ; import java . util . Random ; import java . util . stream . Stream ; import static java . util . stream . Collectors . toList ; public class Rpg { private static final Random random = new Random ( ) ; public static int genAttribute ( ) { return random . ints ( 1 , 6 + 1 ) . limit ( 4 ) . sorted ( ) . limit ( 3 ) . sum ( ) ; } public static void main ( String [ ] args ) { while ( true ) { List < Integer > stats = Stream . generate ( Rpg :: genAttribute ) . limit ( 6 ) . collect ( toList ( ) ) ; int sum = stats . stream ( ) . mapToInt ( Integer :: intValue ) . sum ( ) ; long count = stats . stream ( ) . filter ( v -> v >= 15 ) . count ( ) ; if ( count >= 2 && sum >= 75 ) { System . out . printf ( " The ▁ 6 ▁ random ▁ numbers ▁ generated ▁ are : ▁ % s \n " , stats ) ; System . out . printf ( " Their ▁ sum ▁ is ▁ % s ▁ and ▁ % s ▁ of ▁ them ▁ are ▁ > = ▁ 15 \n " , sum , count ) ; return ; } } } }
public static void main ( String [ ] args ) { BigInteger n = new BigInteger ( "9516311845790656153499716760847001433441357" ) ; BigInteger e = new BigInteger ( "65537" ) ; BigInteger d = new BigInteger ( "5617843187844953170308463622230283376298685" ) ; Charset c = Charsets . UTF_8 ; String plainText = " Rosetta ▁ Code " ; System . out . println ( " PlainText  : ▁ " + plainText ) ; byte [ ] bytes = plainText . getBytes ( ) ; BigInteger plainNum = new BigInteger ( bytes ) ; System . out . println ( " As ▁ number  : ▁ " + plainNum ) ; BigInteger Bytes = new BigInteger ( bytes ) ; if ( Bytes . compareTo ( n ) == 1 ) { System . out . println ( " Plaintext ▁ is ▁ too ▁ long " ) ; return ; } BigInteger enc = plainNum . modPow ( e , n ) ; System . out . println ( " Encoded : ▁ " + enc ) ; BigInteger dec = enc . modPow ( d , n ) ; System . out . println ( " Decoded : ▁ " + dec ) ; String decText = new String ( dec . toByteArray ( ) , c ) ; System . out . println ( " As ▁ text : ▁ " + decText ) ; }
public static String encode ( String source ) { StringBuffer dest = new StringBuffer ( ) ; for ( int i = 0 ; i < source . length ( ) ; i ++ ) { int runLength = 1 ; while ( i + 1 < source . length ( ) && source . charAt ( i ) == source . charAt ( i + 1 ) ) { runLength ++ ; i ++ ; } dest . append ( runLength ) ; dest . append ( source . charAt ( i ) ) ; } return dest . toString ( ) ; }
public static String decode ( String source ) { StringBuffer dest = new StringBuffer ( ) ; Pattern pattern = Pattern . compile ( " [ 0-9 ] + | [ a - zA - Z ] " ) ; Matcher matcher = pattern . matcher ( source ) ; while ( matcher . find ( ) ) { int number = Integer . parseInt ( matcher . group ( ) ) ; matcher . find ( ) ; while ( number -- != 0 ) { dest . append ( matcher . group ( ) ) ; } } return dest . toString ( ) ; }
public class SafePrimes { public static void main ( String ... args ) { int SIEVE_SIZE = 10_000_000 ; boolean [ ] isComposite = new boolean [ SIEVE_SIZE ] ; isComposite [ 0 ] = true ; isComposite [ 1 ] = true ; for ( int n = 2 ; n < SIEVE_SIZE ; n ++ ) { if ( isComposite [ n ] ) { continue ; } for ( int i = n * 2 ; i < SIEVE_SIZE ; i += n ) { isComposite [ i ] = true ; } } int oldSafePrimeCount = 0 ; int oldUnsafePrimeCount = 0 ; int safePrimeCount = 0 ; int unsafePrimeCount = 0 ; StringBuilder safePrimes = new StringBuilder ( ) ; StringBuilder unsafePrimes = new StringBuilder ( ) ; int safePrimesStrCount = 0 ; int unsafePrimesStrCount = 0 ; for ( int n = 2 ; n < SIEVE_SIZE ; n ++ ) { if ( n == 1_000_000 ) { oldSafePrimeCount = safePrimeCount ; oldUnsafePrimeCount = unsafePrimeCount ; } if ( isComposite [ n ] ) { continue ; } boolean isUnsafe = isComposite [ ( n - 1 ) >>> 1 ] ; if ( isUnsafe ) { if ( unsafePrimeCount < 40 ) { if ( unsafePrimeCount > 0 ) { unsafePrimes . append ( " , ▁ " ) ; } unsafePrimes . append ( n ) ; unsafePrimesStrCount ++ ; } unsafePrimeCount ++ ; } else { if ( safePrimeCount < 35 ) { if ( safePrimeCount > 0 ) { safePrimes . append ( " , ▁ " ) ; } safePrimes . append ( n ) ; safePrimesStrCount ++ ; } safePrimeCount ++ ; } } System . out . println ( " First ▁ " + safePrimesStrCount + " ▁ safe ▁ primes : ▁ " + safePrimes . toString ( ) ) ; System . out . println ( " Number ▁ of ▁ safe ▁ primes ▁ below ▁ 1,000,000 : ▁ " + oldSafePrimeCount ) ; System . out . println ( " Number ▁ of ▁ safe ▁ primes ▁ below ▁ 10,000,000 : ▁ " + safePrimeCount ) ; System . out . println ( " First ▁ " + unsafePrimesStrCount + " ▁ unsafe ▁ primes : ▁ " + unsafePrimes . toString ( ) ) ; System . out . println ( " Number ▁ of ▁ unsafe ▁ primes ▁ below ▁ 1,000,000 : ▁ " + oldUnsafePrimeCount ) ; System . out . println ( " Number ▁ of ▁ unsafe ▁ primes ▁ below ▁ 10,000,000 : ▁ " + unsafePrimeCount ) ; return ; } }
import java . util . List ; import java . util . Arrays ; List < String > haystack = Arrays . asList ( " Zig " , " Zag " , " Wally " , " Ronald " , " Bush " , " Krusty " , " Charlie " , " Bush " , " Bozo " ) ; for ( String needle : new String [ ] { " Washington " , " Bush " } ) { int index = haystack . indexOf ( needle ) ; if ( index < 0 ) System . out . println ( needle + " ▁ is ▁ not ▁ in ▁ haystack " ) ; else System . out . println ( index + " ▁ " + needle ) ; }
import java . lang . reflect . Method ; class Example { public int foo ( int x ) { return 42 + x ; } } public class Main { public static void main ( String [ ] args ) throws Exception { Object example = new Example ( ) ; String name = " foo " ; Class < ? > clazz = example . getClass ( ) ; Method meth = clazz . getMethod ( name , int . class ) ; Object result = meth . invoke ( example , 5 ) ; System . out . println ( result ) ; } }
private static final boolean isPrime ( long test ) { if ( test == 2 ) { return true ; } if ( test % 2 == 0 ) { return false ; } for ( long d = 3 ; d * d <= test ; d += 2 ) { if ( test % d == 0 ) { return false ; } } return true ; }
private static < E > List < Set < E > > consolidate ( Collection < ? extends Set < E > > sets ) { List < Set < E > > r = new ArrayList < > ( ) ; for ( Set < E > s : sets ) { List < Set < E > > new_r = new ArrayList < > ( ) ; new_r . add ( s ) ; for ( Set < E > x : r ) { if ( ! Collections . disjoint ( s , x ) ) { s . addAll ( x ) ; } else { new_r . add ( x ) ; } } r = new_r ; } return r ; }
import java . util . Objects ; import java . util . function . Predicate ; public class RealNumberSet { public enum RangeType { CLOSED , BOTH_OPEN , LEFT_OPEN , RIGHT_OPEN , } public static class RealSet { private Double low ; private Double high ; private Predicate < Double > predicate ; private double interval = 0.00001 ; public RealSet ( Double low , Double high , Predicate < Double > predicate ) { this . low = low ; this . high = high ; this . predicate = predicate ; } public RealSet ( Double start , Double end , RangeType rangeType ) { this ( start , end , d -> { switch ( rangeType ) { case CLOSED : return start <= d && d <= end ; case BOTH_OPEN : return start < d && d < end ; case LEFT_OPEN : return start < d && d <= end ; case RIGHT_OPEN : return start <= d && d < end ; default : throw new IllegalStateException ( " Unhandled ▁ range ▁ type ▁ encountered . " ) ; } } ) ; } public boolean contains ( Double d ) { return predicate . test ( d ) ; } public RealSet union ( RealSet other ) { double low2 = Math . min ( low , other . low ) ; double high2 = Math . max ( high , other . high ) ; return new RealSet ( low2 , high2 , d -> predicate . or ( other . predicate ) . test ( d ) ) ; } public RealSet intersect ( RealSet other ) { double low2 = Math . min ( low , other . low ) ; double high2 = Math . max ( high , other . high ) ; return new RealSet ( low2 , high2 , d -> predicate . and ( other . predicate ) . test ( d ) ) ; } public RealSet subtract ( RealSet other ) { return new RealSet ( low , high , d -> predicate . and ( other . predicate . negate ( ) ) . test ( d ) ) ; } public double length ( ) { if ( low . isInfinite ( ) || high . isInfinite ( ) ) return - 1.0 ; if ( high <= low ) return 0.0 ; Double p = low ; int count = 0 ; do { if ( predicate . test ( p ) ) count ++ ; p += interval ; } while ( p < high ) ; return count * interval ; } public boolean isEmpty ( ) { if ( Objects . equals ( high , low ) ) { return predicate . negate ( ) . test ( low ) ; } return length ( ) == 0.0 ; } } public static void main ( String [ ] args ) { RealSet a = new RealSet ( 0.0 , 1.0 , RangeType . LEFT_OPEN ) ; RealSet b = new RealSet ( 0.0 , 2.0 , RangeType . RIGHT_OPEN ) ; RealSet c = new RealSet ( 1.0 , 2.0 , RangeType . LEFT_OPEN ) ; RealSet d = new RealSet ( 0.0 , 3.0 , RangeType . RIGHT_OPEN ) ; RealSet e = new RealSet ( 0.0 , 1.0 , RangeType . BOTH_OPEN ) ; RealSet f = new RealSet ( 0.0 , 1.0 , RangeType . CLOSED ) ; RealSet g = new RealSet ( 0.0 , 0.0 , RangeType . CLOSED ) ; for ( int i = 0 ; i <= 2 ; i ++ ) { Double dd = ( double ) i ; System . out . printf ( " ( 0 , ▁ 1 ] ▁ ∪ ▁ [ 0 , ▁ 2 ) ▁ contains ▁ % d ▁ is ▁ % s \n " , i , a . union ( b ) . contains ( dd ) ) ; System . out . printf ( " [ 0 , ▁ 2 ) ▁ ∩ ▁ ( 1 , ▁ 2 ] ▁ contains ▁ % d ▁ is ▁ % s \n " , i , b . intersect ( c ) . contains ( dd ) ) ; System . out . printf ( " [ 0 , ▁ 3 ) ▁ − ▁ ( 0 , ▁ 1 ) ▁ contains ▁ % d ▁ is ▁ % s \n " , i , d . subtract ( e ) . contains ( dd ) ) ; System . out . printf ( " [ 0 , ▁ 3 ) ▁ − ▁ [ 0 , ▁ 1 ] ▁ contains ▁ % d ▁ is ▁ % s \n " , i , d . subtract ( f ) . contains ( dd ) ) ; System . out . println ( ) ; } System . out . printf ( " [ 0 , ▁ 0 ] ▁ is ▁ empty ▁ is ▁ % s \n " , g . isEmpty ( ) ) ; System . out . println ( ) ; RealSet aa = new RealSet ( 0.0 , 10.0 , x -> ( 0.0 < x && x < 10.0 ) && Math . abs ( Math . sin ( Math . PI * x * x ) ) > 0.5 ) ; RealSet bb = new RealSet ( 0.0 , 10.0 , x -> ( 0.0 < x && x < 10.0 ) && Math . abs ( Math . sin ( Math . PI * x ) ) > 0.5 ) ; RealSet cc = aa . subtract ( bb ) ; System . out . printf ( " Approx ▁ length ▁ of ▁ A ▁ - ▁ B ▁ is ▁ % f \n " , cc . length ( ) ) ; } }
var str = ' Rosetta ▁ code ' ; puts ( Util . hash ( str , { type : ' sha1' } ) ) ;
public static void main ( String [ ] args ) { if ( args . length != 1 ) { System . err . println ( " missing ▁ file ▁ argument " ) ; System . exit ( 1 ) ; } try ( InputStream in = new BufferedInputStream ( new FileInputStream ( args [ 0 ] ) ) ) { byte [ ] digest = sha256MerkleTree ( in , 1024 ) ; if ( digest != null ) System . out . println ( digestToString ( digest ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
public class ShowAsciiTable { public static void main ( String [ ] args ) { for ( int i = 32 ; i <= 127 ; i ++ ) { if ( i == 32 || i == 127 ) { String s = i == 32 ? " Spc " : " Del " ; System . out . printf ( " % 3d : ▁ % s ▁ " , i , s ) ; } else { System . out . printf ( " % 3d : ▁ % c ▁ ▁ ▁ " , i , i ) ; } if ( ( i - 1 ) % 6 == 0 ) { System . out . println ( ) ; } } } }
public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> { JFrame f = new JFrame ( ) ; f . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; f . setTitle ( " Sierpinski ▁ Pentagon " ) ; f . setResizable ( true ) ; f . add ( new SierpinskiPentagon ( ) , BorderLayout . CENTER ) ; f . pack ( ) ; f . setLocationRelativeTo ( null ) ; f . setVisible ( true ) ; } ) ; }
public class SierpinskiTriangle { public static void main ( String [ ] args ) { System . out . println ( getSierpinskiTriangle ( 4 ) ) ; } private static final String getSierpinskiTriangle ( int n ) { if ( n == 0 ) { return " * " ; } String s = getSierpinskiTriangle ( n - 1 ) ; String [ ] split = s . split ( " \n " ) ; int length = split . length ; StringBuilder sb = new StringBuilder ( ) ; String top = buildSpace ( ( int ) Math . pow ( 2 , n - 1 ) ) ; for ( int i = 0 ; i < length ; i ++ ) { sb . append ( top ) ; sb . append ( split [ i ] ) ; sb . append ( " \n " ) ; } for ( int i = 0 ; i < length ; i ++ ) { sb . append ( split [ i ] ) ; sb . append ( buildSpace ( length - i ) ) ; sb . append ( split [ i ] ) ; sb . append ( " \n " ) ; } return sb . toString ( ) ; } private static String buildSpace ( int n ) { StringBuilder sb = new StringBuilder ( ) ; while ( n > 0 ) { sb . append ( " ▁ " ) ; n -- ; } return sb . toString ( ) ; } }
public static void main ( String [ ] args ) { SwingUtilities . invokeLater ( ( ) -> new Clicks ( ) ) ; }
import java . awt . Robot public static void type ( String str ) { Robot robot = new Robot ( ) ; for ( char ch : str . toCharArray ( ) ) { if ( Character . isUpperCase ( ch ) ) { robot . keyPress ( KeyEvent . VK_SHIFT ) ; robot . keyPress ( ( int ) ch ) ; robot . keyRelease ( ( int ) ch ) ; robot . keyRelease ( KeyEvent . VK_SHIFT ) ; } else { char upCh = Character . toUpperCase ( ch ) ; robot . keyPress ( ( int ) upCh ) ; robot . keyRelease ( ( int ) upCh ) ; } } }
class Link { Link next ; int data ; }
LinkedList < Type > list = new LinkedList < Type > ( ) ; for ( Type i : list ) { System . out . println ( i ) ; }
import java . util . InputMismatchException ; import java . util . Scanner ; public class Sleep { public static void main ( final String [ ] args ) throws InterruptedException { try { int ms = new Scanner ( System . in ) . nextInt ( ) ; System . out . println ( " Sleeping . . . " ) ; Thread . sleep ( ms ) ; System . out . println ( " Awake ! " ) ; } catch ( InputMismatchException inputMismatchException ) { System . err . println ( " Exception : ▁ " + inputMismatchException ) ; } } }
private static final boolean isPrime ( long test ) { if ( test % 2 == 0 ) return false ; for ( long i = 3 ; i <= Math . sqrt ( test ) ; i += 2 ) { if ( test % i == 0 ) { return false ; } } return true ; }
static int sumDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } return sum ; }
import java . util . Map ; import java . util . Random ; public class Game { private static final Map < Integer , Integer > snl = Map . ofEntries ( Map . entry ( 4 , 14 ) , Map . entry ( 9 , 31 ) , Map . entry ( 17 , 7 ) , Map . entry ( 20 , 38 ) , Map . entry ( 28 , 84 ) , Map . entry ( 40 , 59 ) , Map . entry ( 51 , 67 ) , Map . entry ( 54 , 34 ) , Map . entry ( 62 , 19 ) , Map . entry ( 63 , 81 ) , Map . entry ( 64 , 60 ) , Map . entry ( 71 , 91 ) , Map . entry ( 87 , 24 ) , Map . entry ( 93 , 73 ) , Map . entry ( 95 , 75 ) , Map . entry ( 99 , 78 ) ) ; private static final boolean sixesThrowAgain = true ; private static Random rand = new Random ( ) ; private static int turn ( int player , int square ) { int square2 = square ; while ( true ) { int roll = rand . nextInt ( 6 ) + 1 ; System . out . printf ( " Player ▁ % d , ▁ on ▁ square ▁ % d , ▁ rolls ▁ a ▁ % d " , player , square2 , roll ) ; if ( square2 + roll > 100 ) { System . out . println ( " ▁ but ▁ cannot ▁ move . " ) ; } else { square2 += roll ; System . out . printf ( " ▁ and ▁ moves ▁ to ▁ square ▁ % d \n " , square2 ) ; if ( square2 == 100 ) return 100 ; Integer next = snl . getOrDefault ( square2 , square2 ) ; if ( square2 < next ) { System . out . printf ( " Yay ! ▁ Landed ▁ on ▁ a ▁ ladder . ▁ Climb ▁ up ▁ to ▁ % d . \n " , next ) ; if ( next == 100 ) return 100 ; square2 = next ; } else if ( square2 > next ) { System . out . printf ( " Oops ! ▁ Landed ▁ on ▁ a ▁ snake . ▁ Slither ▁ down ▁ to ▁ % d . \n " , next ) ; square2 = next ; } } if ( roll < 6 || ! sixesThrowAgain ) return square2 ; System . out . println ( " Rolled ▁ a ▁ 6 ▁ so ▁ roll ▁ again . " ) ; } } public static void main ( String [ ] args ) { int [ ] players = { 1 , 1 , 1 } ; while ( true ) { for ( int i = 0 ; i < players . length ; ++ i ) { int ns = turn ( i + 1 , players [ i ] ) ; if ( ns == 100 ) { System . out . printf ( " Player ▁ % d ▁ wins ! \n " , i + 1 ) ; return ; } players [ i ] = ns ; System . out . println ( ) ; } } } }
const L = 1 , R = 2 , D = 4 , U = 8 ; var block = 24 , wid = 30 , hei = 20 , frameR = 7 , fruit , snake ; function Snake ( ) { this . length = 1 ; this . alive = true ; this . pos = createVector ( 1 , 1 ) ; this . posArray = [ ] ; this . posArray . push ( createVector ( 1 , 1 ) ) ; this . dir = R ; this . draw = function ( ) { fill ( 130 , 190 , 0 ) ; var pos , i = this . posArray . length - 1 , l = this . length ; while ( true ) { pos = this . posArray [ i -- ] ; rect ( pos . x * block , pos . y * block , block , block ) ; if ( -- l == 0 ) break ; } } this . eat = function ( frut ) { var b = this . pos . x == frut . x && this . pos . y == frut . y ; if ( b ) this . length ++ ; return b ; } this . overlap = function ( ) { var len = this . posArray . length - 1 ; for ( var i = len ; i > len - this . length ; i -- ) { tp = this . posArray [ i ] ; if ( tp . x == = this . pos . x && tp . y == = this . pos . y ) return true ; } return false ; } this . update = function ( ) { if ( ! this . alive ) return ; switch ( this . dir ) { case L : this . pos . x -- ; if ( this . pos . x < 1 ) this . pos . x = wid - 2 ; break ; case R : this . pos . x ++ ; if ( this . pos . x > wid - 2 ) this . pos . x = 1 ; break ; case U : this . pos . y -- ; if ( this . pos . y < 1 ) this . pos . y = hei - 2 ; break ; case D : this . pos . y ++ ; if ( this . pos . y > hei - 2 ) this . pos . y = 1 ; break ; } if ( this . overlap ( ) ) { this . alive = false ; } else { this . posArray . push ( createVector ( this . pos . x , this . pos . y ) ) ; if ( this . posArray . length > 5000 ) { this . posArray . splice ( 0 , 1 ) ; } } } } function Fruit ( ) { this . fruitTime = true ; this . pos = createVector ( ) ; this . draw = function ( ) { fill ( 200 , 50 , 20 ) ; rect ( this . pos . x * block , this . pos . y * block , block , block ) ; } this . setFruit = function ( ) { this . pos . x = floor ( random ( 1 , wid - 1 ) ) ; this . pos . y = floor ( random ( 1 , hei - 1 ) ) ; this . fruitTime = false ; } } function setup ( ) { createCanvas ( block * wid , block * hei ) ; noStroke ( ) ; frameRate ( frameR ) ; snake = new Snake ( ) ; fruit = new Fruit ( ) ; } function keyPressed ( ) { switch ( keyCode ) { case LEFT_ARROW : snake . dir = L ; break ; case RIGHT_ARROW : snake . dir = R ; break ; case UP_ARROW : snake . dir = U ; break ; case DOWN_ARROW : snake . dir = D ; } } function draw ( ) { background ( color ( 0 , 0x22 , 0 ) ) ; fill ( 20 , 50 , 120 ) ; for ( var i = 0 ; i < wid ; i ++ ) { rect ( i * block , 0 , block , block ) ; rect ( i * block , height - block , block , block ) ; } for ( var i = 1 ; i < hei - 1 ; i ++ ) { rect ( 1 , i * block , block , block ) ; rect ( width - block , i * block , block , block ) ; } if ( fruit . fruitTime ) { fruit . setFruit ( ) ; frameR += .2 ; frameRate ( frameR ) ; } fruit . draw ( ) ; snake . update ( ) ; if ( snake . eat ( fruit . pos ) ) { fruit . fruitTime = true ; } snake . draw ( ) ; fill ( 200 ) ; textStyle ( BOLD ) ; textAlign ( RIGHT ) ; textSize ( 120 ) ; text ( " " + ( snake . length - 1 ) , 690 , 440 ) ; if ( ! snake . alive ) text ( " THE ▁ END " , 630 , 250 ) ; }
import java . io . IOException ; import java . net . * ; public class SocketSend { public static void main ( String args [ ] ) throws IOException { sendData ( " localhost " , " hello ▁ socket ▁ world " ) ; } public static void sendData ( String host , String msg ) throws IOException { Socket sock = new Socket ( host , 256 ) ; sock . getOutputStream ( ) . write ( msg . getBytes ( ) ) ; sock . getOutputStream ( ) . flush ( ) ; sock . close ( ) ; } }
private static boolean solve ( int r , int c , int count ) { if ( count == total ) return true ; List < int [ ] > nbrs = neighbors ( r , c ) ; if ( nbrs . isEmpty ( ) && count != total ) return false ; Collections . sort ( nbrs , ( a , b ) -> a [ 2 ] - b [ 2 ] ) ; for ( int [ ] nb : nbrs ) { r = nb [ 0 ] ; c = nb [ 1 ] ; grid [ r ] [ c ] = count ; if ( solve ( r , c , count + 1 ) ) return true ; grid [ r ] [ c ] = 0 ; } return false ; }
static boolean solve ( int r , int c , int count ) { if ( count > totalToFill ) return true ; List < int [ ] > nbrs = neighbors ( r , c ) ; if ( nbrs . isEmpty ( ) && count != totalToFill ) return false ; Collections . sort ( nbrs , ( a , b ) -> a [ 2 ] - b [ 2 ] ) ; for ( int [ ] nb : nbrs ) { r = nb [ 0 ] ; c = nb [ 1 ] ; grid [ r ] [ c ] = count ; if ( solve ( r , c , count + 1 ) ) return true ; grid [ r ] [ c ] = 0 ; } return false ; }
static boolean solve ( int r , int c , int count , int nextClue ) { if ( count > totalToFill ) return true ; if ( grid [ r ] [ c ] != 0 && grid [ r ] [ c ] != count ) return false ; if ( grid [ r ] [ c ] == 0 && nextClue < clues . length ) if ( clues [ nextClue ] == count ) return false ; int back = grid [ r ] [ c ] ; if ( back == count ) nextClue ++ ; grid [ r ] [ c ] = count ; for ( int [ ] move : moves ) if ( solve ( r + move [ 1 ] , c + move [ 0 ] , count + 1 , nextClue ) ) return true ; grid [ r ] [ c ] = back ; return false ; }
package com . rosettacode ; import java . util . Comparator ; import java . util . stream . Stream ; public class OIDListSorting { public static void main ( String [ ] args ) { final String dot = " \\ . " ; final Comparator < String > oids_comparator = ( o1 , o2 ) -> { final String [ ] o1Numbers = o1 . split ( dot ) , o2Numbers = o2 . split ( dot ) ; for ( int i = 0 ; ; i ++ ) { if ( i == o1Numbers . length && i == o2Numbers . length ) return 0 ; if ( i == o1Numbers . length ) return - 1 ; if ( i == o2Numbers . length ) return 1 ; final int nextO1Number = Integer . valueOf ( o1Numbers [ i ] ) , nextO2Number = Integer . valueOf ( o2Numbers [ i ] ) ; final int result = Integer . compare ( nextO1Number , nextO2Number ) ; if ( result != 0 ) return result ; } } ; Stream . of ( "1.3.6.1.4.1.11.2.17.19.3.4.0.10" , "1.3.6.1.4.1.11.2.17.5.2.0.79" , "1.3.6.1.4.1.11.2.17.19.3.4.0.4" , "1.3.6.1.4.1.11150.3.4.0.1" , "1.3.6.1.4.1.11.2.17.19.3.4.0.1" , "1.3.6.1.4.1.11150.3.4.0" ) . sorted ( oids_comparator ) . forEach ( System . out :: println ) ; } }
import java . util . Arrays ; import java . util . Comparator ; public class SortComp { public static class Pair { public String name ; public String value ; public Pair ( String n , String v ) { name = n ; value = v ; } } public static void main ( String [ ] args ) { Pair [ ] pairs = { new Pair ( "06-07" , " Ducks " ) , new Pair ( "00-01" , " Avalanche " ) , new Pair ( "02-03" , " Devils " ) , new Pair ( "01-02" , " Red ▁ Wings " ) , new Pair ( "03-04" , " Lightning " ) , new Pair ( "04-05" , " lockout " ) , new Pair ( "05-06" , " Hurricanes " ) , new Pair ( "99-00" , " Devils " ) , new Pair ( "07-08" , " Red ▁ Wings " ) , new Pair ( "08-09" , " Penguins " ) } ; sortByName ( pairs ) ; for ( Pair p : pairs ) { System . out . println ( p . name + " ▁ " + p . value ) ; } } public static void sortByName ( Pair [ ] pairs ) { Arrays . sort ( pairs , new Comparator < Pair > ( ) { public int compare ( Pair p1 , Pair p2 ) { return p1 . name . compareTo ( p2 . name ) ; } } ) ; } }
import java . util . Arrays ; public class Example { public static void main ( String [ ] args ) { int [ ] nums = { 2 , 4 , 3 , 1 , 2 } ; Arrays . sort ( nums ) ; } }
import java . util . List ; import java . util . stream . * ; public class LexicographicalNumbers { static List < Integer > lexOrder ( int n ) { int first = 1 , last = n ; if ( n < 1 ) { first = n ; last = 1 ; } return IntStream . rangeClosed ( first , last ) . mapToObj ( Integer :: toString ) . sorted ( ) . map ( Integer :: valueOf ) . collect ( Collectors . toList ( ) ) ; } public static void main ( String [ ] args ) { System . out . println ( " In ▁ lexicographical ▁ order : \n " ) ; int [ ] ints = { 0 , 5 , 13 , 21 , - 22 } ; for ( int n : ints ) { System . out . printf ( " % 3d : ▁ % s \n " , n , lexOrder ( n ) ) ; } } }
import java . util . Arrays ; import java . util . Comparator ; public class RJSortStability { public static void main ( String [ ] args ) { String [ ] cityList = { " UK ▁ ▁ London " , " US ▁ ▁ New ▁ York " , " US ▁ ▁ Birmingham " , " UK ▁ ▁ Birmingham " , } ; String [ ] cn = cityList . clone ( ) ; System . out . println ( " \n Before ▁ sort : " ) ; for ( String city : cn ) { System . out . println ( city ) ; } Arrays . sort ( cn , new Comparator < String > ( ) { public int compare ( String lft , String rgt ) { return lft . substring ( 4 ) . compareTo ( rgt . substring ( 4 ) ) ; } } ) ; System . out . println ( " \n After ▁ sort ▁ on ▁ city : " ) ; for ( String city : cn ) { System . out . println ( city ) ; } cn = cityList . clone ( ) ; System . out . println ( " \n Before ▁ sort : " ) ; for ( String city : cn ) { System . out . println ( city ) ; } Arrays . sort ( cn , new Comparator < String > ( ) { public int compare ( String lft , String rgt ) { return lft . substring ( 0 , 2 ) . compareTo ( rgt . substring ( 0 , 2 ) ) ; } } ) ; System . out . println ( " \n After ▁ sort ▁ on ▁ country : " ) ; for ( String city : cn ) { System . out . println ( city ) ; } System . out . println ( ) ; } }
import java . util . Comparator ; import java . util . stream . Stream ; class Box { public int weightKg ; Box ( final int weightKg ) { this . weightKg = weightKg ; } } public class Sort3Vars { public static void main ( String ... args ) { int iA = 21 ; int iB = 11 ; int iC = 82 ; int [ ] sortedInt = Stream . of ( iA , iB , iC ) . sorted ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; iA = sortedInt [ 0 ] ; iB = sortedInt [ 1 ] ; iC = sortedInt [ 2 ] ; System . out . printf ( " Sorted ▁ values : ▁ % d ▁ % d ▁ % d % n " , iA , iB , iC ) ; String sA = " s21" ; String sB = " s11" ; String sC = " s82" ; Object [ ] sortedStr = Stream . of ( sA , sB , sC ) . sorted ( ) . toArray ( ) ; sA = ( String ) sortedStr [ 0 ] ; sB = ( String ) sortedStr [ 1 ] ; sC = ( String ) sortedStr [ 2 ] ; System . out . printf ( " Sorted ▁ values : ▁ % s ▁ % s ▁ % s % n " , sA , sB , sC ) ; Box bA = new Box ( 200 ) ; Box bB = new Box ( 12 ) ; Box bC = new Box ( 143 ) ; Object [ ] sortedBox = Stream . of ( bA , bB , bC ) . sorted ( Comparator . comparingInt ( a -> a . weightKg ) ) . toArray ( ) ; bA = ( Box ) sortedBox [ 0 ] ; bB = ( Box ) sortedBox [ 1 ] ; bC = ( Box ) sortedBox [ 2 ] ; System . out . printf ( " Sorted ▁ Boxes : ▁ % dKg ▁ % dKg ▁ % dKg % n " , bA . weightKg , bB . weightKg , bC . weightKg ) ; } }
public static void circleSort ( int [ ] arr ) { if ( arr . length > 0 ) do { System . out . println ( Arrays . toString ( arr ) ) ; } while ( circleSortR ( arr , 0 , arr . length - 1 , 0 ) != 0 ) ; }
public static void insertSort ( int [ ] A ) { for ( int i = 1 ; i < A . length ; i ++ ) { int value = A [ i ] ; int j = i - 1 ; while ( j >= 0 && A [ j ] > value ) { A [ j + 1 ] = A [ j ] ; j = j - 1 ; } A [ j + 1 ] = value ; } }
public static < E extends Comparable < ? super E > > List < E > mergeSort ( List < E > m ) { if ( m . size ( ) <= 1 ) return m ; int middle = m . size ( ) / 2 ; List < E > left = m . subList ( 0 , middle ) ; List < E > right = m . subList ( middle , m . size ( ) ) ; right = mergeSort ( right ) ; left = mergeSort ( left ) ; List < E > result = merge ( left , right ) ; return result ; }
import java . util . * ; public class PatienceSort { public static < E extends Comparable < ? super E > > void sort ( E [ ] n ) { List < Pile < E > > piles = new ArrayList < Pile < E > > ( ) ; for ( E x : n ) { Pile < E > newPile = new Pile < E > ( ) ; newPile . push ( x ) ; int i = Collections . binarySearch ( piles , newPile ) ; if ( i < 0 ) i = ~ i ; if ( i != piles . size ( ) ) piles . get ( i ) . push ( x ) ; else piles . add ( newPile ) ; } PriorityQueue < Pile < E > > heap = new PriorityQueue < Pile < E > > ( piles ) ; for ( int c = 0 ; c < n . length ; c ++ ) { Pile < E > smallPile = heap . poll ( ) ; n [ c ] = smallPile . pop ( ) ; if ( ! smallPile . isEmpty ( ) ) heap . offer ( smallPile ) ; } assert ( heap . isEmpty ( ) ) ; } private static class Pile < E extends Comparable < ? super E > > extends Stack < E > implements Comparable < Pile < E > > { public int compareTo ( Pile < E > y ) { return peek ( ) . compareTo ( y . peek ( ) ) ; } } public static void main ( String [ ] args ) { Integer [ ] a = { 4 , 65 , 2 , - 31 , 0 , 99 , 83 , 782 , 1 } ; sort ( a ) ; System . out . println ( Arrays . toString ( a ) ) ; } }
import java . util . List ; import java . util . ArrayList ; import java . util . Arrays ; public class PermutationSort { public static void main ( String [ ] args ) { int [ ] a = { 3 , 2 , 1 , 8 , 9 , 4 , 6 } ; System . out . println ( " Unsorted : ▁ " + Arrays . toString ( a ) ) ; a = pSort ( a ) ; System . out . println ( " Sorted : ▁ " + Arrays . toString ( a ) ) ; } public static int [ ] pSort ( int [ ] a ) { List < int [ ] > list = new ArrayList < int [ ] > ( ) ; permute ( a , a . length , list ) ; for ( int [ ] x : list ) if ( isSorted ( x ) ) return x ; return a ; } private static void permute ( int [ ] a , int n , List < int [ ] > list ) { if ( n == 1 ) { int [ ] b = new int [ a . length ] ; System . arraycopy ( a , 0 , b , 0 , a . length ) ; list . add ( b ) ; return ; } for ( int i = 0 ; i < n ; i ++ ) { swap ( a , i , n - 1 ) ; permute ( a , n - 1 , list ) ; swap ( a , i , n - 1 ) ; } } private static boolean isSorted ( int [ ] a ) { for ( int i = 1 ; i < a . length ; i ++ ) if ( a [ i - 1 ] > a [ i ] ) return false ; return true ; } private static void swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } }
public static < E extends Comparable < ? super E > > LinkedList < E > strandSort ( LinkedList < E > list ) { if ( list . size ( ) <= 1 ) return list ; LinkedList < E > result = new LinkedList < E > ( ) ; while ( list . size ( ) > 0 ) { LinkedList < E > sorted = new LinkedList < E > ( ) ; sorted . add ( list . removeFirst ( ) ) ; for ( Iterator < E > it = list . iterator ( ) ; it . hasNext ( ) ; ) { E elem = it . next ( ) ; if ( sorted . peekLast ( ) . compareTo ( elem ) <= 0 ) { sorted . addLast ( elem ) ; it . remove ( ) ; } } result = merge ( sorted , result ) ; } return result ; }
import java . util . Arrays ; public class SpecialVariables { public static void main ( String [ ] args ) { System . out . println ( Arrays . toString ( args ) ) ; System . out . println ( SpecialVariables . class ) ; System . out . println ( System . getenv ( ) ) ; System . out . println ( System . getProperties ( ) ) ; System . out . println ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; } }
public class SpinningRod { public static void main ( String [ ] args ) throws InterruptedException { String a = " | / - \ \" ; System . out . print ( " \033[2J " ) ; long start = System . currentTimeMillis ( ) ; while ( true ) { for ( int i = 0 ; i < 4 ; i ++ ) { System . out . print ( " \033[2J " ) ; System . out . print ( " \033[0 ; 0H " ) ; for ( int j = 0 ; j < 80 ; j ++ ) { System . out . print ( a . charAt ( i ) ) ; } Thread . sleep ( 250 ) ; } long now = System . currentTimeMillis ( ) ; if ( now - start >= 20000 ) break ; } System . out . print ( " \033 [ ? 25h " ) ; } }
public class Blah { public static void main ( String [ ] args ) { print2dArray ( getSpiralArray ( 5 ) ) ; } public static int [ ] [ ] getSpiralArray ( int dimension ) { int [ ] [ ] spiralArray = new int [ dimension ] [ dimension ] ; int numConcentricSquares = ( int ) Math . ceil ( ( dimension ) / 2.0 ) ; int j ; int sideLen = dimension ; int currNum = 0 ; for ( int i = 0 ; i < numConcentricSquares ; i ++ ) { for ( j = 0 ; j < sideLen ; j ++ ) { spiralArray [ i ] [ i + j ] = currNum ++ ; } for ( j = 1 ; j < sideLen ; j ++ ) { spiralArray [ i + j ] [ dimension - 1 - i ] = currNum ++ ; } for ( j = sideLen - 2 ; j > - 1 ; j -- ) { spiralArray [ dimension - 1 - i ] [ i + j ] = currNum ++ ; } for ( j = sideLen - 2 ; j > 0 ; j -- ) { spiralArray [ i + j ] [ i ] = currNum ++ ; } sideLen -= 2 ; } return spiralArray ; } public static void print2dArray ( int [ ] [ ] array ) { for ( int [ ] row : array ) { for ( int elem : row ) { System . out . printf ( " % 3d " , elem ) ; } System . out . println ( ) ; } } }
public static void main ( String ... args ) { long n = 1 ; int squareOnlyCount = 0 ; int squareCubeCount = 0 ; while ( ( squareOnlyCount < 30 ) || ( squareCubeCount < 3 ) ) { long sq = n * n ; if ( isPerfectCube ( sq ) ) { squareCubeCount ++ ; System . out . println ( " Square ▁ and ▁ cube : ▁ " + sq ) ; } else { squareOnlyCount ++ ; System . out . println ( " Square : ▁ " + sq ) ; } n ++ ; } }
public class StackTracer { public static void printStackTrace ( ) { StackTraceElement [ ] elems = Thread . currentThread ( ) . getStackTrace ( ) ; System . out . println ( " Stack ▁ trace : " ) ; for ( int i = elems . length - 1 , j = 2 ; i >= 3 ; i -- , j += 2 ) { System . out . printf ( " % " + j + " s % s . % s % n " , " " , elems [ i ] . getClassName ( ) , elems [ i ] . getMethodName ( ) ) ; } } }
import java . util . Stack ; public class StackTest { public static void main ( final String [ ] args ) { final Stack < String > stack = new Stack < String > ( ) ; System . out . println ( " New ▁ stack ▁ empty ? ▁ " + stack . empty ( ) ) ; stack . push ( " There ▁ can ▁ be ▁ only ▁ one " ) ; System . out . println ( " Pushed ▁ stack ▁ empty ? ▁ " + stack . empty ( ) ) ; System . out . println ( " Popped ▁ single ▁ entry : ▁ " + stack . pop ( ) ) ; stack . push ( " First " ) ; stack . push ( " Second " ) ; System . out . println ( " Popped ▁ entry ▁ should ▁ be ▁ second : ▁ " + stack . pop ( ) ) ; stack . pop ( ) ; stack . pop ( ) ; } }
import java . util . * ; import java . util . stream . * ; public class StateNamePuzzle { static String [ ] states = { " Alabama " , " Alaska " , " Arizona " , " Arkansas " , " California " , " Colorado " , " Connecticut " , " Delaware " , " Florida " , " Georgia " , " hawaii " , " Hawaii " , " Idaho " , " Illinois " , " Indiana " , " Iowa " , " Kansas " , " Kentucky " , " Louisiana " , " Maine " , " Maryland " , " Massachusetts " , " Michigan " , " Minnesota " , " Mississippi " , " Missouri " , " Montana " , " Nebraska " , " Nevada " , " New ▁ Hampshire " , " New ▁ Jersey " , " New ▁ Mexico " , " New ▁ York " , " North ▁ Carolina ▁ " , " North ▁ Dakota " , " Ohio " , " Oklahoma " , " Oregon " , " Pennsylvania " , " Rhode ▁ Island " , " South ▁ Carolina " , " South ▁ Dakota " , " Tennessee " , " Texas " , " Utah " , " Vermont " , " Virginia " , " Washington " , " West ▁ Virginia " , " Wisconsin " , " Wyoming " , " New ▁ Kory " , " Wen ▁ Kory " , " York ▁ New " , " Kory ▁ New " , " New ▁ Kory " , } ; public static void main ( String [ ] args ) { solve ( Arrays . asList ( states ) ) ; } static void solve ( List < String > input ) { Map < String , String > orig = input . stream ( ) . collect ( Collectors . toMap ( s -> s . replaceAll ( " \\ s " , " " ) . toLowerCase ( ) , s -> s , ( s , a ) -> s ) ) ; input = new ArrayList < > ( orig . keySet ( ) ) ; Map < String , List < String [ ] > > map = new HashMap < > ( ) ; for ( int i = 0 ; i < input . size ( ) - 1 ; i ++ ) { String pair0 = input . get ( i ) ; for ( int j = i + 1 ; j < input . size ( ) ; j ++ ) { String [ ] pair = { pair0 , input . get ( j ) } ; String s = pair0 + pair [ 1 ] ; String key = Arrays . toString ( s . chars ( ) . sorted ( ) . toArray ( ) ) ; List < String [ ] > val = map . getOrDefault ( key , new ArrayList < > ( ) ) ; val . add ( pair ) ; map . put ( key , val ) ; } } map . forEach ( ( key , list ) -> { for ( int i = 0 ; i < list . size ( ) - 1 ; i ++ ) { String [ ] a = list . get ( i ) ; for ( int j = i + 1 ; j < list . size ( ) ; j ++ ) { String [ ] b = list . get ( j ) ; if ( Stream . of ( a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] ) . distinct ( ) . count ( ) < 4 ) continue ; System . out . printf ( " % s ▁ + ▁ % s ▁ = ▁ % s ▁ + ▁ % s ▁ % n " , orig . get ( a [ 0 ] ) , orig . get ( a [ 1 ] ) , orig . get ( b [ 0 ] ) , orig . get ( b [ 1 ] ) ) ; } } } ) ; } }
import static java . lang . Math . * ; import static java . util . Arrays . stream ; import java . util . Locale ; import java . util . function . DoubleSupplier ; import static java . util . stream . Collectors . joining ; import java . util . stream . DoubleStream ; import static java . util . stream . IntStream . range ; public class Test implements DoubleSupplier { private double mu , sigma ; private double [ ] state = new double [ 2 ] ; private int index = state . length ; Test ( double m , double s ) { mu = m ; sigma = s ; } static double [ ] meanStdDev ( double [ ] numbers ) { if ( numbers . length == 0 ) return new double [ ] { 0.0 , 0.0 } ; double sx = 0.0 , sxx = 0.0 ; long n = 0 ; for ( double x : numbers ) { sx += x ; sxx += pow ( x , 2 ) ; n ++ ; } return new double [ ] { sx / n , pow ( ( n * sxx - pow ( sx , 2 ) ) , 0.5 ) / n } ; } static String replicate ( int n , String s ) { return range ( 0 , n + 1 ) . mapToObj ( i -> s ) . collect ( joining ( ) ) ; } static void showHistogram01 ( double [ ] numbers ) { final int maxWidth = 50 ; long [ ] bins = new long [ 10 ] ; for ( double x : numbers ) bins [ ( int ) ( x * bins . length ) ] ++ ; double maxFreq = stream ( bins ) . max ( ) . getAsLong ( ) ; for ( int i = 0 ; i < bins . length ; i ++ ) System . out . printf ( " ▁ % 3.1f : ▁ % s % n " , i / ( double ) bins . length , replicate ( ( int ) ( bins [ i ] / maxFreq * maxWidth ) , " * " ) ) ; System . out . println ( ) ; } @ Override public double getAsDouble ( ) { index ++ ; if ( index >= state . length ) { double r = sqrt ( - 2 * log ( random ( ) ) ) * sigma ; double x = 2 * PI * random ( ) ; state = new double [ ] { mu + r * sin ( x ) , mu + r * cos ( x ) } ; index = 0 ; } return state [ index ] ; } public static void main ( String [ ] args ) { Locale . setDefault ( Locale . US ) ; double [ ] data = DoubleStream . generate ( new Test ( 0.0 , 0.5 ) ) . limit ( 100_000 ) . toArray ( ) ; double [ ] res = meanStdDev ( data ) ; System . out . printf ( " Mean : ▁ % 8.6f , ▁ SD : ▁ % 8.6f % n " , res [ 0 ] , res [ 1 ] ) ; showHistogram01 ( stream ( data ) . map ( a -> max ( 0.0 , min ( 0.9999 , a / 3 + 0.5 ) ) ) . toArray ( ) ) ; } }
private static final BigInteger sterling1 ( int n , int k ) { String key = n + " , " + k ; if ( COMPUTED . containsKey ( key ) ) { return COMPUTED . get ( key ) ; } if ( n == 0 && k == 0 ) { return BigInteger . valueOf ( 1 ) ; } if ( n > 0 && k == 0 ) { return BigInteger . ZERO ; } if ( k > n ) { return BigInteger . ZERO ; } BigInteger result = sterling1 ( n - 1 , k - 1 ) . add ( BigInteger . valueOf ( n - 1 ) . multiply ( sterling1 ( n - 1 , k ) ) ) ; COMPUTED . put ( key , result ) ; return result ; }
private static final BigInteger sterling2 ( int n , int k ) { String key = n + " , " + k ; if ( COMPUTED . containsKey ( key ) ) { return COMPUTED . get ( key ) ; } if ( n == 0 && k == 0 ) { return BigInteger . valueOf ( 1 ) ; } if ( ( n > 0 && k == 0 ) || ( n == 0 && k > 0 ) ) { return BigInteger . ZERO ; } if ( n == k ) { return BigInteger . valueOf ( 1 ) ; } if ( k > n ) { return BigInteger . ZERO ; } BigInteger result = BigInteger . valueOf ( k ) . multiply ( sterling2 ( n - 1 , k ) ) . add ( sterling2 ( n - 1 , k - 1 ) ) ; COMPUTED . put ( key , result ) ; return result ; }
public static void main ( String [ ] args ) { var xs = IntStream . rangeClosed ( 100 , 500 ) . filter ( StrangeNumbers :: isStrange ) . boxed ( ) . collect ( Collectors . toList ( ) ) ; System . out . println ( " Strange ▁ numbers ▁ in ▁ range ▁ [ 100 . . 500 ] " ) ; System . out . printf ( " ( Total : ▁ % d ) \n \n " , xs . size ( ) ) ; for ( int i = 0 ; i < xs . size ( ) ; i ++ ) { Integer x = xs . get ( i ) ; System . out . print ( x ) ; if ( ( i + 1 ) % 10 == 0 ) { System . out . println ( ) ; } else { System . out . print ( ' ▁ ' ) ; } } }
private static List < Integer > digits ( int n ) { var result = new LinkedList < Integer > ( ) ; while ( n > 0 ) { var rem = n % 10 ; result . addFirst ( rem ) ; n /= 10 ; } return result ; }
String sa = " Hello " ; sa += " , ▁ World ! " ; System . out . println ( sa ) ; StringBuilder ba = new StringBuilder ( ) ; ba . append ( " Hello " ) ; ba . append ( " , ▁ World ! " ) ; System . out . println ( ba . toString ( ) ) ;
String str = " alphaBETA " ; System . out . println ( str . toUpperCase ( ) ) ; System . out . println ( str . toLowerCase ( ) ) ; System . out . println ( " äàâáçñßæεбế " . toUpperCase ( ) ) ; System . out . println ( " ÄÀÂÁÇÑSSÆΕБẾ " . toLowerCase ( ) ) ;
public static void compare ( String A , String B ) { if ( A . equals ( B ) ) System . out . printf ( " ' % s ' ▁ and ▁ ' % s ' ▁ are ▁ lexically ▁ equal . " , A , B ) ; else System . out . printf ( " ' % s ' ▁ and ▁ ' % s ' ▁ are ▁ not ▁ lexically ▁ equal . " , A , B ) ; System . out . println ( ) ; if ( A . equalsIgnoreCase ( B ) ) System . out . printf ( " ' % s ' ▁ and ▁ ' % s ' ▁ are ▁ case - insensitive ▁ lexically ▁ equal . " , A , B ) ; else System . out . printf ( " ' % s ' ▁ and ▁ ' % s ' ▁ are ▁ not ▁ case - insensitive ▁ lexically ▁ equal . " , A , B ) ; System . out . println ( ) ; if ( A . compareTo ( B ) < 0 ) System . out . printf ( " ' % s ' ▁ is ▁ lexically ▁ before ▁ ' % s ' . \n " , A , B ) ; else if ( A . compareTo ( B ) > 0 ) System . out . printf ( " ' % s ' ▁ is ▁ lexically ▁ after ▁ ' % s ' . \n " , A , B ) ; if ( A . compareTo ( B ) >= 0 ) System . out . printf ( " ' % s ' ▁ is ▁ not ▁ lexically ▁ before ▁ ' % s ' . \n " , A , B ) ; if ( A . compareTo ( B ) <= 0 ) System . out . printf ( " ' % s ' ▁ is ▁ not ▁ lexically ▁ after ▁ ' % s ' . \n " , A , B ) ; System . out . printf ( " The ▁ lexical ▁ relationship ▁ is : ▁ % d \n " , A . compareTo ( B ) ) ; System . out . printf ( " The ▁ case - insensitive ▁ lexical ▁ relationship ▁ is : ▁ % d \n \n " , A . compareToIgnoreCase ( B ) ) ; }
public class Str { public static void main ( String [ ] args ) { String s = " hello " ; System . out . println ( s + " ▁ literal " ) ; String s2 = s + " ▁ literal " ; System . out . println ( s2 ) ; } }
String s = " Hello , ▁ world ! " ; int byteCountUTF16 = s . getBytes ( " UTF - 16" ) . length ; int byteCountUTF16LE = s . getBytes ( " UTF - 16LE " ) . length ; int byteCountUTF8 = s . getBytes ( " UTF - 8" ) . length ;
" abcd " . startsWith ( " ab " ) " abcd " . endsWith ( " zn " ) " abab " . contains ( " bb " ) " abab " . contains ( " ab " ) int loc = " abab " . indexOf ( " bb " ) loc = " abab " . indexOf ( " ab " ) loc = " abab " . indexOf ( " ab " , loc + 1 )
public class Prepend { public static void main ( String [ ] args ) { StringBuilder sb = new StringBuilder ( " world " ) ; sb . insert ( 0 , " Hello , ▁ " ) ; System . out . println ( sb ) ; } }
import java . util . function . IntPredicate ; public class StripControlCodes { public static void main ( String [ ] args ) { String s = " \u0000 \n ▁ abc\u00E9def\u007F " ; System . out . println ( stripChars ( s , c -> c > ' \u001F ' && c != ' \u007F ' ) ) ; System . out . println ( stripChars ( s , c -> c > ' \u001F ' && c < ' \u007F ' ) ) ; } static String stripChars ( String s , IntPredicate include ) { return s . codePoints ( ) . filter ( include :: test ) . collect ( StringBuilder :: new , StringBuilder :: appendCodePoint , StringBuilder :: append ) . toString ( ) ; } }
public class SubsetSum { private static class Item { private String word ; private int weight ; public Item ( String word , int weight ) { this . word = word ; this . weight = weight ; } @ Override public String toString ( ) { return String . format ( " ( % s , ▁ % d ) " , word , weight ) ; } } private static Item [ ] items = new Item [ ] { new Item ( " alliance " , - 624 ) , new Item ( " archbishop " , - 915 ) , new Item ( " balm " , 397 ) , new Item ( " bonnet " , 452 ) , new Item ( " brute " , 870 ) , new Item ( " centipede " , - 658 ) , new Item ( " cobol " , 362 ) , new Item ( " covariate " , 590 ) , new Item ( " departure " , 952 ) , new Item ( " deploy " , 44 ) , new Item ( " diophantine " , 645 ) , new Item ( " efferent " , 54 ) , new Item ( " elysee " , - 326 ) , new Item ( " eradicate " , 376 ) , new Item ( " escritoire " , 856 ) , new Item ( " exorcism " , - 983 ) , new Item ( " fiat " , 170 ) , new Item ( " filmy " , - 874 ) , new Item ( " flatworm " , 503 ) , new Item ( " gestapo " , 915 ) , new Item ( " infra " , - 847 ) , new Item ( " isis " , - 982 ) , new Item ( " lindholm " , 999 ) , new Item ( " markham " , 475 ) , new Item ( " mincemeat " , - 880 ) , new Item ( " moresby " , 756 ) , new Item ( " mycenae " , 183 ) , new Item ( " plugging " , - 266 ) , new Item ( " smokescreen " , 423 ) , new Item ( " speakeasy " , - 745 ) , new Item ( " vein " , 813 ) , } ; private static final int n = items . length ; private static final int [ ] indices = new int [ n ] ; private static int count = 0 ; private static final int LIMIT = 5 ; private static void zeroSum ( int i , int w ) { if ( i != 0 && w == 0 ) { for ( int j = 0 ; j < i ; ++ j ) { System . out . printf ( " % s ▁ " , items [ indices [ j ] ] ) ; } System . out . println ( " \n " ) ; if ( count < LIMIT ) count ++ ; else return ; } int k = ( i != 0 ) ? indices [ i - 1 ] + 1 : 0 ; for ( int j = k ; j < n ; ++ j ) { indices [ i ] = j ; zeroSum ( i + 1 , w + items [ j ] . weight ) ; if ( count == LIMIT ) return ; } } public static void main ( String [ ] args ) { System . out . printf ( " The ▁ weights ▁ of ▁ the ▁ following ▁ % d ▁ subsets ▁ add ▁ up ▁ to ▁ zero : \n \n " , LIMIT ) ; zeroSum ( 0 , 0 ) ; } }
public class RM_chars { public static void main ( String [ ] args ) { System . out . println ( " knight " . substring ( 1 ) ) ; System . out . println ( " socks " . substring ( 0 , 4 ) ) ; System . out . println ( " brooms " . substring ( 1 , 5 ) ) ; System . out . println ( " knight " . replaceAll ( " ^ . " , " " ) ) ; System . out . println ( " socks " . replaceAll ( " . $ " , " " ) ) ; System . out . println ( " brooms " . replaceAll ( " ^ . | . $ " , " " ) ) ; } }
private static List < List < Integer > > successivePrimes ( Integer [ ] primes , Integer [ ] diffs ) { List < List < Integer > > results = new ArrayList < > ( ) ; int dl = diffs . length ; outer : for ( int i = 0 ; i < primes . length - dl ; i ++ ) { Integer [ ] group = new Integer [ dl + 1 ] ; group [ 0 ] = primes [ i ] ; for ( int j = i ; j < i + dl ; ++ j ) { if ( primes [ j + 1 ] - primes [ j ] != diffs [ j - i ] ) { continue outer ; } group [ j - i + 1 ] = primes [ j + 1 ] ; } results . add ( Arrays . asList ( group ) ) ; } return results ; }
private static int F ( int n , int x , int y ) { if ( n == 0 ) { return x + y ; } else if ( y == 0 ) { return x ; } return F ( n - 1 , F ( n , x , y - 1 ) , F ( n , x , y - 1 ) + y ) ; }
import java . util . ArrayList ; import java . util . List ; public class SuffixTreeProblem { private static class Node { String sub = " " ; List < Integer > ch = new ArrayList < > ( ) ; } private static class SuffixTree { private List < Node > nodes = new ArrayList < > ( ) ; public SuffixTree ( String str ) { nodes . add ( new Node ( ) ) ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { addSuffix ( str . substring ( i ) ) ; } } private void addSuffix ( String suf ) { int n = 0 ; int i = 0 ; while ( i < suf . length ( ) ) { char b = suf . charAt ( i ) ; List < Integer > children = nodes . get ( n ) . ch ; int x2 = 0 ; int n2 ; while ( true ) { if ( x2 == children . size ( ) ) { n2 = nodes . size ( ) ; Node temp = new Node ( ) ; temp . sub = suf . substring ( i ) ; nodes . add ( temp ) ; children . add ( n2 ) ; return ; } n2 = children . get ( x2 ) ; if ( nodes . get ( n2 ) . sub . charAt ( 0 ) == b ) break ; x2 ++ ; } String sub2 = nodes . get ( n2 ) . sub ; int j = 0 ; while ( j < sub2 . length ( ) ) { if ( suf . charAt ( i + j ) != sub2 . charAt ( j ) ) { int n3 = n2 ; n2 = nodes . size ( ) ; Node temp = new Node ( ) ; temp . sub = sub2 . substring ( 0 , j ) ; temp . ch . add ( n3 ) ; nodes . add ( temp ) ; nodes . get ( n3 ) . sub = sub2 . substring ( j ) ; nodes . get ( n ) . ch . set ( x2 , n2 ) ; break ; } j ++ ; } i += j ; n = n2 ; } } public void visualize ( ) { if ( nodes . isEmpty ( ) ) { System . out . println ( " < empty > " ) ; return ; } visualize_f ( 0 , " " ) ; } private void visualize_f ( int n , String pre ) { List < Integer > children = nodes . get ( n ) . ch ; if ( children . isEmpty ( ) ) { System . out . println ( " - ▁ " + nodes . get ( n ) . sub ) ; return ; } System . out . println ( " ┐ ▁ " + nodes . get ( n ) . sub ) ; for ( int i = 0 ; i < children . size ( ) - 1 ; i ++ ) { Integer c = children . get ( i ) ; System . out . print ( pre + " ├ ─ " ) ; visualize_f ( c , pre + " │ ▁ " ) ; } System . out . print ( pre + " └ ─ " ) ; visualize_f ( children . get ( children . size ( ) - 1 ) , pre + " ▁ ▁ " ) ; } } public static void main ( String [ ] args ) { new SuffixTree ( " banana $ " ) . visualize ( ) ; } }
public class SumProd { public static void main ( final String [ ] args ) { int sum = 0 ; int prod = 1 ; int [ ] arg = { 1 , 2 , 3 , 4 , 5 } ; for ( int i : arg ) { sum += i ; prod *= i ; } } }
public class Sum { public static double f ( double x ) { return 1 / ( x * x ) ; } public static void main ( String [ ] args ) { double start = 1 ; double end = 1000 ; double sum = 0 ; for ( double x = start ; x <= end ; x ++ ) sum += f ( x ) ; System . out . println ( " Sum ▁ of ▁ f ( x ) ▁ from ▁ " + start + " ▁ to ▁ " + end + " ▁ is ▁ " + sum ) ; } }
public static void main ( String [ ] args ) { int [ ] [ ] matrix = { { 1 , 3 , 7 , 8 , 10 } , { 2 , 4 , 16 , 14 , 4 } , { 3 , 1 , 9 , 18 , 11 } , { 12 , 14 , 17 , 18 , 20 } , { 7 , 1 , 3 , 9 , 5 } } ; int sum = 0 ; for ( int row = 1 ; row < matrix . length ; row ++ ) { for ( int col = 0 ; col < row ; col ++ ) { sum += matrix [ row ] [ col ] ; } } System . out . println ( sum ) ; }
public class SumSquares { public static void main ( final String [ ] args ) { double sum = 0 ; int [ ] nums = { 1 , 2 , 3 , 4 , 5 } ; for ( int i : nums ) sum += i * i ; System . out . println ( " The ▁ sum ▁ of ▁ the ▁ squares ▁ is : ▁ " + sum ) ; } }
public class SystemTime { public static void main ( String [ ] args ) { System . out . format ( " % tc % n " , System . currentTimeMillis ( ) ) ; } }
import java . io . * ; import java . nio . channels . * ; import java . util . Date ; public class TakeNotes { public static void main ( String [ ] args ) throws IOException { if ( args . length > 0 ) { PrintStream ps = new PrintStream ( new FileOutputStream ( " notes . txt " , true ) ) ; ps . println ( new Date ( ) ) ; ps . print ( " \t " + args [ 0 ] ) ; for ( int i = 1 ; i < args . length ; i ++ ) ps . print ( " ▁ " + args [ i ] ) ; ps . println ( ) ; ps . close ( ) ; } else { FileChannel fc = new FileInputStream ( " notes . txt " ) . getChannel ( ) ; fc . transferTo ( 0 , fc . size ( ) , Channels . newChannel ( System . out ) ) ; fc . close ( ) ; } } }
import java . util . PriorityQueue ; import java . util . ArrayList ; import java . util . List ; import java . util . Iterator ; class CubeSum implements Comparable < CubeSum > { public long x , y , value ; public CubeSum ( long x , long y ) { this . x = x ; this . y = y ; this . value = x * x * x + y * y * y ; } public String toString ( ) { return String . format ( " % 4d ^ 3 ▁ + ▁ % 4d ^ 3" , x , y ) ; } public int compareTo ( CubeSum that ) { return value < that . value ? - 1 : value > that . value ? 1 : 0 ; } } class SumIterator implements Iterator < CubeSum > { PriorityQueue < CubeSum > pq = new PriorityQueue < CubeSum > ( ) ; long n = 0 ; public boolean hasNext ( ) { return true ; } public CubeSum next ( ) { while ( pq . size ( ) == 0 || pq . peek ( ) . value >= n * n * n ) pq . add ( new CubeSum ( ++ n , 1 ) ) ; CubeSum s = pq . remove ( ) ; if ( s . x > s . y + 1 ) pq . add ( new CubeSum ( s . x , s . y + 1 ) ) ; return s ; } } class TaxiIterator implements Iterator < List < CubeSum > > { Iterator < CubeSum > sumIterator = new SumIterator ( ) ; CubeSum last = sumIterator . next ( ) ; public boolean hasNext ( ) { return true ; } public List < CubeSum > next ( ) { CubeSum s ; List < CubeSum > train = new ArrayList < CubeSum > ( ) ; while ( ( s = sumIterator . next ( ) ) . value != last . value ) last = s ; train . add ( last ) ; do { train . add ( s ) ; } while ( ( s = sumIterator . next ( ) ) . value == last . value ) ; last = s ; return train ; } } public class Taxi { public static final void main ( String [ ] args ) { Iterator < List < CubeSum > > taxi = new TaxiIterator ( ) ; for ( int i = 1 ; i <= 2006 ; i ++ ) { List < CubeSum > t = taxi . next ( ) ; if ( i > 25 && i < 2000 ) continue ; System . out . printf ( " % 4d : ▁ % 10d " , i , t . get ( 0 ) . value ) ; for ( CubeSum s : t ) System . out . print ( " ▁ = ▁ " + s ) ; System . out . println ( ) ; } } }
public static void main ( String [ ] args ) { if ( args . length != 1 ) { System . err . println ( " usage : ▁ java ▁ Teacup ▁ dictionary " ) ; System . exit ( 1 ) ; } try { findTeacupWords ( loadDictionary ( args [ 0 ] ) ) ; } catch ( Exception ex ) { System . err . println ( ex . getMessage ( ) ) ; } }
public class Clear { public static void main ( String [ ] args ) { System . out . print ( " \033[2J " ) ; } }
import java . io . PrintStream ; import java . io . UnsupportedEncodingException ; public class Main { public static void main ( String [ ] args ) throws UnsupportedEncodingException { PrintStream writer = new PrintStream ( System . out , true , " UTF - 8" ) ; writer . println ( " £ " ) ; writer . println ( " 札幌 " ) ; } }
public class PreserveScreen { public static void main ( String [ ] args ) throws InterruptedException { System . out . print ( " \033 [ ? 1049h\033 [ H " ) ; System . out . println ( " Alternate ▁ screen ▁ buffer \n " ) ; for ( int i = 5 ; i > 0 ; i -- ) { String s = ( i > 1 ) ? " s " : " " ; System . out . printf ( " \r going ▁ back ▁ in ▁ % d ▁ second % s . . . " , i , s ) ; Thread . sleep ( 1000 ) ; } System . out . print ( " \033 [ ? 1049l " ) ; } }
public class Bell { public static void main ( String [ ] args ) { java . awt . Toolkit . getDefaultToolkit ( ) . beep ( ) ; System . out . println ( ( char ) 7 ) ; } }
# ! / usr / bin / perl use strict ; use warnings ; use Curses ; use Term : : ReadKey ; use Time : : HiRes qw ( time ) ; use IO : : Select ; my $delay = 1 ; my $width = 12 ; my $oneshort = $width - 1 ; my $g3 = qr / ( . . { $oneshort } ) / s ; my $g4 = qr / ( . { $oneshort } ) / s ; my $below = qr / ... . { $oneshort } / s ; my $height = 20 ; my $well = ( ' | ' . ' ▁ ' x $width . " | \n " ) x $height . ' - ' x ( $width + 2 ) . " \n " ; my $piece ; my $nexttime = time + $delay ; my $sel = IO :: Select -> new ( * STDIN ) ; sub transpose { local $_ = $well ; $well = ''; $well . = " \n " while s / ^ . / $well . = $ & ; ''/gem; } sub place { substr $well , $width / 2 - 1 + ( $width + 3 ) * $_ , 4 , shift for 0 . . 3 ; } my % shape = ( I = > [ ' ▁ O ▁ ▁ ' , ' ▁ O ▁ ▁ ' , ' ▁ O ▁ ▁ ' , ' ▁ O ▁ ▁ ' ] , J = > [ ' ▁ ▁ ▁ ▁ ' , ' ▁ ▁ ▁ ▁ ' , ' OOO ▁ ' , ' ▁ ▁ O ▁ ' ] , L = > [ ' ▁ ▁ ▁ ▁ ' , ' ▁ ▁ ▁ ▁ ' , ' ▁ OOO ' , ' ▁ O ▁ ▁ ' ] , O = > [ ' ▁ ▁ ▁ ▁ ' , ' ▁ ▁ ▁ ▁ ' , ' ▁ OO ▁ ' , ' ▁ OO ▁ ' ] , S = > [ ' ▁ ▁ ▁ ▁ ' , ' ▁ ▁ ▁ ▁ ' , ' ▁ OO ▁ ' , ' OO ▁ ▁ ' ] , T = > [ ' ▁ ▁ ▁ ▁ ' , ' ▁ ▁ ▁ ▁ ' , ' ▁ O ▁ ▁ ' , ' OOO ▁ ' ] , Z = > [ ' ▁ ▁ ▁ ▁ ' , ' ▁ ▁ ▁ ▁ ' , ' ▁ OO ▁ ' , ' ▁ ▁ OO ' ] , ) ; sub add { if ( $well = ~ / ^ ( . * . \ n ) { 4 } / ) { place $shape { $piece } -> @ * ; $piece = ( keys % shape ) [ rand keys % shape ] ; } else { die " end ▁ of ▁ game \n " ; } } sub rotate { s / $ { g3 } OO $g3 OO / O$1 OO$2 O / or # Z s / O$g3 OO$g3 O / $1OO $2 OO / or s / $g3 OO$ { g3 } OO / O $1 OO$2 O / or # S s / O $g3 OO$g3 O / $1 OO$2OO / or s / $ { g3 } OOO$ { g3 } O / OO $1 O $2 O / or # L s / OO $g3 O $g3 O / $1 O$2OOO / or s / $g3 O$ { g3 } OOO / O $1 O $2 OO / or s / O $g3 O $g3 OO / $1OOO$2O / or s / $ { g3 } OOO$g3 O / O $1 O $2OO / or # J s / O $g3 O $ { g3 } OO / $1O $2OOO / or s / $ { g3 } O $ { g3 } OOO / OO$1 O $2 O / or s / OO$g3 O $g3 O / $1OOO$2 O / or s / $g3 O $ { g3 } OOO / O $1 OO$2 O / or # T s / O $g3 OO$g3 O / $1OOO$2 O / or s / $ { g3 } OOO$g3 O / O $1OO $2 O / or s / O $ { g3 } OO $g3 O / $1 O $2OOO / or s / $g4 $g4 $ { g4 } OOOO / O $1 O $2 O $3 O / or # I s / O $g4 O $g4 O $g4 O / $1 $2 $3OOOO / or s / O $ { g4 } O $ { g4 } O $ { g4 } O / $1 $2 $3OOOO / or s / O$g4 O$g4 O$g4 O / $1 $2 $3OOOO / for $well ; } sub step { if ( $well = ~ s / ( ? <= \ | ) # { $width } ( ? = \ | ) / ' = ' x $width / e ) # full row ? { transpose ( ) ; $well = ~ s / ( . * ) = / $1 / g ; # remove full row transpose ( ) ; } elsif ( $well ! ~ / O / ) # any O   ? { add ( ) ; } elsif ( not down ( ) ) # can 't move down { $well = ~ tr / O / # / ; # convert to # } } sub down { $well ! ~ / O / || $well = ~ / O$below [ # - ] / and return 0 ; transpose ( ) ; $well = ~ s / ( O + ) / $1 / g ; transpose ( ) ; return 1 ; } sub drop { 1 while down ( ) } sub right { $well = ~ / O [ # | ] / or $well = ~ s / ( O + ) / $1 / g } sub left { $well = ~ / [ # | ] O / or $well = ~ s / ( O + ) / $1 / g } sub draw { addstr ( 2 , 0 , ( $well . " \n \n " ) = ~ s / ^ / ' ▁ ' x 20 / gmer ) ; my $row = 4 ; addstr ( $row ++ , 10 , $_ ) for @ { $shape { $piece } } ; addstr ( 22 , 0 , ' ▁ ' ) ; refresh ; } ; sub eventloop { while ( 1 ) { my $time = time ; my $delta = $nexttime - $time ; if ( $delta <= 0 ) { step ( ) ; $nexttime = time + $delay ; } else { draw ( ) ; for ( $sel -> can_read ( $delta ) ) { sysread * STDIN , $_ , 1024 ; for ( / \ e ( ? : \ [ M ... | [ O \ [ ] [ 0 - 9 ; ] * [ A - ~ ] ) | . / gs ) # keep esc seq together { / ^ ( ? : q | \ e ) \ z / i ? die " quit \n " : / ^ ( ? : h | \ e \ [ D ) \ z / ? left ( ) : / ^ ( ? : l | \ e \ [ C ) \ z / ? right ( ) : / ^ ( ? : r | \ e \ [ A ) \ z / ? rotate ( ) : / ^ ( ? : [ j ] | \ e \ [ B ) \ z / ? drop ( ) : 0 ; } } } } } $piece = ( keys % shape ) [ rand keys % shape ] ; initscr ( ) ; clear ; ReadMode ' cbreak ' ; eval { eventloop ( ) } ; my $errormsg = $ @ ; ReadMode ' restore ' ; endwin ( ) ; print $errormsg ;
import java . io . File ; import java . util . * ; import static java . lang . System . out ; public class TextProcessing1 { public static void main ( String [ ] args ) throws Exception { Locale . setDefault ( new Locale ( " en " , " US " ) ) ; Metrics metrics = new Metrics ( ) ; int dataGap = 0 ; String gapBeginDate = null ; try ( Scanner lines = new Scanner ( new File ( " readings . txt " ) ) ) { while ( lines . hasNextLine ( ) ) { double lineTotal = 0.0 ; int linePairs = 0 ; int lineInvalid = 0 ; String lineDate ; try ( Scanner line = new Scanner ( lines . nextLine ( ) ) ) { lineDate = line . next ( ) ; while ( line . hasNext ( ) ) { final double value = line . nextDouble ( ) ; if ( line . nextInt ( ) <= 0 ) { if ( dataGap == 0 ) gapBeginDate = lineDate ; dataGap ++ ; lineInvalid ++ ; continue ; } lineTotal += value ; linePairs ++ ; metrics . addDataGap ( dataGap , gapBeginDate , lineDate ) ; dataGap = 0 ; } } metrics . addLine ( lineTotal , linePairs ) ; metrics . lineResult ( lineDate , lineInvalid , linePairs , lineTotal ) ; } metrics . report ( ) ; } } private static class Metrics { private List < String [ ] > gapDates ; private int maxDataGap = - 1 ; private double total ; private int pairs ; private int lineResultCount ; void addLine ( double tot , double prs ) { total += tot ; pairs += prs ; } void addDataGap ( int gap , String begin , String end ) { if ( gap > 0 && gap >= maxDataGap ) { if ( gap > maxDataGap ) { maxDataGap = gap ; gapDates = new ArrayList < > ( ) ; } gapDates . add ( new String [ ] { begin , end } ) ; } } void lineResult ( String date , int invalid , int prs , double tot ) { if ( lineResultCount >= 3 ) return ; out . printf ( " % 10s ▁ ▁ out : ▁ % 2d ▁ ▁ in : ▁ % 2d ▁ ▁ tot : ▁ % 10.3f ▁ ▁ avg : ▁ % 10.3f % n " , date , invalid , prs , tot , ( prs > 0 ) ? tot / prs : 0.0 ) ; lineResultCount ++ ; } void report ( ) { out . printf ( " % ntotal ▁ ▁ ▁ ▁ = ▁ % 10.3f % n " , total ) ; out . printf ( " readings ▁ = ▁ % 6d % n " , pairs ) ; out . printf ( " average ▁ ▁ = ▁ % 010.3f % n " , total / pairs ) ; out . printf ( " % nmaximum ▁ run ( s ) ▁ of ▁ % d ▁ invalid ▁ measurements : ▁ % n " , maxDataGap ) ; for ( String [ ] dates : gapDates ) out . printf ( " begins ▁ at ▁ % s ▁ and ▁ ends ▁ at ▁ % s % n " , dates [ 0 ] , dates [ 1 ] ) ; } } }
import java . util . * ; import java . util . regex . * ; import java . io . * ; public class DataMunging2 { public static final Pattern e = Pattern . compile ( " \\ s + " ) ; public static void main ( String [ ] args ) { try { BufferedReader infile = new BufferedReader ( new FileReader ( args [ 0 ] ) ) ; List < String > duplicates = new ArrayList < String > ( ) ; Set < String > datestamps = new HashSet < String > ( ) ; String eingabe ; int all_ok = 0 ; while ( ( eingabe = infile . readLine ( ) ) != null ) { String [ ] fields = e . split ( eingabe ) ; if ( fields . length != 49 ) System . out . println ( " Format ▁ not ▁ ok ! " ) ; if ( datestamps . add ( fields [ 0 ] ) ) { int howoften = ( fields . length - 1 ) / 2 ; for ( int n = 1 ; Integer . parseInt ( fields [ 2 * n ] ) >= 1 ; n ++ ) { if ( n == howoften ) { all_ok ++ ; break ; } } } else { duplicates . add ( fields [ 0 ] ) ; } } infile . close ( ) ; System . out . println ( " The ▁ following ▁ " + duplicates . size ( ) + " ▁ datestamps ▁ were ▁ duplicated : " ) ; for ( String x : duplicates ) System . out . println ( x ) ; System . out . println ( all_ok + " ▁ records ▁ were ▁ complete ▁ and ▁ ok ! " ) ; } catch ( IOException e ) { System . err . println ( " Can ' t ▁ open ▁ file ▁ " + args [ 0 ] ) ; System . exit ( 1 ) ; } } }
import java . io . BufferedReader ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . IOException ; import java . util . LinkedList ; public class License { public static void main ( String [ ] args ) throws FileNotFoundException , IOException { BufferedReader in = new BufferedReader ( new FileReader ( args [ 0 ] ) ) ; int max = Integer . MIN_VALUE ; LinkedList < String > dates = new LinkedList < String > ( ) ; String line ; int count = 0 ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . startsWith ( " License ▁ OUT ▁ " ) ) count ++ ; if ( line . startsWith ( " License ▁ IN ▁ " ) ) count -- ; if ( count > max ) { max = count ; String date = line . split ( " ▁ " ) [ 3 ] ; dates . clear ( ) ; dates . add ( date ) ; } else if ( count == max ) { String date = line . split ( " ▁ " ) [ 3 ] ; dates . add ( date ) ; } } System . out . println ( " Max ▁ licenses ▁ out : ▁ " + max ) ; System . out . println ( " At ▁ time ( s ) : ▁ " + dates ) ; } }
private static void printVerse ( String name ) { StringBuilder sb = new StringBuilder ( name . toLowerCase ( ) ) ; sb . setCharAt ( 0 , Character . toUpperCase ( sb . charAt ( 0 ) ) ) ; String x = sb . toString ( ) ; String y = " AEIOU " . indexOf ( x . charAt ( 0 ) ) > - 1 ? x . toLowerCase ( ) : x . substring ( 1 ) ; String b = " b " + y ; String f = " f " + y ; String m = " m " + y ; switch ( x . charAt ( 0 ) ) { case ' B ' : b = y ; break ; case ' F ' : f = y ; break ; case ' M ' : m = y ; break ; default : break ; } System . out . printf ( " % s , ▁ % s , ▁ bo - % s \n " , x , x , b ) ; System . out . printf ( " Banana - fana ▁ fo - % s \n " , f ) ; System . out . printf ( " Fee - fi - mo - % s \n " , m ) ; System . out . printf ( " % s ! \n \n " , x ) ; }
public class TwelveDaysOfChristmas { final static String [ ] gifts = { " A ▁ partridge ▁ in ▁ a ▁ pear ▁ tree . " , " Two ▁ turtle ▁ doves ▁ and " , " Three ▁ french ▁ hens " , " Four ▁ calling ▁ birds " , " Five ▁ golden ▁ rings " , " Six ▁ geese ▁ a - laying " , " Seven ▁ swans ▁ a - swimming " , " Eight ▁ maids ▁ a - milking " , " Nine ▁ ladies ▁ dancing " , " Ten ▁ lords ▁ a - leaping " , " Eleven ▁ pipers ▁ piping " , " Twelve ▁ drummers ▁ drumming " , " And ▁ a ▁ partridge ▁ in ▁ a ▁ pear ▁ tree . " , " Two ▁ turtle ▁ doves " } ; final static String [ ] days = { " first " , " second " , " third " , " fourth " , " fifth " , " sixth " , " seventh " , " eighth " , " ninth " , " tenth " , " eleventh " , " Twelfth " } ; public static void main ( String [ ] args ) { for ( int i = 0 ; i < days . length ; i ++ ) { System . out . printf ( " % nOn ▁ the ▁ % s ▁ day ▁ of ▁ Christmas % n " , days [ i ] ) ; System . out . println ( " My ▁ true ▁ love ▁ gave ▁ to ▁ me : " ) ; for ( int j = i ; j >= 0 ; j -- ) System . out . println ( gifts [ i == 11 && j < 2 ? j + 12 : j ] ) ; } } }
public class ThueMorse { public static void main ( String [ ] args ) { sequence ( 6 ) ; } public static void sequence ( int steps ) { StringBuilder sb1 = new StringBuilder ( "0" ) ; StringBuilder sb2 = new StringBuilder ( "1" ) ; for ( int i = 0 ; i < steps ; i ++ ) { String tmp = sb1 . toString ( ) ; sb1 . append ( sb2 ) ; sb2 . append ( tmp ) ; } System . out . println ( sb1 ) ; } }
String toTokenize = " Hello , How , Are , You , Today " ; System . out . println ( String . join ( " . " , toTokenize . split ( " , " ) ) ) ;
import java . io . File ; import java . util . * ; public class TopRankPerGroup { private static class Employee { final String name ; final String id ; final String department ; final int salary ; Employee ( String [ ] rec ) { name = rec [ 0 ] ; id = rec [ 1 ] ; salary = Integer . parseInt ( rec [ 2 ] ) ; department = rec [ 3 ] ; } @ Override public String toString ( ) { return String . format ( " % s ▁ % s ▁ % d ▁ % s " , id , name , salary , department ) ; } } public static void main ( String [ ] args ) throws Exception { int N = args . length > 0 ? Integer . parseInt ( args [ 0 ] ) : 3 ; Map < String , List < Employee > > records = new TreeMap < > ( ) ; try ( Scanner sc = new Scanner ( new File ( " data . txt " ) ) ) { while ( sc . hasNextLine ( ) ) { String [ ] rec = sc . nextLine ( ) . trim ( ) . split ( " , ▁ " ) ; List < Employee > lst = records . get ( rec [ 3 ] ) ; if ( lst == null ) { lst = new ArrayList < > ( ) ; records . put ( rec [ 3 ] , lst ) ; } lst . add ( new Employee ( rec ) ) ; } } records . forEach ( ( key , val ) -> { System . out . printf ( " % nDepartment ▁ % s % n " , key ) ; val . stream ( ) . sorted ( ( a , b ) -> Integer . compare ( b . salary , a . salary ) ) . limit ( N ) . forEach ( System . out :: println ) ; } ) ; } }
public class CirclesTotalArea { private static double distSq ( double x1 , double y1 , double x2 , double y2 ) { return ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ; } private static boolean rectangleFullyInsideCircle ( double [ ] rect , double [ ] circ ) { double r2 = circ [ 2 ] * circ [ 2 ] ; return distSq ( rect [ 0 ] , rect [ 1 ] , circ [ 0 ] , circ [ 1 ] ) <= r2 && distSq ( rect [ 0 ] + rect [ 2 ] , rect [ 1 ] , circ [ 0 ] , circ [ 1 ] ) <= r2 && distSq ( rect [ 0 ] , rect [ 1 ] - rect [ 3 ] , circ [ 0 ] , circ [ 1 ] ) <= r2 && distSq ( rect [ 0 ] + rect [ 2 ] , rect [ 1 ] - rect [ 3 ] , circ [ 0 ] , circ [ 1 ] ) <= r2 ; } private static boolean rectangleSurelyOutsideCircle ( double [ ] rect , double [ ] circ ) { if ( rect [ 0 ] <= circ [ 0 ] && circ [ 0 ] <= rect [ 0 ] + rect [ 2 ] && rect [ 1 ] - rect [ 3 ] <= circ [ 1 ] && circ [ 1 ] <= rect [ 1 ] ) { return false ; } double r2 = circ [ 2 ] + Math . max ( rect [ 2 ] , rect [ 3 ] ) ; r2 = r2 * r2 ; return distSq ( rect [ 0 ] , rect [ 1 ] , circ [ 0 ] , circ [ 1 ] ) >= r2 && distSq ( rect [ 0 ] + rect [ 2 ] , rect [ 1 ] , circ [ 0 ] , circ [ 1 ] ) >= r2 && distSq ( rect [ 0 ] , rect [ 1 ] - rect [ 3 ] , circ [ 0 ] , circ [ 1 ] ) >= r2 && distSq ( rect [ 0 ] + rect [ 2 ] , rect [ 1 ] - rect [ 3 ] , circ [ 0 ] , circ [ 1 ] ) >= r2 ; } private static boolean [ ] surelyOutside ; private static double totalArea ( double [ ] rect , double [ ] [ ] circs , int d ) { int surelyOutsideCount = 0 ; for ( int i = 0 ; i < circs . length ; i ++ ) { if ( rectangleFullyInsideCircle ( rect , circs [ i ] ) ) { return rect [ 2 ] * rect [ 3 ] ; } if ( rectangleSurelyOutsideCircle ( rect , circs [ i ] ) ) { surelyOutside [ i ] = true ; surelyOutsideCount ++ ; } else { surelyOutside [ i ] = false ; } } if ( surelyOutsideCount == circs . length ) { return 0 ; } if ( d < 1 ) { return rect [ 2 ] * rect [ 3 ] / 3 ; } if ( surelyOutsideCount > 0 ) { double [ ] [ ] newCircs = new double [ circs . length - surelyOutsideCount ] [ 3 ] ; int loc = 0 ; for ( int i = 0 ; i < circs . length ; i ++ ) { if ( ! surelyOutside [ i ] ) { newCircs [ loc ++ ] = circs [ i ] ; } } circs = newCircs ; } double w = rect [ 2 ] / 2 ; double h = rect [ 3 ] / 2 ; double [ ] [ ] pieces = { { rect [ 0 ] , rect [ 1 ] , w , h } , { rect [ 0 ] + w , rect [ 1 ] , w , h } , { rect [ 0 ] , rect [ 1 ] - h , w , h } , { rect [ 0 ] + w , rect [ 1 ] - h , w , h } } ; double total = 0 ; for ( double [ ] piece : pieces ) { total += totalArea ( piece , circs , d - 1 ) ; } return total ; } public static double totalArea ( double [ ] [ ] circs , int d ) { double maxx = Double . NEGATIVE_INFINITY ; double minx = Double . POSITIVE_INFINITY ; double maxy = Double . NEGATIVE_INFINITY ; double miny = Double . POSITIVE_INFINITY ; for ( double [ ] circ : circs ) { if ( circ [ 0 ] + circ [ 2 ] > maxx ) { maxx = circ [ 0 ] + circ [ 2 ] ; } if ( circ [ 0 ] - circ [ 2 ] < minx ) { minx = circ [ 0 ] - circ [ 2 ] ; } if ( circ [ 1 ] + circ [ 2 ] > maxy ) { maxy = circ [ 1 ] + circ [ 2 ] ; } if ( circ [ 1 ] - circ [ 2 ] < miny ) { miny = circ [ 1 ] - circ [ 2 ] ; } } double [ ] rect = { minx , maxy , maxx - minx , maxy - miny } ; surelyOutside = new boolean [ circs . length ] ; return totalArea ( rect , circs , d ) ; } public static void main ( String [ ] args ) { double [ ] [ ] circs = { { 1.6417233788 , 1.6121789534 , 0.0848270516 } , { - 1.4944608174 , 1.2077959613 , 1.1039549836 } , { 0.6110294452 , - 0.6907087527 , 0.9089162485 } , { 0.3844862411 , 0.2923344616 , 0.2375743054 } , { - 0.2495892950 , - 0.3832854473 , 1.0845181219 } , { 1.7813504266 , 1.6178237031 , 0.8162655711 } , { - 0.1985249206 , - 0.8343333301 , 0.0538864941 } , { - 1.7011985145 , - 0.1263820964 , 0.4776976918 } , { - 0.4319462812 , 1.4104420482 , 0.7886291537 } , { 0.2178372997 , - 0.9499557344 , 0.0357871187 } , { - 0.6294854565 , - 1.3078893852 , 0.7653357688 } , { 1.7952608455 , 0.6281269104 , 0.2727652452 } , { 1.4168575317 , 1.0683357171 , 1.1016025378 } , { 1.4637371396 , 0.9463877418 , 1.1846214562 } , { - 0.5263668798 , 1.7315156631 , 1.4428514068 } , { - 1.2197352481 , 0.9144146579 , 1.0727263474 } , { - 0.1389358881 , 0.1092805780 , 0.7350208828 } , { 1.5293954595 , 0.0030278255 , 1.2472867347 } , { - 0.5258728625 , 1.3782633069 , 1.3495508831 } , { - 0.1403562064 , 0.2437382535 , 1.3804956588 } , { 0.8055826339 , - 0.0482092025 , 0.3327165165 } , { - 0.6311979224 , 0.7184578971 , 0.2491045282 } , { 1.4685857879 , - 0.8347049536 , 1.3670667538 } , { - 0.6855727502 , 1.6465021616 , 1.0593087096 } , { 0.0152957411 , 0.0638919221 , 0.9771215985 } } ; double ans = totalArea ( circs , 24 ) ; System . out . println ( " Approx . ▁ area ▁ is ▁ " + ans ) ; System . out . println ( " Error ▁ is ▁ " + Math . abs ( 21.56503660 - ans ) ) ; } }
import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . Stack ; public class TruthTable { public static void main ( final String ... args ) { System . out . println ( new TruthTable ( args ) ) ; } private interface Operator { boolean evaluate ( Stack < Boolean > s ) ; } private static final Map < String , Operator > operators = new HashMap < String , Operator > ( ) { { put ( " & " , stack -> Boolean . logicalAnd ( stack . pop ( ) , stack . pop ( ) ) ) ; put ( " | " , stack -> Boolean . logicalOr ( stack . pop ( ) , stack . pop ( ) ) ) ; put ( " ! " , stack -> ! stack . pop ( ) ) ; put ( " ^ " , stack -> ! stack . pop ( ) . equals ( stack . pop ( ) ) ) ; } } ; private final List < String > variables ; private final String [ ] symbols ; public TruthTable ( final String ... symbols ) { final Set < String > variables = new LinkedHashSet < > ( ) ; for ( final String symbol : symbols ) { if ( ! operators . containsKey ( symbol ) ) { variables . add ( symbol ) ; } } this . variables = new ArrayList < > ( variables ) ; this . symbols = symbols ; } @ Override public String toString ( ) { final StringBuilder result = new StringBuilder ( ) ; for ( final String variable : variables ) { result . append ( variable ) . append ( ' ▁ ' ) ; } result . append ( ' ▁ ' ) ; for ( final String symbol : symbols ) { result . append ( symbol ) . append ( ' ▁ ' ) ; } result . append ( ' \n ' ) ; for ( final List < Boolean > values : enumerate ( variables . size ( ) ) ) { final Iterator < String > i = variables . iterator ( ) ; for ( final Boolean value : values ) { result . append ( String . format ( " % - " + i . next ( ) . length ( ) + " c ▁ " , value ? ' T ' : ' F ' ) ) ; } result . append ( ' ▁ ' ) . append ( evaluate ( values ) ? ' T ' : ' F ' ) . append ( ' \n ' ) ; } return result . toString ( ) ; } private static List < List < Boolean > > enumerate ( final int size ) { if ( 1 == size ) return new ArrayList < List < Boolean > > ( ) { { add ( new ArrayList < Boolean > ( ) { { add ( false ) ; } } ) ; add ( new ArrayList < Boolean > ( ) { { add ( true ) ; } } ) ; } } ; return new ArrayList < List < Boolean > > ( ) { { for ( final List < Boolean > head : enumerate ( size - 1 ) ) { add ( new ArrayList < Boolean > ( head ) { { add ( false ) ; } } ) ; add ( new ArrayList < Boolean > ( head ) { { add ( true ) ; } } ) ; } } } ; } private boolean evaluate ( final List < Boolean > enumeration ) { final Iterator < Boolean > i = enumeration . iterator ( ) ; final Map < String , Boolean > values = new HashMap < > ( ) ; final Stack < Boolean > stack = new Stack < > ( ) ; variables . forEach ( v -> values . put ( v , i . next ( ) ) ) ; for ( final String symbol : symbols ) { final Operator op = operators . get ( symbol ) ; stack . push ( null == op ? values . get ( symbol ) : op . evaluate ( stack ) ) ; } return stack . pop ( ) ; } }
public static int [ ] twoSum ( int [ ] a , long target ) { int i = 0 , j = a . length - 1 ; while ( i < j ) { long sum = a [ i ] + a [ j ] ; if ( sum == target ) return new int [ ] { i , j } ; if ( sum < target ) i ++ ; else j -- ; } return null ; }
private static int ulam ( int n ) { int [ ] ulams = new int [ Math . max ( n , 2 ) ] ; ulams [ 0 ] = 1 ; ulams [ 1 ] = 2 ; int sieveLength = 2 ; int [ ] sieve = new int [ sieveLength ] ; sieve [ 0 ] = sieve [ 1 ] = 1 ; for ( int u = 2 , ulen = 2 ; ulen < n ; ) { sieveLength = u + ulams [ ulen - 2 ] ; sieve = extend ( sieve , sieveLength ) ; for ( int i = 0 ; i < ulen - 1 ; ++ i ) ++ sieve [ u + ulams [ i ] - 1 ] ; for ( int i = u ; i < sieveLength ; ++ i ) { if ( sieve [ i ] == 1 ) { u = i + 1 ; ulams [ ulen ++ ] = u ; break ; } } } return ulams [ n - 1 ] ; }
public static boolean unbiased ( int n ) { boolean a , b ; do { a = biased ( n ) ; b = biased ( n ) ; } while ( a == b ) ; return a ; }
String string = null ; System . out . println ( string ) ; System . out . println ( string . length ( ) ) ;
julia > 四十二 = " voilà " ; julia > println ( 四十二 ) voilà
public static void main ( String [ ] args ) { var barcodes = List . of ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ ▁ ▁ # ▁ # # ▁ ▁ # ▁ ▁ # # ▁ # ▁ ▁ ▁ # # ▁ # # # ▁ # # ▁ # # # ▁ # # ▁ # # # # ▁ # ▁ # ▁ # ▁ # # ▁ # # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ # # ▁ ▁ # # ▁ # # # ▁ ▁ # ▁ # # ▁ ▁ # # ▁ # # # ▁ # ▁ ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ # ▁ ▁ ▁ # # ▁ ▁ ▁ # # ▁ # ▁ # # # # ▁ # ▁ ▁ ▁ # ▁ # # ▁ # ▁ ▁ ▁ # # ▁ # ▁ ▁ ▁ # # ▁ # ▁ # ▁ # ▁ # # # ▁ ▁ # ▁ # # # ▁ ▁ # # ▁ ▁ # # ▁ # # # ▁ ▁ # ▁ # ▁ ▁ # # # ▁ # # # ▁ ▁ # ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ ▁ ▁ ▁ # ▁ # ▁ # ▁ ▁ # # # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ ▁ ▁ # ▁ # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ ▁ ▁ # ▁ # ▁ # ▁ # ▁ # # ▁ # ▁ ▁ ▁ # # ▁ # ▁ ▁ ▁ # # ▁ # ▁ ▁ ▁ # # ▁ ▁ ▁ # ▁ # ▁ # # # # ▁ # # # ▁ # # ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ # # ▁ ▁ # # ▁ # # ▁ ▁ # # ▁ ▁ ▁ # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ # ▁ # # # ▁ ▁ # ▁ # # ▁ ▁ # # ▁ # ▁ # ▁ # ▁ ▁ ▁ # # ▁ # # ▁ ▁ # ▁ ▁ # # # ▁ # # ▁ # # ▁ # ▁ ▁ ▁ # ▁ # # # # ▁ # # ▁ # ▁ ▁ ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ # # # ▁ # # ▁ # ▁ ▁ ▁ # # ▁ # # ▁ # # # ▁ ▁ # # ▁ ▁ # ▁ # # ▁ ▁ ▁ # ▁ ▁ ▁ # ▁ # # ▁ # ▁ # ▁ # # # ▁ # ▁ ▁ # # ▁ # # ▁ ▁ # ▁ ▁ ▁ ▁ # ▁ # # # ▁ # ▁ ▁ # # ▁ # # ▁ ▁ # ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ ▁ # ▁ ▁ ▁ # ▁ # # ▁ ▁ # # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ # ▁ # # ▁ ▁ # # ▁ ▁ # ▁ ▁ ▁ # ▁ # ▁ # ▁ # ▁ # # # # ▁ # ▁ ▁ # # ▁ ▁ # ▁ # # # # ▁ # # # # ▁ # ▁ # ▁ ▁ # # ▁ ▁ # ▁ # # # # ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ ▁ # ▁ ▁ # # ▁ ▁ # # ▁ ▁ # ▁ # ▁ ▁ ▁ # # ▁ # # ▁ ▁ ▁ # ▁ # # # ▁ # # ▁ # # ▁ ▁ ▁ # ▁ # ▁ # ▁ # ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ ▁ # ▁ ▁ # ▁ ▁ # # # ▁ # ▁ # ▁ ▁ ▁ ▁ # # # ▁ ▁ # ▁ # ▁ ▁ # ▁ ▁ ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ # ▁ ▁ ▁ ▁ # ▁ # # ▁ ▁ # # ▁ ▁ ▁ # ▁ ▁ # ▁ # # ▁ ▁ # # ▁ ▁ # # # ▁ # ▁ ▁ ▁ # ▁ ▁ # ▁ # ▁ # ▁ # # # ▁ # # ▁ # # ▁ # # # ▁ # # ▁ # # # ▁ # # # ▁ # # ▁ # ▁ ▁ # # ▁ ▁ # # # ▁ # # ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ # # # ▁ # # ▁ ▁ ▁ # # ▁ # ▁ # ▁ # # # # ▁ # ▁ ▁ ▁ # # ▁ # ▁ # # # # ▁ # ▁ # # # # ▁ # ▁ # ▁ # ▁ ▁ ▁ # ▁ ▁ # ▁ # # # ▁ ▁ # ▁ ▁ ▁ ▁ # ▁ # # # ▁ ▁ # ▁ # ▁ ▁ ▁ ▁ # ▁ # # # ▁ ▁ # ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ " , " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ # ▁ # ▁ # # # # ▁ # # ▁ ▁ ▁ # ▁ # # # # ▁ # ▁ # ▁ ▁ ▁ # # ▁ # # ▁ # # # ▁ # # # # ▁ # ▁ # ▁ # ▁ # ▁ ▁ # # # ▁ # ▁ # # # ▁ ▁ # # # ▁ ▁ # ▁ # ▁ # # # ▁ ▁ # ▁ ▁ ▁ ▁ # ▁ # ▁ ▁ # # # ▁ # ▁ # ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " ) ; barcodes . forEach ( UPC :: decodeUPC ) ; }
import java . io . * ; import java . util . * ; import java . util . regex . * ; public class UpdateConfig { public static void main ( String [ ] args ) { if ( args [ 0 ] == null ) { System . out . println ( " filename ▁ required " ) ; } else if ( readConfig ( args [ 0 ] ) ) { enableOption ( " seedsremoved " ) ; disableOption ( " needspeeling " ) ; setOption ( " numberofbananas " , "1024" ) ; addOption ( " numberofstrawberries " , "62000" ) ; store ( ) ; } } private enum EntryType { EMPTY , ENABLED , DISABLED , COMMENT } private static class Entry { EntryType type ; String name , value ; Entry ( EntryType t , String n , String v ) { type = t ; name = n ; value = v ; } } private static Map < String , Entry > entries = new LinkedHashMap < > ( ) ; private static String path ; private static boolean readConfig ( String p ) { path = p ; File f = new File ( path ) ; if ( ! f . exists ( ) || f . isDirectory ( ) ) return false ; String regexString = " ^ ( ; * ) \\ s * ( [ A - Za - z0-9 ] + ) \\ s * ( [ A - Za - z0-9 ] * ) " ; Pattern regex = Pattern . compile ( regexString ) ; try ( Scanner sc = new Scanner ( new FileReader ( f ) ) ) { int emptyLines = 0 ; String line ; while ( sc . hasNext ( ) ) { line = sc . nextLine ( ) . trim ( ) ; if ( line . isEmpty ( ) ) { addOption ( " " + emptyLines ++ , null , EntryType . EMPTY ) ; } else if ( line . charAt ( 0 ) == ' # ' ) { entries . put ( line , new Entry ( EntryType . COMMENT , line , null ) ) ; } else { line = line . replaceAll ( " [ ^ a - zA - Z0-9 \\ x20 ; ] " , " " ) ; Matcher m = regex . matcher ( line ) ; if ( m . find ( ) && ! m . group ( 2 ) . isEmpty ( ) ) { EntryType t = EntryType . ENABLED ; if ( ! m . group ( 1 ) . isEmpty ( ) ) t = EntryType . DISABLED ; addOption ( m . group ( 2 ) , m . group ( 3 ) , t ) ; } } } } catch ( IOException e ) { System . out . println ( e ) ; } return true ; } private static void addOption ( String name , String value ) { addOption ( name , value , EntryType . ENABLED ) ; } private static void addOption ( String name , String value , EntryType t ) { name = name . toUpperCase ( ) ; entries . put ( name , new Entry ( t , name , value ) ) ; } private static void enableOption ( String name ) { Entry e = entries . get ( name . toUpperCase ( ) ) ; if ( e != null ) e . type = EntryType . ENABLED ; } private static void disableOption ( String name ) { Entry e = entries . get ( name . toUpperCase ( ) ) ; if ( e != null ) e . type = EntryType . DISABLED ; } private static void setOption ( String name , String value ) { Entry e = entries . get ( name . toUpperCase ( ) ) ; if ( e != null ) e . value = value ; } private static void store ( ) { try ( PrintWriter pw = new PrintWriter ( path ) ) { for ( Entry e : entries . values ( ) ) { switch ( e . type ) { case EMPTY : pw . println ( ) ; break ; case ENABLED : pw . format ( " % s ▁ % s % n " , e . name , e . value ) ; break ; case DISABLED : pw . format ( " ; ▁ % s ▁ % s % n " , e . name , e . value ) ; break ; case COMMENT : pw . println ( e . name ) ; break ; default : break ; } } if ( pw . checkError ( ) ) { throw new IOException ( " writing ▁ to ▁ file ▁ failed " ) ; } } catch ( IOException e ) { System . out . println ( e ) ; } } }
import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; public class Main { public static void main ( String [ ] args ) throws UnsupportedEncodingException { String encoded = " http % 3A % 2F % 2Ffoo % 20bar % 2F " ; String normal = URLDecoder . decode ( encoded , " utf - 8" ) ; System . out . println ( normal ) ; } }
import java . io . UnsupportedEncodingException ; import java . net . URLEncoder ; public class Main { public static void main ( String [ ] args ) throws UnsupportedEncodingException { String normal = " http : // foo ▁ bar / " ; String encoded = URLEncoder . encode ( normal , " utf - 8" ) ; System . out . println ( encoded ) ; } }
import java . net . URI ; import java . net . URISyntaxException ; public class WebAddressParser { public static void main ( String [ ] args ) { parseAddress ( " foo : // example . com : 8042 / over / there ? name = ferret # nose " ) ; parseAddress ( " urn : example : animal : ferret : nose " ) ; } static void parseAddress ( String a ) { System . out . println ( " Parsing ▁ " + a ) ; try { URI u = new URI ( a ) ; System . out . println ( " \tscheme ▁ = ▁ " + u . getScheme ( ) ) ; System . out . println ( " \tdomain ▁ = ▁ " + u . getHost ( ) ) ; System . out . println ( " \tport ▁ = ▁ " + ( - 1 == u . getPort ( ) ? " default " : u . getPort ( ) ) ) ; System . out . println ( " \tpath ▁ = ▁ " + ( null == u . getPath ( ) ? u . getSchemeSpecificPart ( ) : u . getPath ( ) ) ) ; System . out . println ( " \tquery ▁ = ▁ " + u . getQuery ( ) ) ; System . out . println ( " \tfragment ▁ = ▁ " + u . getFragment ( ) ) ; } catch ( URISyntaxException x ) { System . err . println ( " Oops : ▁ " + x ) ; } } }
import javax . swing . * ; public class GetInputSwing { public static void main ( String [ ] args ) throws Exception { int number = Integer . parseInt ( JOptionPane . showInputDialog ( " Enter ▁ an ▁ Integer " ) ) ; String string = JOptionPane . showInputDialog ( " Enter ▁ a ▁ String " ) ; } }
import java . util . Scanner ; public class GetInput { public static void main ( String [ ] args ) throws Exception { Scanner s = new Scanner ( System . in ) ; System . out . print ( " Enter ▁ a ▁ string : ▁ " ) ; String str = s . nextLine ( ) ; System . out . print ( " Enter ▁ an ▁ integer : ▁ " ) ; int i = Integer . parseInt ( s . next ( ) ) ; } }
public static double vdc ( int n ) { double vdc = 0 ; int denom = 1 ; while ( n != 0 ) { vdc += n % 2.0 / ( denom *= 2 ) ; n /= 2 ; } return vdc ; }
private static void vanEck ( int firstIndex , int lastIndex ) { Map < Integer , Integer > vanEckMap = new HashMap < > ( ) ; int last = 0 ; if ( firstIndex == 1 ) { System . out . printf ( " VanEck [ % d ] ▁ = ▁ % d % n " , 1 , 0 ) ; } for ( int n = 2 ; n <= lastIndex ; n ++ ) { int vanEck = vanEckMap . containsKey ( last ) ? n - vanEckMap . get ( last ) : 0 ; vanEckMap . put ( last , n ) ; last = vanEck ; if ( n >= firstIndex ) { System . out . printf ( " VanEck [ % d ] ▁ = ▁ % d % n " , n , vanEck ) ; } } }
public class VariableDeclarationReset { public static void main ( String [ ] args ) { int [ ] s = { 1 , 2 , 2 , 3 , 4 , 4 , 5 } ; for ( int i = 0 ; i < s . length ; ++ i ) { int curr = s [ i ] ; int prev = 0 ; if ( i > 0 && curr == prev ) System . out . println ( i ) ; prev = curr ; } int gprev = 0 ; for ( int i = 0 ; i < s . length ; ++ i ) { int curr = s [ i ] ; if ( i > 0 && curr == gprev ) System . out . println ( i ) ; gprev = curr ; } } }
int a ; double b ; AClassNameHere c ;
public static void printAll ( Object ... things ) { for ( Object i : things ) { System . out . println ( i ) ; } }
static String encrypt ( String text , final String key ) { String res = " " ; text = text . toUpperCase ( ) ; for ( int i = 0 , j = 0 ; i < text . length ( ) ; i ++ ) { char c = text . charAt ( i ) ; if ( c < ' A ' || c > ' Z ' ) continue ; res += ( char ) ( ( c + key . charAt ( j ) - 2 * ' A ' ) % 26 + ' A ' ) ; j = ++ j % key . length ( ) ; } return res ; }
static String decrypt ( String text , final String key ) { String res = " " ; text = text . toUpperCase ( ) ; for ( int i = 0 , j = 0 ; i < text . length ( ) ; i ++ ) { char c = text . charAt ( i ) ; if ( c < ' A ' || c > ' Z ' ) continue ; res += ( char ) ( ( c - key . charAt ( j ) + 26 ) % 26 + ' A ' ) ; j = ++ j % key . length ( ) ; } return res ; }
public static void main ( String [ ] args ) { String key = " VIGENERECIPHER " ; String ori = " Beware ▁ the ▁ Jabberwock , ▁ my ▁ son ! ▁ The ▁ jaws ▁ that ▁ bite , ▁ the ▁ claws ▁ that ▁ catch ! " ; String enc = encrypt ( ori , key ) ; System . out . println ( enc ) ; System . out . println ( decrypt ( enc , key ) ) ; }
import java . util . Arrays ; import static java . util . Arrays . stream ; import java . util . concurrent . * ; public class VogelsApproximationMethod { final static int [ ] demand = { 30 , 20 , 70 , 30 , 60 } ; final static int [ ] supply = { 50 , 60 , 50 , 50 } ; final static int [ ] [ ] costs = { { 16 , 16 , 13 , 22 , 17 } , { 14 , 14 , 13 , 19 , 15 } , { 19 , 19 , 20 , 23 , 50 } , { 50 , 12 , 50 , 15 , 11 } } ; final static int nRows = supply . length ; final static int nCols = demand . length ; static boolean [ ] rowDone = new boolean [ nRows ] ; static boolean [ ] colDone = new boolean [ nCols ] ; static int [ ] [ ] result = new int [ nRows ] [ nCols ] ; static ExecutorService es = Executors . newFixedThreadPool ( 2 ) ; public static void main ( String [ ] args ) throws Exception { int supplyLeft = stream ( supply ) . sum ( ) ; int totalCost = 0 ; while ( supplyLeft > 0 ) { int [ ] cell = nextCell ( ) ; int r = cell [ 0 ] ; int c = cell [ 1 ] ; int quantity = Math . min ( demand [ c ] , supply [ r ] ) ; demand [ c ] -= quantity ; if ( demand [ c ] == 0 ) colDone [ c ] = true ; supply [ r ] -= quantity ; if ( supply [ r ] == 0 ) rowDone [ r ] = true ; result [ r ] [ c ] = quantity ; supplyLeft -= quantity ; totalCost += quantity * costs [ r ] [ c ] ; } stream ( result ) . forEach ( a -> System . out . println ( Arrays . toString ( a ) ) ) ; System . out . println ( " Total ▁ cost : ▁ " + totalCost ) ; es . shutdown ( ) ; } static int [ ] nextCell ( ) throws Exception { Future < int [ ] > f1 = es . submit ( ( ) -> maxPenalty ( nRows , nCols , true ) ) ; Future < int [ ] > f2 = es . submit ( ( ) -> maxPenalty ( nCols , nRows , false ) ) ; int [ ] res1 = f1 . get ( ) ; int [ ] res2 = f2 . get ( ) ; if ( res1 [ 3 ] == res2 [ 3 ] ) return res1 [ 2 ] < res2 [ 2 ] ? res1 : res2 ; return ( res1 [ 3 ] > res2 [ 3 ] ) ? res2 : res1 ; } static int [ ] diff ( int j , int len , boolean isRow ) { int min1 = Integer . MAX_VALUE , min2 = Integer . MAX_VALUE ; int minP = - 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( isRow ? colDone [ i ] : rowDone [ i ] ) continue ; int c = isRow ? costs [ j ] [ i ] : costs [ i ] [ j ] ; if ( c < min1 ) { min2 = min1 ; min1 = c ; minP = i ; } else if ( c < min2 ) min2 = c ; } return new int [ ] { min2 - min1 , min1 , minP } ; } static int [ ] maxPenalty ( int len1 , int len2 , boolean isRow ) { int md = Integer . MIN_VALUE ; int pc = - 1 , pm = - 1 , mc = - 1 ; for ( int i = 0 ; i < len1 ; i ++ ) { if ( isRow ? rowDone [ i ] : colDone [ i ] ) continue ; int [ ] res = diff ( i , len2 , isRow ) ; if ( res [ 0 ] > md ) { md = res [ 0 ] ; pm = i ; mc = res [ 1 ] ; pc = res [ 2 ] ; } } return isRow ? new int [ ] { pm , pc , mc , md } : new int [ ] { pc , pm , mc , md } ; } }
File dir = new File ( " / foo / bar " ) ; String [ ] contents = dir . list ( ) ; for ( String file : contents ) if ( file . endsWith ( " . mp3" ) ) System . out . println ( file ) ;
import java . io . File ; public class MainEntry { public static void main ( String [ ] args ) { walkin ( new File ( " / home / user " ) ) ; } public static void walkin ( File dir ) { String pattern = " . mp3" ; File listFile [ ] = dir . listFiles ( ) ; if ( listFile != null ) { for ( int i = 0 ; i < listFile . length ; i ++ ) { if ( listFile [ i ] . isDirectory ( ) ) { walkin ( listFile [ i ] ) ; } else { if ( listFile [ i ] . getName ( ) . endsWith ( pattern ) ) { System . out . println ( listFile [ i ] . getPath ( ) ) ; } } } } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . URL ; import java . net . URLConnection ; public class WebTime { public static void main ( String [ ] args ) { try { URL address = new URL ( " http : // tycho . usno . navy . mil / cgi - bin / timer . pl " ) ; URLConnection conn = address . openConnection ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( conn . getInputStream ( ) ) ) ; String line ; while ( ! ( line = in . readLine ( ) ) . contains ( " UTC " ) ) ; System . out . println ( line . substring ( 4 ) ) ; } catch ( IOException e ) { System . err . println ( " error ▁ connecting ▁ to ▁ server . " ) ; e . printStackTrace ( ) ; } } }
public static void main ( String [ ] args ) { int n = 2 ; for ( int count = 1 ; count <= 25 ; n += 2 ) { if ( isWeird ( n ) ) { System . out . printf ( " w ( % d ) ▁ = ▁ % d % n " , count , n ) ; count ++ ; } } }
import javax . swing . JFrame ; public class Main { public static void main ( String [ ] args ) throws Exception { JFrame w = new JFrame ( " Title " ) ; w . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; w . setSize ( 800 , 600 ) ; w . setVisible ( true ) ; } }
import javax . swing . JFrame ; import javax . swing . SwingUtilities ; public class WindowExample { public static void main ( String [ ] args ) { Runnable runnable = new Runnable ( ) { public void run ( ) { createAndShow ( ) ; } } ; SwingUtilities . invokeLater ( runnable ) ; } static void createAndShow ( ) { JFrame frame = new JFrame ( " Hello ▁ World " ) ; frame . setSize ( 640 , 480 ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; } }
public static void main ( String [ ] args ) { List < String > dict = Arrays . asList ( " a " , " aa " , " b " , " ab " , " aab " ) ; for ( String testString : Arrays . asList ( " aab " , " aa ▁ b " ) ) { List < List < String > > matches = wordBreak ( testString , dict ) ; System . out . printf ( " String ▁ = ▁ % s , ▁ Dictionary ▁ = ▁ % s . ▁ ▁ Solutions ▁ = ▁ % d : % n " , testString , dict , matches . size ( ) ) ; for ( List < String > match : matches ) { System . out . printf ( " ▁ Word ▁ Break ▁ = ▁ % s % n " , match ) ; } System . out . printf ( " % n " ) ; } dict = Arrays . asList ( " abc " , " a " , " ac " , " b " , " c " , " cb " , " d " ) ; for ( String testString : Arrays . asList ( " abcd " , " abbc " , " abcbcd " , " acdbc " , " abcdd " ) ) { List < List < String > > matches = wordBreak ( testString , dict ) ; System . out . printf ( " String ▁ = ▁ % s , ▁ Dictionary ▁ = ▁ % s . ▁ ▁ Solutions ▁ = ▁ % d : % n " , testString , dict , matches . size ( ) ) ; for ( List < String > match : matches ) { System . out . printf ( " ▁ Word ▁ Break ▁ = ▁ % s % n " , match ) ; } System . out . printf ( " % n " ) ; } }
import java . io . IOException ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . Paths ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . stream . Collectors ; public class WordCount { public static void main ( String [ ] args ) throws IOException { Path path = Paths . get ( "135-0 . txt " ) ; byte [ ] bytes = Files . readAllBytes ( path ) ; String text = new String ( bytes ) ; text = text . toLowerCase ( ) ; Pattern r = Pattern . compile ( " \\ p { javaLowerCase } + " ) ; Matcher matcher = r . matcher ( text ) ; Map < String , Integer > freq = new HashMap < > ( ) ; while ( matcher . find ( ) ) { String word = matcher . group ( ) ; Integer current = freq . getOrDefault ( word , 0 ) ; freq . put ( word , current + 1 ) ; } List < Map . Entry < String , Integer > > entries = freq . entrySet ( ) . stream ( ) . sorted ( ( i1 , i2 ) -> Integer . compare ( i2 . getValue ( ) , i1 . getValue ( ) ) ) . limit ( 10 ) . collect ( Collectors . toList ( ) ) ; System . out . println ( " Rank ▁ ▁ Word ▁ ▁ Frequency " ) ; System . out . println ( " = = = = ▁ ▁ = = = = ▁ ▁ = = = = = = = = = " ) ; int rank = 1 ; for ( Map . Entry < String , Integer > entry : entries ) { String word = entry . getKey ( ) ; Integer count = entry . getValue ( ) ; System . out . printf ( " % 2d ▁ ▁ ▁   % -4s ▁ ▁ ▁ ▁ % 5d \n " , rank ++ , word , count ) ; } } }
static List < String > readWords ( String filename ) { int maxLen = Math . max ( nRows , nCols ) ; List < String > words = new ArrayList < > ( ) ; try ( Scanner sc = new Scanner ( new FileReader ( filename ) ) ) { while ( sc . hasNext ( ) ) { String s = sc . next ( ) . trim ( ) . toLowerCase ( ) ; if ( s . matches ( " ^ [ a - z ] { 3 , " + maxLen + " } $ " ) ) words . add ( s ) ; } } catch ( FileNotFoundException e ) { System . out . println ( e ) ; } return words ; }
static int placeMessage ( Grid grid , String msg ) { msg = msg . toUpperCase ( ) . replaceAll ( " [ ^ A - Z ] " , " " ) ; int messageLen = msg . length ( ) ; if ( messageLen > 0 && messageLen < gridSize ) { int gapSize = gridSize / messageLen ; for ( int i = 0 ; i < messageLen ; i ++ ) { int pos = i * gapSize + rand . nextInt ( gapSize ) ; grid . cells [ pos / nCols ] [ pos % nCols ] = msg . charAt ( i ) ; } return messageLen ; } return 0 ; }
static int tryLocation ( Grid grid , String word , int dir , int pos ) { int r = pos / nCols ; int c = pos % nCols ; int len = word . length ( ) ; if ( ( dirs [ dir ] [ 0 ] == 1 && ( len + c ) > nCols ) || ( dirs [ dir ] [ 0 ] == - 1 && ( len - 1 ) > c ) || ( dirs [ dir ] [ 1 ] == 1 && ( len + r ) > nRows ) || ( dirs [ dir ] [ 1 ] == - 1 && ( len - 1 ) > r ) ) return 0 ; int rr , cc , i , overlaps = 0 ; for ( i = 0 , rr = r , cc = c ; i < len ; i ++ ) { if ( grid . cells [ rr ] [ cc ] != 0 && grid . cells [ rr ] [ cc ] != word . charAt ( i ) ) return 0 ; cc += dirs [ dir ] [ 0 ] ; rr += dirs [ dir ] [ 1 ] ; } for ( i = 0 , rr = r , cc = c ; i < len ; i ++ ) { if ( grid . cells [ rr ] [ cc ] == word . charAt ( i ) ) overlaps ++ ; else grid . cells [ rr ] [ cc ] = word . charAt ( i ) ; if ( i < len - 1 ) { cc += dirs [ dir ] [ 0 ] ; rr += dirs [ dir ] [ 1 ] ; } } int lettersPlaced = len - overlaps ; if ( lettersPlaced > 0 ) { grid . solutions . add ( format ( " % -10s ▁ ( % d , % d ) ( % d , % d ) " , word , c , r , cc , rr ) ) ; } return lettersPlaced ; }
static int tryPlaceWord ( Grid grid , String word ) { int randDir = rand . nextInt ( dirs . length ) ; int randPos = rand . nextInt ( gridSize ) ; for ( int dir = 0 ; dir < dirs . length ; dir ++ ) { dir = ( dir + randDir ) % dirs . length ; for ( int pos = 0 ; pos < gridSize ; pos ++ ) { pos = ( pos + randPos ) % gridSize ; int lettersPlaced = tryLocation ( grid , word , dir , pos ) ; if ( lettersPlaced > 0 ) return lettersPlaced ; } } return 0 ; }
static Grid createWordSearch ( List < String > words ) { Grid grid = null ; int numAttempts = 0 ; outer : while ( ++ numAttempts < 100 ) { Collections . shuffle ( words ) ; grid = new Grid ( ) ; int messageLen = placeMessage ( grid , " Rosetta ▁ Code " ) ; int target = gridSize - messageLen ; int cellsFilled = 0 ; for ( String word : words ) { cellsFilled += tryPlaceWord ( grid , word ) ; if ( cellsFilled == target ) { if ( grid . solutions . size ( ) >= minWords ) { grid . numAttempts = numAttempts ; break outer ; } else break ; } } } return grid ; }
static void printResult ( Grid grid ) { if ( grid == null || grid . numAttempts == 0 ) { System . out . println ( " No ▁ grid ▁ to ▁ display " ) ; return ; } int size = grid . solutions . size ( ) ; System . out . println ( " Attempts : ▁ " + grid . numAttempts ) ; System . out . println ( " Number ▁ of ▁ words : ▁ " + size ) ; System . out . println ( " \n ▁ ▁ ▁ ▁ ▁ 0 ▁ ▁ 1 ▁ ▁ 2 ▁ ▁ 3 ▁ ▁ 4 ▁ ▁ 5 ▁ ▁ 6 ▁ ▁ 7 ▁ ▁ 8 ▁ ▁ 9" ) ; for ( int r = 0 ; r < nRows ; r ++ ) { System . out . printf ( " % n % d ▁ ▁ ▁ " , r ) ; for ( int c = 0 ; c < nCols ; c ++ ) System . out . printf ( " ▁ % c ▁ " , grid . cells [ r ] [ c ] ) ; } System . out . println ( " \n " ) ; for ( int i = 0 ; i < size - 1 ; i += 2 ) { System . out . printf ( " % s ▁ ▁ ▁ % s % n " , grid . solutions . get ( i ) , grid . solutions . get ( i + 1 ) ) ; } if ( size % 2 == 1 ) System . out . println ( grid . solutions . get ( size - 1 ) ) ; }
import java . io . * ; import java . util . * ; public class NeighbourWords { public static void main ( String [ ] args ) { try { int minLength = 9 ; List < String > words = new ArrayList < > ( ) ; try ( BufferedReader reader = new BufferedReader ( new FileReader ( " unixdict . txt " ) ) ) { String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . length ( ) >= minLength ) words . add ( line ) ; } } Collections . sort ( words ) ; String previousWord = null ; int count = 0 ; for ( int i = 0 , n = words . size ( ) ; i + minLength <= n ; ++ i ) { StringBuilder sb = new StringBuilder ( minLength ) ; for ( int j = 0 ; j < minLength ; ++ j ) sb . append ( words . get ( i + j ) . charAt ( j ) ) ; String word = sb . toString ( ) ; if ( word . equals ( previousWord ) ) continue ; if ( Collections . binarySearch ( words , word ) >= 0 ) System . out . printf ( " % 2d . ▁ % s \n " , ++ count , word ) ; previousWord = word ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
import java . util . Arrays ; public class GroupStage { static String [ ] games = { "12" , "13" , "14" , "23" , "24" , "34" } ; static String results = "000000" ; private static boolean nextResult ( ) { if ( results . equals ( "222222" ) ) return false ; int res = Integer . parseInt ( results , 3 ) + 1 ; results = Integer . toString ( res , 3 ) ; while ( results . length ( ) < 6 ) results = "0" + results ; return true ; } public static void main ( String [ ] args ) { int [ ] [ ] points = new int [ 4 ] [ 10 ] ; do { int [ ] records = { 0 , 0 , 0 , 0 } ; for ( int i = 0 ; i < 6 ; i ++ ) { switch ( results . charAt ( i ) ) { case '2' : records [ games [ i ] . charAt ( 0 ) - '1' ] += 3 ; break ; case '1' : records [ games [ i ] . charAt ( 0 ) - '1' ] ++ ; records [ games [ i ] . charAt ( 1 ) - '1' ] ++ ; break ; case '0' : records [ games [ i ] . charAt ( 1 ) - '1' ] += 3 ; break ; } } Arrays . sort ( records ) ; points [ 0 ] [ records [ 0 ] ] ++ ; points [ 1 ] [ records [ 1 ] ] ++ ; points [ 2 ] [ records [ 2 ] ] ++ ; points [ 3 ] [ records [ 3 ] ] ++ ; } while ( nextResult ( ) ) ; System . out . println ( " First ▁ place : ▁ " + Arrays . toString ( points [ 3 ] ) ) ; System . out . println ( " Second ▁ place : ▁ " + Arrays . toString ( points [ 2 ] ) ) ; System . out . println ( " Third ▁ place : ▁ " + Arrays . toString ( points [ 1 ] ) ) ; System . out . println ( " Fourth ▁ place : ▁ " + Arrays . toString ( points [ 0 ] ) ) ; } }
import java . io . * ; public class Test { public static void main ( String [ ] args ) throws IOException { try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( " test . txt " ) ) ) { bw . write ( " abc " ) ; } } }
import java . io . * ; public class FloatArray { public static void writeDat ( String filename , double [ ] x , double [ ] y , int xprecision , int yprecision ) throws IOException { assert x . length == y . length ; PrintWriter out = new PrintWriter ( filename ) ; for ( int i = 0 ; i < x . length ; i ++ ) out . printf ( " % . " + xprecision + " g\t % . " + yprecision + " g \n " , x [ i ] , y [ i ] ) ; out . close ( ) ; } public static void main ( String [ ] args ) { double [ ] x = { 1 , 2 , 3 , 1e11 } ; double [ ] y = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i ++ ) y [ i ] = Math . sqrt ( x [ i ] ) ; try { writeDat ( " sqrt . dat " , x , y , 3 , 5 ) ; } catch ( IOException e ) { System . err . println ( " writeDat : ▁ exception : ▁ " + e ) ; } try { BufferedReader br = new BufferedReader ( new FileReader ( " sqrt . dat " ) ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) System . out . println ( line ) ; } catch ( IOException e ) { } } }
public class F5 { char [ ] z = { ' ▁ ' , ' ▁ ' , ' _ ' , ' / ' , } ; long [ ] [ ] f = { { 87381 , 87381 , 87381 , 87381 , 87381 , 87381 , 87381 , } , { 349525 , 375733 , 742837 , 742837 , 375733 , 349525 , 349525 , } , { 742741 , 768853 , 742837 , 742837 , 768853 , 349525 , 349525 , } , { 349525 , 375733 , 742741 , 742741 , 375733 , 349525 , 349525 , } , { 349621 , 375733 , 742837 , 742837 , 375733 , 349525 , 349525 , } , { 349525 , 375637 , 768949 , 742741 , 375733 , 349525 , 349525 , } , { 351157 , 374101 , 768949 , 374101 , 374101 , 349525 , 349525 , } , { 349525 , 375733 , 742837 , 742837 , 375733 , 349621 , 351157 , } , { 742741 , 768853 , 742837 , 742837 , 742837 , 349525 , 349525 , } , { 181 , 85 , 181 , 181 , 181 , 85 , 85 , } , { 1461 , 1365 , 1461 , 1461 , 1461 , 1461 , 2901 , } , { 742741 , 744277 , 767317 , 744277 , 742837 , 349525 , 349525 , } , { 181 , 181 , 181 , 181 , 181 , 85 , 85 , } , { 1431655765 , 3149249365L , 3042661813L , 3042661813L , 3042661813L , 1431655765 , 1431655765 , } , { 349525 , 768853 , 742837 , 742837 , 742837 , 349525 , 349525 , } , { 349525 , 375637 , 742837 , 742837 , 375637 , 349525 , 349525 , } , { 349525 , 768853 , 742837 , 742837 , 768853 , 742741 , 742741 , } , { 349525 , 375733 , 742837 , 742837 , 375733 , 349621 , 349621 , } , { 349525 , 744373 , 767317 , 742741 , 742741 , 349525 , 349525 , } , { 349525 , 375733 , 767317 , 351157 , 768853 , 349525 , 349525 , } , { 374101 , 768949 , 374101 , 374101 , 351157 , 349525 , 349525 , } , { 349525 , 742837 , 742837 , 742837 , 375733 , 349525 , 349525 , } , { 5592405 , 11883957 , 11883957 , 5987157 , 5616981 , 5592405 , 5592405 , } , { 366503875925L , 778827027893L , 778827027893L , 392374737749L , 368114513237L , 366503875925L , 366503875925L , } , { 349525 , 742837 , 375637 , 742837 , 742837 , 349525 , 349525 , } , { 349525 , 742837 , 742837 , 742837 , 375733 , 349621 , 375637 , } , { 349525 , 768949 , 351061 , 374101 , 768949 , 349525 , 349525 , } , { 375637 , 742837 , 768949 , 742837 , 742837 , 349525 , 349525 , } , { 768853 , 742837 , 768853 , 742837 , 768853 , 349525 , 349525 , } , { 375733 , 742741 , 742741 , 742741 , 375733 , 349525 , 349525 , } , { 192213 , 185709 , 185709 , 185709 , 192213 , 87381 , 87381 , } , { 1817525 , 1791317 , 1817429 , 1791317 , 1817525 , 1398101 , 1398101 , } , { 768949 , 742741 , 768853 , 742741 , 742741 , 349525 , 349525 , } , { 375733 , 742741 , 744373 , 742837 , 375733 , 349525 , 349525 , } , { 742837 , 742837 , 768949 , 742837 , 742837 , 349525 , 349525 , } , { 48053 , 23381 , 23381 , 23381 , 48053 , 21845 , 21845 , } , { 349621 , 349621 , 349621 , 742837 , 375637 , 349525 , 349525 , } , { 742837 , 744277 , 767317 , 744277 , 742837 , 349525 , 349525 , } , { 742741 , 742741 , 742741 , 742741 , 768949 , 349525 , 349525 , } , { 11883957 , 12278709 , 11908533 , 11883957 , 11883957 , 5592405 , 5592405 , } , { 11883957 , 12277173 , 11908533 , 11885493 , 11883957 , 5592405 , 5592405 , } , { 375637 , 742837 , 742837 , 742837 , 375637 , 349525 , 349525 , } , { 768853 , 742837 , 768853 , 742741 , 742741 , 349525 , 349525 , } , { 6010197 , 11885397 , 11909973 , 11885397 , 6010293 , 5592405 , 5592405 , } , { 768853 , 742837 , 768853 , 742837 , 742837 , 349525 , 349525 , } , { 375733 , 742741 , 375637 , 349621 , 768853 , 349525 , 349525 , } , { 12303285 , 5616981 , 5616981 , 5616981 , 5616981 , 5592405 , 5592405 , } , { 742837 , 742837 , 742837 , 742837 , 375637 , 349525 , 349525 , } , { 11883957 , 11883957 , 11883957 , 5987157 , 5616981 , 5592405 , 5592405 , } , { 3042268597L , 3042268597L , 3042661813L , 1532713813 , 1437971797 , 1431655765 , 1431655765 , } , { 11883957 , 5987157 , 5616981 , 5987157 , 11883957 , 5592405 , 5592405 , } , { 11883957 , 5987157 , 5616981 , 5616981 , 5616981 , 5592405 , 5592405 , } , { 12303285 , 5593941 , 5616981 , 5985621 , 12303285 , 5592405 , 5592405 , } , } ; public static void main ( String [ ] a ) { new F5 ( a . length > 0 ? a [ 0 ] : " Java " ) ; } private F5 ( String s ) { StringBuilder [ ] o = new StringBuilder [ 7 ] ; for ( int i = 0 ; i < 7 ; i ++ ) o [ i ] = new StringBuilder ( ) ; for ( int i = 0 , l = s . length ( ) ; i < l ; i ++ ) { int c = s . charAt ( i ) ; if ( 65 <= c && c <= 90 ) c -= 39 ; else if ( 97 <= c && c <= 122 ) c -= 97 ; else c = - 1 ; long [ ] d = f [ ++ c ] ; for ( int j = 0 ; j < 7 ; j ++ ) { StringBuilder b = new StringBuilder ( ) ; long v = d [ j ] ; while ( v > 0 ) { b . append ( z [ ( int ) ( v & 3 ) ] ) ; v >>= 2 ; } o [ j ] . append ( b . reverse ( ) . toString ( ) ) ; } } for ( int i = 0 ; i < 7 ; i ++ ) { for ( int j = 0 ; j < 7 - i ; j ++ ) System . out . print ( ' ▁ ' ) ; System . out . println ( o [ i ] ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . Locale ; import java . util . concurrent . TimeUnit ; import java . util . stream . Collectors ; public class WriteToWindowsEventLog { public static void main ( String [ ] args ) throws IOException , InterruptedException { String osName = System . getProperty ( " os . name " ) . toUpperCase ( Locale . ENGLISH ) ; if ( ! osName . startsWith ( " WINDOWS " ) ) { System . err . println ( " Not ▁ windows " ) ; return ; } Process process = Runtime . getRuntime ( ) . exec ( " EventCreate ▁ / t ▁ INFORMATION ▁ / id ▁ 123 ▁ / l ▁ APPLICATION ▁ / so ▁ Java ▁ / d ▁ \" Rosetta ▁ Code ▁ Example \" " ) ; process . waitFor ( 10 , TimeUnit . SECONDS ) ; int exitValue = process . exitValue ( ) ; System . out . printf ( " Process ▁ exited ▁ with ▁ value ▁ % d \n " , exitValue ) ; if ( exitValue != 0 ) { InputStream errorStream = process . getErrorStream ( ) ; String result = new BufferedReader ( new InputStreamReader ( errorStream ) ) . lines ( ) . collect ( Collectors . joining ( " \n " ) ) ; System . err . println ( result ) ; } } }
import static javax . xml . XMLConstants . W3C_XML_SCHEMA_NS_URI ; import java . net . MalformedURLException ; import java . net . URL ; import javax . xml . transform . stream . StreamSource ; import javax . xml . validation . SchemaFactory ; import javax . xml . validation . Validator ; import javax . xml . ws . Holder ; import org . xml . sax . ErrorHandler ; import org . xml . sax . SAXException ; import org . xml . sax . SAXParseException ; public class XmlValidation { public static void main ( String ... args ) throws MalformedURLException { URL schemaLocation = new URL ( " http : // venus . eas . asu . edu / WSRepository / xml / Courses . xsd " ) ; URL documentLocation = new URL ( " http : // venus . eas . asu . edu / WSRepository / xml / Courses . xml " ) ; if ( validate ( schemaLocation , documentLocation ) ) { System . out . println ( " document ▁ is ▁ valid " ) ; } else { System . out . println ( " document ▁ is ▁ invalid " ) ; } } public static boolean minimalValidate ( URL schemaLocation , URL documentLocation ) { SchemaFactory factory = SchemaFactory . newInstance ( W3C_XML_SCHEMA_NS_URI ) ; try { Validator validator = factory . newSchema ( schemaLocation ) . newValidator ( ) ; validator . validate ( new StreamSource ( documentLocation . toString ( ) ) ) ; return true ; } catch ( Exception e ) { return false ; } } public static boolean validate ( URL schemaLocation , URL documentLocation ) { SchemaFactory factory = SchemaFactory . newInstance ( W3C_XML_SCHEMA_NS_URI ) ; final Holder < Boolean > valid = new Holder < > ( true ) ; try { Validator validator = factory . newSchema ( schemaLocation ) . newValidator ( ) ; validator . setErrorHandler ( new ErrorHandler ( ) { @ Override public void warning ( SAXParseException exception ) { System . out . println ( " warning : ▁ " + exception . getMessage ( ) ) ; } @ Override public void error ( SAXParseException exception ) { System . out . println ( " error : ▁ " + exception . getMessage ( ) ) ; valid . value = false ; } @ Override public void fatalError ( SAXParseException exception ) throws SAXException { System . out . println ( " fatal ▁ error : ▁ " + exception . getMessage ( ) ) ; throw exception ; } } ) ; validator . validate ( new StreamSource ( documentLocation . toString ( ) ) ) ; return valid . value ; } catch ( SAXException e ) { return false ; } catch ( Exception e ) { System . err . println ( e ) ; return false ; } } }
import java . io . StringWriter ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import javax . xml . transform . OutputKeys ; import javax . xml . transform . Transformer ; import javax . xml . transform . TransformerConfigurationException ; import javax . xml . transform . TransformerException ; import javax . xml . transform . TransformerFactory ; import javax . xml . transform . TransformerFactoryConfigurationError ; import javax . xml . transform . dom . DOMSource ; import javax . xml . transform . stream . StreamResult ; import org . w3c . dom . DOMImplementation ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; public class RDOMSerialization { private Document domDoc ; public RDOMSerialization ( ) { return ; } protected void buildDOMDocument ( ) { DocumentBuilderFactory factory ; DocumentBuilder builder ; DOMImplementation impl ; Element elmt1 ; Element elmt2 ; try { factory = DocumentBuilderFactory . newInstance ( ) ; builder = factory . newDocumentBuilder ( ) ; impl = builder . getDOMImplementation ( ) ; domDoc = impl . createDocument ( null , null , null ) ; elmt1 = domDoc . createElement ( " root " ) ; elmt2 = domDoc . createElement ( " element " ) ; elmt2 . setTextContent ( " Some ▁ text ▁ here " ) ; domDoc . appendChild ( elmt1 ) ; elmt1 . appendChild ( elmt2 ) ; } catch ( ParserConfigurationException ex ) { ex . printStackTrace ( ) ; } return ; } protected void serializeXML ( ) { DOMSource domSrc ; Transformer txformer ; StringWriter sw ; StreamResult sr ; try { domSrc = new DOMSource ( domDoc ) ; txformer = TransformerFactory . newInstance ( ) . newTransformer ( ) ; txformer . setOutputProperty ( OutputKeys . OMIT_XML_DECLARATION , " no " ) ; txformer . setOutputProperty ( OutputKeys . METHOD , " xml " ) ; txformer . setOutputProperty ( OutputKeys . ENCODING , " UTF - 8" ) ; txformer . setOutputProperty ( OutputKeys . INDENT , " yes " ) ; txformer . setOutputProperty ( OutputKeys . STANDALONE , " yes " ) ; txformer . setOutputProperty ( " { http : // xml . apache . org / xslt } indent - amount " , "2" ) ; sw = new StringWriter ( ) ; sr = new StreamResult ( sw ) ; txformer . transform ( domSrc , sr ) ; System . out . println ( sw . toString ( ) ) ; } catch ( TransformerConfigurationException ex ) { ex . printStackTrace ( ) ; } catch ( TransformerFactoryConfigurationError ex ) { ex . printStackTrace ( ) ; } catch ( TransformerException ex ) { ex . printStackTrace ( ) ; } return ; } public static void serializationDriver ( String [ ] args ) { RDOMSerialization lcl = new RDOMSerialization ( ) ; lcl . buildDOMDocument ( ) ; lcl . serializeXML ( ) ; return ; } public static void main ( String [ ] args ) { serializationDriver ( args ) ; return ; } }
public static void main ( String [ ] args ) { System . out . printf ( " First ▁ 30 ▁ values ▁ in ▁ the ▁ yellowstone ▁ sequence : % n % s % n " , yellowstoneSequence ( 30 ) ) ; }
import java . util . List ; public class Zeckendorf implements Comparable < Zeckendorf > { private static List < String > dig = List . of ( "00" , "01" , "10" ) ; private static List < String > dig1 = List . of ( " " , "1" , "10" ) ; private String x ; private int dVal = 0 ; private int dLen = 0 ; public Zeckendorf ( ) { this ( "0" ) ; } public Zeckendorf ( String x ) { this . x = x ; int q = 1 ; int i = x . length ( ) - 1 ; dLen = i / 2 ; while ( i >= 0 ) { dVal += ( x . charAt ( i ) - '0' ) * q ; q *= 2 ; i -- ; } } private void a ( int n ) { int i = n ; while ( true ) { if ( dLen < i ) dLen = i ; int j = ( dVal >> ( i * 2 ) ) & 3 ; switch ( j ) { case 0 : case 1 : return ; case 2 : if ( ( ( dVal >> ( ( i + 1 ) * 2 ) ) & 1 ) != 1 ) return ; dVal += 1 << ( i * 2 + 1 ) ; return ; case 3 : int temp = 3 << ( i * 2 ) ; temp ^= - 1 ; dVal = dVal & temp ; b ( ( i + 1 ) * 2 ) ; break ; } i ++ ; } } private void b ( int pos ) { if ( pos == 0 ) { Zeckendorf thiz = this ; thiz . inc ( ) ; return ; } if ( ( ( dVal >> pos ) & 1 ) == 0 ) { dVal += 1 << pos ; a ( pos / 2 ) ; if ( pos > 1 ) a ( pos / 2 - 1 ) ; } else { int temp = 1 << pos ; temp ^= - 1 ; dVal = dVal & temp ; b ( pos + 1 ) ; b ( pos - ( pos > 1 ? 2 : 1 ) ) ; } } private void c ( int pos ) { if ( ( ( dVal >> pos ) & 1 ) == 1 ) { int temp = 1 << pos ; temp ^= - 1 ; dVal = dVal & temp ; return ; } c ( pos + 1 ) ; if ( pos > 0 ) { b ( pos - 1 ) ; } else { Zeckendorf thiz = this ; thiz . inc ( ) ; } } public Zeckendorf inc ( ) { dVal ++ ; a ( 0 ) ; return this ; } public void plusAssign ( Zeckendorf other ) { for ( int gn = 0 ; gn < ( other . dLen + 1 ) * 2 ; gn ++ ) { if ( ( ( other . dVal >> gn ) & 1 ) == 1 ) { b ( gn ) ; } } } public void minusAssign ( Zeckendorf other ) { for ( int gn = 0 ; gn < ( other . dLen + 1 ) * 2 ; gn ++ ) { if ( ( ( other . dVal >> gn ) & 1 ) == 1 ) { c ( gn ) ; } } while ( ( ( ( dVal >> dLen * 2 ) & 3 ) == 0 ) || ( dLen == 0 ) ) { dLen -- ; } } public void timesAssign ( Zeckendorf other ) { Zeckendorf na = other . copy ( ) ; Zeckendorf nb = other . copy ( ) ; Zeckendorf nt ; Zeckendorf nr = new Zeckendorf ( ) ; for ( int i = 0 ; i < ( dLen + 1 ) * 2 ; i ++ ) { if ( ( ( dVal >> i ) & 1 ) > 0 ) { nr . plusAssign ( nb ) ; } nt = nb . copy ( ) ; nb . plusAssign ( na ) ; na = nt . copy ( ) ; } dVal = nr . dVal ; dLen = nr . dLen ; } private Zeckendorf copy ( ) { Zeckendorf z = new Zeckendorf ( ) ; z . dVal = dVal ; z . dLen = dLen ; return z ; } @ Override public int compareTo ( Zeckendorf other ) { return ( ( Integer ) dVal ) . compareTo ( other . dVal ) ; } @ Override public String toString ( ) { if ( dVal == 0 ) { return "0" ; } int idx = ( dVal >> ( dLen * 2 ) ) & 3 ; StringBuilder stringBuilder = new StringBuilder ( dig1 . get ( idx ) ) ; for ( int i = dLen - 1 ; i >= 0 ; i -- ) { idx = ( dVal >> ( i * 2 ) ) & 3 ; stringBuilder . append ( dig . get ( idx ) ) ; } return stringBuilder . toString ( ) ; } public static void main ( String [ ] args ) { System . out . println ( " Addition : " ) ; Zeckendorf g = new Zeckendorf ( "10" ) ; g . plusAssign ( new Zeckendorf ( "10" ) ) ; System . out . println ( g ) ; g . plusAssign ( new Zeckendorf ( "10" ) ) ; System . out . println ( g ) ; g . plusAssign ( new Zeckendorf ( "1001" ) ) ; System . out . println ( g ) ; g . plusAssign ( new Zeckendorf ( "1000" ) ) ; System . out . println ( g ) ; g . plusAssign ( new Zeckendorf ( "10101" ) ) ; System . out . println ( g ) ; System . out . println ( " \n Subtraction : " ) ; g = new Zeckendorf ( "1000" ) ; g . minusAssign ( new Zeckendorf ( "101" ) ) ; System . out . println ( g ) ; g = new Zeckendorf ( "10101010" ) ; g . minusAssign ( new Zeckendorf ( "1010101" ) ) ; System . out . println ( g ) ; System . out . println ( " \n Multiplication : " ) ; g = new Zeckendorf ( "1001" ) ; g . timesAssign ( new Zeckendorf ( "101" ) ) ; System . out . println ( g ) ; g = new Zeckendorf ( "101010" ) ; g . plusAssign ( new Zeckendorf ( "101" ) ) ; System . out . println ( g ) ; } }
System . out . println ( Math . pow ( 0 , 0 ) ) ;
public class Baklava { public static void up ( ) { for ( int i = 0 ; i < 10 ; i ++ ) printRow ( i ) ; } public static void down ( ) { for ( int i = 10 ; i >= 0 ; i -- ) printRow ( i ) ; } public static void printRow ( int rowNum ) { for ( int j = 10 - rowNum ; j > 0 ; j -- ) System . out . print ( " ▁ " ) ; for ( int j = 0 ; j <= rowNum * 2 ; j ++ ) System . out . print ( " * " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { up ( ) ; down ( ) ; } }
public static void binarySearch ( ArrayList < Integer > arr , int first , int last , int key ) { int mid = ( first + last ) / 2 ; while ( first <= last ) { if ( arr . get ( mid ) < key ) { first = mid + 1 ; } else if ( arr . get ( mid ) == key ) { System . out . println ( " True " ) ; break ; } else { last = mid - 1 ; } mid = ( first + last ) / 2 ; } if ( first > last ) { System . out . println ( " False " ) ; } }
public static void main ( String [ ] args ) { try { ArrayList < Integer > listOfNumbers = new ArrayList < > ( ) ; String [ ] NumberArray = args [ 0 ] . split ( " , " ) ; for ( String Number : NumberArray ) { listOfNumbers . add ( Integer . parseInt ( Number . trim ( ) ) ) ; } if ( listOfNumbers . size ( ) >= 2 ) { StringBuilder output = new StringBuilder ( ) ; ArrayList < Integer > SortedList = sort ( listOfNumbers ) ; for ( Integer Number : SortedList ) { if ( SortedList . indexOf ( Number ) == 0 ) { output . append ( Number ) ; } else { output . append ( " , ▁ " ) . append ( Number ) ; } } System . out . println ( output ) ; } else { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } } catch ( Exception e ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } }
import java . util . * ; public class DuplicateCharacterCounter { public static void error ( ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ string " ) ; } public static void main ( String [ ] args ) { if ( args . length <= 0 ) { error ( ) ; } else if ( args [ 0 ] . length ( ) == 0 ) { error ( ) ; } else { String inputStr = args [ 0 ] ; Map < Character , Integer > map = new HashMap < > ( ) ; for ( Character c : inputStr . toCharArray ( ) ) { map . put ( c , map . getOrDefault ( c , 0 ) + 1 ) ; } boolean flag = false ; for ( Character c : inputStr . toCharArray ( ) ) { if ( map . get ( c ) > 1 ) { flag = true ; System . out . printf ( " % c : ▁ % d \n " , c , map . get ( c ) ) ; map . put ( c , 0 ) ; } } if ( flag == false ) { System . out . println ( " No ▁ duplicate ▁ characters " ) ; } } } }
public static void main ( String [ ] args ) { try { String nstr = args [ 0 ] . trim ( ) ; verifyNumber ( nstr ) ; String lastDigit = nstr . substring ( nstr . length ( ) - 1 ) ; int n = Integer . parseInt ( lastDigit ) ; String result = n % 2 == 0 ? " Even " : " Odd " ; System . out . println ( result ) ; } catch ( NumberFormatException | ArrayIndexOutOfBoundsException | StringIndexOutOfBoundsException e ) { ErrorAndExit ( ) ; } }
public static void main ( String [ ] args ) { try { long n = Long . parseLong ( args [ 0 ] ) ; if ( n > 59 ) { System . out . println ( String . format ( " % 1 $ s ! ▁ is ▁ out ▁ of ▁ the ▁ reasonable ▁ bounds ▁ for ▁ calculation . " , n ) ) ; System . exit ( 1 ) ; } else if ( n < 0 ) { System . out . println ( " Usage : ▁ please ▁ input ▁ a ▁ non - negative ▁ integer " ) ; System . exit ( 1 ) ; } long result = fact ( n ) ; System . out . println ( result ) ; } catch ( Exception e ) { System . out . println ( " Usage : ▁ please ▁ input ▁ a ▁ non - negative ▁ integer " ) ; System . exit ( 1 ) ; } }
public static void main ( String [ ] args ) { try { int n = Integer . parseInt ( args [ 0 ] ) ; int first = 0 ; int second = 1 ; int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { result = first + second ; first = second ; second = result ; System . out . println ( i + " : ▁ " + first ) ; } } catch ( Exception e ) { System . out . println ( " Usage : ▁ please ▁ input ▁ the ▁ count ▁ of ▁ fibonacci ▁ numbers ▁ to ▁ output " ) ; System . exit ( 1 ) ; } }
public static void readFile ( File file ) { try { BufferedReader buffer = new BufferedReader ( new FileReader ( file ) ) ; try { String nextLine = buffer . readLine ( ) ; while ( nextLine != null ) { System . out . println ( nextLine ) ; nextLine = buffer . readLine ( ) ; } buffer . close ( ) ; } catch ( IOException e ) { System . out . println ( " Error ▁ occurred ▁ while ▁ reading ▁ the ▁ file " ) ; } } catch ( FileNotFoundException e ) { System . out . println ( " Error ▁ occurred ▁ while ▁ opening ▁ the ▁ file ! " ) ; } }
public class FizzBuzz { public static void main ( String [ ] args ) { for ( int i = 1 ; i < 101 ; i ++ ) { String output = " " ; if ( i % 3 == 0 ) { output += " Fizz " ; } if ( i % 5 == 0 ) { output += " Buzz " ; } if ( output . isEmpty ( ) ) { output += i ; } System . out . println ( output ) ; } } }
class HelloWorld { public static void main ( String [ ] args ) { System . out . println ( " Hello , ▁ World ! " ) ; } }
public static void insertionSort ( ArrayList < Integer > numList ) { for ( int j = 1 ; j < numList . size ( ) ; j ++ ) { int k = j - 1 , val = numList . get ( j ) ; while ( k >= 0 && numList . get ( k ) > val ) { numList . set ( k + 1 , numList . get ( k ) ) ; k -- ; } numList . set ( k + 1 , val ) ; } for ( int i = 0 ; i < numList . size ( ) - 1 ; i ++ ) { System . out . print ( numList . get ( i ) + " , ▁ " ) ; } System . out . print ( numList . get ( numList . size ( ) - 1 ) ) ; }
public static void main ( String [ ] args ) { ArrayList < Integer > numList = new ArrayList < > ( ) ; if ( args . length < 1 ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } else if ( args [ 0 ] . length ( ) < 2 ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } else { String [ ] stringList = args [ 0 ] . split ( " , " ) ; if ( stringList . length < 2 ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } else { for ( int i = 0 ; i < stringList . length ; i ++ ) { numList . add ( Integer . parseInt ( stringList [ i ] . trim ( ) ) ) ; } if ( numList . size ( ) < 2 ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } else { insertionSort ( numList ) ; } } } }
public static void main ( String [ ] args ) { try { if ( args . length < 2 || " " . equals ( args [ 0 ] ) || " " . equals ( args [ 1 ] ) ) { throw new InvalidInputException ( ) ; } List < Integer > profits = converStringToList ( args [ 0 ] ) ; List < Integer > deadlines = converStringToList ( args [ 1 ] ) ; if ( profits . size ( ) != deadlines . size ( ) ) { throw new InvalidInputException ( ) ; } List < Job > jobs = createJobList ( deadlines , profits ) ; System . out . println ( getMaxProfit ( jobs , jobs . size ( ) ) ) ; } catch ( NumberFormatException | InvalidInputException e ) { System . err . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ profits ▁ and ▁ a ▁ list ▁ of ▁ deadlines " ) ; } }
private static Boolean linearSearch ( ArrayList < Integer > list , Integer keyToSearch ) { Boolean ans = false ; for ( Integer number : list ) { if ( number == keyToSearch ) { ans = true ; break ; } } return ans ; }
public static void main ( String args [ ] ) { if ( args . length < 2 || args [ 0 ] == " " || args [ 1 ] == " " ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ two ▁ lists ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; return ; } ArrayList < String > arr1 = split_strings ( args [ 0 ] ) ; ArrayList < String > arr2 = split_strings ( args [ 1 ] ) ; longest_common_subsequence ( arr1 , arr2 ) ; }
import java . util . * ; class LongestWord { public static void error ( ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ string " ) ; } public static void main ( String [ ] args ) { if ( args . length <= 0 ) { error ( ) ; } else if ( args [ 0 ] . length ( ) == 0 ) { error ( ) ; } else { String inputStr = args [ 0 ] ; String [ ] words = inputStr . split ( " \\ s + " ) ; int max = - 1 ; for ( String word : words ) { if ( word . length ( ) > max ) { max = word . length ( ) ; } } System . out . println ( max ) ; } } }
public static void mergeSort ( ArrayList < Integer > numList , int low , int high ) { if ( low < high ) { int mid = low + ( high - low ) / 2 ; mergeSort ( numList , low , mid ) ; mergeSort ( numList , mid + 1 , high ) ; mergeList ( numList , low , mid , high ) ; } }
public static void main ( String [ ] args ) { ArrayList < Integer > numList = new ArrayList < > ( ) ; if ( args . length < 1 ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } else if ( args [ 0 ] . length ( ) < 2 ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } else { String [ ] stringList = args [ 0 ] . split ( " , " ) ; if ( stringList . length < 2 ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } else { for ( int i = 0 ; i < stringList . length ; i ++ ) { numList . add ( Integer . parseInt ( stringList [ i ] . trim ( ) ) ) ; } if ( numList . size ( ) < 2 ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } else { mergeSort ( numList , 0 , numList . size ( ) - 1 ) ; String str = " " ; for ( int i = 0 ; i < numList . size ( ) - 1 ; i ++ ) { str += String . valueOf ( numList . get ( i ) ) ; str += " , ▁ " ; } str += String . valueOf ( numList . get ( numList . size ( ) - 1 ) ) ; System . out . println ( str ) ; } } } }
public static void main ( String [ ] args ) { Long num ; try { num = Long . parseLong ( args [ 0 ] ) ; } catch ( Exception ignored ) { num = null ; } if ( num == null || num < 0 ) { System . out . println ( " Usage : ▁ please ▁ input ▁ a ▁ non - negative ▁ integer " ) ; } else { System . out . println ( isPalindromic ( num ) ) ; } }
public static boolean isPrime ( int number ) { if ( ( number % 2 == 0 && number != 2 ) || number == 1 ) { return false ; } boolean foundFactor = false ; for ( int n = 3 ; n <= ( int ) Math . ceil ( Math . sqrt ( number ) ) ; ++ n ) { if ( ( number % n ) == 0 ) { foundFactor = true ; break ; } } return ! foundFactor ; }
public static void main ( String [ ] args ) { try { if ( args . length < 1 || args [ 0 ] . indexOf ( ' - ' ) != - 1 ) { throw new PrimeNumberException ( ) ; } if ( isPrime ( Integer . valueOf ( args [ 0 ] ) ) ) { System . out . println ( " Prime " ) ; } else { System . out . println ( " Composite " ) ; } } catch ( NumberFormatException | PrimeNumberException e ) { System . err . println ( " Usage : ▁ please ▁ input ▁ a ▁ non - negative ▁ integer " ) ; } }
public static void main ( String [ ] args ) { ArrayList < Integer > numList = new ArrayList < > ( ) ; if ( args . length < 1 ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } else if ( args [ 0 ] . length ( ) < 2 ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } else { String [ ] stringList = args [ 0 ] . split ( " , " ) ; if ( stringList . length < 2 ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } else { for ( int i = 0 ; i < stringList . length ; i ++ ) { numList . add ( Integer . parseInt ( stringList [ i ] . trim ( ) ) ) ; } if ( numList . size ( ) < 2 ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } else { sort ( numList , 0 , numList . size ( ) - 1 ) ; String str = " " ; for ( int i = 0 ; i < numList . size ( ) - 1 ; i ++ ) { str += String . valueOf ( numList . get ( i ) ) ; str += " , ▁ " ; } str += String . valueOf ( numList . get ( numList . size ( ) - 1 ) ) ; System . out . println ( str ) ; } } } }
public class Quine { public static void main ( String [ ] args ) { char quote = 34 ; String code = " public ▁ class ▁ Quine { public ▁ static ▁ void ▁ main ( String [ ] ▁ args ) { char ▁ quote = 34 ; String ▁ code = ; System . out . println ( code . substring ( 0,84 ) + quote + code + quote + code . substring ( 84 ) ) ; } } " ; System . out . println ( code . substring ( 0 , 84 ) + quote + code + quote + code . substring ( 84 ) ) ; } }
public class ReverseString { public static void main ( String args [ ] ) { if ( args . length > 0 ) { StringBuilder builder = new StringBuilder ( args [ 0 ] ) ; String reversed = builder . reverse ( ) . toString ( ) ; System . out . println ( reversed ) ; } } }
public static void main ( String [ ] args ) { if ( args . length < 1 ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ string ▁ to ▁ encrypt " ) ; } else { String code = args [ 0 ] ; String result = " " ; if ( code . length ( ) == 0 ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ string ▁ to ▁ encrypt " ) ; } else { String lower = " abcdefghijklmnopqrstuvwxyz " ; String upper = " ABCDEFGHIJKLMNOPQRSTUVWXYZ " ; for ( int a = 0 ; a < code . length ( ) ; a ++ ) { String ch = code . substring ( a , a + 1 ) ; int l = lower . indexOf ( ch ) ; int u = upper . indexOf ( ch ) ; if ( l != - 1 ) { result += lower . substring ( ( l + 13 ) % 26 , ( l + 14 ) % 26 != 0 ? ( l + 14 ) % 26 : l + 14 ) ; } else if ( u != - 1 ) { result += upper . substring ( ( u + 13 ) % 26 , ( u + 14 ) % 26 != 0 ? ( u + 14 ) % 26 : u + 14 ) ; } else { result += ch ; } } System . out . println ( result ) ; } } }
public static void main ( String [ ] args ) { try { ArrayList < Integer > listOfNumbers = new ArrayList < > ( ) ; String [ ] NumberArray = args [ 0 ] . split ( " , " ) ; for ( String Number : NumberArray ) { listOfNumbers . add ( Integer . parseInt ( Number . trim ( ) ) ) ; } if ( listOfNumbers . size ( ) >= 2 ) { StringBuilder output = new StringBuilder ( ) ; ArrayList < Integer > SortedList = sort ( listOfNumbers ) ; for ( Integer Number : SortedList ) { if ( SortedList . indexOf ( Number ) == 0 ) { output . append ( Number ) ; } else { output . append ( " , ▁ " ) . append ( Number ) ; } } System . out . println ( output ) ; } else { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } } catch ( Exception e ) { System . out . println ( " Usage : ▁ please ▁ provide ▁ a ▁ list ▁ of ▁ at ▁ least ▁ two ▁ integers ▁ to ▁ sort ▁ in ▁ the ▁ format ▁ \" 1 , ▁ 2 , ▁ 3 , ▁ 4 , ▁ 5 \" " ) ; } }
class Solution { public int [ ] twoSum ( int [ ] nums , int target ) { Map < Integer , Integer > numToIndex = new HashMap < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( numToIndex . containsKey ( target - nums [ i ] ) ) return new int [ ] { numToIndex . get ( target - nums [ i ] ) , i } ; numToIndex . put ( nums [ i ] , i ) ; } throw new IllegalArgumentException ( ) ; } }
class Solution { public boolean isMatch ( String s , String p ) { final int m = s . length ( ) ; final int n = p . length ( ) ; boolean [ ] [ ] dp = new boolean [ m + 1 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = true ; for ( int j = 0 ; j < p . length ( ) ; ++ j ) if ( p . charAt ( j ) == ' * ' && dp [ 0 ] [ j - 1 ] ) dp [ 0 ] [ j + 1 ] = true ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( p . charAt ( j ) == ' * ' ) { final boolean noRepeat = dp [ i + 1 ] [ j - 1 ] ; final boolean doRepeat = isMatch ( s , i , p , j - 1 ) && dp [ i ] [ j + 1 ] ; dp [ i + 1 ] [ j + 1 ] = noRepeat || doRepeat ; } else if ( isMatch ( s , i , p , j ) ) { dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] ; } return dp [ m ] [ n ] ; } private boolean isMatch ( final String s , int i , final String p , int j ) { return j >= 0 && p . charAt ( j ) == ' . ' || s . charAt ( i ) == p . charAt ( j ) ; } }
class Solution { public boolean isSameTree ( TreeNode p , TreeNode q ) { if ( p == null || q == null ) return p == q ; return p . val == q . val && isSameTree ( p . left , q . left ) && isSameTree ( p . right , q . right ) ; } }
class Solution { public int [ ] gridIllumination ( int N , int [ ] [ ] lamps , int [ ] [ ] queries ) { List < Integer > ans = new ArrayList < > ( ) ; Map < Integer , Integer > rows = new HashMap < > ( ) ; Map < Integer , Integer > cols = new HashMap < > ( ) ; Map < Integer , Integer > diag1 = new HashMap < > ( ) ; Map < Integer , Integer > diag2 = new HashMap < > ( ) ; Set < Long > lampsSet = new HashSet < > ( ) ; for ( int [ ] lamp : lamps ) { int i = lamp [ 0 ] ; int j = lamp [ 1 ] ; if ( lampsSet . add ( hash ( i , j ) ) ) { rows . put ( i , rows . getOrDefault ( i , 0 ) + 1 ) ; cols . put ( j , cols . getOrDefault ( j , 0 ) + 1 ) ; diag1 . put ( i + j , diag1 . getOrDefault ( i + j , 0 ) + 1 ) ; diag2 . put ( i - j , diag2 . getOrDefault ( i - j , 0 ) + 1 ) ; } } for ( int [ ] q : queries ) { int i = q [ 0 ] ; int j = q [ 1 ] ; if ( rows . getOrDefault ( i , 0 ) > 0 || cols . getOrDefault ( j , 0 ) > 0 || diag1 . getOrDefault ( i + j , 0 ) > 0 || diag2 . getOrDefault ( i - j , 0 ) > 0 ) { ans . add ( 1 ) ; for ( int y = Math . max ( 0 , i - 1 ) ; y < Math . min ( N , i + 2 ) ; ++ y ) for ( int x = Math . max ( 0 , j - 1 ) ; x < Math . min ( N , j + 2 ) ; ++ x ) if ( lampsSet . remove ( hash ( y , x ) ) ) { rows . put ( y , rows . getOrDefault ( y , 0 ) - 1 ) ; cols . put ( x , cols . getOrDefault ( x , 0 ) - 1 ) ; diag1 . put ( y + x , diag1 . getOrDefault ( y + x , 0 ) - 1 ) ; diag2 . put ( y - x , diag2 . getOrDefault ( y - x , 0 ) - 1 ) ; } } else ans . add ( 0 ) ; } return ans . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; } private long hash ( int i , int j ) { return ( ( long ) i << 32 ) + j ; } }
class Solution { public List < String > commonChars ( String [ ] A ) { List < String > ans = new ArrayList < > ( ) ; int [ ] commonCount = new int [ 26 ] ; Arrays . fill ( commonCount , Integer . MAX_VALUE ) ; for ( String a : A ) { int [ ] count = new int [ 26 ] ; for ( char c : a . toCharArray ( ) ) ++ count [ c - ' a ' ] ; for ( int i = 0 ; i < 26 ; ++ i ) commonCount [ i ] = Math . min ( commonCount [ i ] , count [ i ] ) ; } for ( char c = ' a ' ; c <= ' z ' ; ++ c ) for ( int i = 0 ; i < commonCount [ c - ' a ' ] ; ++ i ) ans . add ( String . valueOf ( c ) ) ; return ans ; } }
class Solution { public boolean isValid ( String s ) { Deque < Character > stack = new ArrayDeque < > ( ) ; for ( final char c : s . toCharArray ( ) ) if ( c == ' c ' ) { if ( stack . size ( ) < 2 ) return false ; if ( stack . peek ( ) != ' b ' ) return false ; stack . pop ( ) ; if ( stack . peek ( ) != ' a ' ) return false ; stack . pop ( ) ; } else { stack . push ( c ) ; } return stack . isEmpty ( ) ; } }
class Solution { public int clumsy ( int N ) { if ( N == 1 ) return 1 ; if ( N == 2 ) return 2 ; if ( N == 3 ) return 6 ; if ( N == 4 ) return 7 ; if ( N % 4 == 1 ) return N + 2 ; if ( N % 4 == 2 ) return N + 2 ; if ( N % 4 == 3 ) return N - 1 ; return N + 1 ; } }
class Solution { public TreeNode bstFromPreorder ( int [ ] preorder ) { TreeNode root = new TreeNode ( preorder [ 0 ] ) ; Deque < TreeNode > stack = new ArrayDeque < > ( Arrays . asList ( root ) ) ; for ( int i = 1 ; i < preorder . length ; ++ i ) { TreeNode parent = stack . peek ( ) ; TreeNode child = new TreeNode ( preorder [ i ] ) ; while ( ! stack . isEmpty ( ) && stack . peek ( ) . val < child . val ) parent = stack . pop ( ) ; if ( parent . val > child . val ) parent . left = child ; else parent . right = child ; stack . push ( child ) ; } return root ; } }
class Solution { public int bitwiseComplement ( int N ) { int mask = 1 ; while ( mask < N ) mask = ( mask << 1 ) + 1 ; return mask ^ N ; } }
class Solution { public boolean isSymmetric ( TreeNode root ) { return isSymmetric ( root , root ) ; } private boolean isSymmetric ( TreeNode p , TreeNode q ) { if ( p == null || q == null ) return p == q ; return p . val == q . val && isSymmetric ( p . left , q . right ) && isSymmetric ( p . right , q . left ) ; } }
class Solution { public int numPairsDivisibleBy60 ( int [ ] time ) { int ans = 0 ; int [ ] count = new int [ 60 ] ; for ( int t : time ) { t %= 60 ; ans += count [ ( 60 - t ) % 60 ] ; ++ count [ t ] ; } return ans ; } }
class Solution { public int shipWithinDays ( int [ ] weights , int days ) { int l = Arrays . stream ( weights ) . max ( ) . getAsInt ( ) ; int r = Arrays . stream ( weights ) . sum ( ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( shipDays ( weights , m ) <= days ) r = m ; else l = m + 1 ; } return l ; } private int shipDays ( int [ ] weights , int shipCapacity ) { int days = 1 ; int capacity = 0 ; for ( final int weight : weights ) { if ( capacity + weight > shipCapacity ) { ++ days ; capacity = weight ; } else capacity += weight ; } return days ; } }
class Solution { public int numDupDigitsAtMostN ( int n ) { return n - countSpecialNumbers ( n ) ; } private int countSpecialNumbers ( int n ) { final int digitSize = ( int ) Math . log10 ( n ) + 1 ; dp = new Integer [ digitSize + 1 ] [ 1 << 10 ] [ 2 ] ; return count ( String . valueOf ( n ) , digitSize , 0 , true ) - 1 ; } private Integer [ ] [ ] [ ] dp ; private int count ( final String s , int digitSize , int usedMask , boolean isTight ) { if ( digitSize == 0 ) return 1 ; if ( dp [ digitSize ] [ usedMask ] [ isTight ? 1 : 0 ] != null ) return dp [ digitSize ] [ usedMask ] [ isTight ? 1 : 0 ] ; int ans = 0 ; final int maxDigit = isTight ? s . charAt ( s . length ( ) - digitSize ) - '0' : 9 ; for ( int digit = 0 ; digit <= maxDigit ; ++ digit ) { if ( ( usedMask >> digit & 1 ) == 1 ) continue ; final boolean nextIsTight = isTight && ( digit == maxDigit ) ; if ( usedMask == 0 && digit == 0 ) ans += count ( s , digitSize - 1 , usedMask , nextIsTight ) ; else ans += count ( s , digitSize - 1 , usedMask | 1 << digit , nextIsTight ) ; } return dp [ digitSize ] [ usedMask ] [ isTight ? 1 : 0 ] = ans ; } }
class Solution { public boolean canThreePartsEqualSum ( int [ ] A ) { int sum = Arrays . stream ( A ) . sum ( ) ; int prefix = 0 ; int parts = 1 ; for ( int a : A ) { prefix += a ; if ( prefix == sum * parts / 3 ) ++ parts ; } return sum % 3 == 0 && parts >= 3 ; } }
class Solution { public int maxScoreSightseeingPair ( int [ ] A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = Math . max ( ans , a + bestPrev ) ; bestPrev = Math . max ( bestPrev , a ) - 1 ; } return ans ; } }
class Solution { public int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; Set < Integer > seen = new HashSet < > ( ) ; int N = 0 ; for ( int length = 1 ; length <= K ; ++ length ) { N = ( N * 10 + 1 ) % K ; if ( N == 0 ) return length ; if ( seen . contains ( N ) ) return - 1 ; seen . add ( N ) ; } return - 1 ; } }
class Solution { public boolean queryString ( String S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; -- i ) if ( ! S . contains ( Integer . toBinaryString ( i ) ) ) return false ; return true ; } }
class Solution { public String baseNeg2 ( int N ) { StringBuilder sb = new StringBuilder ( ) ; while ( N != 0 ) { sb . append ( N & 1 ) ; N = - ( N >> 1 ) ; } return sb . length ( ) > 0 ? sb . reverse ( ) . toString ( ) : "0" ; } }
class Solution { public List < Boolean > prefixesDivBy5 ( int [ ] A ) { List < Boolean > ans = new ArrayList < > ( ) ; int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . add ( num % 5 == 0 ) ; } return ans ; } }
class Solution { public int [ ] nextLargerNodes ( ListNode head ) { List < Integer > ans = new ArrayList < > ( ) ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( ; head != null ; head = head . next ) { while ( ! stack . isEmpty ( ) && head . val > ans . get ( stack . peek ( ) ) ) { int index = stack . pop ( ) ; ans . set ( index , head . val ) ; } stack . push ( ans . size ( ) ) ; ans . add ( head . val ) ; } while ( ! stack . isEmpty ( ) ) ans . set ( stack . pop ( ) , 0 ) ; return ans . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; } }
class Solution { public List < List < Integer > > levelOrder ( TreeNode root ) { if ( root == null ) return new ArrayList < > ( ) ; List < List < Integer > > ans = new ArrayList < > ( ) ; Queue < TreeNode > q = new ArrayDeque < > ( Arrays . asList ( root ) ) ; while ( ! q . isEmpty ( ) ) { List < Integer > currLevel = new ArrayList < > ( ) ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { TreeNode node = q . poll ( ) ; currLevel . add ( node . val ) ; if ( node . left != null ) q . offer ( node . left ) ; if ( node . right != null ) q . offer ( node . right ) ; } ans . add ( currLevel ) ; } return ans ; } }
class Solution { public List < Boolean > camelMatch ( String [ ] queries , String pattern ) { List < Boolean > ans = new ArrayList < > ( ) ; for ( final String q : queries ) ans . add ( isMatch ( q , pattern ) ) ; return ans ; } private boolean isMatch ( final String q , final String pattern ) { int j = 0 ; for ( int i = 0 ; i < q . length ( ) ; ++ i ) if ( j < pattern . length ( ) && q . charAt ( i ) == pattern . charAt ( j ) ) ++ j ; else if ( Character . isUpperCase ( q . charAt ( i ) ) ) return false ; return j == pattern . length ( ) ; } }
class Solution { public int videoStitching ( int [ ] [ ] clips , int time ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; Arrays . sort ( clips , ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; int i = 0 ; while ( farthest < time ) { while ( i < clips . length && clips [ i ] [ 0 ] <= end ) farthest = Math . max ( farthest , clips [ i ++ ] [ 1 ] ) ; if ( end == farthest ) return - 1 ; ++ ans ; end = farthest ; } return ans ; } }
class Solution { public boolean divisorGame ( int N ) { return N % 2 == 0 ; } }
class Solution { public int longestArithSeqLength ( int [ ] nums ) { final int n = nums . length ; int ans = 0 ; int [ ] [ ] dp = new int [ n ] [ 1001 ] ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { final int k = nums [ i ] - nums [ j ] + 500 ; dp [ i ] [ k ] = Math . max ( 2 , dp [ j ] [ k ] + 1 ) ; ans = Math . max ( ans , dp [ i ] [ k ] ) ; } return ans ; } }
class Solution { public int twoCitySchedCost ( int [ ] [ ] costs ) { final int n = costs . length / 2 ; int ans = 0 ; Arrays . sort ( costs , ( a , b ) -> ( b [ 1 ] - b [ 0 ] ) - ( a [ 1 ] - a [ 0 ] ) ) ; for ( int i = 0 ; i < n ; ++ i ) ans += costs [ i ] [ 0 ] + costs [ i + n ] [ 1 ] ; return ans ; } }
class Solution { public List < List < Integer > > zigzagLevelOrder ( TreeNode root ) { if ( root == null ) return new ArrayList < > ( ) ; List < List < Integer > > ans = new ArrayList < > ( ) ; Deque < TreeNode > q = new ArrayDeque < > ( Arrays . asList ( root ) ) ; boolean isLeftToRight = true ; while ( ! q . isEmpty ( ) ) { List < Integer > currLevel = new ArrayList < > ( ) ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) if ( isLeftToRight ) { TreeNode node = q . pollFirst ( ) ; currLevel . add ( node . val ) ; if ( node . left != null ) q . addLast ( node . left ) ; if ( node . right != null ) q . addLast ( node . right ) ; } else { TreeNode node = q . pollLast ( ) ; currLevel . add ( node . val ) ; if ( node . right != null ) q . addFirst ( node . right ) ; if ( node . left != null ) q . addFirst ( node . left ) ; } ans . add ( currLevel ) ; isLeftToRight = ! isLeftToRight ; } return ans ; } }
class Solution { public int maxSumTwoNoOverlap ( int [ ] nums , int firstLen , int secondLen ) { return Math . max ( helper ( nums , firstLen , secondLen ) , helper ( nums , secondLen , firstLen ) ) ; } private int helper ( int [ ] A , int l , int r ) { final int n = A . length ; int [ ] left = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += A [ i ] ; if ( i >= l ) sum -= A [ i - l ] ; if ( i >= l - 1 ) left [ i ] = i > 0 ? Math . max ( left [ i - 1 ] , sum ) : sum ; } int [ ] right = new int [ n ] ; sum = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { sum += A [ i ] ; if ( i <= n - r - 1 ) sum -= A [ i + r ] ; if ( i <= n - r ) right [ i ] = i < n - 1 ? Math . max ( right [ i + 1 ] , sum ) : sum ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) ans = Math . max ( ans , left [ i ] + right [ i + 1 ] ) ; return ans ; } }
class TrieNode { public TrieNode [ ] children = new TrieNode [ 26 ] ; public boolean isWord = false ; } class StreamChecker { public StreamChecker ( String [ ] words ) { for ( final String word : words ) insert ( word ) ; } public boolean query ( char letter ) { letters . append ( letter ) ; TrieNode node = root ; for ( int i = letters . length ( ) - 1 ; i >= 0 ; -- i ) { final int index = letters . charAt ( i ) - ' a ' ; if ( node . children [ index ] == null ) return false ; node = node . children [ index ] ; if ( node . isWord ) return true ; } return false ; } private TrieNode root = new TrieNode ( ) ; private StringBuilder letters = new StringBuilder ( ) ; private void insert ( final String word ) { TrieNode node = root ; for ( int i = word . length ( ) - 1 ; i >= 0 ; -- i ) { final int index = word . charAt ( i ) - ' a ' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode ( ) ; node = node . children [ index ] ; } node . isWord = true ; } }
class Solution { public int [ ] numMovesStones ( int a , int b , int c ) { int [ ] nums = new int [ ] { a , b , c } ; Arrays . sort ( nums ) ; if ( nums [ 2 ] - nums [ 0 ] == 2 ) return new int [ ] { 0 , 0 } ; return new int [ ] { Math . min ( nums [ 1 ] - nums [ 0 ] , nums [ 2 ] - nums [ 1 ] ) <= 2 ? 1 : 2 , nums [ 2 ] - nums [ 0 ] - 2 } ; } }
class Solution { public int [ ] [ ] colorBorder ( int [ ] [ ] grid , int r0 , int c0 , int color ) { dfs ( grid , r0 , c0 , grid [ r0 ] [ c0 ] ) ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) if ( grid [ i ] [ j ] < 0 ) grid [ i ] [ j ] = color ; return grid ; } private void dfs ( int [ ] [ ] grid , int i , int j , int startColor ) { if ( i < 0 || i == grid . length || j < 0 || j == grid [ 0 ] . length ) return ; if ( grid [ i ] [ j ] != startColor ) return ; grid [ i ] [ j ] = - startColor ; dfs ( grid , i + 1 , j , startColor ) ; dfs ( grid , i - 1 , j , startColor ) ; dfs ( grid , i , j + 1 , startColor ) ; dfs ( grid , i , j - 1 , startColor ) ; if ( i == 0 || i == grid . length - 1 || j == 0 || j == grid [ 0 ] . length - 1 ) return ; if ( Math . abs ( grid [ i + 1 ] [ j ] ) == startColor && Math . abs ( grid [ i - 1 ] [ j ] ) == startColor && Math . abs ( grid [ i ] [ j + 1 ] ) == startColor && Math . abs ( grid [ i ] [ j - 1 ] ) == startColor ) grid [ i ] [ j ] = startColor ; } }
class Solution { public int maxUncrossedLines ( int [ ] A , int [ ] B ) { final int m = A . length ; final int n = B . length ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ] [ j ] = A [ i - 1 ] == B [ j - 1 ] ? dp [ i - 1 ] [ j - 1 ] + 1 : Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; return dp [ m ] [ n ] ; } }
class Solution { public boolean isEscapePossible ( int [ ] [ ] blocked , int [ ] source , int [ ] target ) { Set < Long > blockedSet = new HashSet < > ( ) ; for ( int [ ] b : blocked ) blockedSet . add ( hash ( b [ 0 ] , b [ 1 ] ) ) ; return dfs ( blockedSet , source [ 0 ] , source [ 1 ] , hash ( target [ 0 ] , target [ 1 ] ) , new HashSet < > ( ) ) && dfs ( blockedSet , target [ 0 ] , target [ 1 ] , hash ( source [ 0 ] , source [ 1 ] ) , new HashSet < > ( ) ) ; } private boolean dfs ( Set < Long > blockedSet , int i , int j , long target , Set < Long > visited ) { if ( i < 0 || i >= 1e6 || j < 0 || j >= 1e6 || blockedSet . contains ( hash ( i , j ) ) || visited . contains ( hash ( i , j ) ) ) return false ; visited . add ( hash ( i , j ) ) ; if ( visited . size ( ) > ( 1 + 199 ) * 199 / 2 || hash ( i , j ) == target ) return true ; return dfs ( blockedSet , i + 1 , j , target , visited ) || dfs ( blockedSet , i - 1 , j , target , visited ) || dfs ( blockedSet , i , j + 1 , target , visited ) || dfs ( blockedSet , i , j - 1 , target , visited ) ; } private long hash ( int i , int j ) { return ( ( long ) i << 16 ) + j ; } }
class Solution { public boolean isBoomerang ( int [ ] [ ] points ) { return ( points [ 1 ] [ 0 ] - points [ 0 ] [ 0 ] ) * ( points [ 2 ] [ 1 ] - points [ 1 ] [ 1 ] ) != ( points [ 1 ] [ 1 ] - points [ 0 ] [ 1 ] ) * ( points [ 2 ] [ 0 ] - points [ 1 ] [ 0 ] ) ; } }
class Solution { public int maxDepth ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + Math . max ( maxDepth ( root . left ) , maxDepth ( root . right ) ) ; } }
class Solution { public int [ ] numMovesStonesII ( int [ ] stones ) { final int n = stones . length ; int minMoves = n ; Arrays . sort ( stones ) ; for ( int l = 0 , r = 0 ; r < n ; ++ r ) { while ( stones [ r ] - stones [ l ] + 1 > n ) ++ l ; int alreadyStored = r - l + 1 ; if ( alreadyStored == n - 1 && stones [ r ] - stones [ l ] + 1 == n - 1 ) minMoves = Math . min ( minMoves , 2 ) ; else minMoves = Math . min ( minMoves , n - alreadyStored ) ; } return new int [ ] { minMoves , Math . max ( stones [ n - 1 ] - stones [ 1 ] - n + 2 , stones [ n - 2 ] - stones [ 0 ] - n + 2 ) } ; } }
class Solution { public boolean isRobotBounded ( String instructions ) { int x = 0 ; int y = 0 ; int d = 0 ; int [ ] [ ] directions = new int [ ] [ ] { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } } ; for ( char instruction : instructions . toCharArray ( ) ) { if ( instruction == ' G ' ) { x += directions [ d ] [ 0 ] ; y += directions [ d ] [ 1 ] ; } else if ( instruction == ' L ' ) d = ( d + 3 ) % 4 ; else d = ( d + 1 ) % 4 ; } return x == 0 && y == 0 || d > 0 ; } }
class Solution { public int [ ] gardenNoAdj ( int n , int [ ] [ ] paths ) { int [ ] ans = new int [ n ] ; List < Integer > [ ] graph = new List [ n ] ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] p : paths ) { final int u = p [ 0 ] - 1 ; final int v = p [ 1 ] - 1 ; graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } for ( int i = 0 ; i < n ; ++ i ) { boolean [ ] used = new boolean [ 5 ] ; for ( final int v : graph [ i ] ) used [ ans [ v ] ] = true ; for ( int type = 1 ; type < 5 ; ++ type ) if ( ! used [ type ] ) { ans [ i ] = type ; break ; } } return ans ; } }
class Solution { public String longestDupSubstring ( String s ) { final int kMod = 1_000_000_007 ; final int n = s . length ( ) ; int [ ] pows = new int [ n ] ; int bestStart = - 1 ; int l = 1 ; int r = n ; pows [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) pows [ i ] = ( int ) ( ( pows [ i - 1 ] * 26L ) % ( long ) kMod ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; final int start = getStart ( s , m , pows , kMod ) ; if ( start == - 1 ) { r = m ; } else { bestStart = start ; l = m + 1 ; } } if ( bestStart == - 1 ) return " " ; if ( getStart ( s , l , pows , kMod ) == - 1 ) return s . substring ( bestStart , bestStart + l - 1 ) ; return s . substring ( bestStart , bestStart + l ) ; } private int getStart ( final String s , int k , int [ ] pows , int kMod ) { Map < Long , List < Integer > > hashedToStarts = new HashMap < > ( ) ; long h = 0 ; for ( int i = 0 ; i < k ; ++ i ) h = ( ( h * 26 ) % kMod + val ( s . charAt ( i ) ) ) % kMod ; hashedToStarts . put ( h , new ArrayList < > ( ) ) ; hashedToStarts . get ( h ) . add ( 0 ) ; for ( int i = k ; i < s . length ( ) ; ++ i ) { final int startIndex = i - k + 1 ; h = ( ( h - ( long ) ( pows [ k - 1 ] ) * val ( s . charAt ( i - k ) ) ) % kMod + kMod ) % kMod ; h = ( h * 26 + val ( s . charAt ( i ) ) ) % kMod ; if ( hashedToStarts . containsKey ( h ) ) { final String currSub = s . substring ( startIndex , startIndex + k ) ; for ( final int start : hashedToStarts . get ( h ) ) if ( s . substring ( start , start + k ) . equals ( currSub ) ) return startIndex ; } hashedToStarts . put ( h , new ArrayList < > ( ) ) ; hashedToStarts . get ( h ) . add ( startIndex ) ; } return - 1 ; } private int val ( char c ) { return c - ' a ' ; } }
class Solution { public int longestStrChain ( String [ ] words ) { Set < String > wordsSet = new HashSet < > ( Arrays . asList ( words ) ) ; int ans = 0 ; for ( final String word : words ) ans = Math . max ( ans , longestStrChain ( word , wordsSet ) ) ; return ans ; } private Map < String , Integer > dp = new HashMap < > ( ) ; private int longestStrChain ( final String s , Set < String > wordsSet ) { if ( dp . containsKey ( s ) ) return dp . get ( s ) ; int ans = 1 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { final String pred = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; if ( wordsSet . contains ( pred ) ) ans = Math . max ( ans , longestStrChain ( pred , wordsSet ) + 1 ) ; } dp . put ( s , ans ) ; return ans ; } }
class Solution { public int lastStoneWeightII ( int [ ] stones ) { final int sum = Arrays . stream ( stones ) . sum ( ) ; boolean [ ] dp = new boolean [ sum + 1 ] ; dp [ 0 ] = true ; int s = 0 ; for ( int stone : stones ) for ( int w = sum / 2 ; w > 0 ; -- w ) { if ( w >= stone ) dp [ w ] = dp [ w ] || dp [ w - stone ] ; if ( dp [ w ] ) s = Math . max ( s , w ) ; } return sum - 2 * s ; } }
class Solution { public TreeNode buildTree ( int [ ] preorder , int [ ] inorder ) { Map < Integer , Integer > inToIndex = new HashMap < > ( ) ; for ( int i = 0 ; i < inorder . length ; ++ i ) inToIndex . put ( inorder [ i ] , i ) ; return build ( preorder , 0 , preorder . length - 1 , inorder , 0 , inorder . length - 1 , inToIndex ) ; } private TreeNode build ( int [ ] preorder , int preStart , int preEnd , int [ ] inorder , int inStart , int inEnd , Map < Integer , Integer > inToIndex ) { if ( preStart > preEnd ) return null ; final int rootVal = preorder [ preStart ] ; final int rootInIndex = inToIndex . get ( rootVal ) ; final int leftSize = rootInIndex - inStart ; TreeNode root = new TreeNode ( rootVal ) ; root . left = build ( preorder , preStart + 1 , preStart + leftSize , inorder , inStart , rootInIndex - 1 , inToIndex ) ; root . right = build ( preorder , preStart + leftSize + 1 , preEnd , inorder , rootInIndex + 1 , inEnd , inToIndex ) ; return root ; } }
class Solution { public int heightChecker ( int [ ] heights ) { int ans = 0 ; int currentHeight = 1 ; int [ ] count = new int [ 101 ] ; for ( int height : heights ) ++ count [ height ] ; for ( int height : heights ) { while ( count [ currentHeight ] == 0 ) ++ currentHeight ; if ( height != currentHeight ) ++ ans ; -- count [ currentHeight ] ; } return ans ; } }
class Solution { public int maxSatisfied ( int [ ] customers , int [ ] grumpy , int X ) { int satisfied = 0 ; int madeSatisfied = 0 ; int windowSatisfied = 0 ; for ( int i = 0 ; i < customers . length ; ++ i ) { if ( grumpy [ i ] == 0 ) satisfied += customers [ i ] ; else windowSatisfied += customers [ i ] ; if ( i >= X && grumpy [ i - X ] == 1 ) windowSatisfied -= customers [ i - X ] ; madeSatisfied = Math . max ( madeSatisfied , windowSatisfied ) ; } return satisfied + madeSatisfied ; } }
class Solution { public int [ ] prevPermOpt1 ( int [ ] A ) { final int n = A . length ; int l = n - 2 ; int r = n - 1 ; while ( l >= 0 && A [ l ] <= A [ l + 1 ] ) l -- ; if ( l < 0 ) return A ; while ( A [ r ] >= A [ l ] || A [ r ] == A [ r - 1 ] ) r -- ; swap ( A , l , r ) ; return A ; } private void swap ( int [ ] A , int l , int r ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } }
class Solution { public int [ ] rearrangeBarcodes ( int [ ] barcodes ) { int [ ] ans = new int [ barcodes . length ] ; int [ ] count = new int [ 10001 ] ; int maxCount = 0 ; int maxNum = 0 ; for ( final int b : barcodes ) ++ count [ b ] ; for ( int i = 1 ; i < 10001 ; ++ i ) if ( count [ i ] > maxCount ) { maxCount = count [ i ] ; maxNum = i ; } fillAns ( ans , count , maxNum , barcodes . length ) ; for ( int num = 1 ; num < 10001 ; ++ num ) fillAns ( ans , count , num , barcodes . length ) ; return ans ; } private int i = 0 ; private void fillAns ( int [ ] ans , int [ ] count , int num , int n ) { while ( count [ num ] -- > 0 ) { ans [ i ] = num ; i = i + 2 < n ? i + 2 : 1 ; } } }
class Solution { public int [ ] assignBikes ( int [ ] [ ] workers , int [ ] [ ] bikes ) { final int n = workers . length ; final int m = bikes . length ; int [ ] ans = new int [ n ] ; boolean [ ] usedBikes = new boolean [ m ] ; List < Pair < Integer , Integer > > [ ] buckets = new List [ 2001 ] ; for ( int i = 0 ; i < 2001 ; ++ i ) buckets [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) buckets [ dist ( workers [ i ] , bikes [ j ] ) ] . add ( new Pair < > ( i , j ) ) ; Arrays . fill ( ans , - 1 ) ; for ( int k = 0 ; k < 2001 ; ++ k ) for ( Pair < Integer , Integer > pair : buckets [ k ] ) { final int i = pair . getKey ( ) ; final int j = pair . getValue ( ) ; if ( ans [ i ] == - 1 && ! usedBikes [ j ] ) { ans [ i ] = j ; usedBikes [ j ] = true ; } } return ans ; } private int dist ( int [ ] p1 , int [ ] p2 ) { return Math . abs ( p1 [ 0 ] - p2 [ 0 ] ) + Math . abs ( p1 [ 1 ] - p2 [ 1 ] ) ; } }
class Solution { public String minimizeError ( String [ ] prices , int target ) { List < double [ ] > A = new ArrayList < > ( ) ; int sumFloored = 0 ; int sumCeiled = 0 ; for ( final String p : prices ) { final double price = Double . parseDouble ( p ) ; final int floored = ( int ) Math . floor ( price ) ; final int ceiled = ( int ) Math . ceil ( price ) ; sumFloored += floored ; sumCeiled += ceiled ; final double costFloor = price - ( double ) floored ; final double costCeil = ( double ) ceiled - price ; A . add ( new double [ ] { costCeil - costFloor , costCeil , costFloor } ) ; } if ( sumFloored > target || sumCeiled < target ) return " - 1" ; Collections . sort ( A , new Comparator < double [ ] > ( ) { @ Override public int compare ( double [ ] a , double [ ] b ) { return Double . compare ( a [ 0 ] , b [ 0 ] ) ; } } ) ; double sumError = 0.0 ; final int nCeiled = target - sumFloored ; for ( int i = 0 ; i < nCeiled ; ++ i ) sumError += A . get ( i ) [ 1 ] ; for ( int i = nCeiled ; i < A . size ( ) ; ++ i ) sumError += A . get ( i ) [ 2 ] ; return String . format ( " % .3f " , sumError ) ; } }
class Solution { public TreeNode buildTree ( int [ ] inorder , int [ ] postorder ) { Map < Integer , Integer > inToIndex = new HashMap < > ( ) ; for ( int i = 0 ; i < inorder . length ; ++ i ) inToIndex . put ( inorder [ i ] , i ) ; return build ( inorder , 0 , inorder . length - 1 , postorder , 0 , postorder . length - 1 , inToIndex ) ; } TreeNode build ( int [ ] inorder , int inStart , int inEnd , int [ ] postorder , int postStart , int postEnd , Map < Integer , Integer > inToIndex ) { if ( inStart > inEnd ) return null ; final int rootVal = postorder [ postEnd ] ; final int rootInIndex = inToIndex . get ( rootVal ) ; final int leftSize = rootInIndex - inStart ; TreeNode root = new TreeNode ( rootVal ) ; root . left = build ( inorder , inStart , rootInIndex - 1 , postorder , postStart , postStart + leftSize - 1 , inToIndex ) ; root . right = build ( inorder , rootInIndex + 1 , inEnd , postorder , postStart + leftSize , postEnd - 1 , inToIndex ) ; return root ; } }
class Solution { public int validSubarrays ( int [ ] nums ) { int ans = 0 ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( final int num : nums ) { while ( ! stack . isEmpty ( ) && stack . peek ( ) > num ) stack . pop ( ) ; stack . push ( num ) ; ans += stack . size ( ) ; } return ans ; } }
class Solution { public int assignBikes ( int [ ] [ ] workers , int [ ] [ ] bikes ) { dp = new int [ 1 << bikes . length ] ; return assignBikes ( workers , bikes , 0 , 0 ) ; } private int [ ] dp ; private int assignBikes ( int [ ] [ ] workers , int [ ] [ ] bikes , int s , int bikeUsed ) { if ( s == workers . length ) return 0 ; if ( dp [ bikeUsed ] > 0 ) return dp [ bikeUsed ] ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < bikes . length ; ++ i ) { if ( ( bikeUsed >> i & 1 ) == 1 ) continue ; ans = Math . min ( ans , dist ( workers [ s ] , bikes [ i ] ) + assignBikes ( workers , bikes , s + 1 , bikeUsed | 1 << i ) ) ; } return dp [ bikeUsed ] = ans ; } private int dist ( int [ ] p1 , int [ ] p2 ) { return Math . abs ( p1 [ 0 ] - p2 [ 0 ] ) + Math . abs ( p1 [ 1 ] - p2 [ 1 ] ) ; } }
class Solution { public List < List < Integer > > levelOrderBottom ( TreeNode root ) { if ( root == null ) return new ArrayList < > ( ) ; List < List < Integer > > ans = new ArrayList < > ( ) ; Queue < TreeNode > q = new ArrayDeque < > ( Arrays . asList ( root ) ) ; while ( ! q . isEmpty ( ) ) { List < Integer > currLevel = new ArrayList < > ( ) ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { TreeNode node = q . poll ( ) ; currLevel . add ( node . val ) ; if ( node . left != null ) q . offer ( node . left ) ; if ( node . right != null ) q . offer ( node . right ) ; } ans . add ( currLevel ) ; } Collections . reverse ( ans ) ; return ans ; } }
class Solution { public String gcdOfStrings ( String str1 , String str2 ) { if ( str1 . length ( ) < str2 . length ( ) ) return gcdOfStrings ( str2 , str1 ) ; if ( ! str1 . startsWith ( str2 ) ) return " " ; if ( str2 . isEmpty ( ) ) return str1 ; return gcdOfStrings ( str2 , mod ( str1 , str2 ) ) ; } private String mod ( String s1 , final String s2 ) { while ( s1 . startsWith ( s2 ) ) s1 = s1 . substring ( s2 . length ( ) ) ; return s1 ; } }
class Solution { public int maxEqualRowsAfterFlips ( int [ ] [ ] matrix ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int ans = 0 ; int [ ] flip = new int [ n ] ; Set < Integer > seen = new HashSet < > ( ) ; for ( int i = 0 ; i < m ; ++ i ) { if ( seen . contains ( i ) ) continue ; int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) flip [ j ] = 1 ^ matrix [ i ] [ j ] ; for ( int k = 0 ; k < m ; ++ k ) if ( Arrays . equals ( matrix [ k ] , matrix [ i ] ) || Arrays . equals ( matrix [ k ] , flip ) ) { seen . add ( k ) ; ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; } }
class Solution { public int [ ] addNegabinary ( int [ ] arr1 , int [ ] arr2 ) { Deque < Integer > ans = new ArrayDeque < > ( ) ; int carry = 0 ; int i = arr1 . length - 1 ; int j = arr2 . length - 1 ; while ( carry != 0 || i >= 0 || j >= 0 ) { if ( i >= 0 ) carry += arr1 [ i -- ] ; if ( j >= 0 ) carry += arr2 [ j -- ] ; ans . addFirst ( carry & 1 ) ; carry = - ( carry >> 1 ) ; } while ( ans . size ( ) > 1 && ans . getFirst ( ) == 0 ) ans . pollFirst ( ) ; return ans . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; } }
class Solution { public int numSubmatrixSumTarget ( int [ ] [ ] matrix , int target ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int ans = 0 ; for ( int [ ] row : matrix ) for ( int i = 1 ; i < n ; ++ i ) row [ i ] += row [ i - 1 ] ; for ( int baseCol = 0 ; baseCol < n ; ++ baseCol ) for ( int j = baseCol ; j < n ; ++ j ) { Map < Integer , Integer > prefixCount = new HashMap < > ( ) ; prefixCount . put ( 0 , 1 ) ; int sum = 0 ; for ( int i = 0 ; i < m ; ++ i ) { if ( baseCol > 0 ) sum -= matrix [ i ] [ baseCol - 1 ] ; sum += matrix [ i ] [ j ] ; ans += prefixCount . getOrDefault ( sum - target , 0 ) ; prefixCount . put ( sum , prefixCount . getOrDefault ( sum , 0 ) + 1 ) ; } } return ans ; } }
class Solution { public String [ ] findOcurrences ( String text , String first , String second ) { List < String > ans = new ArrayList < > ( ) ; String [ ] words = text . split ( " ▁ " ) ; for ( int i = 0 ; i + 2 < words . length ; ++ i ) if ( first . equals ( words [ i ] ) && second . equals ( words [ i + 1 ] ) ) ans . add ( words [ i + 2 ] ) ; return ans . toArray ( new String [ 0 ] ) ; } }
class Solution { public int numTilePossibilities ( String tiles ) { int [ ] count = new int [ 26 ] ; for ( final char t : tiles . toCharArray ( ) ) ++ count [ t - ' A ' ] ; return dfs ( count ) ; } private int dfs ( int [ ] count ) { int possibleSequences = 0 ; for ( int i = 0 ; i < 26 ; ++ i ) { if ( count [ i ] == 0 ) continue ; -- count [ i ] ; possibleSequences += 1 + dfs ( count ) ; ++ count [ i ] ; } return possibleSequences ; } }
class Solution { public TreeNode sortedArrayToBST ( int [ ] nums ) { return build ( nums , 0 , nums . length - 1 ) ; } private TreeNode build ( int [ ] nums , int l , int r ) { if ( l > r ) return null ; final int m = ( l + r ) / 2 ; return new TreeNode ( nums [ m ] , build ( nums , l , m - 1 ) , build ( nums , m + 1 , r ) ) ; } }
class Solution { public String smallestSubsequence ( String text ) { StringBuilder sb = new StringBuilder ( ) ; int [ ] count = new int [ 128 ] ; boolean [ ] used = new boolean [ 128 ] ; for ( final char c : text . toCharArray ( ) ) ++ count [ c ] ; for ( final char c : text . toCharArray ( ) ) { -- count [ c ] ; if ( used [ c ] ) continue ; while ( sb . length ( ) > 0 && last ( sb ) > c && count [ last ( sb ) ] > 0 ) { used [ last ( sb ) ] = false ; sb . setLength ( sb . length ( ) - 1 ) ; } used [ c ] = true ; sb . append ( c ) ; } return sb . toString ( ) ; } private char last ( StringBuilder sb ) { return sb . charAt ( sb . length ( ) - 1 ) ; } }
class Solution { public String [ ] expand ( String s ) { List < String > ans = new ArrayList < > ( ) ; dfs ( s , 0 , new StringBuilder ( ) , ans ) ; Collections . sort ( ans ) ; return ans . toArray ( new String [ 0 ] ) ; } private void dfs ( final String s , int i , StringBuilder sb , List < String > ans ) { if ( i == s . length ( ) ) { ans . add ( sb . toString ( ) ) ; return ; } if ( s . charAt ( i ) == ' { ' ) { final int nextRightBraceIndex = s . indexOf ( " } " , i ) ; for ( final String c : s . substring ( i + 1 , nextRightBraceIndex ) . split ( " , " ) ) { sb . append ( c ) ; dfs ( s , nextRightBraceIndex + 1 , sb , ans ) ; sb . deleteCharAt ( sb . length ( ) - 1 ) ; } } else { sb . append ( s . charAt ( i ) ) ; dfs ( s , i + 1 , sb , ans ) ; sb . deleteCharAt ( sb . length ( ) - 1 ) ; } } }
class Solution { public int confusingNumberII ( int n ) { return dfs ( n , 0 , 0 , 1 ) ; } private int [ ] [ ] digitToRotated = { { 0 , 0 } , { 1 , 1 } , { 6 , 9 } , { 8 , 8 } , { 9 , 6 } } ; int dfs ( int n , long num , long rotatedNum , long unit ) { int ans = num == rotatedNum ? 0 : 1 ; for ( int [ ] pair : digitToRotated ) { final int digit = pair [ 0 ] ; final int rotated = pair [ 1 ] ; if ( digit == 0 && num == 0 ) continue ; final long nextNum = num * 10 + digit ; if ( nextNum > n ) break ; ans += dfs ( n , nextNum , rotated * unit + rotatedNum , unit * 10 ) ; } return ans ; } }
class Solution { public void duplicateZeros ( int [ ] arr ) { int zeros = 0 ; for ( int a : arr ) if ( a == 0 ) ++ zeros ; for ( int i = arr . length - 1 , j = arr . length + zeros - 1 ; i < j ; -- i , -- j ) { if ( j < arr . length ) arr [ j ] = arr [ i ] ; if ( arr [ i ] == 0 ) if ( -- j < arr . length ) arr [ j ] = arr [ i ] ; } } }
class Solution { public TreeNode sortedListToBST ( ListNode head ) { if ( head == null ) return null ; if ( head . next == null ) return new TreeNode ( head . val ) ; ListNode mid = findMid ( head ) ; TreeNode root = new TreeNode ( mid . val ) ; root . left = sortedListToBST ( head ) ; root . right = sortedListToBST ( mid . next ) ; return root ; } private ListNode findMid ( ListNode head ) { ListNode prev = null ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } }
class Solution { public double [ ] sampleStats ( int [ ] count ) { final int n = Arrays . stream ( count ) . sum ( ) ; return new double [ ] { getMinimum ( count ) , getMaximum ( count ) , getMean ( count , n ) , ( getLeftMedian ( count , n ) + getRightMedian ( count , n ) ) / 2.0 , getMode ( count ) , } ; } private double getMinimum ( int [ ] count ) { for ( int i = 0 ; i < count . length ; ++ i ) if ( count [ i ] > 0 ) return i ; return - 1 ; } private double getMaximum ( int [ ] count ) { for ( int i = count . length - 1 ; i >= 0 ; -- i ) if ( count [ i ] > 0 ) return i ; return - 1 ; } private double getMean ( int [ ] count , double n ) { double mean = 0 ; for ( int i = 0 ; i < count . length ; ++ i ) mean += ( ( long ) i * ( long ) count [ i ] ) / n ; return mean ; } private double getLeftMedian ( int [ ] count , double n ) { int numCount = 0 ; for ( int i = 0 ; i < count . length ; ++ i ) { numCount += count [ i ] ; if ( numCount >= n / 2 ) return i ; } return - 1 ; } private double getRightMedian ( int [ ] count , double n ) { int numCount = 0 ; for ( int i = count . length - 1 ; i >= 0 ; -- i ) { numCount += count [ i ] ; if ( numCount >= n / 2 ) return i ; } return - 1 ; } private double getMode ( int [ ] count ) { int mode = - 1 ; int maxCount = 0 ; for ( int i = 0 ; i < count . length ; ++ i ) if ( count [ i ] > maxCount ) { maxCount = count [ i ] ; mode = i ; } return mode ; } }
class Solution { public int findInMountainArray ( int target , MountainArray mountainArr ) { final int n = mountainArr . length ( ) ; final int peakIndex = peakIndexInMountainArray ( mountainArr , 0 , n - 1 ) ; final int leftIndex = searchLeft ( mountainArr , target , 0 , peakIndex ) ; if ( mountainArr . get ( leftIndex ) == target ) return leftIndex ; final int rightIndex = searchRight ( mountainArr , target , peakIndex + 1 , n - 1 ) ; if ( mountainArr . get ( rightIndex ) == target ) return rightIndex ; return - 1 ; } private int peakIndexInMountainArray ( MountainArray A , int l , int r ) { while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A . get ( m ) < A . get ( m + 1 ) ) l = m + 1 ; else r = m ; } return l ; } private int searchLeft ( MountainArray A , int target , int l , int r ) { while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A . get ( m ) < target ) l = m + 1 ; else r = m ; } return l ; } private int searchRight ( MountainArray A , int target , int l , int r ) { while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A . get ( m ) > target ) l = m + 1 ; else r = m ; } return l ; } }
class Solution { public List < String > braceExpansionII ( String expression ) { return dfs ( expression , 0 , expression . length ( ) - 1 ) ; } private List < String > dfs ( final String expression , int s , int e ) { TreeSet < String > ans = new TreeSet < > ( ) ; List < List < String > > groups = new ArrayList < > ( ) ; groups . add ( new ArrayList < > ( ) ) ; int layer = 0 ; int left = 0 ; for ( int i = s ; i <= e ; ++ i ) if ( expression . charAt ( i ) == ' { ' && ++ layer == 1 ) left = i + 1 ; else if ( expression . charAt ( i ) == ' } ' && -- layer == 0 ) merge ( groups , dfs ( expression , left , i - 1 ) ) ; else if ( expression . charAt ( i ) == ' , ' && layer == 0 ) groups . add ( new ArrayList < > ( ) ) ; else if ( layer == 0 ) merge ( groups , new ArrayList < > ( Arrays . asList ( String . valueOf ( expression . charAt ( i ) ) ) ) ) ; for ( final List < String > group : groups ) for ( final String word : group ) ans . add ( word ) ; return new ArrayList < > ( ans ) ; } void merge ( List < List < String > > groups , List < String > group ) { if ( groups . get ( groups . size ( ) - 1 ) . isEmpty ( ) ) { groups . set ( groups . size ( ) - 1 , group ) ; return ; } List < String > mergedGroup = new ArrayList < > ( ) ; for ( final String word1 : groups . get ( groups . size ( ) - 1 ) ) for ( final String word2 : group ) mergedGroup . add ( word1 + word2 ) ; groups . set ( groups . size ( ) - 1 , mergedGroup ) ; } }
class Solution { public int maxArea ( int [ ] height ) { int ans = 0 ; int l = 0 ; int r = height . length - 1 ; while ( l < r ) { final int minHeight = Math . min ( height [ l ] , height [ r ] ) ; ans = Math . max ( ans , minHeight * ( r - l ) ) ; if ( height [ l ] < height [ r ] ) ++ l ; else -- r ; } return ans ; } }
class Solution { public boolean isBalanced ( TreeNode root ) { if ( root == null ) return true ; return Math . abs ( maxDepth ( root . left ) - maxDepth ( root . right ) ) <= 1 && isBalanced ( root . left ) && isBalanced ( root . right ) ; } private int maxDepth ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + Math . max ( maxDepth ( root . left ) , maxDepth ( root . right ) ) ; } }
class Solution { public int numKLenSubstrNoRepeats ( String s , int k ) { int ans = 0 ; int unique = 0 ; int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( ++ count [ s . charAt ( i ) - ' a ' ] == 1 ) ++ unique ; if ( i >= k && -- count [ s . charAt ( i - k ) - ' a ' ] == 0 ) -- unique ; if ( unique == k ) ++ ans ; } return ans ; } }
class UnionFind { public UnionFind ( int n ) { count = n ; id = new int [ n ] ; rank = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) id [ i ] = i ; } public void union ( int u , int v ) { int i = find ( u ) ; int j = find ( v ) ; if ( i == j ) return ; if ( rank [ i ] > rank [ j ] ) { final int temp = i ; i = j ; j = temp ; } else if ( rank [ i ] == rank [ j ] ) { ++ rank [ j ] ; } id [ i ] = j ; -- count ; } public int getCount ( ) { return count ; } private int count ; private int [ ] id ; private int [ ] rank ; private int find ( int u ) { return id [ u ] == u ? u : ( id [ u ] = find ( id [ u ] ) ) ; } } class Solution { public int earliestAcq ( int [ ] [ ] logs , int n ) { UnionFind uf = new UnionFind ( n ) ; Arrays . sort ( logs , ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; for ( int [ ] log : logs ) { final int timestamp = log [ 0 ] ; final int x = log [ 1 ] ; final int y = log [ 2 ] ; uf . union ( x , y ) ; if ( uf . getCount ( ) == 1 ) return timestamp ; } return - 1 ; } }
class Solution { public int [ ] distributeCandies ( int candies , int num_people ) { int [ ] ans = new int [ num_people ] ; long c = ( long ) candies ; long n = ( long ) num_people ; int rows = ( int ) ( - n + Math . sqrt ( n * n + 8 * n * n * c ) ) / ( int ) ( 2 * n * n ) ; int accumN = rows * ( rows - 1 ) * num_people / 2 ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = accumN + rows * ( i + 1 ) ; int givenCandies = ( num_people * num_people * rows * rows + num_people * rows ) / 2 ; candies -= givenCandies ; for ( int i = 0 , lastGiven = rows * num_people + 1 ; candies > 0 ; ++ i , ++ lastGiven ) { int actualGiven = Math . min ( lastGiven , candies ) ; candies -= actualGiven ; ans [ i ] += actualGiven ; } return ans ; } }
class Solution { public List < Integer > pathInZigZagTree ( int label ) { LinkedList < Integer > ans = new LinkedList < > ( ) ; int level = 0 ; for ( int l = 0 ; l < 21 ; ++ l ) if ( Math . pow ( 2 , l ) > label ) { level = l - 1 ; break ; } if ( level % 2 == 1 ) label = boundarySum ( level ) - label ; for ( int l = level ; l >= 0 ; -- l ) { ans . addFirst ( l % 2 == 1 ? boundarySum ( l ) - label : label ) ; label /= 2 ; } return new ArrayList < > ( ans ) ; } private int boundarySum ( int level ) { return ( int ) Math . pow ( 2 , level ) + ( int ) Math . pow ( 2 , level + 1 ) - 1 ; } }
class Solution { public int minHeightShelves ( int [ ] [ ] books , int shelfWidth ) { final int n = books . length ; int [ ] dp = new int [ n + 1 ] ; Arrays . fill ( dp , Integer . MAX_VALUE ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < books . length ; ++ i ) { int sumThickness = 0 ; int maxHeight = 0 ; for ( int j = i ; j >= 0 ; -- j ) { final int thickness = books [ j ] [ 0 ] ; final int height = books [ j ] [ 1 ] ; sumThickness += thickness ; if ( sumThickness > shelfWidth ) break ; maxHeight = Math . max ( maxHeight , height ) ; dp [ i + 1 ] = Math . min ( dp [ i + 1 ] , dp [ j ] + maxHeight ) ; } } return dp [ n ] ; } }
class Solution { public boolean parseBoolExpr ( String expression ) { return dfs ( expression , 0 , expression . length ( ) - 1 ) ; } private boolean dfs ( final String expression , int s , int e ) { if ( s == e ) return expression . charAt ( s ) == ' t ' ; List < Boolean > exps = new ArrayList < > ( ) ; int layer = 0 ; int left = 0 ; char op = ' ▁ ' ; for ( int i = s ; i <= e ; ++ i ) { char c = expression . charAt ( i ) ; if ( layer == 0 && ( c == ' ! ' || c == ' & ' || c == ' | ' ) ) op = c ; else if ( c == ' ( ' && ++ layer == 1 ) left = i + 1 ; else if ( c == ' ) ' && -- layer == 0 ) exps . add ( dfs ( expression , left , i - 1 ) ) ; else if ( c == ' , ' && layer == 1 ) { exps . add ( dfs ( expression , left , i - 1 ) ) ; left = i + 1 ; } } if ( op == ' & ' ) { boolean ans = true ; for ( boolean exp : exps ) ans &= exp ; return ans ; } if ( op == ' | ' ) { boolean ans = false ; for ( boolean exp : exps ) ans |= exp ; return ans ; } return ! exps . get ( 0 ) ; } }
class Solution { public String defangIPaddr ( String address ) { return address . replace ( " . " , " [ . ] " ) ; } }
class Solution { public int [ ] corpFlightBookings ( int [ ] [ ] bookings , int n ) { int [ ] ans = new int [ n ] ; for ( int [ ] booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ] ; if ( booking [ 1 ] < n ) ans [ booking [ 1 ] ] -= booking [ 2 ] ; } for ( int i = 1 ; i < n ; ++ i ) ans [ i ] += ans [ i - 1 ] ; return ans ; } }
class Solution { public int minDepth ( TreeNode root ) { if ( root == null ) return 0 ; if ( root . left == null ) return minDepth ( root . right ) + 1 ; if ( root . right == null ) return minDepth ( root . left ) + 1 ; return Math . min ( minDepth ( root . left ) , minDepth ( root . right ) ) + 1 ; } }
class Solution { public List < TreeNode > delNodes ( TreeNode root , int [ ] to_delete ) { List < TreeNode > ans = new ArrayList < > ( ) ; Set < Integer > toDeleteSet = Arrays . stream ( to_delete ) . boxed ( ) . collect ( Collectors . toSet ( ) ) ; dfs ( root , toDeleteSet , true , ans ) ; return ans ; } private TreeNode dfs ( TreeNode root , Set < Integer > toDeleteSet , boolean isRoot , List < TreeNode > ans ) { if ( root == null ) return null ; final boolean deleted = toDeleteSet . contains ( root . val ) ; if ( isRoot && ! deleted ) ans . add ( root ) ; root . left = dfs ( root . left , toDeleteSet , deleted , ans ) ; root . right = dfs ( root . right , toDeleteSet , deleted , ans ) ; return deleted ? null : root ; } }
class Solution { public int [ ] maxDepthAfterSplit ( String seq ) { int [ ] ans = new int [ seq . length ( ) ] ; int depth = 1 ; for ( int i = 0 ; i < seq . length ( ) ; ++ i ) if ( seq . charAt ( i ) == ' ( ' ) ans [ i ] = ++ depth % 2 ; else ans [ i ] = depth -- % 2 ; return ans ; } }
class Foo { public void first ( Runnable printFirst ) throws InterruptedException { printFirst . run ( ) ; firstDone . incrementAndGet ( ) ; } public void second ( Runnable printSecond ) throws InterruptedException { while ( firstDone . get ( ) != 1 ) ; printSecond . run ( ) ; secondDone . incrementAndGet ( ) ; } public void third ( Runnable printThird ) throws InterruptedException { while ( secondDone . get ( ) != 1 ) ; printThird . run ( ) ; } private AtomicInteger firstDone = new AtomicInteger ( ) ; private AtomicInteger secondDone = new AtomicInteger ( ) ; }
class FooBar { public FooBar ( int n ) { this . n = n ; } public void foo ( Runnable printFoo ) throws InterruptedException { for ( int i = 0 ; i < n ; ++ i ) { fooSemaphore . acquire ( ) ; printFoo . run ( ) ; barSemaphore . release ( ) ; } } public void bar ( Runnable printBar ) throws InterruptedException { for ( int i = 0 ; i < n ; ++ i ) { barSemaphore . acquire ( ) ; printBar . run ( ) ; fooSemaphore . release ( ) ; } } private int n ; private Semaphore fooSemaphore = new Semaphore ( 1 ) ; private Semaphore barSemaphore = new Semaphore ( 0 ) ; }
class Solution { public boolean hasPathSum ( TreeNode root , int sum ) { if ( root == null ) return false ; if ( root . val == sum && root . left == null && root . right == null ) return true ; return hasPathSum ( root . left , sum - root . val ) || hasPathSum ( root . right , sum - root . val ) ; } }
class T { public int sum ; public int count ; public double maxAverage ; public T ( int sum , int count , double maxAverage ) { this . sum = sum ; this . count = count ; this . maxAverage = maxAverage ; } } class Solution { public double maximumAverageSubtree ( TreeNode root ) { return maximumAverage ( root ) . maxAverage ; } private T maximumAverage ( TreeNode root ) { if ( root == null ) return new T ( 0 , 0 , 0.0 ) ; T l = maximumAverage ( root . left ) ; T r = maximumAverage ( root . right ) ; final int sum = root . val + l . sum + r . sum ; final int count = 1 + l . count + r . count ; final double maxAverage = Math . max ( sum / ( double ) count , Math . max ( l . maxAverage , r . maxAverage ) ) ; return new T ( sum , count , maxAverage ) ; } }
class Solution { public boolean canDivideIntoSubsequences ( int [ ] nums , int k ) { final int n = nums . length ; int freq = 1 ; int maxFreq = 1 ; for ( int i = 1 ; i < n ; ++ i ) { freq = nums [ i - 1 ] < nums [ i ] ? 1 : ++ freq ; maxFreq = Math . max ( maxFreq , freq ) ; } return n >= maxFreq * k ; } }
class Solution { public int [ ] relativeSortArray ( int [ ] arr1 , int [ ] arr2 ) { int [ ] ans = new int [ arr1 . length ] ; int [ ] count = new int [ 1001 ] ; int i = 0 ; for ( int a : arr1 ) ++ count [ a ] ; for ( int a : arr2 ) while ( count [ a ] -- > 0 ) ans [ i ++ ] = a ; for ( int num = 0 ; num < 1001 ; ++ num ) while ( count [ num ] -- > 0 ) ans [ i ++ ] = num ; return ans ; } }
class Solution { public int numEquivDominoPairs ( int [ ] [ ] dominoes ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( int [ ] domino : dominoes ) { int key = Math . min ( domino [ 0 ] , domino [ 1 ] ) * 10 + Math . max ( domino [ 0 ] , domino [ 1 ] ) ; ans += count . getOrDefault ( key , 0 ) ; count . put ( key , count . getOrDefault ( key , 0 ) + 1 ) ; } return ans ; } }
class Solution { public List < List < Integer > > pathSum ( TreeNode root , int sum ) { List < List < Integer > > ans = new ArrayList < > ( ) ; dfs ( root , sum , new ArrayList < > ( ) , ans ) ; return ans ; } private void dfs ( TreeNode root , int sum , List < Integer > path , List < List < Integer > > ans ) { if ( root == null ) return ; if ( root . val == sum && root . left == null && root . right == null ) { path . add ( root . val ) ; ans . add ( new ArrayList < > ( path ) ) ; path . remove ( path . size ( ) - 1 ) ; return ; } path . add ( root . val ) ; dfs ( root . left , sum - root . val , path , ans ) ; dfs ( root . right , sum - root . val , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; } }
class Solution { public int mctFromLeafValues ( int [ ] arr ) { final int n = arr . length ; int [ ] [ ] dp = new int [ n ] [ n ] ; int [ ] [ ] maxVal = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; ++ i ) maxVal [ i ] [ i ] = arr [ i ] ; for ( int d = 1 ; d < n ; ++ d ) for ( int i = 0 ; i + d < n ; ++ i ) { final int j = i + d ; maxVal [ i ] [ j ] = Math . max ( maxVal [ i ] [ j - 1 ] , maxVal [ i + 1 ] [ j ] ) ; } for ( int d = 1 ; d < n ; ++ d ) for ( int i = 0 ; i + d < n ; ++ i ) { final int j = i + d ; dp [ i ] [ j ] = Integer . MAX_VALUE ; for ( int k = i ; k < j ; ++ k ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] ) ; } return dp [ 0 ] [ n - 1 ] ; } }
class Solution { public int maxAbsValExpr ( int [ ] arr1 , int [ ] arr2 ) { final int n = arr1 . length ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; int [ ] c = new int [ n ] ; int [ ] d = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = arr1 [ i ] + arr2 [ i ] + i ; b [ i ] = arr1 [ i ] + arr2 [ i ] - i ; c [ i ] = arr1 [ i ] - arr2 [ i ] + i ; d [ i ] = arr1 [ i ] - arr2 [ i ] - i ; } return Math . max ( Math . max ( diff ( a ) , diff ( b ) ) , Math . max ( diff ( c ) , diff ( d ) ) ) ; } private int diff ( int [ ] nums ) { final int min = Arrays . stream ( nums ) . min ( ) . getAsInt ( ) ; final int max = Arrays . stream ( nums ) . max ( ) . getAsInt ( ) ; return max - min ; } }
enum State { INIT , VISITING , VISITED } class Solution { public int minimumSemesters ( int n , int [ ] [ ] relations ) { List < Integer > [ ] graph = new List [ n ] ; State [ ] state = new State [ n ] ; int [ ] depth = new int [ n ] ; Arrays . fill ( depth , 1 ) ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] r : relations ) graph [ r [ 0 ] - 1 ] . add ( r [ 1 ] - 1 ) ; for ( int i = 0 ; i < n ; ++ i ) if ( hasCycle ( graph , i , state , depth ) ) return - 1 ; return Arrays . stream ( depth ) . max ( ) . getAsInt ( ) ; } private boolean hasCycle ( List < Integer > [ ] graph , int u , State [ ] state , int [ ] depth ) { if ( state [ u ] == State . VISITING ) return true ; if ( state [ u ] == State . VISITED ) return false ; state [ u ] = State . VISITING ; for ( final int v : graph [ u ] ) { if ( hasCycle ( graph , v , state , depth ) ) return true ; depth [ u ] = Math . max ( depth [ u ] , 1 + depth [ v ] ) ; } state [ u ] = State . VISITED ; return false ; } }
class Solution { public void flatten ( TreeNode root ) { if ( root == null ) return ; flatten ( root . left ) ; flatten ( root . right ) ; TreeNode left = root . left ; TreeNode right = root . right ; root . left = null ; root . right = left ; TreeNode rightmost = root ; while ( rightmost . right != null ) rightmost = rightmost . right ; rightmost . right = right ; } }
class Solution { public int longestCommonSubsequence ( String text1 , String text2 ) { final int m = text1 . length ( ) ; final int n = text2 . length ( ) ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) dp [ i + 1 ] [ j + 1 ] = text1 . charAt ( i ) == text2 . charAt ( j ) ? 1 + dp [ i ] [ j ] : Math . max ( dp [ i ] [ j + 1 ] , dp [ i + 1 ] [ j ] ) ; return dp [ m ] [ n ] ; } }
class Solution { public int movesToMakeZigzag ( int [ ] nums ) { int [ ] decreasing = new int [ 2 ] ; for ( int i = 0 ; i < nums . length ; ++ i ) { int l = i > 0 ? nums [ i - 1 ] : 1001 ; int r = i + 1 < nums . length ? nums [ i + 1 ] : 1001 ; decreasing [ i % 2 ] += Math . max ( 0 , nums [ i ] - Math . min ( l , r ) + 1 ) ; } return Math . min ( decreasing [ 0 ] , decreasing [ 1 ] ) ; } }
class SnapshotArray { public SnapshotArray ( int length ) { snaps = new List [ length ] ; for ( int i = 0 ; i < length ; ++ i ) { snaps [ i ] = new ArrayList < > ( ) ; snaps [ i ] . add ( new int [ ] { 0 , 0 } ) ; } } public void set ( int index , int val ) { int [ ] snap = snaps [ index ] . get ( snaps [ index ] . size ( ) - 1 ) ; if ( snap [ 0 ] == snap_id ) snap [ 1 ] = val ; else snaps [ index ] . add ( new int [ ] { snap_id , val } ) ; } public int snap ( ) { return snap_id ++ ; } public int get ( int index , int snap_id ) { int i = Collections . binarySearch ( snaps [ index ] , new int [ ] { snap_id , 0 } , ( a , b ) -> Integer . compare ( a [ 0 ] , b [ 0 ] ) ) ; if ( i < 0 ) i = - i - 2 ; return snaps [ index ] . get ( i ) [ 1 ] ; } private List < int [ ] > [ ] snaps ; private int snap_id = 0 ; }
class Solution { public int numDistinct ( String s , String t ) { final int m = s . length ( ) ; final int n = t . length ( ) ; long [ ] [ ] dp = new long [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) dp [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( s . charAt ( i - 1 ) == t . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; return ( int ) dp [ m ] [ n ] ; } }
class Solution { public int minSwaps ( int [ ] data ) { final int k = ( int ) Arrays . stream ( data ) . filter ( a -> a == 1 ) . count ( ) ; int ones = 1 ; int maxOnes = 0 ; for ( int i = 0 ; i < data . length ; ++ i ) { if ( i >= k && data [ i - k ] == 1 ) -- ones ; if ( data [ i ] == 1 ) ++ ones ; maxOnes = Math . max ( maxOnes , ones ) ; } return k - maxOnes ; } }
class Solution { public boolean canConvert ( String str1 , String str2 ) { if ( str1 . equals ( str2 ) ) return true ; Map < Character , Character > mappings = new HashMap < > ( ) ; for ( int i = 0 ; i < str1 . length ( ) ; ++ i ) { final char a = str1 . charAt ( i ) ; final char b = str2 . charAt ( i ) ; if ( mappings . getOrDefault ( a , b ) != b ) return false ; mappings . put ( a , b ) ; } return new HashSet < > ( mappings . values ( ) ) . size ( ) < 26 ; } }
class Solution { public int dayOfYear ( String date ) { int ans = 0 ; int year = Integer . valueOf ( date . substring ( 0 , 4 ) ) ; int month = Integer . valueOf ( date . substring ( 5 , 7 ) ) ; int day = Integer . valueOf ( date . substring ( 8 ) ) ; int [ ] days = new int [ ] { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; for ( int i = 0 ; i < month - 1 ; ++ i ) ans += days [ i ] ; return ans + day ; } private boolean isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } }
class Solution { public int numRollsToTarget ( int n , int k , int target ) { final int kMod = 1_000_000_007 ; int [ ] dp = new int [ target + 1 ] ; dp [ 0 ] = 1 ; while ( n -- > 0 ) { int [ ] newDp = new int [ target + 1 ] ; for ( int i = 1 ; i <= k ; ++ i ) for ( int t = i ; t <= target ; ++ t ) { newDp [ t ] += dp [ t - i ] ; newDp [ t ] %= kMod ; } dp = newDp ; } return dp [ target ] ; } }
class Solution { public int maxRepOpt1 ( String text ) { int ans = 0 ; int [ ] count = new int [ 26 ] ; List < int [ ] > groups = new ArrayList < > ( ) ; for ( char c : text . toCharArray ( ) ) ++ count [ c - ' a ' ] ; groups . add ( new int [ ] { text . charAt ( 0 ) , 1 } ) ; for ( int i = 1 ; i < text . length ( ) ; ++ i ) if ( text . charAt ( i ) == text . charAt ( i - 1 ) ) ++ groups . get ( groups . size ( ) - 1 ) [ 1 ] ; else groups . add ( new int [ ] { text . charAt ( i ) , 1 } ) ; for ( int [ ] group : groups ) ans = Math . max ( ans , Math . min ( group [ 1 ] + 1 , count [ group [ 0 ] - ' a ' ] ) ) ; for ( int i = 1 ; i + 1 < groups . size ( ) ; ++ i ) if ( groups . get ( i - 1 ) [ 0 ] == groups . get ( i + 1 ) [ 0 ] && groups . get ( i ) [ 1 ] == 1 ) ans = Math . max ( ans , Math . min ( groups . get ( i - 1 ) [ 1 ] + groups . get ( i + 1 ) [ 1 ] + 1 , count [ groups . get ( i - 1 ) [ 0 ] - ' a ' ] ) ) ; return ans ; } }
class MajorityChecker { public MajorityChecker ( int [ ] arr ) { A = arr ; for ( int i = 0 ; i < A . length ; ++ i ) { if ( ! numToIndices . containsKey ( A [ i ] ) ) numToIndices . put ( A [ i ] , new ArrayList < > ( ) ) ; numToIndices . get ( A [ i ] ) . add ( i ) ; } } public int query ( int left , int right , int threshold ) { for ( int i = 0 ; i < kTimes ; ++ i ) { final int num = A [ rand . nextInt ( A . length ) ] ; List < Integer > indices = numToIndices . get ( num ) ; final int l = firstGreaterEqual ( indices , left ) ; final int r = firstGreaterEqual ( indices , right + 1 ) ; if ( r - l >= threshold ) return num ; } return - 1 ; } private static final int kTimes = 20 ; private int [ ] A ; private Map < Integer , List < Integer > > numToIndices = new HashMap < > ( ) ; private Random rand = new Random ( ) ; private int firstGreaterEqual ( List < Integer > indices , int target ) { int index = Collections . binarySearch ( indices , target ) ; return index < 0 ? - index - 1 : index ; } }
class Solution { public Node connect ( Node root ) { if ( root == null ) return null ; connectTwoNodes ( root . left , root . right ) ; return root ; } private void connectTwoNodes ( Node p , Node q ) { if ( p == null ) return ; p . next = q ; connectTwoNodes ( p . left , p . right ) ; connectTwoNodes ( q . left , q . right ) ; connectTwoNodes ( p . right , q . left ) ; } }
class Solution { public int countCharacters ( String [ ] words , String chars ) { int ans = 0 ; int [ ] count = new int [ 26 ] ; for ( final char c : chars . toCharArray ( ) ) ++ count [ c - ' a ' ] ; for ( final String word : words ) { int [ ] tempCount = count . clone ( ) ; for ( final char c : word . toCharArray ( ) ) if ( -- tempCount [ c - ' a ' ] < 0 ) { ans -= word . length ( ) ; break ; } ans += word . length ( ) ; } return ans ; } }
class Solution { public String lastSubstring ( String s ) { int i = 0 ; int j = 1 ; int k = 0 ; while ( j + k < s . length ( ) ) { if ( s . charAt ( i + k ) == s . charAt ( j + k ) ) { ++ k ; } else if ( s . charAt ( i + k ) > s . charAt ( j + k ) ) { j += k + 1 ; k = 0 ; } else { i = Math . max ( i + k + 1 , j ) ; j = i + 1 ; k = 0 ; } } return s . substring ( i ) ; } }
class Solution { public int connectSticks ( int [ ] sticks ) { int ans = 0 ; Queue < Integer > minHeap = new PriorityQueue < > ( ) ; for ( final int stick : sticks ) minHeap . offer ( stick ) ; while ( minHeap . size ( ) > 1 ) { final int x = minHeap . poll ( ) ; final int y = minHeap . poll ( ) ; ans += x + y ; minHeap . offer ( x + y ) ; } return ans ; } }
class Solution { public int minCostToSupplyWater ( int n , int [ ] wells , int [ ] [ ] pipes ) { int ans = 0 ; List < Pair < Integer , Integer > > [ ] graph = new List [ n + 1 ] ; Queue < Pair < Integer , Integer > > minHeap = new PriorityQueue < > ( Comparator . comparing ( Pair :: getKey ) ) ; for ( int i = 0 ; i <= n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] p : pipes ) { final int u = p [ 0 ] ; final int v = p [ 1 ] ; final int w = p [ 2 ] ; graph [ u ] . add ( new Pair < > ( v , w ) ) ; graph [ v ] . add ( new Pair < > ( u , w ) ) ; } for ( int i = 0 ; i < n ; ++ i ) { graph [ 0 ] . add ( new Pair < > ( i + 1 , wells [ i ] ) ) ; minHeap . offer ( new Pair < > ( wells [ i ] , i + 1 ) ) ; } Set < Integer > mst = new HashSet < > ( Arrays . asList ( 0 ) ) ; while ( mst . size ( ) < n + 1 ) { Pair < Integer , Integer > pair = minHeap . poll ( ) ; final int d = pair . getKey ( ) ; final int u = pair . getValue ( ) ; if ( mst . contains ( u ) ) continue ; mst . add ( u ) ; ans += d ; for ( Pair < Integer , Integer > node : graph [ u ] ) { final int v = node . getKey ( ) ; final int w = node . getValue ( ) ; if ( ! mst . contains ( v ) ) minHeap . offer ( new Pair < > ( w , v ) ) ; } } return ans ; } }
class Trans { public String name ; public int time ; public int amount ; public String city ; public Trans ( String name , int time , int amount , String city ) { this . name = name ; this . time = time ; this . amount = amount ; this . city = city ; } } class Solution { public List < String > invalidTransactions ( String [ ] transactions ) { List < String > ans = new ArrayList < > ( ) ; Map < String , List < Trans > > nameToTranses = new HashMap < > ( ) ; for ( final String t : transactions ) { Trans trans = getTrans ( t ) ; nameToTranses . putIfAbsent ( trans . name , new ArrayList < > ( ) ) ; nameToTranses . get ( trans . name ) . add ( trans ) ; } for ( final String t : transactions ) { Trans currTrans = getTrans ( t ) ; if ( currTrans . amount > 1000 ) { ans . add ( t ) ; } else if ( nameToTranses . containsKey ( currTrans . name ) ) { for ( Trans trans : nameToTranses . get ( currTrans . name ) ) if ( Math . abs ( trans . time - currTrans . time ) <= 60 && ! trans . city . equals ( currTrans . city ) ) { ans . add ( t ) ; break ; } } } return ans ; } private Trans getTrans ( final String t ) { String [ ] s = t . split ( " , " ) ; return new Trans ( s [ 0 ] , Integer . parseInt ( s [ 1 ] ) , Integer . parseInt ( s [ 2 ] ) , s [ 3 ] ) ; } }
class Solution { public Node connect ( Node root ) { Node node = root ; while ( node != null ) { Node dummy = new Node ( ) ; for ( Node needle = dummy ; node != null ; node = node . next ) { if ( node . left != null ) { needle . next = node . left ; needle = needle . next ; } if ( node . right != null ) { needle . next = node . right ; needle = needle . next ; } } node = dummy . next ; } return root ; } }
class Solution { public int [ ] numSmallerByFrequency ( String [ ] queries , String [ ] words ) { int [ ] ans = new int [ queries . length ] ; int [ ] wordsFreq = new int [ words . length ] ; for ( int i = 0 ; i < words . length ; ++ i ) wordsFreq [ i ] = f ( words [ i ] ) ; Arrays . sort ( wordsFreq ) ; for ( int i = 0 ; i < queries . length ; ++ i ) { final int freq = f ( queries [ i ] ) ; ans [ i ] = words . length - upper_bound ( wordsFreq , 0 , wordsFreq . length , freq ) ; } return ans ; } private int f ( String word ) { int count = 0 ; char currentChar = ' z ' + 1 ; for ( char c : word . toCharArray ( ) ) if ( c < currentChar ) { currentChar = c ; count = 1 ; } else if ( c == currentChar ) { ++ count ; } return count ; } private int upper_bound ( int [ ] nums , int l , int r , int value ) { while ( l < r ) { final int m = ( l + r ) / 2 ; if ( nums [ m ] <= value ) l = m + 1 ; else r = m ; } return l ; } }
class Solution { public ListNode removeZeroSumSublists ( ListNode head ) { ListNode dummy = new ListNode ( 0 , head ) ; int prefix = 0 ; Map < Integer , ListNode > prefixToNode = new HashMap < > ( ) ; prefixToNode . put ( 0 , dummy ) ; for ( ; head != null ; head = head . next ) { prefix += head . val ; prefixToNode . put ( prefix , head ) ; } prefix = 0 ; for ( head = dummy ; head != null ; head = head . next ) { prefix += head . val ; head . next = prefixToNode . get ( prefix ) . next ; } return dummy . next ; } }
class DinnerPlates { public DinnerPlates ( int capacity ) { this . capacity = capacity ; minHeap . offer ( 0 ) ; } public void push ( int val ) { final int index = minHeap . peek ( ) ; if ( index == stacks . size ( ) ) stacks . add ( new ArrayDeque < > ( ) ) ; stacks . get ( index ) . push ( val ) ; if ( stacks . get ( index ) . size ( ) == capacity ) { minHeap . poll ( ) ; if ( minHeap . isEmpty ( ) ) minHeap . offer ( stacks . size ( ) ) ; } } public int pop ( ) { while ( ! stacks . isEmpty ( ) && stacks . get ( stacks . size ( ) - 1 ) . isEmpty ( ) ) stacks . remove ( stacks . size ( ) - 1 ) ; if ( stacks . isEmpty ( ) ) return - 1 ; return popAtStack ( stacks . size ( ) - 1 ) ; } public int popAtStack ( int index ) { if ( index >= stacks . size ( ) || stacks . get ( index ) . isEmpty ( ) ) return - 1 ; if ( stacks . get ( index ) . size ( ) == capacity ) minHeap . offer ( index ) ; return stacks . get ( index ) . pop ( ) ; } private final int capacity ; private List < Deque < Integer > > stacks = new ArrayList < > ( ) ; private Queue < Integer > minHeap = new PriorityQueue < > ( ) ; }
class Solution { public int numPrimeArrangements ( int n ) { final int kMod = 1_000_000_007 ; final int count = countPrimes ( n ) ; return ( int ) ( ( factorial ( count , kMod ) * factorial ( n - count , kMod ) ) % kMod ) ; } private int countPrimes ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , 2 , n + 1 , true ) ; for ( int i = 0 ; i * i <= n ; ++ i ) if ( prime [ i ] ) for ( int j = i * i ; j <= n ; j += i ) prime [ j ] = false ; int count = 0 ; for ( boolean p : prime ) if ( p ) ++ count ; return count ; } long factorial ( int n , final long kMod ) { long fact = 1 ; for ( int i = 1 ; i <= n ; ++ i ) fact = fact * i % kMod ; return fact ; } }
class Solution { public List < Boolean > canMakePaliQueries ( String s , int [ ] [ ] queries ) { List < Boolean > ans = new ArrayList < > ( ) ; int [ ] dp = new int [ s . length ( ) + 1 ] ; for ( int i = 1 ; i <= s . length ( ) ; ++ i ) dp [ i ] = dp [ i - 1 ] ^ 1 << s . charAt ( i - 1 ) - ' a ' ; for ( int [ ] q : queries ) { int odds = Integer . bitCount ( dp [ q [ 1 ] + 1 ] ^ dp [ q [ 0 ] ] ) ; ans . add ( odds / 2 <= q [ 2 ] ) ; } return ans ; } }
class Solution { public List < Integer > findNumOfValidWords ( String [ ] words , String [ ] puzzles ) { List < Integer > ans = new ArrayList < > ( ) ; Map < Integer , Integer > binaryCount = new HashMap < > ( ) ; for ( final String word : words ) { int mask = 0 ; for ( char c : word . toCharArray ( ) ) mask |= 1 << ( c - ' a ' ) ; binaryCount . put ( mask , binaryCount . getOrDefault ( mask , 0 ) + 1 ) ; } for ( final String puzzle : puzzles ) { int valid = 0 ; final int n = puzzle . length ( ) - 1 ; for ( int i = 0 ; i < ( 1 << n ) ; ++ i ) { int mask = 1 << puzzle . charAt ( 0 ) - ' a ' ; for ( int j = 0 ; j < n ; ++ j ) if ( ( i & 1 << j ) > 0 ) mask |= 1 << puzzle . charAt ( j + 1 ) - ' a ' ; if ( binaryCount . containsKey ( mask ) ) valid += binaryCount . get ( mask ) ; } ans . add ( valid ) ; } return ans ; } }
class Solution { public List < List < Integer > > generate ( int numRows ) { List < List < Integer > > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i < numRows ; ++ i ) { Integer [ ] temp = new Integer [ i + 1 ] ; Arrays . fill ( temp , 1 ) ; ans . add ( Arrays . asList ( temp ) ) ; } for ( int i = 2 ; i < numRows ; ++ i ) for ( int j = 1 ; j < ans . get ( i ) . size ( ) - 1 ; ++ j ) ans . get ( i ) . set ( j , ans . get ( i - 1 ) . get ( j - 1 ) + ans . get ( i - 1 ) . get ( j ) ) ; return ans ; } }
class Solution { public int maximumNumberOfOnes ( int width , int height , int sideLength , int maxOnes ) { int ans = 0 ; int [ ] [ ] submatrix = new int [ sideLength ] [ sideLength ] ; Queue < Integer > maxHeap = new PriorityQueue < > ( Comparator . reverseOrder ( ) ) ; for ( int i = 0 ; i < width ; ++ i ) for ( int j = 0 ; j < height ; ++ j ) ++ submatrix [ i % sideLength ] [ j % sideLength ] ; for ( int [ ] row : submatrix ) for ( final int a : row ) maxHeap . offer ( a ) ; for ( int i = 0 ; i < maxOnes ; ++ i ) ans += maxHeap . poll ( ) ; return ans ; } }
class Solution { public int distanceBetweenBusStops ( int [ ] distance , int start , int destination ) { int clockwise = 0 ; int counterclockwise = 0 ; if ( start > destination ) { int temp = start ; start = destination ; destination = temp ; } for ( int i = 0 ; i < distance . length ; ++ i ) { if ( i >= start && i < destination ) clockwise += distance [ i ] ; else counterclockwise += distance [ i ] ; } return Math . min ( clockwise , counterclockwise ) ; } }
class Solution { public String dayOfTheWeek ( int day , int month , int year ) { String [ ] week = { " Sunday " , " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " } ; int [ ] days = { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; int count = 0 ; for ( int i = 1971 ; i < year ; ++ i ) count += i % 4 == 0 ? 366 : 365 ; for ( int i = 0 ; i < month - 1 ; ++ i ) count += days [ i ] ; count += day ; return week [ ( count + 4 ) % 7 ] ; } private boolean isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } }
class Solution { public int makeArrayIncreasing ( int [ ] arr1 , int [ ] arr2 ) { Map < Integer , Integer > dp = new HashMap < > ( ) ; dp . put ( - 1 , 0 ) ; Arrays . sort ( arr2 ) ; for ( final int a : arr1 ) { Map < Integer , Integer > nextDp = new HashMap < > ( ) ; for ( final int val : dp . keySet ( ) ) { final int steps = dp . get ( val ) ; if ( a > val ) nextDp . put ( a , Math . min ( nextDp . getOrDefault ( a , Integer . MAX_VALUE ) , steps ) ) ; final int i = firstGreater ( arr2 , val ) ; if ( i < arr2 . length ) nextDp . put ( arr2 [ i ] , Math . min ( nextDp . getOrDefault ( arr2 [ i ] , Integer . MAX_VALUE ) , steps + 1 ) ) ; } if ( nextDp . isEmpty ( ) ) return - 1 ; dp = nextDp ; } return Collections . min ( dp . values ( ) ) ; } private int firstGreater ( int [ ] A , int val ) { final int i = Arrays . binarySearch ( A , val + 1 ) ; return i < 0 ? - ( i + 1 ) : i ; } }
class Solution { public int maxNumberOfBalloons ( String text ) { int ans = Integer . MAX_VALUE ; int [ ] count = new int [ 26 ] ; for ( char c : text . toCharArray ( ) ) ++ count [ c - ' a ' ] ; for ( char c : new char [ ] { ' b ' , ' a ' , ' n ' } ) ans = Math . min ( ans , count [ c - ' a ' ] ) ; for ( char c : new char [ ] { ' o ' , ' l ' } ) ans = Math . min ( ans , count [ c - ' a ' ] / 2 ) ; return ans ; } }
class Solution { public List < Integer > getRow ( int rowIndex ) { Integer [ ] ans = new Integer [ rowIndex + 1 ] ; Arrays . fill ( ans , 1 ) ; for ( int i = 2 ; i < rowIndex + 1 ; ++ i ) for ( int j = 1 ; j < i ; ++ j ) ans [ i - j ] += ans [ i - j - 1 ] ; return Arrays . asList ( ans ) ; } }
class Solution { public int minBuildTime ( int [ ] blocks , int split ) { Queue < Integer > minHeap = new PriorityQueue < > ( ) ; for ( final int block : blocks ) minHeap . offer ( block ) ; while ( minHeap . size ( ) > 1 ) { minHeap . poll ( ) ; final int x = minHeap . poll ( ) ; minHeap . offer ( x + split ) ; } return minHeap . poll ( ) ; } }
class Solution { public String intToRoman ( int num ) { final int [ ] values = { 1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 } ; final String [ ] symbols = { " M " , " CM " , " D " , " CD " , " C " , " XC " , " L " , " XL " , " X " , " IX " , " V " , " IV " , " I " } ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < values . length ; ++ i ) { if ( num == 0 ) break ; while ( num >= values [ i ] ) { num -= values [ i ] ; sb . append ( symbols [ i ] ) ; } } return sb . toString ( ) ; } }
class Solution { public int minimumTotal ( List < List < Integer > > triangle ) { for ( int i = triangle . size ( ) - 2 ; i >= 0 ; -- i ) for ( int j = 0 ; j <= i ; ++ j ) triangle . get ( i ) . set ( j , triangle . get ( i ) . get ( j ) + Math . min ( triangle . get ( i + 1 ) . get ( j ) , triangle . get ( i + 1 ) . get ( j + 1 ) ) ) ; return triangle . get ( 0 ) . get ( 0 ) ; } }
class Solution { public List < List < Integer > > minimumAbsDifference ( int [ ] arr ) { List < List < Integer > > ans = new ArrayList < > ( ) ; int min = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i + 1 < arr . length ; ++ i ) { int diff = arr [ i + 1 ] - arr [ i ] ; if ( diff < min ) { min = diff ; ans . clear ( ) ; } if ( diff == min ) ans . add ( Arrays . asList ( arr [ i ] , arr [ i + 1 ] ) ) ; } return ans ; } }
class Solution { public int nthUglyNumber ( int n , long a , long b , long c ) { final long ab = a * b / gcd ( a , b ) ; final long ac = a * c / gcd ( a , c ) ; final long bc = b * c / gcd ( b , c ) ; final long abc = a * bc / gcd ( a , bc ) ; int l = 1 ; int r = 2 * ( int ) 1e9 ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc >= n ) r = m ; else l = m + 1 ; } return l ; } private long gcd ( long a , long b ) { return b == 0 ? a : gcd ( b , a % b ) ; } }
class UnionFind { public UnionFind ( int n ) { id = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) id [ i ] = i ; } public void union ( int u , int v ) { id [ find ( u ) ] = find ( v ) ; } public int find ( int u ) { return id [ u ] == u ? u : ( id [ u ] = find ( id [ u ] ) ) ; } private int [ ] id ; } class Solution { public String smallestStringWithSwaps ( String s , List < List < Integer > > pairs ) { StringBuilder ans = new StringBuilder ( ) ; UnionFind uf = new UnionFind ( s . length ( ) ) ; Map < Integer , Queue < Character > > map = new HashMap < > ( ) ; for ( List < Integer > pair : pairs ) uf . union ( pair . get ( 0 ) , pair . get ( 1 ) ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) map . computeIfAbsent ( uf . find ( i ) , k -> new PriorityQueue < > ( ) ) . offer ( s . charAt ( i ) ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) ans . append ( map . get ( uf . find ( i ) ) . poll ( ) ) ; return ans . toString ( ) ; } }
class Node { public int val ; public Node next ; public Node down ; public Node ( int val , Node next , Node down ) { this . val = val ; this . next = next ; this . down = down ; } } class Skiplist { public boolean search ( int target ) { for ( Node node = dummy ; node != null ; node = node . down ) { node = advance ( node , target ) ; if ( node . next != null && node . next . val == target ) return true ; } return false ; } public void add ( int num ) { Deque < Node > nodes = new ArrayDeque < > ( ) ; for ( Node node = dummy ; node != null ; node = node . down ) { node = advance ( node , num ) ; nodes . push ( node ) ; } Node down = null ; boolean shouldInsert = true ; while ( shouldInsert && ! nodes . isEmpty ( ) ) { Node prev = nodes . poll ( ) ; prev . next = new Node ( num , prev . next , down ) ; down = prev . next ; shouldInsert = Math . random ( ) < 0.5 ; } if ( shouldInsert ) dummy = new Node ( - 1 , null , dummy ) ; } public boolean erase ( int num ) { boolean found = false ; for ( Node node = dummy ; node != null ; node = node . down ) { node = advance ( node , num ) ; if ( node . next != null && node . next . val == num ) { node . next = node . next . next ; found = true ; } } return found ; } private Node dummy = new Node ( - 1 , null , null ) ; private Node advance ( Node node , int target ) { while ( node . next != null && node . next . val < target ) node = node . next ; return node ; } }
class Solution { public boolean uniqueOccurrences ( int [ ] arr ) { Map < Integer , Integer > count = new HashMap < > ( ) ; Set < Integer > occurrences = new HashSet < > ( ) ; for ( final int a : arr ) count . put ( a , count . getOrDefault ( a , 0 ) + 1 ) ; for ( final int value : count . values ( ) ) if ( ! occurrences . add ( value ) ) return false ; return true ; } }
class Solution { public int equalSubstring ( String s , String t , int maxCost ) { int j = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { maxCost -= Math . abs ( s . charAt ( i ) - t . charAt ( i ) ) ; if ( maxCost < 0 ) maxCost += Math . abs ( s . charAt ( j ) - t . charAt ( j ++ ) ) ; } return s . length ( ) - j ; } }
class Item { char c ; int freq ; public Item ( char c , int freq ) { this . c = c ; this . freq = freq ; } } class Solution { public String removeDuplicates ( String s , int k ) { StringBuilder sb = new StringBuilder ( ) ; LinkedList < Item > stack = new LinkedList < > ( ) ; for ( final char c : s . toCharArray ( ) ) { if ( ! stack . isEmpty ( ) && stack . peek ( ) . c == c ) ++ stack . peek ( ) . freq ; else stack . push ( new Item ( c , 1 ) ) ; if ( stack . peek ( ) . freq == k ) stack . pop ( ) ; } while ( ! stack . isEmpty ( ) ) { Item item = stack . pop ( ) ; for ( int i = 0 ; i < item . freq ; ++ i ) sb . append ( item . c ) ; } return sb . reverse ( ) . toString ( ) ; } }
class Solution { public int maxProfit ( int [ ] prices ) { int sellOne = 0 ; int holdOne = Integer . MIN_VALUE ; for ( final int price : prices ) { sellOne = Math . max ( sellOne , holdOne + price ) ; holdOne = Math . max ( holdOne , - price ) ; } return sellOne ; } }
enum Pos { HORIZONTAL , VERTICAL } class Solution { public int minimumMoves ( int [ ] [ ] grid ) { final int n = grid . length ; int ans = 0 ; Queue < int [ ] > q = new ArrayDeque < > ( Arrays . asList ( new int [ ] { 0 , 0 , Pos . HORIZONTAL . ordinal ( ) } ) ) ; boolean [ ] [ ] [ ] seen = new boolean [ n ] [ n ] [ 2 ] ; seen [ 0 ] [ 0 ] [ Pos . HORIZONTAL . ordinal ( ) ] = true ; while ( ! q . isEmpty ( ) ) { for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int x = q . peek ( ) [ 0 ] ; final int y = q . peek ( ) [ 1 ] ; final int pos = q . poll ( ) [ 2 ] ; if ( x == n - 1 && y == n - 2 && pos == Pos . HORIZONTAL . ordinal ( ) ) return ans ; if ( canMoveRight ( grid , x , y , pos ) && ! seen [ x ] [ y + 1 ] [ pos ] ) { q . offer ( new int [ ] { x , y + 1 , pos } ) ; seen [ x ] [ y + 1 ] [ pos ] = true ; } if ( canMoveDown ( grid , x , y , pos ) && ! seen [ x + 1 ] [ y ] [ pos ] ) { q . offer ( new int [ ] { x + 1 , y , pos } ) ; seen [ x + 1 ] [ y ] [ pos ] = true ; } final int newPos = pos == Pos . HORIZONTAL . ordinal ( ) ? Pos . VERTICAL . ordinal ( ) : Pos . HORIZONTAL . ordinal ( ) ; if ( ( canRotateClockwise ( grid , x , y , pos ) || canRotateCounterclockwise ( grid , x , y , pos ) ) && ! seen [ x ] [ y ] [ newPos ] ) { q . offer ( new int [ ] { x , y , newPos } ) ; seen [ x ] [ y ] [ newPos ] = true ; } } ++ ans ; } return - 1 ; } private boolean canMoveRight ( int [ ] [ ] grid , int x , int y , int pos ) { if ( pos == Pos . HORIZONTAL . ordinal ( ) ) return y + 2 < grid . length && grid [ x ] [ y + 2 ] == 0 ; return y + 1 < grid . length && grid [ x ] [ y + 1 ] == 0 && grid [ x + 1 ] [ y + 1 ] == 0 ; } private boolean canMoveDown ( int [ ] [ ] grid , int x , int y , int pos ) { if ( pos == Pos . VERTICAL . ordinal ( ) ) return x + 2 < grid . length && grid [ x + 2 ] [ y ] == 0 ; return x + 1 < grid . length && grid [ x + 1 ] [ y ] == 0 && grid [ x + 1 ] [ y + 1 ] == 0 ; } ; private boolean canRotateClockwise ( int [ ] [ ] grid , int x , int y , int pos ) { return pos == Pos . HORIZONTAL . ordinal ( ) && x + 1 < grid . length && grid [ x + 1 ] [ y + 1 ] == 0 && grid [ x + 1 ] [ y ] == 0 ; } ; private boolean canRotateCounterclockwise ( int [ ] [ ] grid , int x , int y , int pos ) { return pos == Pos . VERTICAL . ordinal ( ) && y + 1 < grid . length && grid [ x + 1 ] [ y + 1 ] == 0 && grid [ x ] [ y + 1 ] == 0 ; } ; }
class Solution { public boolean isValidPalindrome ( String s , int k ) { return s . length ( ) - longestPalindromeSubseq ( s ) <= k ; } private int longestPalindromeSubseq ( final String s ) { final int n = s . length ( ) ; int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ] [ i ] = 1 ; for ( int d = 1 ; d < n ; ++ d ) for ( int i = 0 ; i + d < n ; ++ i ) { final int j = i + d ; if ( s . charAt ( i ) == s . charAt ( j ) ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } return dp [ 0 ] [ n - 1 ] ; } }
class Solution { public int minCostToMoveChips ( int [ ] chips ) { int [ ] count = new int [ 2 ] ; for ( int chip : chips ) ++ count [ chip % 2 ] ; return Math . min ( count [ 0 ] , count [ 1 ] ) ; } }
class Solution { public int longestSubsequence ( int [ ] arr , int difference ) { int ans = 0 ; Map < Integer , Integer > lengthAt = new HashMap < > ( ) ; for ( int a : arr ) { lengthAt . put ( a , lengthAt . getOrDefault ( a - difference , 0 ) + 1 ) ; ans = Math . max ( ans , lengthAt . get ( a ) ) ; } return ans ; } }
class Solution { public int maxProfit ( int [ ] prices ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( final int price : prices ) { sell = Math . max ( sell , hold + price ) ; hold = Math . max ( hold , sell - price ) ; } return sell ; } }
class Solution { public List < List < Integer > > queensAttacktheKing ( int [ ] [ ] queens , int [ ] king ) { List < List < Integer > > ans = new ArrayList < > ( ) ; Set < Integer > queensSet = new HashSet < > ( ) ; for ( int [ ] queen : queens ) queensSet . add ( hash ( queen [ 0 ] , queen [ 1 ] ) ) ; int [ ] [ ] directions = new int [ ] [ ] { { - 1 , - 1 } , { - 1 , 0 } , { - 1 , 1 } , { 0 , - 1 } , { 0 , 1 } , { 1 , - 1 } , { 1 , 0 } , { 1 , 1 } } ; for ( int [ ] d : directions ) for ( int i = king [ 0 ] + d [ 0 ] , j = king [ 1 ] + d [ 1 ] ; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ] , j += d [ 1 ] ) if ( queensSet . contains ( hash ( i , j ) ) ) { ans . add ( Arrays . asList ( i , j ) ) ; break ; } return ans ; } private int hash ( int i , int j ) { return i * 8 + j ; } }
class Solution { public int maxEqualFreq ( int [ ] nums ) { int ans = 0 ; int maxFreq = 0 ; Map < Integer , Integer > count = new HashMap < > ( ) ; Map < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { int currentFreq = count . getOrDefault ( nums [ i ] , 0 ) ; freq . put ( currentFreq , freq . getOrDefault ( currentFreq , 0 ) - 1 ) ; int updatedFreq = currentFreq + 1 ; count . put ( nums [ i ] , updatedFreq ) ; freq . put ( updatedFreq , freq . getOrDefault ( updatedFreq , 0 ) + 1 ) ; maxFreq = Math . max ( maxFreq , updatedFreq ) ; if ( maxFreq == 1 || maxFreq * freq . get ( maxFreq ) == i || ( maxFreq - 1 ) * ( freq . get ( maxFreq - 1 ) + 1 ) == i ) ans = i + 1 ; } return ans ; } }
class Solution { public double nthPersonGetsNthSeat ( int n ) { return n == 1 ? 1 : 0.5 ; } }
class Solution { public int maxProfit ( int [ ] prices ) { int sellTwo = 0 ; int holdTwo = Integer . MIN_VALUE ; int sellOne = 0 ; int holdOne = Integer . MIN_VALUE ; for ( final int price : prices ) { sellTwo = Math . max ( sellTwo , holdTwo + price ) ; holdTwo = Math . max ( holdTwo , sellOne - price ) ; sellOne = Math . max ( sellOne , holdOne + price ) ; holdOne = Math . max ( holdOne , - price ) ; } return sellTwo ; } }
class Solution { public int maximizeSweetness ( int [ ] sweetness , int k ) { int l = sweetness . length / ( k + 1 ) ; int r = Arrays . stream ( sweetness ) . sum ( ) / ( k + 1 ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( canEat ( sweetness , k , m ) ) l = m + 1 ; else r = m ; } return canEat ( sweetness , k , l ) ? l : l - 1 ; } private boolean canEat ( int [ ] sweetness , int k , int m ) { int pieces = 0 ; int sum = 0 ; for ( final int s : sweetness ) { sum += s ; if ( sum >= m ) { if ( ++ pieces > k ) return true ; sum = 0 ; } } return false ; } }
class Solution { public boolean checkStraightLine ( int [ ] [ ] coordinates ) { int x0 = coordinates [ 0 ] [ 0 ] ; int y0 = coordinates [ 0 ] [ 1 ] ; int x1 = coordinates [ 1 ] [ 0 ] ; int y1 = coordinates [ 1 ] [ 1 ] ; int dx = x1 - x0 ; int dy = y1 - y0 ; for ( int i = 2 ; i < coordinates . length ; ++ i ) { int x = coordinates [ i ] [ 0 ] ; int y = coordinates [ i ] [ 1 ] ; if ( ( x - x0 ) * dy != ( y - y0 ) * dx ) return false ; } return true ; } }
class Solution { public List < String > removeSubfolders ( String [ ] folder ) { List < String > ans = new ArrayList < > ( ) ; String prev = " " ; Arrays . sort ( folder ) ; for ( final String f : folder ) { if ( ! prev . isEmpty ( ) && f . startsWith ( prev ) && f . charAt ( prev . length ( ) ) == ' / ' ) continue ; ans . add ( f ) ; prev = f ; } return ans ; } }
class Solution { public int balancedString ( String s ) { final int n = s . length ( ) ; final int k = n / 4 ; int ans = n ; int [ ] count = new int [ 128 ] ; for ( final char c : s . toCharArray ( ) ) ++ count [ c ] ; for ( int i = 0 , j = 0 ; i < n ; ++ i ) { -- count [ s . charAt ( i ) ] ; while ( j < n && count [ ' Q ' ] <= k && count [ ' W ' ] <= k && count [ ' E ' ] <= k && count [ ' R ' ] <= k ) { ans = Math . min ( ans , i - j + 1 ) ; ++ count [ s . charAt ( j ) ] ; ++ j ; } } return ans ; } }
class Job { public int startTime ; public int endTime ; public int profit ; public Job ( int startTime , int endTime , int profit ) { this . startTime = startTime ; this . endTime = endTime ; this . profit = profit ; } } class Solution { public int jobScheduling ( int [ ] startTime , int [ ] endTime , int [ ] profit ) { final int n = startTime . length ; dp = new int [ n + 1 ] ; Job [ ] jobs = new Job [ n ] ; for ( int i = 0 ; i < n ; ++ i ) jobs [ i ] = new Job ( startTime [ i ] , endTime [ i ] , profit [ i ] ) ; Arrays . sort ( jobs , ( a , b ) -> a . startTime - b . startTime ) ; for ( int i = 0 ; i < n ; ++ i ) startTime [ i ] = jobs [ i ] . startTime ; return jobScheduling ( jobs , startTime , 0 ) ; } private int [ ] dp ; private int jobScheduling ( Job [ ] jobs , int [ ] startTime , int i ) { if ( i == jobs . length ) return 0 ; if ( dp [ i ] > 0 ) return dp [ i ] ; final int j = firstGreaterEqual ( startTime , i + 1 , jobs [ i ] . endTime ) ; final int choose = jobs [ i ] . profit + jobScheduling ( jobs , startTime , j ) ; final int skip = jobScheduling ( jobs , startTime , i + 1 ) ; return dp [ i ] = Math . max ( choose , skip ) ; } private int firstGreaterEqual ( int [ ] A , int startFrom , int target ) { int l = startFrom ; int r = A . length ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A [ m ] >= target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public List < String > crawl ( String startUrl , HtmlParser htmlParser ) { Queue < String > q = new ArrayDeque < > ( Arrays . asList ( startUrl ) ) ; Set < String > seen = new HashSet < > ( Arrays . asList ( startUrl ) ) ; final String hostname = startUrl . split ( " / " ) [ 2 ] ; while ( ! q . isEmpty ( ) ) { final String currUrl = q . poll ( ) ; for ( final String url : htmlParser . getUrls ( currUrl ) ) { if ( seen . contains ( url ) ) continue ; if ( url . contains ( hostname ) ) { q . offer ( url ) ; seen . add ( url ) ; } } } return new ArrayList < > ( seen ) ; } }
class Solution { public List < List < Integer > > findSolution ( CustomFunction customfunction , int z ) { List < List < Integer > > ans = new LinkedList < > ( ) ; int x = 1 ; int y = 1000 ; while ( x <= 1000 && y >= 1 ) { int f = customfunction . f ( x , y ) ; if ( f < z ) ++ x ; else if ( f > z ) -- y ; else ans . add ( Arrays . asList ( x ++ , y -- ) ) ; } return ans ; } }
class Solution { public List < Integer > circularPermutation ( int n , int start ) { List < Integer > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i < 1 << n ; ++ i ) ans . add ( start ^ i ^ i >> 1 ) ; return ans ; } }
class Solution { public int maxPathSum ( TreeNode root ) { maxPathSumDownFrom ( root ) ; return ans ; } private int ans = Integer . MIN_VALUE ; private int maxPathSumDownFrom ( TreeNode root ) { if ( root == null ) return 0 ; final int l = Math . max ( maxPathSumDownFrom ( root . left ) , 0 ) ; final int r = Math . max ( maxPathSumDownFrom ( root . right ) , 0 ) ; ans = Math . max ( ans , root . val + l + r ) ; return root . val + Math . max ( l , r ) ; } }
class Solution { public int tilingRectangle ( int n , int m ) { return tilingRectangle ( n , m , 0 , new int [ m ] ) ; } private static final int kBase = 13 ; private Map < Long , Integer > dp = new HashMap < > ( ) ; private int tilingRectangle ( int n , int m , long hashedHeights , int [ ] heights ) { if ( dp . containsKey ( hashedHeights ) ) return dp . get ( hashedHeights ) ; final int minHeight = Arrays . stream ( heights ) . min ( ) . getAsInt ( ) ; if ( minHeight == n ) return 0 ; int ans = m * n ; int start = - 1 ; for ( int i = 0 ; i < m ; ++ i ) if ( heights [ i ] == minHeight ) { start = i ; break ; } for ( int sz = 1 ; sz <= Math . min ( m - start , n - minHeight ) ; ++ sz ) { if ( heights [ start + sz - 1 ] != minHeight ) break ; for ( int i = start ; i < start + sz ; ++ i ) heights [ i ] += sz ; ans = Math . min ( ans , tilingRectangle ( n , m , hash ( heights ) , heights ) ) ; for ( int i = start ; i < start + sz ; ++ i ) heights [ i ] -= sz ; } dp . put ( hashedHeights , 1 + ans ) ; return 1 + ans ; } private long hash ( int [ ] heights ) { long hashed = 0 ; for ( int i = heights . length - 1 ; i >= 0 ; -- i ) hashed = hashed * kBase + heights [ i ] ; return hashed ; } }
class Leaderboard { public void addScore ( int playerId , int score ) { idToScore . put ( playerId , idToScore . getOrDefault ( playerId , 0 ) + score ) ; } public int top ( int K ) { int ans = 0 ; Queue < Integer > minHeap = new PriorityQueue < > ( ) ; for ( final int score : idToScore . values ( ) ) { minHeap . offer ( score ) ; if ( minHeap . size ( ) > K ) minHeap . poll ( ) ; } while ( ! minHeap . isEmpty ( ) ) ans += minHeap . poll ( ) ; return ans ; } public void reset ( int playerId ) { idToScore . remove ( playerId ) ; } private Map < Integer , Integer > idToScore = new HashMap < > ( ) ; }
class Solution { public int minimumMoves ( int [ ] arr ) { final int n = arr . length ; int [ ] [ ] dp = new int [ n ] [ n ] ; Arrays . stream ( dp ) . forEach ( A -> Arrays . fill ( A , n ) ) ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ] [ i ] = 1 ; for ( int i = 0 ; i + 1 < n ; ++ i ) dp [ i ] [ i + 1 ] = arr [ i ] == arr [ i + 1 ] ? 1 : 2 ; for ( int d = 2 ; d < n ; ++ d ) for ( int i = 0 ; i + d < n ; ++ i ) { final int j = i + d ; if ( arr [ i ] == arr [ j ] ) dp [ i ] [ j ] = dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; ++ k ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } return dp [ 0 ] [ n - 1 ] ; } }
class Solution { public int numberOfSubarrays ( int [ ] nums , int k ) { return numberOfSubarraysAtMost ( nums , k ) - numberOfSubarraysAtMost ( nums , k - 1 ) ; } private int numberOfSubarraysAtMost ( int [ ] nums , int k ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r <= nums . length ; ) if ( k >= 0 ) { ans += r - l ; if ( r == nums . length ) break ; if ( nums [ r ] % 2 == 1 ) -- k ; ++ r ; } else { if ( nums [ l ] % 2 == 1 ) ++ k ; ++ l ; } return ans ; } }
class Solution { public String minRemoveToMakeValid ( String s ) { Deque < Integer > stack = new ArrayDeque < > ( ) ; StringBuilder sb = new StringBuilder ( s ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( sb . charAt ( i ) == ' ( ' ) { stack . push ( i ) ; } else if ( sb . charAt ( i ) == ' ) ' ) { if ( stack . isEmpty ( ) ) sb . setCharAt ( i , ' # ' ) ; else stack . pop ( ) ; } while ( ! stack . isEmpty ( ) ) sb . setCharAt ( stack . pop ( ) , ' # ' ) ; return sb . toString ( ) . replaceAll ( " # " , " " ) ; } }
class Solution { public boolean isPalindrome ( String s ) { int l = 0 ; int r = s . length ( ) - 1 ; while ( l < r ) { while ( l < r && ! Character . isLetterOrDigit ( s . charAt ( l ) ) ) ++ l ; while ( l < r && ! Character . isLetterOrDigit ( s . charAt ( r ) ) ) -- r ; if ( Character . toLowerCase ( s . charAt ( l ) ) != Character . toLowerCase ( s . charAt ( r ) ) ) return false ; ++ l ; -- r ; } return true ; } }
class Solution { public int oddCells ( int m , int n , int [ ] [ ] indices ) { int ans = 0 ; boolean [ ] rows = new boolean [ n ] ; boolean [ ] cols = new boolean [ n ] ; for ( int [ ] index : indices ) { rows [ index [ 0 ] ] = rows [ index [ 0 ] ] ^ true ; cols [ index [ 1 ] ] = cols [ index [ 1 ] ] ^ true ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( rows [ i ] ^ cols [ j ] ) ++ ans ; return ans ; } }
class Solution { public List < List < Integer > > reconstructMatrix ( int upper , int lower , int [ ] colsum ) { if ( upper + lower != Arrays . stream ( colsum ) . sum ( ) ) return new ArrayList < > ( ) ; int count = 0 ; for ( int c : colsum ) if ( c == 2 ) ++ count ; if ( Math . min ( upper , lower ) < count ) return new ArrayList < > ( ) ; int [ ] [ ] ans = new int [ 2 ] [ colsum . length ] ; for ( int j = 0 ; j < colsum . length ; ++ j ) if ( colsum [ j ] == 2 ) { ans [ 0 ] [ j ] = 1 ; ans [ 1 ] [ j ] = 1 ; -- upper ; -- lower ; } for ( int j = 0 ; j < colsum . length ; ++ j ) { if ( colsum [ j ] == 1 && upper > 0 ) { ans [ 0 ] [ j ] = 1 ; -- colsum [ j ] ; -- upper ; } if ( colsum [ j ] == 1 && lower > 0 ) { ans [ 1 ] [ j ] = 1 ; -- lower ; } } return new ArrayList ( Arrays . asList ( ans [ 0 ] , ans [ 1 ] ) ) ; } }
class Solution { public int closedIsland ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( i * j == 0 || i == m - 1 || j == n - 1 ) if ( grid [ i ] [ j ] == 0 ) dfs ( grid , i , j ) ; int ans = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ] [ j ] == 0 ) { dfs ( grid , i , j ) ; ++ ans ; } return ans ; } private void dfs ( int [ ] [ ] grid , int i , int j ) { if ( i < 0 || i == grid . length || j < 0 || j == grid [ 0 ] . length ) return ; if ( grid [ i ] [ j ] == 1 ) return ; grid [ i ] [ j ] = 1 ; dfs ( grid , i + 1 , j ) ; dfs ( grid , i - 1 , j ) ; dfs ( grid , i , j + 1 ) ; dfs ( grid , i , j - 1 ) ; } }
class Solution { public int maxScoreWords ( String [ ] words , char [ ] letters , int [ ] score ) { int [ ] count = new int [ 26 ] ; for ( final char c : letters ) ++ count [ c - ' a ' ] ; return dfs ( words , 0 , count , score ) ; } private int dfs ( String [ ] words , int s , int [ ] count , int [ ] score ) { int ans = 0 ; for ( int i = s ; i < words . length ; ++ i ) { final int earned = useWord ( words , i , count , score ) ; if ( earned > 0 ) ans = Math . max ( ans , earned + dfs ( words , i + 1 , count , score ) ) ; unuseWord ( words , i , count ) ; } return ans ; } int useWord ( String [ ] words , int i , int [ ] count , int [ ] score ) { boolean isValid = true ; int earned = 0 ; for ( final char c : words [ i ] . toCharArray ( ) ) { if ( -- count [ c - ' a ' ] < 0 ) isValid = false ; earned += score [ c - ' a ' ] ; } return isValid ? earned : - 1 ; } void unuseWord ( String [ ] words , int i , int [ ] count ) { for ( final char c : words [ i ] . toCharArray ( ) ) ++ count [ c - ' a ' ] ; } }
class Solution { public int numberOfWays ( int numPeople ) { final long kMod = 1_000_000_007 ; long [ ] dp = new long [ numPeople / 2 + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= numPeople / 2 ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { dp [ i ] += dp [ j ] * dp [ i - 1 - j ] ; dp [ i ] %= kMod ; } return ( int ) dp [ numPeople / 2 ] ; } }
class Solution { public List < List < String > > findLadders ( String beginWord , String endWord , List < String > wordList ) { Set < String > wordSet = new HashSet < > ( wordList ) ; if ( ! wordSet . contains ( endWord ) ) return new ArrayList < > ( ) ; Map < String , List < String > > graph = new HashMap < > ( ) ; if ( ! bfs ( beginWord , endWord , wordSet , graph ) ) return new ArrayList < > ( ) ; List < List < String > > ans = new ArrayList < > ( ) ; List < String > path = new ArrayList < > ( Arrays . asList ( beginWord ) ) ; dfs ( graph , beginWord , endWord , path , ans ) ; return ans ; } private boolean bfs ( final String beginWord , final String endWord , Set < String > wordSet , Map < String , List < String > > graph ) { Set < String > currentLevelWords = new HashSet < > ( ) ; currentLevelWords . add ( beginWord ) ; boolean reachEndWord = false ; while ( ! currentLevelWords . isEmpty ( ) ) { for ( final String word : currentLevelWords ) wordSet . remove ( word ) ; Set < String > nextLevelWords = new HashSet < > ( ) ; for ( final String parent : currentLevelWords ) { graph . putIfAbsent ( parent , new ArrayList < > ( ) ) ; for ( final String child : getChildren ( parent , wordSet ) ) { if ( wordSet . contains ( child ) ) { nextLevelWords . add ( child ) ; graph . get ( parent ) . add ( child ) ; } if ( child . equals ( endWord ) ) reachEndWord = true ; } } if ( reachEndWord ) return true ; currentLevelWords = nextLevelWords ; } return false ; } private List < String > getChildren ( final String parent , Set < String > wordSet ) { List < String > children = new ArrayList < > ( ) ; StringBuilder sb = new StringBuilder ( parent ) ; for ( int i = 0 ; i < sb . length ( ) ; ++ i ) { final char cache = sb . charAt ( i ) ; for ( char c = ' a ' ; c <= ' z ' ; ++ c ) { if ( c == cache ) continue ; sb . setCharAt ( i , c ) ; final String child = sb . toString ( ) ; if ( wordSet . contains ( child ) ) children . add ( child ) ; } sb . setCharAt ( i , cache ) ; } return children ; } private void dfs ( Map < String , List < String > > graph , final String word , final String endWord , List < String > path , List < List < String > > ans ) { if ( word . equals ( endWord ) ) { ans . add ( new ArrayList < > ( path ) ) ; return ; } if ( ! graph . containsKey ( word ) ) return ; for ( final String child : graph . get ( word ) ) { path . add ( child ) ; dfs ( graph , child , endWord , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; } } }
class Solution { public List < List < Integer > > shiftGrid ( int [ ] [ ] grid , int k ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; List < List < Integer > > ans = new ArrayList < > ( ) ; int [ ] [ ] arr = new int [ m ] [ n ] ; k %= m * n ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int index = ( i * n + j + k ) % ( m * n ) ; int x = index / n ; int y = index % n ; arr [ x ] [ y ] = grid [ i ] [ j ] ; } for ( int [ ] row : arr ) ans . add ( Arrays . stream ( row ) . boxed ( ) . collect ( Collectors . toList ( ) ) ) ; return ans ; } }
class FindElements { public FindElements ( TreeNode root ) { dfs ( root , 0 ) ; } public boolean find ( int target ) { return vals . contains ( target ) ; } private Set < Integer > vals = new HashSet < > ( ) ; private void dfs ( TreeNode root , int val ) { if ( root == null ) return ; root . val = val ; vals . add ( val ) ; dfs ( root . left , val * 2 + 1 ) ; dfs ( root . right , val * 2 + 2 ) ; } }
class Solution { public int minPushBox ( char [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int [ ] box = { - 1 , - 1 } ; int [ ] player = { - 1 , - 1 } ; int [ ] target = { - 1 , - 1 } ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ] [ j ] == ' B ' ) box = new int [ ] { i , j } ; else if ( grid [ i ] [ j ] == ' S ' ) player = new int [ ] { i , j } ; else if ( grid [ i ] [ j ] == ' T ' ) target = new int [ ] { i , j } ; int ans = 0 ; Queue < int [ ] > q = new ArrayDeque < > ( Arrays . asList ( new int [ ] { box [ 0 ] , box [ 1 ] , player [ 0 ] , player [ 1 ] } ) ) ; boolean [ ] [ ] [ ] [ ] seen = new boolean [ m ] [ n ] [ m ] [ n ] ; seen [ box [ 0 ] ] [ box [ 1 ] ] [ player [ 0 ] ] [ player [ 1 ] ] = true ; while ( ! q . isEmpty ( ) ) { for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int boxX = q . peek ( ) [ 0 ] ; final int boxY = q . peek ( ) [ 1 ] ; final int playerX = q . peek ( ) [ 2 ] ; final int playerY = q . poll ( ) [ 3 ] ; if ( boxX == target [ 0 ] && boxY == target [ 1 ] ) return ans ; for ( int k = 0 ; k < 4 ; ++ k ) { final int nextBoxX = boxX + dirs [ k ] ; final int nextBoxY = boxY + dirs [ k + 1 ] ; if ( isInvalid ( grid , nextBoxX , nextBoxY ) ) continue ; if ( seen [ nextBoxX ] [ nextBoxY ] [ boxX ] [ boxY ] ) continue ; final int fromX = boxX + dirs [ ( k + 2 ) % 4 ] ; final int fromY = boxY + dirs [ ( k + 3 ) % 4 ] ; if ( isInvalid ( grid , fromX , fromY ) ) continue ; if ( canGoTo ( grid , playerX , playerY , fromX , fromY , boxX , boxY ) ) { seen [ nextBoxX ] [ nextBoxY ] [ boxX ] [ boxY ] = true ; q . offer ( new int [ ] { nextBoxX , nextBoxY , boxX , boxY } ) ; } } } ++ ans ; } return - 1 ; } private static final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; private boolean canGoTo ( char [ ] [ ] grid , int playerX , int playerY , int fromX , int fromY , int boxX , int boxY ) { Queue < Pair < Integer , Integer > > q = new ArrayDeque < > ( Arrays . asList ( new Pair < > ( playerX , playerY ) ) ) ; boolean [ ] [ ] seen = new boolean [ grid . length ] [ grid [ 0 ] . length ] ; seen [ playerX ] [ playerY ] = true ; while ( ! q . isEmpty ( ) ) { final int i = q . peek ( ) . getKey ( ) ; final int j = q . poll ( ) . getValue ( ) ; if ( i == fromX && j == fromY ) return true ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( isInvalid ( grid , x , y ) ) continue ; if ( seen [ x ] [ y ] ) continue ; if ( x == boxX && y == boxY ) continue ; q . offer ( new Pair < > ( x , y ) ) ; seen [ x ] [ y ] = true ; } } return false ; } private boolean isInvalid ( char [ ] [ ] grid , int playerX , int playerY ) { return playerX < 0 || playerX == grid . length || playerY < 0 || playerY == grid [ 0 ] . length || grid [ playerX ] [ playerY ] == ' # ' ; } }
class Solution { public int minTimeToVisitAllPoints ( int [ ] [ ] points ) { int ans = 0 ; for ( int i = 1 ; i < points . length ; ++ i ) ans += Math . max ( Math . abs ( points [ i ] [ 0 ] - points [ i - 1 ] [ 0 ] ) , Math . abs ( points [ i ] [ 1 ] - points [ i - 1 ] [ 1 ] ) ) ; return ans ; } }
class Solution { public int countServers ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int ans = 0 ; int [ ] rows = new int [ m ] ; int [ ] cols = new int [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ] [ j ] == 1 ) { ++ rows [ i ] ; ++ cols [ j ] ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ] [ j ] == 1 && ( rows [ i ] > 1 || cols [ j ] > 1 ) ) ++ ans ; return ans ; } }
class Solution { public int numWays ( int steps , int arrLen ) { final int kMod = 1_000_000_007 ; final int n = Math . min ( arrLen , steps / 2 + 1 ) ; long [ ] dp = new long [ n ] ; dp [ 0 ] = 1 ; while ( steps -- > 0 ) { long [ ] newDp = new long [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { newDp [ i ] = dp [ i ] ; if ( i - 1 >= 0 ) newDp [ i ] += dp [ i - 1 ] ; if ( i + 1 < n ) newDp [ i ] += dp [ i + 1 ] ; newDp [ i ] %= kMod ; } dp = newDp ; } return ( int ) dp [ 0 ] ; } }
class Solution { public int ladderLength ( String beginWord , String endWord , List < String > wordList ) { Set < String > wordSet = new HashSet < > ( wordList ) ; if ( ! wordSet . contains ( endWord ) ) return 0 ; int ans = 0 ; Queue < String > q = new ArrayDeque < > ( Arrays . asList ( beginWord ) ) ; while ( ! q . isEmpty ( ) ) { ++ ans ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { StringBuilder sb = new StringBuilder ( q . poll ( ) ) ; for ( int i = 0 ; i < sb . length ( ) ; ++ i ) { final char cache = sb . charAt ( i ) ; for ( char c = ' a ' ; c <= ' z ' ; ++ c ) { sb . setCharAt ( i , c ) ; final String word = sb . toString ( ) ; if ( word . equals ( endWord ) ) return ans + 1 ; if ( wordSet . contains ( word ) ) { q . offer ( word ) ; wordSet . remove ( word ) ; } } sb . setCharAt ( i , cache ) ; } } } return 0 ; } }
class Solution { public int countShips ( Sea sea , int [ ] topRight , int [ ] bottomLeft ) { if ( topRight [ 0 ] < bottomLeft [ 0 ] || topRight [ 1 ] < bottomLeft [ 1 ] ) return 0 ; if ( ! sea . hasShips ( topRight , bottomLeft ) ) return 0 ; if ( topRight [ 0 ] == bottomLeft [ 0 ] && topRight [ 1 ] == bottomLeft [ 1 ] ) return 1 ; final int mx = ( topRight [ 0 ] + bottomLeft [ 0 ] ) / 2 ; final int my = ( topRight [ 1 ] + bottomLeft [ 1 ] ) / 2 ; int ans = 0 ; ans += countShips ( sea , topRight , new int [ ] { mx + 1 , my + 1 } ) ; ans += countShips ( sea , new int [ ] { topRight [ 0 ] , my } , new int [ ] { mx + 1 , bottomLeft [ 1 ] } ) ; ans += countShips ( sea , new int [ ] { mx , topRight [ 1 ] } , new int [ ] { bottomLeft [ 0 ] , my + 1 } ) ; ans += countShips ( sea , new int [ ] { mx , my } , bottomLeft ) ; return ans ; } }
class Solution { public String tictactoe ( int [ ] [ ] moves ) { int [ ] [ ] row = new int [ 2 ] [ 3 ] ; int [ ] [ ] col = new int [ 2 ] [ 3 ] ; int [ ] diag1 = new int [ 2 ] ; int [ ] diag2 = new int [ 2 ] ; for ( int i = 0 ; i < moves . length ; ++ i ) { int r = moves [ i ] [ 0 ] ; int c = moves [ i ] [ 1 ] ; int j = i % 2 ; if ( ++ row [ j ] [ r ] == 3 || ++ col [ j ] [ c ] == 3 || r == c && ++ diag1 [ j ] == 3 || r + c == 2 && ++ diag2 [ j ] == 3 ) return j == 0 ? " A " : " B " ; } return moves . length == 9 ? " Draw " : " Pending " ; } }
class Solution { public List < Integer > numOfBurgers ( int tomatoSlices , int cheeseSlices ) { if ( tomatoSlices % 2 == 1 || tomatoSlices < 2 * cheeseSlices || tomatoSlices > cheeseSlices * 4 ) return new ArrayList < > ( ) ; int jumboBurgers = ( tomatoSlices - 2 * cheeseSlices ) / 2 ; return new ArrayList < > ( Arrays . asList ( jumboBurgers , cheeseSlices - jumboBurgers ) ) ; } }
class Solution { public int countSquares ( int [ ] [ ] matrix ) { int ans = 0 ; for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) { if ( matrix [ i ] [ j ] == 1 && i > 0 && j > 0 ) matrix [ i ] [ j ] += Math . min ( matrix [ i - 1 ] [ j - 1 ] , Math . min ( matrix [ i - 1 ] [ j ] , matrix [ i ] [ j - 1 ] ) ) ; ans += matrix [ i ] [ j ] ; } return ans ; } }
class Solution { public int longestConsecutive ( int [ ] nums ) { int ans = 0 ; Set < Integer > seen = Arrays . stream ( nums ) . boxed ( ) . collect ( Collectors . toSet ( ) ) ; for ( int num : nums ) { if ( seen . contains ( num - 1 ) ) continue ; int length = 1 ; while ( seen . contains ( ++ num ) ) ++ length ; ans = Math . max ( ans , length ) ; } return ans ; } }
class Solution { public int subtractProductAndSum ( int n ) { int prod = 1 ; int summ = 0 ; for ( ; n > 0 ; n /= 10 ) { prod *= n % 10 ; summ += n % 10 ; } return prod - summ ; } }
class Solution { public int minFlips ( int [ ] [ ] mat ) { final int m = mat . length ; final int n = mat [ 0 ] . length ; final int hashed = hash ( mat , m , n ) ; if ( hashed == 0 ) return 0 ; final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; Queue < Integer > q = new ArrayDeque < > ( Arrays . asList ( hashed ) ) ; Set < Integer > seen = new HashSet < > ( Arrays . asList ( hashed ) ) ; for ( int step = 1 ; ! q . isEmpty ( ) ; ++ step ) { for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int curr = q . poll ( ) ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { int next = curr ^ 1 << ( i * n + j ) ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; next ^= 1 << ( x * n + y ) ; } if ( next == 0 ) return step ; if ( seen . contains ( next ) ) continue ; q . offer ( next ) ; seen . add ( next ) ; } } } } return - 1 ; } private int hash ( int [ ] [ ] mat , int m , int n ) { int hashed = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( mat [ i ] [ j ] == 1 ) hashed |= 1 << ( i * n + j ) ; return hashed ; } }
class Solution { public int findSpecialInteger ( int [ ] arr ) { final int n = arr . length ; final int quarter = n / 4 ; for ( int i = 0 ; i < n - quarter ; ++ i ) if ( arr [ i ] == arr [ i + quarter ] ) return arr [ i ] ; throw new IllegalArgumentException ( ) ; } }
class Solution { public int minFallingPathSum ( int [ ] [ ] grid ) { final int n = grid . length ; for ( int i = 1 ; i < n ; ++ i ) { Pair < Integer , Integer > [ ] twoMinNumAndIndexs = getTwoMinNumAndIndexs ( grid [ i - 1 ] ) ; final int firstMinNum = twoMinNumAndIndexs [ 0 ] . getKey ( ) ; final int firstMinIndex = twoMinNumAndIndexs [ 0 ] . getValue ( ) ; final int secondMinNum = twoMinNumAndIndexs [ 1 ] . getKey ( ) ; for ( int j = 0 ; j < n ; ++ j ) if ( j == firstMinIndex ) grid [ i ] [ j ] += secondMinNum ; else grid [ i ] [ j ] += firstMinNum ; } return Arrays . stream ( grid [ n - 1 ] ) . min ( ) . getAsInt ( ) ; } private Pair < Integer , Integer > [ ] getTwoMinNumAndIndexs ( int [ ] A ) { List < Pair < Integer , Integer > > numAndIndexs = new ArrayList < > ( ) ; for ( int i = 0 ; i < A . length ; ++ i ) numAndIndexs . add ( new Pair < > ( A [ i ] , i ) ) ; Collections . sort ( numAndIndexs , ( a , b ) -> a . getKey ( ) - b . getKey ( ) ) ; return new Pair [ ] { numAndIndexs . get ( 0 ) , numAndIndexs . get ( 1 ) } ; } }
class Solution { public int sumNumbers ( TreeNode root ) { dfs ( root , 0 ) ; return ans ; } private int ans = 0 ; private void dfs ( TreeNode root , int path ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { ans += path * 10 + root . val ; return ; } dfs ( root . left , path * 10 + root . val ) ; dfs ( root . right , path * 10 + root . val ) ; } }
class Solution { public int getDecimalValue ( ListNode head ) { int ans = 0 ; for ( ; head != null ; head = head . next ) ans = ans * 2 + head . val ; return ans ; } }
class Solution { public int maxSideLength ( int [ ] [ ] mat , int threshold ) { final int m = mat . length ; final int n = mat [ 0 ] . length ; int ans = 0 ; int [ ] [ ] prefix = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) prefix [ i + 1 ] [ j + 1 ] = mat [ i ] [ j ] + prefix [ i ] [ j + 1 ] + prefix [ i + 1 ] [ j ] - prefix [ i ] [ j ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) for ( int length = ans ; length < Math . min ( m - i , n - j ) ; ++ length ) { if ( squareSum ( prefix , i , j , i + length , j + length ) > threshold ) break ; ans = Math . max ( ans , length + 1 ) ; } return ans ; } private int squareSum ( int [ ] [ ] prefix , int r1 , int c1 , int r2 , int c2 ) { return prefix [ r2 + 1 ] [ c2 + 1 ] - prefix [ r1 ] [ c2 + 1 ] - prefix [ r2 + 1 ] [ c1 ] + prefix [ r1 ] [ c1 ] ; } }
class T { public int i ; public int j ; public int eliminate ; public T ( int i , int j , int eliminate ) { this . i = i ; this . j = j ; this . eliminate = eliminate ; } } class Solution { public int shortestPath ( int [ ] [ ] grid , int k ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; if ( m == 1 && n == 1 ) return 0 ; final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; int steps = 0 ; Queue < T > q = new ArrayDeque < > ( ) ; q . offer ( new T ( 0 , 0 , k ) ) ; boolean [ ] [ ] [ ] seen = new boolean [ m ] [ n ] [ k + 1 ] ; seen [ 0 ] [ 0 ] [ k ] = true ; while ( ! q . isEmpty ( ) ) { ++ steps ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int i = q . peek ( ) . i ; final int j = q . peek ( ) . j ; final int eliminate = q . poll ( ) . eliminate ; for ( int l = 0 ; l < 4 ; ++ l ) { final int x = i + dirs [ l ] ; final int y = j + dirs [ l + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( x == m - 1 && y == n - 1 ) return steps ; if ( grid [ x ] [ y ] == 1 && eliminate == 0 ) continue ; final int newEliminate = eliminate - grid [ x ] [ y ] ; if ( seen [ x ] [ y ] [ newEliminate ] ) continue ; q . offer ( new T ( x , y , newEliminate ) ) ; seen [ x ] [ y ] [ newEliminate ] = true ; } } } return - 1 ; } }
class Solution { public int findNumbers ( int [ ] nums ) { int ans = 0 ; for ( int num : nums ) if ( 9 < num && num < 100 || 999 < num && num < 10000 || num == 100000 ) ++ ans ; return ans ; } }
class Solution { public boolean isPossibleDivide ( int [ ] nums , int k ) { TreeMap < Integer , Integer > count = new TreeMap < > ( ) ; for ( final int num : nums ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ) ; for ( final int start : count . keySet ( ) ) { final int value = count . getOrDefault ( start , 0 ) ; if ( value > 0 ) for ( int i = start ; i < start + k ; ++ i ) { count . put ( i , count . getOrDefault ( i , 0 ) - value ) ; if ( count . get ( i ) < 0 ) return false ; } } return true ; } }
class Solution { public int maxCandies ( int [ ] status , int [ ] candies , int [ ] [ ] keys , int [ ] [ ] containedBoxes , int [ ] initialBoxes ) { int ans = 0 ; Queue < Integer > q = new ArrayDeque < > ( ) ; boolean [ ] reachedClosedBoxes = new boolean [ status . length ] ; pushBoxesIfPossible ( initialBoxes , status , q , reachedClosedBoxes ) ; while ( ! q . isEmpty ( ) ) { final int currBox = q . poll ( ) ; ans += candies [ currBox ] ; for ( final int key : keys [ currBox ] ) { if ( status [ key ] == 0 && reachedClosedBoxes [ key ] ) q . offer ( key ) ; status [ key ] = 1 ; } pushBoxesIfPossible ( containedBoxes [ currBox ] , status , q , reachedClosedBoxes ) ; } return ans ; } private void pushBoxesIfPossible ( int [ ] boxes , int [ ] status , Queue < Integer > q , boolean [ ] reachedClosedBoxes ) { for ( final int box : boxes ) if ( status [ box ] == 1 ) q . offer ( box ) ; else reachedClosedBoxes [ box ] = true ; } }
class Solution { public int [ ] replaceElements ( int [ ] arr ) { int maxOfRight = - 1 ; for ( int i = arr . length - 1 ; i >= 0 ; -- i ) { int a = arr [ i ] ; arr [ i ] = maxOfRight ; maxOfRight = Math . max ( maxOfRight , a ) ; } return arr ; } }
class Solution { public int romanToInt ( String s ) { int ans = 0 ; int [ ] roman = new int [ 128 ] ; roman [ ' I ' ] = 1 ; roman [ ' V ' ] = 5 ; roman [ ' X ' ] = 10 ; roman [ ' L ' ] = 50 ; roman [ ' C ' ] = 100 ; roman [ ' D ' ] = 500 ; roman [ ' M ' ] = 1000 ; for ( int i = 0 ; i + 1 < s . length ( ) ; ++ i ) if ( roman [ s . charAt ( i ) ] < roman [ s . charAt ( i + 1 ) ] ) ans -= roman [ s . charAt ( i ) ] ; else ans += roman [ s . charAt ( i ) ] ; return ans + roman [ s . charAt ( s . length ( ) - 1 ) ] ; } }
class Solution { public void solve ( char [ ] [ ] board ) { if ( board . length == 0 ) return ; final int m = board . length ; final int n = board [ 0 ] . length ; final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; Queue < int [ ] > q = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( i * j == 0 || i == m - 1 || j == n - 1 ) if ( board [ i ] [ j ] == ' O ' ) { q . offer ( new int [ ] { i , j } ) ; board [ i ] [ j ] = ' * ' ; } while ( ! q . isEmpty ( ) ) { final int i = q . peek ( ) [ 0 ] ; final int j = q . poll ( ) [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( board [ x ] [ y ] != ' O ' ) continue ; q . offer ( new int [ ] { x , y } ) ; board [ x ] [ y ] = ' * ' ; } } for ( char [ ] row : board ) for ( int i = 0 ; i < row . length ; ++ i ) if ( row [ i ] == ' * ' ) row [ i ] = ' O ' ; else if ( row [ i ] == ' O ' ) row [ i ] = ' X ' ; } }
class Solution { public int findBestValue ( int [ ] arr , int target ) { final int n = arr . length ; final double err = 1e-9 ; int prefix = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; ++ i ) { int ans = ( int ) Math . round ( ( ( float ) target - prefix - err ) / ( n - i ) ) ; if ( ans <= arr [ i ] ) return ans ; prefix += arr [ i ] ; } return arr [ n - 1 ] ; } }
class Solution { public int [ ] pathsWithMaxScore ( List < String > board ) { final int kMod = 1_000_000_007 ; final int n = board . size ( ) ; final int [ ] [ ] dirs = { { 0 , 1 } , { 1 , 0 } , { 1 , 1 } } ; int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; Arrays . stream ( dp ) . forEach ( A -> Arrays . fill ( A , - 1 ) ) ; int [ ] [ ] count = new int [ n + 1 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = 0 ; dp [ n - 1 ] [ n - 1 ] = 0 ; count [ n - 1 ] [ n - 1 ] = 1 ; for ( int i = n - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { if ( board . get ( i ) . charAt ( j ) == ' S ' || board . get ( i ) . charAt ( j ) == ' X ' ) continue ; for ( int [ ] dir : dirs ) { final int x = i + dir [ 0 ] ; final int y = j + dir [ 1 ] ; if ( dp [ i ] [ j ] < dp [ x ] [ y ] ) { dp [ i ] [ j ] = dp [ x ] [ y ] ; count [ i ] [ j ] = count [ x ] [ y ] ; } else if ( dp [ i ] [ j ] == dp [ x ] [ y ] ) { count [ i ] [ j ] += count [ x ] [ y ] ; count [ i ] [ j ] %= kMod ; } } if ( dp [ i ] [ j ] != - 1 && board . get ( i ) . charAt ( j ) != ' E ' ) { dp [ i ] [ j ] += board . get ( i ) . charAt ( j ) - '0' ; dp [ i ] [ j ] %= kMod ; } } return new int [ ] { dp [ 0 ] [ 0 ] , count [ 0 ] [ 0 ] } ; } }
class Solution { public int [ ] sumZero ( int n ) { int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = i * 2 - n + 1 ; return ans ; } }
class Solution { public boolean isSolvable ( String [ ] words , String result ) { rows = words . length + 1 ; for ( final String word : words ) cols = Math . max ( cols , word . length ( ) ) ; cols = Math . max ( cols , result . length ( ) ) ; return dfs ( words , result , 0 , 0 , 0 ) ; } private Map < Character , Integer > letterToDigit = new HashMap < > ( ) ; private boolean [ ] usedDigit = new boolean [ 10 ] ; private int rows = 0 ; private int cols = 0 ; private boolean dfs ( String [ ] words , String result , int row , int col , int sum ) { if ( col == cols ) return sum == 0 ; if ( row == rows ) return sum % 10 == 0 && dfs ( words , result , 0 , col + 1 , sum / 10 ) ; String word = row == rows - 1 ? result : words [ row ] ; if ( col >= word . length ( ) ) return dfs ( words , result , row + 1 , col , sum ) ; char letter = word . charAt ( word . length ( ) - col - 1 ) ; int sign = row == rows - 1 ? - 1 : 1 ; if ( letterToDigit . containsKey ( letter ) && ( letterToDigit . get ( letter ) > 0 || col < word . length ( ) - 1 ) ) return dfs ( words , result , row + 1 , col , sum + sign * letterToDigit . get ( letter ) ) ; for ( int digit = 0 ; digit < 10 ; ++ digit ) if ( ! usedDigit [ digit ] && ( digit > 0 || col < word . length ( ) - 1 ) ) { letterToDigit . put ( letter , digit ) ; usedDigit [ digit ] = true ; if ( dfs ( words , result , row + 1 , col , sum + sign * letterToDigit . get ( letter ) ) ) return true ; usedDigit [ digit ] = false ; letterToDigit . remove ( letter ) ; } return false ; } }
class Solution { public String freqAlphabets ( String s ) { String ans = " " ; for ( int i = 0 ; i < s . length ( ) ; ) { if ( i + 2 < s . length ( ) && s . charAt ( i + 2 ) == ' # ' ) { ans += ( char ) ( Integer . valueOf ( s . substring ( i , i + 2 ) ) + ' a ' - 1 ) ; i += 3 ; } else { ans += ( char ) ( ( s . charAt ( i ) - '0' ) + ' a ' - 1 ) ; i += 1 ; } } return ans ; } }
class Solution { public List < List < String > > partition ( String s ) { List < List < String > > ans = new ArrayList < > ( ) ; dfs ( s , 0 , new ArrayList < > ( ) , ans ) ; return ans ; } private void dfs ( final String s , int start , List < String > path , List < List < String > > ans ) { if ( start == s . length ( ) ) { ans . add ( new ArrayList < > ( path ) ) ; return ; } for ( int i = start ; i < s . length ( ) ; ++ i ) if ( isPalindrome ( s , start , i ) ) { path . add ( s . substring ( start , i + 1 ) ) ; dfs ( s , i + 1 , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; } } private boolean isPalindrome ( final String s , int l , int r ) { while ( l < r ) if ( s . charAt ( l ++ ) != s . charAt ( r -- ) ) return false ; return true ; } }
class Solution { public int [ ] xorQueries ( int [ ] arr , int [ ] [ ] queries ) { int [ ] ans = new int [ queries . length ] ; int [ ] xors = new int [ arr . length + 1 ] ; for ( int i = 0 ; i < arr . length ; ++ i ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ] ; int i = 0 ; for ( int [ ] q : queries ) ans [ i ++ ] = xors [ q [ 0 ] ] ^ xors [ q [ 1 ] + 1 ] ; return ans ; } }
class Solution { public List < String > watchedVideosByFriends ( List < List < String > > watchedVideos , int [ ] [ ] friends , int id , int level ) { boolean [ ] visited = new boolean [ friends . length ] ; visited [ id ] = true ; Queue < Integer > queue = new ArrayDeque < > ( ) ; queue . add ( id ) ; Map < String , Integer > count = new HashMap < > ( ) ; for ( int i = 0 ; i < level ; ++ i ) for ( int j = queue . size ( ) ; j > 0 ; -- j ) { for ( int friend : friends [ queue . peek ( ) ] ) if ( visited [ friend ] == false ) { visited [ friend ] = true ; queue . add ( friend ) ; } queue . poll ( ) ; } for ( int friend : queue ) for ( final String video : watchedVideos . get ( friend ) ) count . put ( video , count . getOrDefault ( video , 0 ) + 1 ) ; List < String > ans = new ArrayList < > ( count . keySet ( ) ) ; ans . sort ( ( a , b ) -> count . get ( a ) == count . get ( b ) ? a . compareTo ( b ) : count . get ( a ) - count . get ( b ) ) ; return ans ; } }
class Solution { public int minInsertions ( String s ) { return s . length ( ) - longestPalindromeSubseq ( s ) ; } public int longestPalindromeSubseq ( String s ) { final int n = s . length ( ) ; int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ] [ i ] = 1 ; for ( int d = 1 ; d < n ; ++ d ) for ( int i = 0 ; i + d < n ; ++ i ) { final int j = i + d ; if ( s . charAt ( i ) == s . charAt ( j ) ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } return dp [ 0 ] [ n - 1 ] ; } }
class Solution { public int [ ] decompressRLElist ( int [ ] nums ) { List < Integer > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i < nums . length ; i += 2 ) for ( int freq = 0 ; freq < nums [ i ] ; ++ freq ) ans . add ( nums [ i + 1 ] ) ; return ans . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; } }
class Solution { public int distinctEchoSubstrings ( String text ) { Set < String > seen = new HashSet < > ( ) ; for ( int k = 1 ; k <= text . length ( ) / 2 ; ++ k ) { int same = 0 ; for ( int l = 0 , r = k ; r < text . length ( ) ; ++ l , ++ r ) { if ( text . charAt ( l ) == text . charAt ( r ) ) ++ same ; else same = 0 ; if ( same == k ) { seen . add ( text . substring ( l - k + 1 , l + 1 ) ) ; -- same ; } } } return seen . size ( ) ; } }
class Solution { public int [ ] getNoZeroIntegers ( int n ) { for ( int A = 1 ; A < n ; ++ A ) { int B = n - A ; if ( ! String . valueOf ( A ) . contains ( "0" ) && ! String . valueOf ( B ) . contains ( "0" ) ) return new int [ ] { A , B } ; } throw new IllegalArgumentException ( ) ; } }
class Solution { public int minCut ( String s ) { final int n = s . length ( ) ; boolean [ ] [ ] isPalindrome = new boolean [ n ] [ n ] ; for ( boolean [ ] row : isPalindrome ) Arrays . fill ( row , true ) ; int [ ] dp = new int [ n ] ; Arrays . fill ( dp , n ) ; for ( int l = 2 ; l <= n ; ++ l ) for ( int i = 0 , j = l - 1 ; j < n ; ++ i , ++ j ) isPalindrome [ i ] [ j ] = s . charAt ( i ) == s . charAt ( j ) && isPalindrome [ i + 1 ] [ j - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) { if ( isPalindrome [ 0 ] [ i ] ) { dp [ i ] = 0 ; continue ; } for ( int j = 0 ; j < i ; ++ j ) if ( isPalindrome [ j + 1 ] [ i ] ) dp [ i ] = Math . min ( dp [ i ] , dp [ j ] + 1 ) ; } return dp [ n - 1 ] ; } }
class Solution { public int minimumDistance ( String word ) { dp = new Integer [ 27 ] [ 27 ] [ word . length ( ) ] ; return minimumDistance ( word , 26 , 26 , 0 ) ; } private Integer [ ] [ ] [ ] dp ; int minimumDistance ( final String word , int i , int j , int k ) { if ( k == word . length ( ) ) return 0 ; if ( dp [ i ] [ j ] [ k ] != null ) return dp [ i ] [ j ] [ k ] ; final int next = word . charAt ( k ) - ' A ' ; final int moveLeft = dist ( i , next ) + minimumDistance ( word , next , j , k + 1 ) ; final int moveRight = dist ( j , next ) + minimumDistance ( word , i , next , k + 1 ) ; return dp [ i ] [ j ] [ k ] = Math . min ( moveLeft , moveRight ) ; } int dist ( int a , int b ) { if ( a == 26 ) return 0 ; final int x1 = a / 6 ; final int y1 = a % 6 ; final int x2 = b / 6 ; final int y2 = b % 6 ; return Math . abs ( x1 - x2 ) + Math . abs ( y1 - y2 ) ; } }
class Solution { public int maximum69Number ( int num ) { char [ ] ans = String . valueOf ( num ) . toCharArray ( ) ; for ( int i = 0 ; i < ans . length ; ++ i ) if ( ans [ i ] == '6' ) { ans [ i ] = '9' ; break ; } return Integer . valueOf ( String . valueOf ( ans ) ) ; } }
class Solution { public int minTaps ( int n , int [ ] ranges ) { int [ ] nums = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) { int l = Math . max ( 0 , i - ranges [ i ] ) ; int r = Math . min ( n , i + ranges [ i ] ) ; nums [ l ] = Math . max ( nums [ l ] , r - l ) ; } int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { farthest = Math . max ( farthest , i + nums [ i ] ) ; if ( i == end ) { ++ ans ; end = farthest ; } } return end == n ? ans : - 1 ; } }
class Solution { public int [ ] [ ] diagonalSort ( int [ ] [ ] mat ) { final int m = mat . length ; final int n = mat [ 0 ] . length ; Map < Integer , Queue < Integer > > count = new HashMap < > ( ) ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) count . computeIfAbsent ( i - j , k -> new PriorityQueue < > ( ) ) . add ( mat [ i ] [ j ] ) ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) mat [ i ] [ j ] = count . get ( i - j ) . poll ( ) ; return mat ; } }
class Solution { public Node cloneGraph ( Node node ) { if ( node == null ) return null ; Queue < Node > q = new ArrayDeque < > ( Arrays . asList ( node ) ) ; Map < Node , Node > map = new HashMap < > ( ) ; map . put ( node , new Node ( node . val ) ) ; while ( ! q . isEmpty ( ) ) { Node u = q . poll ( ) ; for ( Node v : u . neighbors ) { if ( ! map . containsKey ( v ) ) { map . put ( v , new Node ( v . val ) ) ; q . offer ( v ) ; } map . get ( u ) . neighbors . add ( map . get ( v ) ) ; } } return map . get ( node ) ; } }
class Solution { public int maxValueAfterReverse ( int [ ] nums ) { int total = 0 ; int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { int a = nums [ i ] ; int b = nums [ i + 1 ] ; total += Math . abs ( a - b ) ; min = Math . min ( min , Math . max ( a , b ) ) ; max = Math . max ( max , Math . min ( a , b ) ) ; } int diff = Math . max ( 0 , ( max - min ) * 2 ) ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { int a = nums [ i ] ; int b = nums [ i + 1 ] ; int headDiff = - Math . abs ( a - b ) + Math . abs ( nums [ 0 ] - b ) ; int tailDiff = - Math . abs ( a - b ) + Math . abs ( nums [ nums . length - 1 ] - a ) ; diff = Math . max ( diff , Math . max ( headDiff , tailDiff ) ) ; } return total + diff ; } }
class Solution { public int [ ] arrayRankTransform ( int [ ] arr ) { int [ ] sortedArr = arr . clone ( ) ; Map < Integer , Integer > rank = new HashMap < > ( ) ; Arrays . sort ( sortedArr ) ; for ( final int a : sortedArr ) rank . putIfAbsent ( a , rank . size ( ) + 1 ) ; for ( int i = 0 ; i < arr . length ; ++ i ) arr [ i ] = rank . get ( arr [ i ] ) ; return arr ; } }
class Solution { public List < Integer > filterRestaurants ( int [ ] [ ] restaurants , int veganFriendly , int maxPrice , int maxDistance ) { return Arrays . stream ( restaurants ) . filter ( r -> r [ 2 ] >= veganFriendly && r [ 3 ] <= maxPrice && r [ 4 ] <= maxDistance ) . sorted ( ( a , b ) -> a [ 1 ] == b [ 1 ] ? b [ 0 ] - a [ 0 ] : b [ 1 ] - a [ 1 ] ) . map ( i -> i [ 0 ] ) . collect ( Collectors . toList ( ) ) ; } }
class Solution { public int minDifficulty ( int [ ] jobDifficulty , int d ) { final int n = jobDifficulty . length ; if ( n < d ) return - 1 ; int [ ] [ ] dp = new int [ n + 1 ] [ d + 1 ] ; Arrays . stream ( dp ) . forEach ( row -> Arrays . fill ( row , Integer . MAX_VALUE / 2 ) ) ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int k = 1 ; k <= d ; ++ k ) { int maxDifficulty = 0 ; for ( int j = i - 1 ; j >= k - 1 ; -- j ) { maxDifficulty = Math . max ( maxDifficulty , jobDifficulty [ j ] ) ; dp [ i ] [ k ] = Math . min ( dp [ i ] [ k ] , dp [ j ] [ k - 1 ] + maxDifficulty ) ; } } return dp [ n ] [ d ] ; } }
class Solution { public int [ ] kWeakestRows ( int [ ] [ ] mat , int k ) { int [ ] ans = new int [ k ] ; int [ ] [ ] candidates = new int [ mat . length ] [ 2 ] ; for ( int i = 0 ; i < mat . length ; ++ i ) { candidates [ i ] [ 0 ] = IntStream . of ( mat [ i ] ) . sum ( ) ; candidates [ i ] [ 1 ] = i ; } Arrays . sort ( candidates , ( a , b ) -> a [ 0 ] == b [ 0 ] ? a [ 1 ] - b [ 1 ] : a [ 0 ] - b [ 0 ] ) ; for ( int i = 0 ; i < k ; ++ i ) ans [ i ] = candidates [ i ] [ 1 ] ; return ans ; } }
class Solution { public int minSetSize ( int [ ] arr ) { final int n = arr . length ; int sum = 0 ; Map < Integer , Integer > map = new HashMap < > ( ) ; for ( final int a : arr ) map . merge ( a , 1 , Integer :: sum ) ; int [ ] [ ] count = new int [ map . size ( ) ] [ 2 ] ; int i = 0 ; for ( final int key : map . keySet ( ) ) { count [ i ] [ 0 ] = key ; count [ i ++ ] [ 1 ] = map . get ( key ) ; } Arrays . sort ( count , ( c1 , c2 ) -> c2 [ 1 ] - c1 [ 1 ] ) ; for ( i = 0 ; i < count . length ; ++ i ) { sum += count [ i ] [ 1 ] ; if ( sum >= n / 2 ) return i + 1 ; } throw new IllegalArgumentException ( ) ; } }
class Solution { public int canCompleteCircuit ( int [ ] gas , int [ ] cost ) { final int gasses = Arrays . stream ( gas ) . sum ( ) ; final int costs = Arrays . stream ( cost ) . sum ( ) ; if ( gasses - costs < 0 ) return - 1 ; int ans = 0 ; int sum = 0 ; for ( int i = 0 ; i < gas . length ; ++ i ) { sum += gas [ i ] - cost [ i ] ; if ( sum < 0 ) { sum = 0 ; ans = i + 1 ; } } return ans ; } }
class Solution { public int maxJumps ( int [ ] arr , int d ) { final int n = arr . length ; int [ ] dp = new int [ n ] ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i <= n ; ++ i ) { while ( ! stack . isEmpty ( ) && ( i == n || arr [ stack . peek ( ) ] < arr [ i ] ) ) { List < Integer > indices = new ArrayList < > ( Arrays . asList ( stack . pop ( ) ) ) ; while ( ! stack . isEmpty ( ) && arr [ stack . peek ( ) ] == arr [ indices . get ( 0 ) ] ) indices . add ( stack . pop ( ) ) ; for ( final int j : indices ) { if ( i < n && i - j <= d ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; if ( ! stack . isEmpty ( ) && j - stack . peek ( ) <= d ) dp [ stack . peek ( ) ] = Math . max ( dp [ stack . peek ( ) ] , dp [ j ] + 1 ) ; } } stack . push ( i ) ; } return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) + 1 ; } }
class Solution { public double angleClock ( int hour , int minutes ) { final double hourHand = ( hour % 12 + minutes / 60.0 ) * 30 ; final double minuteHand = minutes * 6 ; final double diff = Math . abs ( hourHand - minuteHand ) ; return Math . min ( diff , 360 - diff ) ; } }
class Solution { public int minJumps ( int [ ] arr ) { final int n = arr . length ; Map < Integer , List < Integer > > graph = new HashMap < > ( ) ; Queue < Integer > q = new ArrayDeque < > ( Arrays . asList ( 0 ) ) ; boolean [ ] seen = new boolean [ n ] ; seen [ 0 ] = true ; for ( int i = 0 ; i < n ; ++ i ) { graph . putIfAbsent ( arr [ i ] , new ArrayList < > ( ) ) ; graph . get ( arr [ i ] ) . add ( i ) ; } for ( int steps = 0 ; ! q . isEmpty ( ) ; ++ steps ) { for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int i = q . poll ( ) ; if ( i == n - 1 ) return steps ; seen [ i ] = true ; final int u = arr [ i ] ; if ( i + 1 < n ) graph . get ( u ) . add ( i + 1 ) ; if ( i - 1 >= 0 ) graph . get ( u ) . add ( i - 1 ) ; for ( final int v : graph . get ( u ) ) { if ( seen [ v ] ) continue ; q . offer ( v ) ; } graph . get ( u ) . clear ( ) ; } } throw new IllegalArgumentException ( ) ; } }
class TweetCounts { public void recordTweet ( String tweetName , int time ) { tweetNameToTimeCount . putIfAbsent ( tweetName , new TreeMap < > ( ) ) ; tweetNameToTimeCount . get ( tweetName ) . merge ( time , 1 , Integer :: sum ) ; } public List < Integer > getTweetCountsPerFrequency ( String freq , String tweetName , int startTime , int endTime ) { final int chunkSize = freq . equals ( " minute " ) ? 60 : freq . equals ( " hour " ) ? 3600 : 86400 ; int [ ] counts = new int [ ( endTime - startTime ) / chunkSize + 1 ] ; TreeMap < Integer , Integer > timeCount = tweetNameToTimeCount . get ( tweetName ) ; for ( Map . Entry < Integer , Integer > entry : timeCount . subMap ( startTime , endTime + 1 ) . entrySet ( ) ) { final int index = ( entry . getKey ( ) - startTime ) / chunkSize ; counts [ index ] += entry . getValue ( ) ; } return Arrays . stream ( counts ) . boxed ( ) . collect ( Collectors . toList ( ) ) ; } private Map < String , TreeMap < Integer , Integer > > tweetNameToTimeCount = new HashMap < > ( ) ; }
class Solution { public int maxStudents ( char [ ] [ ] seats ) { int studentsCount = 0 ; for ( char [ ] seat : seats ) for ( final char s : seat ) if ( s == ' . ' ) ++ studentsCount ; return studentsCount - hungarian ( seats ) ; } private static final int [ ] [ ] dirs = { { - 1 , - 1 } , { 0 , - 1 } , { 1 , - 1 } , { - 1 , 1 } , { 0 , 1 } , { 1 , 1 } } ; private int hungarian ( char [ ] [ ] seats ) { final int m = seats . length ; final int n = seats [ 0 ] . length ; int count = 0 ; int [ ] [ ] seen = new int [ m ] [ n ] ; int [ ] [ ] match = new int [ m ] [ n ] ; Arrays . stream ( match ) . forEach ( A -> Arrays . fill ( A , - 1 ) ) ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( seats [ i ] [ j ] == ' . ' && match [ i ] [ j ] == - 1 ) { final int sessionId = i * n + j ; seen [ i ] [ j ] = sessionId ; if ( dfs ( seats , i , j , sessionId , seen , match ) ) ++ count ; } return count ; } private boolean dfs ( char [ ] [ ] seats , int i , int j , int sessionId , int [ ] [ ] seen , int [ ] [ ] match ) { final int m = seats . length ; final int n = seats [ 0 ] . length ; for ( int [ ] dir : dirs ) { final int x = i + dir [ 0 ] ; final int y = j + dir [ 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seats [ x ] [ y ] != ' . ' || seen [ x ] [ y ] == sessionId ) continue ; seen [ x ] [ y ] = sessionId ; if ( match [ x ] [ y ] == - 1 || dfs ( seats , match [ x ] [ y ] / n , match [ x ] [ y ] % n , sessionId , seen , match ) ) { match [ x ] [ y ] = i * n + j ; match [ i ] [ j ] = x * n + y ; return true ; } } return false ; } }
class Solution { public int candy ( int [ ] ratings ) { final int n = ratings . length ; int ans = 0 ; int [ ] l = new int [ n ] ; int [ ] r = new int [ n ] ; Arrays . fill ( l , 1 ) ; Arrays . fill ( r , 1 ) ; for ( int i = 1 ; i < n ; ++ i ) if ( ratings [ i ] > ratings [ i - 1 ] ) l [ i ] = l [ i - 1 ] + 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) if ( ratings [ i ] > ratings [ i + 1 ] ) r [ i ] = r [ i + 1 ] + 1 ; for ( int i = 0 ; i < n ; ++ i ) ans += Math . max ( l [ i ] , r [ i ] ) ; return ans ; } }
class Solution { public int countNegatives ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int ans = 0 ; int i = m - 1 ; int j = 0 ; while ( i >= 0 && j < n ) { if ( grid [ i ] [ j ] < 0 ) { ans += n - j ; -- i ; } else { ++ j ; } } return ans ; } }
class Solution { public int maxEvents ( int [ ] [ ] events ) { int ans = 0 ; int d = 0 ; int i = 0 ; Queue < Integer > minHeap = new PriorityQueue < > ( ) ; Arrays . sort ( events , ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; while ( ! minHeap . isEmpty ( ) || i < events . length ) { if ( minHeap . isEmpty ( ) ) d = events [ i ] [ 0 ] ; while ( i < events . length && events [ i ] [ 0 ] == d ) minHeap . offer ( events [ i ++ ] [ 1 ] ) ; minHeap . poll ( ) ; ++ ans ; ++ d ; while ( ! minHeap . isEmpty ( ) && minHeap . peek ( ) < d ) minHeap . poll ( ) ; } return ans ; } }
class Solution { public boolean isPossible ( int [ ] target ) { if ( target . length == 1 ) return target [ 0 ] == 1 ; long sum = Arrays . stream ( target ) . asLongStream ( ) . sum ( ) ; Queue < Integer > maxHeap = new PriorityQueue < > ( Collections . reverseOrder ( ) ) ; for ( final int num : target ) maxHeap . offer ( num ) ; while ( maxHeap . peek ( ) > 1 ) { final long max = maxHeap . poll ( ) ; final long restSum = sum - max ; if ( restSum == 1 ) return true ; final long updated = max % restSum ; if ( updated == 0 || updated == max ) return false ; maxHeap . offer ( ( int ) updated ) ; sum = sum - max + updated ; } return true ; } }
class Solution { public int countOrders ( int n ) { final int kMod = 1_000_000_007 ; long ans = 1 ; for ( int i = 1 ; i <= n ; ++ i ) ans = ans * i * ( i * 2 - 1 ) % kMod ; return ( int ) ans ; } }
class Solution { public int singleNumber ( int [ ] nums ) { int ans = 0 ; for ( final int num : nums ) ans ^= num ; return ans ; } }
class Solution { public int [ ] closestDivisors ( int num ) { for ( int root = ( int ) Math . sqrt ( num + 2 ) ; root > 0 ; -- root ) for ( int cand : new int [ ] { num + 1 , num + 2 } ) if ( cand % root == 0 ) return new int [ ] { root , cand / root } ; throw new IllegalArgumentException ( ) ; } }
class Solution { public String largestMultipleOfThree ( int [ ] digits ) { StringBuilder ans = new StringBuilder ( ) ; int [ ] mod1 = new int [ ] { 1 , 4 , 7 , 2 , 5 , 8 } ; int [ ] mod2 = new int [ ] { 2 , 5 , 8 , 1 , 4 , 7 } ; int [ ] count = new int [ 10 ] ; int sum = 0 ; for ( int digit : digits ) { ++ count [ digit ] ; sum += digit ; } while ( sum % 3 != 0 ) for ( int i : sum % 3 == 1 ? mod1 : mod2 ) if ( count [ i ] > 0 ) { -- count [ i ] ; sum -= i ; break ; } for ( int digit = 9 ; digit >= 0 ; -- digit ) ans . append ( Character . toString ( '0' + digit ) . repeat ( count [ digit ] ) ) ; return ans . length ( ) > 0 && ans . charAt ( 0 ) == '0' ? "0" : ans . toString ( ) ; } }
class Solution { public int minCost ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; dp = new int [ m ] [ n ] ; Arrays . stream ( dp ) . forEach ( A -> Arrays . fill ( A , - 1 ) ) ; Queue < Pair < Integer , Integer > > q = new ArrayDeque < > ( ) ; dfs ( grid , 0 , 0 , 0 , q ) ; for ( int cost = 1 ; ! q . isEmpty ( ) ; ++ cost ) for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { Pair < Integer , Integer > node = q . poll ( ) ; final int i = node . getKey ( ) ; final int j = node . getValue ( ) ; for ( int [ ] dir : dirs ) dfs ( grid , i + dir [ 0 ] , j + dir [ 1 ] , cost , q ) ; } return dp [ m - 1 ] [ n - 1 ] ; } private static final int [ ] [ ] dirs = { { 0 , 1 } , { 0 , - 1 } , { 1 , 0 } , { - 1 , 0 } } ; private int [ ] [ ] dp ; private void dfs ( int [ ] [ ] grid , int i , int j , int cost , Queue < Pair < Integer , Integer > > q ) { if ( i < 0 || i == grid . length || j < 0 || j == grid [ 0 ] . length ) return ; if ( dp [ i ] [ j ] != - 1 ) return ; dp [ i ] [ j ] = cost ; q . add ( new Pair < > ( i , j ) ) ; int [ ] dir = dirs [ grid [ i ] [ j ] - 1 ] ; dfs ( grid , i + dir [ 0 ] , j + dir [ 1 ] , cost , q ) ; } }
class Solution { public int singleNumber ( int [ ] nums ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) { int sum = 0 ; for ( final int num : nums ) sum += num >> i & 1 ; sum %= 3 ; ans |= sum << i ; } return ans ; } }
class Solution { public int findTheLongestSubstring ( String s ) { int ans = 0 ; int prefix = 0 ; Map < Integer , Integer > prefixToIndex = new HashMap < > ( ) ; prefixToIndex . put ( 0 , - 1 ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { final int index = " aeiou " . indexOf ( s . charAt ( i ) ) ; if ( index != - 1 ) prefix ^= 1 << index ; prefixToIndex . putIfAbsent ( prefix , i ) ; ans = Math . max ( ans , i - prefixToIndex . get ( prefix ) ) ; } return ans ; } }
class T { public boolean isBST ; public Integer max ; public Integer min ; public Integer sum ; public T ( ) { this . isBST = false ; this . max = null ; this . min = null ; this . sum = null ; } public T ( boolean isBST , int max , int min , int sum ) { this . isBST = isBST ; this . max = max ; this . min = min ; this . sum = sum ; } } class Solution { public int maxSumBST ( TreeNode root ) { traverse ( root ) ; return ans ; } private int ans = 0 ; private T traverse ( TreeNode root ) { if ( root == null ) return new T ( true , Integer . MIN_VALUE , Integer . MAX_VALUE , 0 ) ; T left = traverse ( root . left ) ; T right = traverse ( root . right ) ; if ( ! left . isBST || ! right . isBST ) return new T ( ) ; if ( root . val <= left . max || root . val >= right . min ) return new T ( ) ; final int sum = root . val + left . sum + right . sum ; ans = Math . max ( ans , sum ) ; return new T ( true , Math . max ( root . val , right . max ) , Math . min ( root . val , left . min ) , sum ) ; } }
class Solution { public double frogPosition ( int n , int [ ] [ ] edges , int t , int target ) { List < Integer > [ ] graph = new List [ n + 1 ] ; Queue < Integer > q = new ArrayDeque < > ( Arrays . asList ( 1 ) ) ; boolean [ ] seen = new boolean [ n + 1 ] ; double [ ] prob = new double [ n + 1 ] ; seen [ 1 ] = true ; prob [ 1 ] = 1.0 ; for ( int i = 1 ; i <= n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } while ( ! q . isEmpty ( ) && t -- > 0 ) for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int a = q . poll ( ) ; int nChildren = 0 ; for ( final int b : graph [ a ] ) if ( ! seen [ b ] ) ++ nChildren ; for ( final int b : graph [ a ] ) { if ( seen [ b ] ) continue ; seen [ b ] = true ; prob [ b ] = prob [ a ] / nChildren ; q . add ( b ) ; } if ( nChildren > 0 ) prob [ a ] = 0.0 ; } return prob [ target ] ; } }
class Solution { public Node copyRandomList ( Node head ) { if ( head == null ) return null ; if ( map . containsKey ( head ) ) return map . get ( head ) ; Node newNode = new Node ( head . val ) ; map . put ( head , newNode ) ; newNode . next = copyRandomList ( head . next ) ; newNode . random = copyRandomList ( head . random ) ; return newNode ; } private Map < Node , Node > map = new HashMap < > ( ) ; }
class Solution { public int maxPerformance ( int n , int [ ] speed , int [ ] efficiency , int k ) { final int kMod = 1_000_000_007 ; long ans = 0 ; long speedSum = 0 ; Pair < Integer , Integer > [ ] A = new Pair [ n ] ; Queue < Integer > minHeap = new PriorityQueue < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) A [ i ] = new Pair < > ( efficiency [ i ] , speed [ i ] ) ; Arrays . sort ( A , ( a , b ) -> Integer . compare ( b . getKey ( ) , a . getKey ( ) ) ) ; for ( Pair < Integer , Integer > a : A ) { final int e = a . getKey ( ) ; final int s = a . getValue ( ) ; minHeap . offer ( s ) ; speedSum += s ; if ( minHeap . size ( ) > k ) speedSum -= minHeap . poll ( ) ; ans = Math . max ( ans , speedSum * e ) ; } return ( int ) ( ans % kMod ) ; } }
class Solution { public boolean wordBreak ( String s , List < String > wordDict ) { return wordBreak ( s , new HashSet < > ( wordDict ) , new HashMap < > ( ) ) ; } private boolean wordBreak ( final String s , Set < String > wordSet , Map < String , Boolean > memo ) { if ( memo . containsKey ( s ) ) return memo . get ( s ) ; if ( wordSet . contains ( s ) ) { memo . put ( s , true ) ; return true ; } for ( int i = 1 ; i < s . length ( ) ; ++ i ) { final String prefix = s . substring ( 0 , i ) ; final String suffix = s . substring ( i ) ; if ( wordSet . contains ( prefix ) && wordBreak ( suffix , wordSet , memo ) ) { memo . put ( s , true ) ; return true ; } } memo . put ( s , false ) ; return false ; } }
class Solution { public int sumFourDivisors ( int [ ] nums ) { int ans = 0 ; for ( int num : nums ) { int divisor = 0 ; for ( int i = 2 ; i * i <= num ; ++ i ) if ( num % i == 0 ) { if ( divisor == 0 ) divisor = i ; else { divisor = 0 ; break ; } } if ( divisor > 0 && divisor * divisor < num ) ans += 1 + num + divisor + num / divisor ; } return ans ; } }
class Solution { public String longestPrefix ( String s ) { final int kBase = 26 ; final int kMod = 1_000_000_007 ; final int n = s . length ( ) ; int maxLength = 0 ; long pow = 1 ; long prefixHash = 0 ; long suffixHash = 0 ; for ( int i = 0 , j = n - 1 ; i < n - 1 ; ++ i , -- j ) { prefixHash = ( prefixHash * kBase + val ( s . charAt ( i ) ) ) % kMod ; suffixHash = ( val ( s . charAt ( j ) ) * pow + suffixHash ) % kMod ; pow = pow * kBase % kMod ; if ( prefixHash == suffixHash ) maxLength = i + 1 ; } return s . substring ( 0 , maxLength ) ; } private int val ( char c ) { return c - ' a ' ; } }
class CheckIn { public String stationName ; public int time ; public CheckIn ( String stationName , int time ) { this . stationName = stationName ; this . time = time ; } } class CheckOut { public int numTrips ; public int totalTime ; public CheckOut ( int numTrips , int totalTime ) { this . numTrips = numTrips ; this . totalTime = totalTime ; } } class UndergroundSystem { public void checkIn ( int id , String stationName , int t ) { checkIns . put ( id , new CheckIn ( stationName , t ) ) ; } public void checkOut ( int id , String stationName , int t ) { final CheckIn checkIn = checkIns . get ( id ) ; checkIns . remove ( id ) ; final String route = checkIn . stationName + " - > " + stationName ; checkOuts . putIfAbsent ( route , new CheckOut ( 0 , 0 ) ) ; ++ checkOuts . get ( route ) . numTrips ; checkOuts . get ( route ) . totalTime += t - checkIn . time ; } public double getAverageTime ( String startStation , String endStation ) { final CheckOut checkOut = checkOuts . get ( startStation + " - > " + endStation ) ; return checkOut . totalTime / ( double ) checkOut . numTrips ; } private Map < Integer , CheckIn > checkIns = new HashMap < > ( ) ; private Map < String , CheckOut > checkOuts = new HashMap < > ( ) ; }
class Solution { public int findGoodStrings ( int n , String s1 , String s2 , String evil ) { dp = new Integer [ n ] [ evil . length ( ) ] [ 2 ] [ 2 ] ; nextMatchedCount = new Integer [ evil . length ( ) ] [ 26 ] ; return find ( s1 , s2 , evil , 0 , 0 , true , true , getLPS ( evil ) ) ; } private static final int kMod = 1_000_000_007 ; private Integer [ ] [ ] [ ] [ ] dp ; private Integer [ ] [ ] nextMatchedCount ; private int find ( final String s1 , final String s2 , final String evil , int i , int matchedEvilCount , boolean isS1Prefix , boolean isS2Prefix , int [ ] evilLPS ) { if ( matchedEvilCount == evil . length ( ) ) return 0 ; if ( i == s1 . length ( ) ) return 1 ; final int k1 = isS1Prefix ? 1 : 0 ; final int k2 = isS2Prefix ? 1 : 0 ; if ( dp [ i ] [ matchedEvilCount ] [ k1 ] [ k2 ] != null ) return dp [ i ] [ matchedEvilCount ] [ k1 ] [ k2 ] ; dp [ i ] [ matchedEvilCount ] [ k1 ] [ k2 ] = 0 ; final char minChar = isS1Prefix ? s1 . charAt ( i ) : ' a ' ; final char maxChar = isS2Prefix ? s2 . charAt ( i ) : ' z ' ; for ( char c = minChar ; c <= maxChar ; ++ c ) { final int nextMatchedEvilCount = getNextMatchedEvilCount ( evil , matchedEvilCount , c , evilLPS ) ; dp [ i ] [ matchedEvilCount ] [ k1 ] [ k2 ] += find ( s1 , s2 , evil , i + 1 , nextMatchedEvilCount , isS1Prefix && c == s1 . charAt ( i ) , isS2Prefix && c == s2 . charAt ( i ) , evilLPS ) ; dp [ i ] [ matchedEvilCount ] [ k1 ] [ k2 ] %= kMod ; } return dp [ i ] [ matchedEvilCount ] [ k1 ] [ k2 ] ; } private int [ ] getLPS ( final String s ) { int [ ] lps = new int [ s . length ( ) ] ; for ( int i = 1 , j = 0 ; i < s . length ( ) ; ++ i ) { while ( j > 0 && s . charAt ( j ) != s . charAt ( i ) ) j = lps [ j - 1 ] ; if ( s . charAt ( i ) == s . charAt ( j ) ) lps [ i ] = ++ j ; } return lps ; } private int getNextMatchedEvilCount ( final String evil , int j , char currChar , int [ ] lps ) { if ( nextMatchedCount [ j ] [ currChar - ' a ' ] != null ) return nextMatchedCount [ j ] [ currChar - ' a ' ] ; while ( j > 0 && evil . charAt ( j ) != currChar ) j = lps [ j - 1 ] ; return nextMatchedCount [ j ] [ currChar - ' a ' ] = ( evil . charAt ( j ) == currChar ? j + 1 : j ) ; } }
class Solution { public String longestCommonPrefix ( String [ ] strs ) { if ( strs . length == 0 ) return " " ; for ( int i = 0 ; i < strs [ 0 ] . length ( ) ; ++ i ) for ( int j = 1 ; j < strs . length ; ++ j ) if ( i == strs [ j ] . length ( ) || strs [ j ] . charAt ( i ) != strs [ 0 ] . charAt ( i ) ) return strs [ 0 ] . substring ( 0 , i ) ; return strs [ 0 ] ; } }
class Solution { public List < String > wordBreak ( String s , List < String > wordDict ) { Set < String > wordSet = new HashSet < > ( wordDict ) ; Map < String , List < String > > memo = new HashMap < > ( ) ; return wordBreak ( s , wordSet , memo ) ; } private List < String > wordBreak ( final String s , Set < String > wordSet , Map < String , List < String > > memo ) { if ( memo . containsKey ( s ) ) return memo . get ( s ) ; List < String > ans = new ArrayList < > ( ) ; for ( int i = 1 ; i < s . length ( ) ; ++ i ) { final String prefix = s . substring ( 0 , i ) ; final String suffix = s . substring ( i ) ; if ( wordSet . contains ( prefix ) ) for ( final String word : wordBreak ( suffix , wordSet , memo ) ) ans . add ( prefix + " ▁ " + word ) ; } if ( wordSet . contains ( s ) ) ans . add ( s ) ; memo . put ( s , ans ) ; return ans ; } }
class Solution { public int maxSatisfaction ( int [ ] satisfaction ) { int ans = 0 ; int sumSatisfaction = 0 ; satisfaction = Arrays . stream ( satisfaction ) . boxed ( ) . sorted ( Collections . reverseOrder ( ) ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; for ( final int s : satisfaction ) { sumSatisfaction += s ; if ( sumSatisfaction <= 0 ) return ans ; ans += sumSatisfaction ; } return ans ; } }
class Solution { public String stoneGameIII ( int [ ] stoneValue ) { dp = new int [ stoneValue . length ] ; Arrays . fill ( dp , Integer . MIN_VALUE ) ; final int score = stoneGameIII ( stoneValue , 0 ) ; return score > 0 ? " Alice " : score < 0 ? " Bob " : " Tie " ; } private int [ ] dp ; private int stoneGameIII ( int [ ] stoneValue , int i ) { if ( i == stoneValue . length ) return 0 ; if ( dp [ i ] > Integer . MIN_VALUE ) return dp [ i ] ; int sum = 0 ; for ( int j = i ; j < i + 3 && j < stoneValue . length ; ++ j ) { sum += stoneValue [ j ] ; dp [ i ] = Math . max ( dp [ i ] , sum - stoneGameIII ( stoneValue , j + 1 ) ) ; } return dp [ i ] ; } ; }
public class Solution { public boolean hasCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) return true ; } return false ; } }
public class Solution { public ListNode detectCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; } }
class Solution { public int numOfArrays ( int n , int m , int k ) { final int kMod = 1_000_000_007 ; int [ ] [ ] [ ] dp = new int [ n + 1 ] [ m + 1 ] [ k + 1 ] ; for ( int j = 1 ; j <= m ; ++ j ) dp [ 1 ] [ j ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 1 ; j <= m ; ++ j ) for ( int cost = 1 ; cost <= k ; ++ cost ) { dp [ i ] [ j ] [ cost ] = ( int ) ( ( long ) j * dp [ i - 1 ] [ j ] [ cost ] % kMod ) ; for ( int prevMax = 1 ; prevMax < j ; ++ prevMax ) { dp [ i ] [ j ] [ cost ] += dp [ i - 1 ] [ prevMax ] [ cost - 1 ] ; dp [ i ] [ j ] [ cost ] %= kMod ; } } int ans = 0 ; for ( int j = 1 ; j <= m ; ++ j ) { ans += dp [ n ] [ j ] [ k ] ; ans %= kMod ; } return ans ; } }
class Solution { public int maxScore ( int [ ] cardPoints , int k ) { final int n = cardPoints . length ; final int sum = Arrays . stream ( cardPoints ) . sum ( ) ; int windowSum = 0 ; for ( int i = 0 ; i < n - k ; ++ i ) windowSum += cardPoints [ i ] ; int ans = sum - windowSum ; for ( int i = 0 ; i < k ; ++ i ) { windowSum -= cardPoints [ i ] ; windowSum += cardPoints [ i + n - k ] ; ans = Math . max ( ans , sum - windowSum ) ; } return ans ; } }
class Solution { public int constrainedSubsetSum ( int [ ] nums , int k ) { int [ ] dp = new int [ nums . length ] ; Deque < Integer > q = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( q . isEmpty ( ) ) dp [ i ] = nums [ i ] ; else dp [ i ] = Math . max ( q . peekFirst ( ) , 0 ) + nums [ i ] ; while ( ! q . isEmpty ( ) && q . peekLast ( ) < dp [ i ] ) q . pollLast ( ) ; q . offerLast ( dp [ i ] ) ; if ( i >= k && dp [ i - k ] == q . peekFirst ( ) ) q . pollFirst ( ) ; } return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; } }
class Solution { public int leftMostColumnWithOne ( BinaryMatrix binaryMatrix ) { final List < Integer > dimensions = binaryMatrix . dimensions ( ) ; final int m = dimensions . get ( 0 ) ; final int n = dimensions . get ( 1 ) ; int ans = - 1 ; int l = 0 ; int r = n - 1 ; while ( l <= r ) { final int mid = ( l + r ) / 2 ; if ( existOne ( binaryMatrix , m , mid ) ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; } private boolean existOne ( BinaryMatrix binaryMatrix , int m , int col ) { for ( int i = 0 ; i < m ; ++ i ) if ( binaryMatrix . get ( i , col ) == 1 ) return true ; return false ; } }
class Solution { public void reorderList ( ListNode head ) { if ( head == null || head . next == null ) return ; ListNode mid = findMid ( head ) ; ListNode reversed = reverse ( mid ) ; merge ( head , reversed ) ; } private ListNode findMid ( ListNode head ) { ListNode prev = null ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } private ListNode reverse ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } private void merge ( ListNode l1 , ListNode l2 ) { while ( l2 != null ) { ListNode next = l1 . next ; l1 . next = l2 ; l1 = l2 ; l2 = next ; } } }
class Solution { public List < Integer > preorderTraversal ( TreeNode root ) { List < Integer > ans = new ArrayList < > ( ) ; preorder ( root , ans ) ; return ans ; } private void preorder ( TreeNode root , List < Integer > ans ) { if ( root == null ) return ; ans . add ( root . val ) ; preorder ( root . left , ans ) ; preorder ( root . right , ans ) ; } }
class Solution { public int ways ( String [ ] pizza , int k ) { final int M = pizza . length ; final int N = pizza [ 0 ] . length ( ) ; dp = new int [ M ] [ N ] [ k ] ; for ( int [ ] [ ] A : dp ) Arrays . stream ( A ) . forEach ( a -> Arrays . fill ( a , - 1 ) ) ; prefix = new int [ M + 1 ] [ N + 1 ] ; for ( int i = 0 ; i < M ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) prefix [ i + 1 ] [ j + 1 ] = ( pizza [ i ] . charAt ( j ) == ' A ' ? 1 : 0 ) + prefix [ i ] [ j + 1 ] + prefix [ i + 1 ] [ j ] - prefix [ i ] [ j ] ; return ways ( 0 , 0 , k - 1 , M , N ) ; } private static final int kMod = 1_000_000_007 ; private int [ ] [ ] [ ] dp ; private int [ ] [ ] prefix ; private boolean hasApple ( int row1 , int row2 , int col1 , int col2 ) { return ( prefix [ row2 ] [ col2 ] - prefix [ row1 ] [ col2 ] - prefix [ row2 ] [ col1 ] + prefix [ row1 ] [ col1 ] ) > 0 ; } private int ways ( int m , int n , int k , final int M , final int N ) { if ( k == 0 ) return 1 ; if ( dp [ m ] [ n ] [ k ] >= 0 ) return dp [ m ] [ n ] [ k ] ; dp [ m ] [ n ] [ k ] = 0 ; for ( int i = m + 1 ; i < M ; ++ i ) if ( hasApple ( m , i , n , N ) && hasApple ( i , M , n , N ) ) dp [ m ] [ n ] [ k ] = ( dp [ m ] [ n ] [ k ] + ways ( i , n , k - 1 , M , N ) ) % kMod ; for ( int j = n + 1 ; j < N ; ++ j ) if ( hasApple ( m , M , n , j ) && hasApple ( m , M , j , N ) ) dp [ m ] [ n ] [ k ] = ( dp [ m ] [ n ] [ k ] + ways ( m , j , k - 1 , M , N ) ) % kMod ; return dp [ m ] [ n ] [ k ] ; } }
class Solution { public List < Integer > postorderTraversal ( TreeNode root ) { List < Integer > ans = new ArrayList < > ( ) ; postorder ( root , ans ) ; return ans ; } private void postorder ( TreeNode root , List < Integer > ans ) { if ( root == null ) return ; postorder ( root . left , ans ) ; postorder ( root . right , ans ) ; ans . add ( root . val ) ; } }
class Point { public double x = 0 ; public double y = 0 ; public Point ( double x , double y ) { this . x = x ; this . y = y ; } } class Solution { public int numPoints ( int [ ] [ ] darts , int r ) { int ans = 1 ; List < Point > points = convertToPoints ( darts ) ; for ( int i = 0 ; i < points . size ( ) ; ++ i ) for ( int j = i + 1 ; j < points . size ( ) ; ++ j ) for ( Point c : getCircles ( points . get ( i ) , points . get ( j ) , r ) ) { int count = 0 ; for ( Point point : points ) if ( dist ( c , point ) - r <= kErr ) ++ count ; ans = Math . max ( ans , count ) ; } return ans ; } private static final double kErr = 1e-6 ; private List < Point > convertToPoints ( int [ ] [ ] darts ) { List < Point > points = new ArrayList < > ( ) ; for ( int [ ] dart : darts ) points . add ( new Point ( dart [ 0 ] , dart [ 1 ] ) ) ; return points ; } private Point [ ] getCircles ( Point p , Point q , int r ) { if ( dist ( p , q ) - 2.0 * r > kErr ) return new Point [ ] { } ; Point m = new Point ( ( p . x + q . x ) / 2 , ( p . y + q . y ) / 2 ) ; final double distCM = Math . sqrt ( Math . pow ( r , 2 ) - Math . pow ( dist ( p , q ) / 2 , 2 ) ) ; final double alpha = Math . atan2 ( p . y - q . y , q . x - p . x ) ; return new Point [ ] { new Point ( m . x - distCM * Math . sin ( alpha ) , m . y - distCM * Math . cos ( alpha ) ) , new Point ( m . x + distCM * Math . sin ( alpha ) , m . y + distCM * Math . cos ( alpha ) ) } ; } private double dist ( Point p , Point q ) { return Math . sqrt ( Math . pow ( p . x - q . x , 2 ) + Math . pow ( p . y - q . y , 2 ) ) ; } }
class Solution { public int pseudoPalindromicPaths ( TreeNode root ) { dfs ( root , 0 ) ; return ans ; } private int ans = 0 ; private void dfs ( TreeNode root , int path ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { path ^= 1 << root . val ; if ( ( path & ( path - 1 ) ) == 0 ) ++ ans ; return ; } dfs ( root . left , path ^ 1 << root . val ) ; dfs ( root . right , path ^ 1 << root . val ) ; } }
class Solution { public int maxDotProduct ( int [ ] nums1 , int [ ] nums2 ) { final int m = nums1 . length ; final int n = nums2 . length ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; Arrays . stream ( dp ) . forEach ( row -> Arrays . fill ( row , Integer . MIN_VALUE ) ) ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) dp [ i + 1 ] [ j + 1 ] = Math . max ( Math . max ( dp [ i ] [ j + 1 ] , dp [ i + 1 ] [ j ] ) , Math . max ( 0 , dp [ i ] [ j ] ) + nums1 [ i ] * nums2 [ j ] ) ; return dp [ m ] [ n ] ; } }
class Node { public int key ; public int value ; public Node ( int key , int value ) { this . key = key ; this . value = value ; } } class LRUCache { public LRUCache ( int capacity ) { this . capacity = capacity ; } public int get ( int key ) { if ( ! keyToNode . containsKey ( key ) ) return - 1 ; Node node = keyToNode . get ( key ) ; cache . remove ( node ) ; cache . add ( node ) ; return node . value ; } public void put ( int key , int value ) { if ( keyToNode . containsKey ( key ) ) { keyToNode . get ( key ) . value = value ; get ( key ) ; return ; } if ( cache . size ( ) == capacity ) { Node lastNode = cache . iterator ( ) . next ( ) ; cache . remove ( lastNode ) ; keyToNode . remove ( lastNode . key ) ; } Node node = new Node ( key , value ) ; cache . add ( node ) ; keyToNode . put ( key , node ) ; } private int capacity ; private Set < Node > cache = new LinkedHashSet < > ( ) ; private Map < Integer , Node > keyToNode = new HashMap < > ( ) ; }
enum BoxCase { EqualBalls , EqualDistantBalls } class Solution { public double getProbability ( int [ ] balls ) { final int n = Arrays . stream ( balls ) . sum ( ) / 2 ; return cases ( balls , 0 , 0 , 0 , 0 , 0 , n , BoxCase . EqualDistantBalls ) / cases ( balls , 0 , 0 , 0 , 0 , 0 , n , BoxCase . EqualBalls ) ; } private int [ ] fact = { 1 , 1 , 2 , 6 , 24 , 120 , 720 } ; double cases ( int [ ] balls , int i , int ballsCountA , int ballsCountB , int colorsCountA , int colorsCountB , int n , BoxCase boxCase ) { if ( ballsCountA > n || ballsCountB > n ) return 0 ; if ( i == balls . length ) return boxCase == BoxCase . EqualBalls ? 1 : ( colorsCountA == colorsCountB ? 1 : 0 ) ; double ans = 0 ; for ( int ballsTakenA = 0 ; ballsTakenA <= balls [ i ] ; ++ ballsTakenA ) { final int ballsTakenB = balls [ i ] - ballsTakenA ; final int newcolorsCountA = colorsCountA + ( ballsTakenA > 0 ? 1 : 0 ) ; final int newcolorsCountB = colorsCountB + ( ballsTakenB > 0 ? 1 : 0 ) ; ans += cases ( balls , i + 1 , ballsCountA + ballsTakenA , ballsCountB + ballsTakenB , newcolorsCountA , newcolorsCountB , n , boxCase ) / ( fact [ ballsTakenA ] * fact [ ballsTakenB ] ) ; } return ans ; } }
class Solution { public ListNode insertionSortList ( ListNode head ) { ListNode dummy = new ListNode ( 0 ) ; ListNode prev = dummy ; while ( head != null ) { ListNode next = head . next ; if ( prev . val >= head . val ) prev = dummy ; while ( prev . next != null && prev . next . val < head . val ) prev = prev . next ; head . next = prev . next ; prev . next = head ; head = next ; } return dummy . next ; } }
class BrowserHistory { public BrowserHistory ( String homepage ) { visit ( homepage ) ; } public void visit ( String url ) { if ( ++ index < urls . size ( ) ) urls . set ( index , url ) ; else urls . add ( url ) ; lastIndex = index ; } public String back ( int steps ) { index = Math . max ( 0 , index - steps ) ; return urls . get ( index ) ; } public String forward ( int steps ) { index = Math . min ( lastIndex , index + steps ) ; return urls . get ( index ) ; } private List < String > urls = new ArrayList < > ( ) ; private int index = - 1 ; private int lastIndex = - 1 ; }
class Solution { public ListNode sortList ( ListNode head ) { final int length = getLength ( head ) ; ListNode dummy = new ListNode ( 0 , head ) ; for ( int k = 1 ; k < length ; k *= 2 ) { ListNode curr = dummy . next ; ListNode tail = dummy ; while ( curr != null ) { ListNode l = curr ; ListNode r = split ( l , k ) ; curr = split ( r , k ) ; ListNode [ ] merged = merge ( l , r ) ; tail . next = merged [ 0 ] ; tail = merged [ 1 ] ; } } return dummy . next ; } private int getLength ( ListNode head ) { int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; return length ; } private ListNode split ( ListNode head , int k ) { while ( -- k > 0 && head != null ) head = head . next ; ListNode rest = head == null ? null : head . next ; if ( head != null ) head . next = null ; return rest ; } private ListNode [ ] merge ( ListNode l1 , ListNode l2 ) { ListNode dummy = new ListNode ( 0 ) ; ListNode tail = dummy ; while ( l1 != null && l2 != null ) { if ( l1 . val > l2 . val ) { ListNode temp = l1 ; l1 = l2 ; l2 = temp ; } tail . next = l1 ; l1 = l1 . next ; tail = tail . next ; } tail . next = l1 == null ? l2 : l1 ; while ( tail . next != null ) tail = tail . next ; return new ListNode [ ] { dummy . next , tail } ; } }
class UnionFind { public UnionFind ( int n ) { id = new int [ n ] ; rank = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) id [ i ] = i ; } public void union ( int u , int v ) { int i = find ( u ) ; int j = find ( v ) ; if ( i == j ) return ; if ( rank [ i ] > rank [ j ] ) { final int temp = i ; i = j ; j = temp ; } else if ( rank [ i ] == rank [ j ] ) { ++ rank [ j ] ; } id [ i ] = j ; } public int find ( int u ) { return id [ u ] == u ? u : ( id [ u ] = find ( id [ u ] ) ) ; } private int [ ] id ; private int [ ] rank ; } class Solution { public List < List < Integer > > findCriticalAndPseudoCriticalEdges ( int n , int [ ] [ ] edges ) { List < Integer > criticalEdges = new ArrayList < > ( ) ; List < Integer > pseudoCriticalEdges = new ArrayList < > ( ) ; for ( int i = 0 ; i < edges . length ; ++ i ) edges [ i ] = new int [ ] { edges [ i ] [ 0 ] , edges [ i ] [ 1 ] , edges [ i ] [ 2 ] , i } ; Arrays . sort ( edges , ( a , b ) -> a [ 2 ] - b [ 2 ] ) ; final int mstWeight = getMSTWeight ( n , edges , new int [ ] { } , - 1 ) ; for ( int [ ] e : edges ) { final int index = e [ 3 ] ; if ( getMSTWeight ( n , edges , new int [ ] { } , index ) > mstWeight ) criticalEdges . add ( index ) ; else if ( getMSTWeight ( n , edges , e , - 1 ) == mstWeight ) pseudoCriticalEdges . add ( index ) ; } return new ArrayList < > ( Arrays . asList ( criticalEdges , pseudoCriticalEdges ) ) ; } private int getMSTWeight ( int n , int [ ] [ ] edges , int [ ] firstEdge , int deletedEdgeIndex ) { int mstWeight = 0 ; UnionFind uf = new UnionFind ( n ) ; if ( firstEdge . length == 4 ) { uf . union ( firstEdge [ 0 ] , firstEdge [ 1 ] ) ; mstWeight += firstEdge [ 2 ] ; } for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; final int weight = e [ 2 ] ; final int index = e [ 3 ] ; if ( index == deletedEdgeIndex ) continue ; if ( uf . find ( u ) == uf . find ( v ) ) continue ; uf . union ( u , v ) ; mstWeight += weight ; } final int root = uf . find ( 0 ) ; for ( int i = 0 ; i < n ; ++ i ) if ( uf . find ( i ) != root ) return Integer . MAX_VALUE ; return mstWeight ; } }
class Solution { public int maxPoints ( int [ ] [ ] points ) { int ans = 0 ; for ( int i = 0 ; i < points . length ; ++ i ) { Map < Pair < Integer , Integer > , Integer > slopeCount = new HashMap < > ( ) ; int [ ] p1 = points [ i ] ; int samePoints = 1 ; int maxPoints = 0 ; for ( int j = i + 1 ; j < points . length ; ++ j ) { int [ ] p2 = points [ j ] ; if ( p1 [ 0 ] == p2 [ 0 ] && p1 [ 1 ] == p2 [ 1 ] ) ++ samePoints ; else { Pair < Integer , Integer > slope = getSlope ( p1 , p2 ) ; slopeCount . merge ( slope , 1 , Integer :: sum ) ; maxPoints = Math . max ( maxPoints , slopeCount . get ( slope ) ) ; } } ans = Math . max ( ans , samePoints + maxPoints ) ; } return ans ; } private Pair < Integer , Integer > getSlope ( int [ ] p , int [ ] q ) { final int dx = p [ 0 ] - q [ 0 ] ; final int dy = p [ 1 ] - q [ 1 ] ; if ( dx == 0 ) return new Pair < > ( 0 , p [ 0 ] ) ; if ( dy == 0 ) return new Pair < > ( p [ 1 ] , 0 ) ; final int d = gcd ( dx , dy ) ; return new Pair < > ( dx / d , dy / y ) ; } private int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } }
class Solution { public int minNumberOfSemesters ( int n , int [ ] [ ] relations , int k ) { int [ ] dp = new int [ 1 << n ] ; Arrays . fill ( dp , n ) ; int [ ] prereq = new int [ n ] ; for ( int [ ] r : relations ) { final int prevCourse = r [ 0 ] - 1 ; final int nextCourse = r [ 1 ] - 1 ; prereq [ nextCourse ] |= 1 << prevCourse ; } dp [ 0 ] = 0 ; for ( int i = 0 ; i < dp . length ; ++ i ) { int coursesCanBeTaken = 0 ; for ( int j = 0 ; j < n ; ++ j ) if ( i & prereq [ j ] == prereq [ j ] ) coursesCanBeTaken |= 1 << j ; coursesCanBeTaken &= ~ i ; for ( int s = coursesCanBeTaken ; s > 0 ; s = ( s - 1 ) & coursesCanBeTaken ) if ( Integer . bitCount ( s ) <= k ) dp [ i | s ] = Math . min ( dp [ i | s ] , dp [ i ] + 1 ) ; } return dp [ ( 1 << n ) - 1 ] ; } }
class Solution { public int numSubseq ( int [ ] nums , int target ) { final int kMod = 1_000_000_007 ; final int n = nums . length ; int ans = 0 ; int [ ] pows = new int [ n ] ; pows [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) pows [ i ] = pows [ i - 1 ] * 2 % kMod ; Arrays . sort ( nums ) ; for ( int l = 0 , r = n - 1 ; l <= r ; ) if ( nums [ l ] + nums [ r ] <= target ) { ans += pows [ r - l ] ; ans %= kMod ; ++ l ; } else { -- r ; } return ans ; } }
class Solution { public int findMaxValueOfEquation ( int [ ] [ ] points , int k ) { int ans = Integer . MIN_VALUE ; Queue < Pair < Integer , Integer > > maxHeap = new PriorityQueue < > ( ( a , b ) -> a . getKey ( ) == b . getKey ( ) ? b . getValue ( ) - a . getValue ( ) : b . getKey ( ) - a . getKey ( ) ) ; for ( int [ ] p : points ) { final int x = p [ 0 ] ; final int y = p [ 1 ] ; while ( ! maxHeap . isEmpty ( ) && x - maxHeap . peek ( ) . getValue ( ) > k ) maxHeap . poll ( ) ; if ( ! maxHeap . isEmpty ( ) ) ans = Math . max ( ans , x + y + maxHeap . peek ( ) . getKey ( ) ) ; maxHeap . offer ( new Pair < > ( y - x , x ) ) ; } return ans ; } }
class Solution { public List < List < Integer > > threeSum ( int [ ] nums ) { if ( nums . length < 3 ) return new ArrayList < > ( ) ; List < List < Integer > > ans = new ArrayList < > ( ) ; Arrays . sort ( nums ) ; for ( int i = 0 ; i + 2 < nums . length ; ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ] ) continue ; int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) { final int sum = nums [ i ] + nums [ l ] + nums [ r ] ; if ( sum == 0 ) { ans . add ( Arrays . asList ( nums [ i ] , nums [ l ++ ] , nums [ r -- ] ) ) ; while ( l < r && nums [ l ] == nums [ l - 1 ] ) ++ l ; while ( l < r && nums [ r ] == nums [ r + 1 ] ) -- r ; } else if ( sum < 0 ) { ++ l ; } else { -- r ; } } } return ans ; } }
class Solution { public int evalRPN ( String [ ] tokens ) { Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( final String token : tokens ) switch ( token ) { case " + " : stack . push ( stack . pop ( ) + stack . pop ( ) ) ; break ; case " - " : stack . push ( - stack . pop ( ) + stack . pop ( ) ) ; break ; case " * " : stack . push ( stack . pop ( ) * stack . pop ( ) ) ; break ; case " / " : final int b = stack . pop ( ) ; final int a = stack . pop ( ) ; stack . push ( a / b ) ; break ; default : stack . push ( Integer . parseInt ( token ) ) ; } return stack . peek ( ) ; } }
class Solution { public int minDifference ( int [ ] nums ) { final int n = nums . length ; if ( n < 5 ) return 0 ; int ans = Integer . MAX_VALUE ; Arrays . sort ( nums ) ; for ( int i = 0 ; i <= 3 ; ++ i ) ans = Math . min ( ans , nums [ n - 4 + i ] - nums [ i ] ) ; return ans ; } }
class Solution { public String reverseWords ( String s ) { StringBuilder sb = new StringBuilder ( s ) . reverse ( ) ; reverseWords ( sb , sb . length ( ) ) ; return cleanSpaces ( sb , sb . length ( ) ) ; } private void reverseWords ( StringBuilder sb , int n ) { int i = 0 ; int j = 0 ; while ( i < n ) { while ( i < j || i < n && sb . charAt ( i ) == ' ▁ ' ) ++ i ; while ( j < i || j < n && sb . charAt ( j ) != ' ▁ ' ) ++ j ; reverse ( sb , i , j - 1 ) ; } } private String cleanSpaces ( StringBuilder sb , int n ) { int i = 0 ; int j = 0 ; while ( j < n ) { while ( j < n && sb . charAt ( j ) == ' ▁ ' ) ++ j ; while ( j < n && sb . charAt ( j ) != ' ▁ ' ) sb . setCharAt ( i ++ , sb . charAt ( j ++ ) ) ; while ( j < n && sb . charAt ( j ) == ' ▁ ' ) ++ j ; if ( j < n ) sb . setCharAt ( i ++ , ' ▁ ' ) ; } return sb . substring ( 0 , i ) . toString ( ) ; } private void reverse ( StringBuilder sb , int l , int r ) { while ( l < r ) { final char temp = sb . charAt ( l ) ; sb . setCharAt ( l ++ , sb . charAt ( r ) ) ; sb . setCharAt ( r -- , temp ) ; } } }
class Solution { public double maxProbability ( int n , int [ ] [ ] edges , double [ ] succProb , int start , int end ) { List < Pair < Integer , Double > > [ ] graph = new List [ n ] ; Queue < Pair < Double , Integer > > maxHeap = new PriorityQueue < > ( ( a , b ) -> Double . compare ( b . getKey ( ) , a . getKey ( ) ) ) ; maxHeap . offer ( new Pair < > ( 1.0 , start ) ) ; boolean [ ] seen = new boolean [ n ] ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < edges . length ; ++ i ) { final int u = edges [ i ] [ 0 ] ; final int v = edges [ i ] [ 1 ] ; final double prob = succProb [ i ] ; graph [ u ] . add ( new Pair < > ( v , prob ) ) ; graph [ v ] . add ( new Pair < > ( u , prob ) ) ; } while ( ! maxHeap . isEmpty ( ) ) { final double prob = maxHeap . peek ( ) . getKey ( ) ; final int u = maxHeap . poll ( ) . getValue ( ) ; if ( u == end ) return prob ; if ( seen [ u ] ) continue ; seen [ u ] = true ; for ( Pair < Integer , Double > node : graph [ u ] ) { final int nextNode = node . getKey ( ) ; final double edgeProb = node . getValue ( ) ; if ( seen [ nextNode ] ) continue ; maxHeap . add ( new Pair < > ( prob * edgeProb , nextNode ) ) ; } } return 0 ; } }
class Solution { public int maxProduct ( int [ ] nums ) { int ans = nums [ 0 ] ; int dpMin = nums [ 0 ] ; int dpMax = nums [ 0 ] ; for ( int i = 1 ; i < nums . length ; ++ i ) { final int num = nums [ i ] ; final int prevMin = dpMin ; final int prevMax = dpMax ; if ( num < 0 ) { dpMin = Math . min ( prevMax * num , num ) ; dpMax = Math . max ( prevMin * num , num ) ; } else { dpMin = Math . min ( prevMin * num , num ) ; dpMax = Math . max ( prevMax * num , num ) ; } ans = Math . max ( ans , dpMax ) ; } return ans ; } }
class Solution { public int numSplits ( String s ) { final int n = s . length ( ) ; int ans = 0 ; int [ ] prefix = new int [ n ] ; int [ ] suffix = new int [ n ] ; Set < Character > seen = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { seen . add ( s . charAt ( i ) ) ; prefix [ i ] = seen . size ( ) ; } seen . clear ( ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { seen . add ( s . charAt ( i ) ) ; suffix [ i ] = seen . size ( ) ; } for ( int i = 0 ; i + 1 < n ; ++ i ) if ( prefix [ i ] == suffix [ i + 1 ] ) ++ ans ; return ans ; } }
class Solution { public int minNumberOperations ( int [ ] target ) { int ans = target [ 0 ] ; for ( int i = 1 ; i < target . length ; ++ i ) if ( target [ i ] > target [ i - 1 ] ) ans += target [ i ] - target [ i - 1 ] ; return ans ; } }
class Solution { public int findMin ( int [ ] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( nums [ m ] < nums [ r ] ) r = m ; else l = m + 1 ; } return nums [ l ] ; } }
class Solution { public int getLengthOfOptimalCompression ( String s , int k ) { dp = new int [ s . length ( ) ] [ k + 1 ] ; Arrays . stream ( dp ) . forEach ( A -> Arrays . fill ( A , kMax ) ) ; return compression ( s , 0 , k ) ; } private static final int kMax = 101 ; private int [ ] [ ] dp ; private int compression ( final String s , int i , int k ) { if ( k < 0 ) return kMax ; if ( i == s . length ( ) || s . length ( ) - i <= k ) return 0 ; if ( dp [ i ] [ k ] != kMax ) return dp [ i ] [ k ] ; int maxFreq = 0 ; int [ ] count = new int [ 128 ] ; for ( int j = i ; j < s . length ( ) ; ++ j ) { maxFreq = Math . max ( maxFreq , ++ count [ s . charAt ( j ) ] ) ; dp [ i ] [ k ] = Math . min ( dp [ i ] [ k ] , getLength ( maxFreq ) + compression ( s , j + 1 , k - ( j - i + 1 - maxFreq ) ) ) ; } return dp [ i ] [ k ] ; } private int getLength ( int maxFreq ) { if ( maxFreq == 1 ) return 1 ; if ( maxFreq < 10 ) return 2 ; if ( maxFreq < 100 ) return 3 ; return 4 ; } }
class Solution { public int maxSum ( int [ ] nums1 , int [ ] nums2 ) { final int kMod = 1_000_000_007 ; long ans = 0 ; long sum1 = 0 ; long sum2 = 0 ; int i = 0 ; int j = 0 ; while ( i < nums1 . length && j < nums2 . length ) if ( nums1 [ i ] < nums2 [ j ] ) { sum1 += nums1 [ i ++ ] ; } else if ( nums1 [ i ] > nums2 [ j ] ) { sum2 += nums2 [ j ++ ] ; } else { ans += Math . max ( sum1 , sum2 ) + nums1 [ i ] ; sum1 = 0 ; sum2 = 0 ; ++ i ; ++ j ; } while ( i < nums1 . length ) sum1 += nums1 [ i ++ ] ; while ( j < nums2 . length ) sum2 += nums2 [ j ++ ] ; return ( int ) ( ( ans + Math . max ( sum1 , sum2 ) ) % kMod ) ; } }
class Solution { public int findMin ( int [ ] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( nums [ m ] == nums [ r ] ) -- r ; else if ( nums [ m ] < nums [ r ] ) r = m ; else l = m + 1 ; } return nums [ l ] ; } }
class Solution { public int longestAwesome ( String s ) { int ans = 0 ; int prefix = 0 ; int [ ] prefixToIndex = new int [ 1024 ] ; Arrays . fill ( prefixToIndex , s . length ( ) ) ; prefixToIndex [ 0 ] = - 1 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { prefix ^= 1 << s . charAt ( i ) - '0' ; ans = Math . max ( ans , i - prefixToIndex [ prefix ] ) ; for ( int j = 0 ; j < 10 ; ++ j ) ans = Math . max ( ans , i - prefixToIndex [ prefix ^ 1 << j ] ) ; prefixToIndex [ prefix ] = Math . min ( prefixToIndex [ prefix ] , i ) ; } return ans ; } }
class Solution { public int minCost ( int n , int [ ] cuts ) { A = new int [ cuts . length + 2 ] ; System . arraycopy ( cuts , 0 , A , 1 , cuts . length ) ; A [ 0 ] = 0 ; A [ A . length - 1 ] = n ; Arrays . sort ( A ) ; dp = new int [ A . length ] [ A . length ] ; return minCost ( 0 , A . length - 1 ) ; } private int [ ] [ ] dp ; private int [ ] A ; private int minCost ( int i , int j ) { if ( j - i <= 1 ) return 0 ; if ( dp [ i ] [ j ] != 0 ) return dp [ i ] [ j ] ; dp [ i ] [ j ] = Integer . MAX_VALUE ; for ( int k = i + 1 ; k < j ; ++ k ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , A [ j ] - A [ i ] + minCost ( i , k ) + minCost ( k , j ) ) ; return dp [ i ] [ j ] ; } }
class Solution { public List < Integer > mostSimilar ( int n , int [ ] [ ] roads , String [ ] names , String [ ] targetPath ) { this . names = names ; this . targetPath = targetPath ; this . cost = new int [ names . length ] [ targetPath . length ] ; this . next = new int [ names . length ] [ targetPath . length ] ; this . graph = new List [ n ] ; Arrays . stream ( cost ) . forEach ( a -> Arrays . fill ( a , - 1 ) ) ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] road : roads ) { graph [ road [ 0 ] ] . add ( road [ 1 ] ) ; graph [ road [ 1 ] ] . add ( road [ 0 ] ) ; } int minDist = Integer . MAX_VALUE ; int start = 0 ; for ( int i = 0 ; i < names . length ; ++ i ) { final int dist = dfs ( i , 0 ) ; if ( dist < minDist ) { minDist = dist ; start = i ; } } List < Integer > ans = new ArrayList < > ( ) ; while ( ans . size ( ) < targetPath . length ) { ans . add ( start ) ; start = next [ start ] [ ans . size ( ) - 1 ] ; } return ans ; } private String [ ] names ; private String [ ] targetPath ; private int [ ] [ ] cost ; private int [ ] [ ] next ; private List < Integer > [ ] graph ; private int dfs ( int nameIndex , int pathIndex ) { if ( cost [ nameIndex ] [ pathIndex ] != - 1 ) return cost [ nameIndex ] [ pathIndex ] ; final int editDist = names [ nameIndex ] . equals ( targetPath [ pathIndex ] ) ? 0 : 1 ; if ( pathIndex == targetPath . length - 1 ) return editDist ; int minDist = Integer . MAX_VALUE ; for ( final int v : graph [ nameIndex ] ) { final int dist = dfs ( v , pathIndex + 1 ) ; if ( dist < minDist ) { minDist = dist ; next [ nameIndex ] [ pathIndex ] = v ; } } return cost [ nameIndex ] [ pathIndex ] = editDist + minDist ; } }
class MinStack { public void push ( int x ) { if ( stack . isEmpty ( ) ) stack . push ( new int [ ] { x , x } ) ; else stack . push ( new int [ ] { x , Math . min ( x , stack . peek ( ) [ 1 ] ) } ) ; } public void pop ( ) { stack . pop ( ) ; } public int top ( ) { return stack . peek ( ) [ 0 ] ; } public int getMin ( ) { return stack . peek ( ) [ 1 ] ; } private Stack < int [ ] > stack = new Stack < > ( ) ; }
class Solution { public TreeNode upsideDownBinaryTree ( TreeNode root ) { if ( root == null || root . left == null ) return root ; TreeNode newRoot = upsideDownBinaryTree ( root . left ) ; root . left . left = root . right ; root . left . right = root ; root . left = null ; root . right = null ; return newRoot ; } }
public class Solution extends Reader4 { public int read ( char [ ] buf , int n ) { char [ ] buf4 = new char [ 4 ] ; int i4 = 0 ; int n4 = 0 ; int i = 0 ; while ( i < n ) { if ( i4 == n4 ) { i4 = 0 ; n4 = read4 ( buf4 ) ; if ( n4 == 0 ) return i ; } buf [ i ++ ] = buf4 [ i4 ++ ] ; } return i ; } }
public class Solution extends Reader4 { public int read ( char [ ] buf , int n ) { int i = 0 ; while ( i < n ) { if ( i4 == n4 ) { i4 = 0 ; n4 = read4 ( buf4 ) ; if ( n4 == 0 ) return i ; } buf [ i ++ ] = buf4 [ i4 ++ ] ; } return i ; } private char [ ] buf4 = new char [ 4 ] ; private int i4 = 0 ; private int n4 = 0 ; }
class Solution { public int unhappyFriends ( int n , int [ ] [ ] preferences , int [ ] [ ] pairs ) { int ans = 0 ; int [ ] matches = new int [ n ] ; Map < Integer , Integer > [ ] prefer = new Map [ n ] ; for ( int [ ] pair : pairs ) { final int x = pair [ 0 ] ; final int y = pair [ 1 ] ; matches [ x ] = y ; matches [ y ] = x ; } for ( int i = 0 ; i < n ; ++ i ) prefer [ i ] = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n - 1 ; ++ j ) prefer [ i ] . put ( preferences [ i ] [ j ] , j ) ; for ( int x = 0 ; x < n ; ++ x ) for ( final int u : preferences [ x ] ) { final int y = matches [ x ] ; final int v = matches [ u ] ; if ( prefer [ x ] . get ( u ) < prefer [ x ] . get ( y ) && prefer [ u ] . get ( x ) < prefer [ u ] . get ( v ) ) { ++ ans ; break ; } } return ans ; } }
class Solution { public int lengthOfLongestSubstringTwoDistinct ( String s ) { int ans = 0 ; int distinct = 0 ; int [ ] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length ( ) ; ++ r ) { if ( ++ count [ s . charAt ( r ) ] == 1 ) ++ distinct ; while ( distinct == 3 ) if ( -- count [ s . charAt ( l ++ ) ] == 0 ) -- distinct ; ans = Math . max ( ans , r - l + 1 ) ; } return ans ; } }
class Solution { public int threeSumClosest ( int [ ] nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] ; Arrays . sort ( nums ) ; for ( int i = 0 ; i + 2 < nums . length ; ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ] ) continue ; int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) { final int sum = nums [ i ] + nums [ l ] + nums [ r ] ; if ( sum == target ) return sum ; if ( Math . abs ( sum - target ) < Math . abs ( ans - target ) ) ans = sum ; if ( sum < target ) ++ l ; else -- r ; } } return ans ; } }
public class Solution { public ListNode getIntersectionNode ( ListNode headA , ListNode headB ) { ListNode a = headA ; ListNode b = headB ; while ( a != b ) { a = a == null ? headB : a . next ; b = b == null ? headA : b . next ; } return a ; } }
class ParkingSystem { public ParkingSystem ( int big , int medium , int small ) { count = new int [ ] { big , medium , small } ; } public boolean addCar ( int carType ) { return count [ carType - 1 ] -- > 0 ; } private int [ ] count ; }
class Solution { public boolean isOneEditDistance ( String s , String t ) { final int m = s . length ( ) ; final int n = t . length ( ) ; if ( m > n ) return isOneEditDistance ( t , s ) ; for ( int i = 0 ; i < m ; ++ i ) if ( s . charAt ( i ) != t . charAt ( i ) ) { if ( m == n ) return s . substring ( i + 1 ) . equals ( t . substring ( i + 1 ) ) ; return s . substring ( i ) . equals ( t . substring ( i + 1 ) ) ; } return m + 1 == n ; } }
class Solution { public int visiblePoints ( List < List < Integer > > points , int angle , List < Integer > location ) { final int posX = location . get ( 0 ) ; final int posY = location . get ( 1 ) ; int maxVisible = 0 ; int same = 0 ; List < Double > pointAngles = new ArrayList < > ( ) ; for ( List < Integer > p : points ) { final int x = p . get ( 0 ) ; final int y = p . get ( 1 ) ; if ( x == posX && y == posY ) ++ same ; else pointAngles . add ( getAngle ( y - posY , x - posX ) ) ; } Collections . sort ( pointAngles ) ; final int n = pointAngles . size ( ) ; for ( int i = 0 ; i < n ; ++ i ) pointAngles . add ( pointAngles . get ( i ) + 360 ) ; for ( int l = 0 , r = 0 ; r < pointAngles . size ( ) ; ++ r ) { while ( pointAngles . get ( r ) - pointAngles . get ( l ) > angle ) ++ l ; maxVisible = Math . max ( maxVisible , r - l + 1 ) ; } return maxVisible + same ; } private double getAngle ( int dy , int dx ) { return Math . atan2 ( dy , dx ) * 180 / Math . PI ; } }
class Solution { public int findPeakElement ( int [ ] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( nums [ m ] >= nums [ m + 1 ] ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public List < String > findMissingRanges ( int [ ] nums , int lower , int upper ) { if ( nums . length == 0 ) return new ArrayList < > ( Arrays . asList ( getRange ( lower , upper ) ) ) ; List < String > ans = new ArrayList < > ( ) ; if ( nums [ 0 ] > lower ) ans . add ( getRange ( lower , nums [ 0 ] - 1 ) ) ; for ( int i = 1 ; i < nums . length ; ++ i ) if ( nums [ i ] > nums [ i - 1 ] + 1 ) ans . add ( getRange ( nums [ i - 1 ] + 1 , nums [ i ] - 1 ) ) ; if ( nums [ nums . length - 1 ] < upper ) ans . add ( getRange ( nums [ nums . length - 1 ] + 1 , upper ) ) ; return ans ; } private String getRange ( int lo , int hi ) { if ( lo == hi ) return String . valueOf ( lo ) ; return lo + " - > " + hi ; } }
class T { public int i ; public int j ; public int d ; public T ( int i , int j , int d ) { this . i = i ; this . j = j ; this . d = d ; } } class Solution { public int minimumEffortPath ( int [ ] [ ] heights ) { final int m = heights . length ; final int n = heights [ 0 ] . length ; final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; Queue < T > minHeap = new PriorityQueue < > ( ( a , b ) -> a . d - b . d ) ; int [ ] [ ] diff = new int [ m ] [ n ] ; Arrays . stream ( diff ) . forEach ( row -> Arrays . fill ( row , Integer . MAX_VALUE ) ) ; boolean [ ] [ ] seen = new boolean [ m ] [ n ] ; minHeap . offer ( new T ( 0 , 0 , 0 ) ) ; diff [ 0 ] [ 0 ] = 0 ; while ( ! minHeap . isEmpty ( ) ) { final int i = minHeap . peek ( ) . i ; final int j = minHeap . peek ( ) . j ; final int d = minHeap . poll ( ) . d ; if ( i == m - 1 && j == n - 1 ) return d ; seen [ i ] [ j ] = true ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seen [ x ] [ y ] ) continue ; final int newDiff = Math . abs ( heights [ i ] [ j ] - heights [ x ] [ y ] ) ; final int maxDiff = Math . max ( diff [ i ] [ j ] , newDiff ) ; if ( diff [ x ] [ y ] > maxDiff ) { diff [ x ] [ y ] = maxDiff ; minHeap . offer ( new T ( x , y , maxDiff ) ) ; } } } throw new IllegalArgumentException ( ) ; } }
class Bucket { public int min ; public int max ; public Bucket ( int min , int max ) { this . min = min ; this . max = max ; } } class Solution { public int maximumGap ( int [ ] nums ) { if ( nums . length < 2 ) return 0 ; final int min = Arrays . stream ( nums ) . min ( ) . getAsInt ( ) ; final int max = Arrays . stream ( nums ) . max ( ) . getAsInt ( ) ; if ( min == max ) return 0 ; final int gap = ( int ) Math . ceil ( ( double ) ( max - min ) / ( nums . length - 1 ) ) ; final int bucketsLength = ( max - min ) / gap + 1 ; Bucket [ ] buckets = new Bucket [ bucketsLength ] ; for ( int i = 0 ; i < buckets . length ; ++ i ) buckets [ i ] = new Bucket ( Integer . MAX_VALUE , Integer . MIN_VALUE ) ; for ( final int num : nums ) { final int i = ( num - min ) / gap ; buckets [ i ] . min = Math . min ( buckets [ i ] . min , num ) ; buckets [ i ] . max = Math . max ( buckets [ i ] . max , num ) ; } int ans = 0 ; int prevMax = min ; for ( final Bucket bucket : buckets ) { if ( bucket . min == Integer . MAX_VALUE ) continue ; ans = Math . max ( ans , bucket . min - prevMax ) ; prevMax = bucket . max ; } return ans ; } }
class Solution { public int compareVersion ( String version1 , String version2 ) { final String [ ] levels1 = version1 . split ( " \\ . " ) ; final String [ ] levels2 = version2 . split ( " \\ . " ) ; final int length = Math . max ( levels1 . length , levels2 . length ) ; for ( int i = 0 ; i < length ; ++ i ) { final Integer v1 = i < levels1 . length ? Integer . parseInt ( levels1 [ i ] ) : 0 ; final Integer v2 = i < levels2 . length ? Integer . parseInt ( levels2 [ i ] ) : 0 ; final int compare = v1 . compareTo ( v2 ) ; if ( compare != 0 ) return compare ; } return 0 ; } }
class Solution { public boolean closeStrings ( String word1 , String word2 ) { if ( word1 . length ( ) != word2 . length ( ) ) return false ; Map < Character , Integer > count1 = new HashMap < > ( ) ; Map < Character , Integer > count2 = new HashMap < > ( ) ; for ( final char c : word1 . toCharArray ( ) ) count1 . put ( c , count1 . getOrDefault ( c , 0 ) + 1 ) ; for ( final char c : word2 . toCharArray ( ) ) count2 . put ( c , count2 . getOrDefault ( c , 0 ) + 1 ) ; if ( ! count1 . keySet ( ) . equals ( count2 . keySet ( ) ) ) return false ; List < Integer > freqs1 = new ArrayList < > ( count1 . values ( ) ) ; List < Integer > freqs2 = new ArrayList < > ( count2 . values ( ) ) ; Collections . sort ( freqs1 ) ; Collections . sort ( freqs2 ) ; return freqs1 . equals ( freqs2 ) ; } }
class Solution { public String fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return "0" ; StringBuilder sb = new StringBuilder ( ) ; if ( numerator < 0 ^ denominator < 0 ) sb . append ( " - " ) ; long n = Math . abs ( ( long ) numerator ) ; long d = Math . abs ( ( long ) denominator ) ; sb . append ( n / d ) ; if ( n % d == 0 ) return sb . toString ( ) ; sb . append ( " . " ) ; Map < Long , Integer > seen = new HashMap < > ( ) ; for ( long r = n % d ; r > 0 ; r %= d ) { if ( seen . containsKey ( r ) ) { sb . insert ( seen . get ( r ) , " ( " ) ; sb . append ( " ) " ) ; break ; } seen . put ( r , sb . length ( ) ) ; r *= 10 ; sb . append ( r / d ) ; } return sb . toString ( ) ; } }
class Solution { public int [ ] twoSum ( int [ ] numbers , int target ) { int l = 0 ; int r = numbers . length - 1 ; while ( numbers [ l ] + numbers [ r ] != target ) if ( numbers [ l ] + numbers [ r ] < target ) ++ l ; else -- r ; return new int [ ] { l + 1 , r + 1 } ; } }
class Solution { public TreeNode lowestCommonAncestor ( TreeNode root , TreeNode [ ] nodes ) { Set < TreeNode > nodesSet = new HashSet < > ( Arrays . asList ( nodes ) ) ; return lca ( root , nodesSet ) ; } private TreeNode lca ( TreeNode root , Set < TreeNode > nodesSet ) { if ( root == null ) return null ; if ( nodesSet . contains ( root ) ) return root ; TreeNode l = lca ( root . left , nodesSet ) ; TreeNode r = lca ( root . right , nodesSet ) ; if ( l != null && r != null ) return root ; return l == null ? r : l ; } }
class Solution { public String convertToTitle ( int n ) { return n == 0 ? " " : convertToTitle ( ( n - 1 ) / 26 ) + ( char ) ( ' A ' + ( ( n - 1 ) % 26 ) ) ; } }
class Solution { public int boxDelivering ( int [ ] [ ] boxes , int portsCount , int maxBoxes , int maxWeight ) { final int n = boxes . length ; int [ ] dp = new int [ n + 1 ] ; int trips = 2 ; int weight = 0 ; for ( int l = 0 , r = 0 ; r < n ; ++ r ) { weight += boxes [ r ] [ 1 ] ; if ( r > 0 && boxes [ r ] [ 0 ] != boxes [ r - 1 ] [ 0 ] ) ++ trips ; while ( r - l + 1 > maxBoxes || weight > maxWeight || ( l < r && dp [ l + 1 ] == dp [ l ] ) ) { weight -= boxes [ l ] [ 1 ] ; if ( boxes [ l ] [ 0 ] != boxes [ l + 1 ] [ 0 ] ) -- trips ; ++ l ; } dp [ r + 1 ] = dp [ l ] + trips ; } return dp [ n ] ; } }
class Solution { public int majorityElement ( int [ ] nums ) { Integer ans = null ; int count = 0 ; for ( final int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } }
class Solution { public List < String > letterCombinations ( String digits ) { if ( digits . isEmpty ( ) ) return new ArrayList < > ( ) ; List < String > ans = new ArrayList < > ( ) ; dfs ( digits , 0 , new StringBuilder ( ) , ans ) ; return ans ; } private static final String [ ] digitToLetters = { " " , " " , " abc " , " def " , " ghi " , " jkl " , " mno " , " pqrs " , " tuv " , " wxyz " } ; private void dfs ( String digits , int i , StringBuilder sb , List < String > ans ) { if ( i == digits . length ( ) ) { ans . add ( sb . toString ( ) ) ; return ; } for ( final char c : digitToLetters [ digits . charAt ( i ) - '0' ] . toCharArray ( ) ) { sb . append ( c ) ; dfs ( digits , i + 1 , sb , ans ) ; sb . deleteCharAt ( sb . length ( ) - 1 ) ; } } }
class TwoSum { public void add ( int number ) { count . put ( number , count . getOrDefault ( number , 0 ) + 1 ) ; } public boolean find ( int value ) { for ( Map . Entry < Integer , Integer > entry : count . entrySet ( ) ) { final int key = entry . getKey ( ) ; final int remain = value - key ; if ( key == remain && entry . getValue ( ) > 1 ) return true ; if ( key != remain && count . containsKey ( remain ) ) return true ; } return false ; } private HashMap < Integer , Integer > count = new HashMap < > ( ) ; }
class Solution { public int [ ] findBall ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int [ ] dp = new int [ n ] ; int [ ] ans = new int [ n ] ; Arrays . fill ( ans , - 1 ) ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ] = i ; for ( int i = 0 ; i < m ; ++ i ) { int [ ] newDp = new int [ n ] ; Arrays . fill ( newDp , - 1 ) ; for ( int j = 0 ; j < n ; ++ j ) { if ( j + grid [ i ] [ j ] < 0 || j + grid [ i ] [ j ] == n ) continue ; if ( grid [ i ] [ j ] == 1 && grid [ i ] [ j + 1 ] == - 1 || grid [ i ] [ j ] == - 1 && grid [ i ] [ j - 1 ] == 1 ) continue ; newDp [ j + grid [ i ] [ j ] ] = dp [ j ] ; } dp = newDp ; } for ( int i = 0 ; i < n ; ++ i ) if ( dp [ i ] != - 1 ) ans [ dp [ i ] ] = i ; return ans ; } }
class Solution { public int titleToNumber ( String s ) { int ans = 0 ; for ( final char c : s . toCharArray ( ) ) ans = ans * 26 + c - ' @ ' ; return ans ; } }
class Solution { public int waysToSplit ( int [ ] nums ) { final int kMod = 1_000_000_007 ; final int n = nums . length ; int ans = 0 ; int [ ] prefix = nums . clone ( ) ; for ( int i = 1 ; i < n ; ++ i ) prefix [ i ] += prefix [ i - 1 ] ; for ( int i = 0 ; i < n - 2 ; ++ i ) { final int j = firstGreaterEqual ( prefix , i ) ; if ( j == n - 1 ) break ; final int mid = prefix [ j ] - prefix [ i ] ; final int right = prefix [ prefix . length - 1 ] - prefix [ j ] ; if ( mid > right ) continue ; final int k = firstGreater ( prefix , i ) ; ans = ( ans + k - j ) % kMod ; } return ans ; } private int firstGreaterEqual ( int [ ] prefix , int i ) { int l = i + 1 ; int r = prefix . length - 1 ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( prefix [ m ] - prefix [ i ] >= prefix [ i ] ) r = m ; else l = m + 1 ; } return l ; } ; private int firstGreater ( int [ ] prefix , int i ) { int l = i + 1 ; int r = prefix . length - 1 ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( prefix [ m ] - prefix [ i ] > prefix [ prefix . length - 1 ] - prefix [ m ] ) r = m ; else l = m + 1 ; } return l ; } ; }
class Solution { public int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ) ; } }
class Solution { public int largestSubmatrix ( int [ ] [ ] matrix ) { final int n = matrix [ 0 ] . length ; int ans = 0 ; int [ ] hist = new int [ n ] ; for ( int [ ] row : matrix ) { for ( int i = 0 ; i < n ; ++ i ) hist [ i ] = row [ i ] == 0 ? 0 : hist [ i ] + 1 ; int [ ] sortedHist = hist . clone ( ) ; Arrays . sort ( sortedHist ) ; for ( int i = 0 ; i < n ; ++ i ) ans = Math . max ( ans , sortedHist [ i ] * ( n - i ) ) ; } return ans ; } }
class Solution { public boolean canMouseWin ( String [ ] grid , int catJump , int mouseJump ) { m = grid . length ; n = grid [ 0 ] . length ( ) ; int cat = 0 ; int mouse = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ] . charAt ( j ) != ' # ' ) ++ nFloors ; if ( grid [ i ] . charAt ( j ) == ' C ' ) cat = hash ( i , j ) ; else if ( grid [ i ] . charAt ( j ) == ' M ' ) mouse = hash ( i , j ) ; } dp = new Boolean [ m * n ] [ m * n ] [ nFloors * 2 ] ; return canMouseWin ( grid , cat , mouse , 0 , catJump , mouseJump ) ; } private static final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; private int m ; private int n ; private int nFloors = 0 ; private Boolean [ ] [ ] [ ] dp ; private boolean canMouseWin ( final String [ ] grid , int cat , int mouse , int turn , int catJump , int mouseJump ) { if ( turn == nFloors * 2 ) return false ; if ( dp [ cat ] [ mouse ] [ turn ] != null ) return dp [ cat ] [ mouse ] [ turn ] ; if ( turn % 2 == 0 ) { final int i = mouse / n ; final int j = mouse % n ; for ( int k = 0 ; k < 4 ; ++ k ) { for ( int jump = 0 ; jump <= mouseJump ; ++ jump ) { final int x = i + dirs [ k ] * jump ; final int y = j + dirs [ k + 1 ] * jump ; if ( x < 0 || x == m || y < 0 || y == n ) break ; if ( grid [ x ] . charAt ( y ) == ' # ' ) break ; if ( grid [ x ] . charAt ( y ) == ' F ' ) return dp [ cat ] [ mouse ] [ turn ] = true ; if ( canMouseWin ( grid , cat , hash ( x , y ) , turn + 1 , catJump , mouseJump ) ) return dp [ cat ] [ mouse ] [ turn ] = true ; } } return dp [ cat ] [ mouse ] [ turn ] = false ; } else { final int i = cat / n ; final int j = cat % n ; for ( int k = 0 ; k < 4 ; ++ k ) { for ( int jump = 0 ; jump <= catJump ; ++ jump ) { final int x = i + dirs [ k ] * jump ; final int y = j + dirs [ k + 1 ] * jump ; if ( x < 0 || x == m || y < 0 || y == n ) break ; if ( grid [ x ] . charAt ( y ) == ' # ' ) break ; if ( grid [ x ] . charAt ( y ) == ' F ' ) return dp [ cat ] [ mouse ] [ turn ] = false ; final int nextCat = hash ( x , y ) ; if ( nextCat == mouse ) return dp [ cat ] [ mouse ] [ turn ] = false ; if ( ! canMouseWin ( grid , nextCat , mouse , turn + 1 , catJump , mouseJump ) ) return dp [ cat ] [ mouse ] [ turn ] = false ; } } return dp [ cat ] [ mouse ] [ turn ] = true ; } } private int hash ( int i , int j ) { return i * n + j ; } }
class BSTIterator { public BSTIterator ( TreeNode root ) { inorder ( root ) ; } public int next ( ) { return vals . get ( i ++ ) ; } public boolean hasNext ( ) { return i < vals . size ( ) ; } private int i = 0 ; private List < Integer > vals = new ArrayList < > ( ) ; private void inorder ( TreeNode root ) { if ( root == null ) return ; inorder ( root . left ) ; vals . add ( root . val ) ; inorder ( root . right ) ; } }
class Solution { public int minimumBoxes ( int n ) { int nBoxes = 0 ; int nextTouchings = 0 ; int currLevelBoxes = 0 ; while ( nBoxes < n ) { ++ nextTouchings ; currLevelBoxes += nextTouchings ; nBoxes += currLevelBoxes ; } if ( nBoxes == n ) return currLevelBoxes ; nBoxes -= currLevelBoxes ; currLevelBoxes -= nextTouchings ; nextTouchings = 0 ; while ( nBoxes < n ) { ++ nextTouchings ; nBoxes += nextTouchings ; } return currLevelBoxes + nextTouchings ; } }
class Solution { public int calculateMinimumHP ( int [ ] [ ] dungeon ) { final int m = dungeon . length ; final int n = dungeon [ 0 ] . length ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; Arrays . stream ( dp ) . forEach ( A -> Arrays . fill ( A , Integer . MAX_VALUE ) ) ; dp [ m ] [ n - 1 ] = 1 ; dp [ m - 1 ] [ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) - dungeon [ i ] [ j ] ; dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , 1 ) ; } return dp [ 0 ] [ 0 ] ; } }
class Solution { public int findDistance ( TreeNode root , int p , int q ) { TreeNode lca = getLCA ( root , p , q ) ; return dist ( lca , p ) + dist ( lca , q ) ; } private TreeNode getLCA ( TreeNode root , int p , int q ) { if ( root == null || root . val == p || root . val == q ) return root ; TreeNode l = getLCA ( root . left , p , q ) ; TreeNode r = getLCA ( root . right , p , q ) ; if ( l != null && r != null ) return root ; return l == null ? r : l ; } private int dist ( TreeNode lca , int target ) { if ( lca == null ) return 10000 ; if ( lca . val == target ) return 0 ; return 1 + Math . min ( dist ( lca . left , target ) , dist ( lca . right , target ) ) ; } }
class Solution { public int [ ] restoreArray ( int [ ] [ ] adjacentPairs ) { int [ ] ans = new int [ adjacentPairs . length + 1 ] ; int i = 0 ; Map < Integer , List < Integer > > numToAdjs = new HashMap < > ( ) ; for ( int [ ] pair : adjacentPairs ) { numToAdjs . putIfAbsent ( pair [ 0 ] , new ArrayList < > ( ) ) ; numToAdjs . putIfAbsent ( pair [ 1 ] , new ArrayList < > ( ) ) ; numToAdjs . get ( pair [ 0 ] ) . add ( pair [ 1 ] ) ; numToAdjs . get ( pair [ 1 ] ) . add ( pair [ 0 ] ) ; } for ( Map . Entry < Integer , List < Integer > > entry : numToAdjs . entrySet ( ) ) if ( entry . getValue ( ) . size ( ) == 1 ) { ans [ i ++ ] = entry . getKey ( ) ; ans [ i ++ ] = entry . getValue ( ) . get ( 0 ) ; break ; } while ( i < adjacentPairs . length + 1 ) { final int tail = ans [ i - 1 ] ; final int prev = ans [ i - 2 ] ; List < Integer > adjs = numToAdjs . get ( tail ) ; if ( adjs . get ( 0 ) == prev ) ans [ i ++ ] = adjs . get ( 1 ) ; else ans [ i ++ ] = adjs . get ( 0 ) ; } return ans ; } }
class Solution { public boolean [ ] canEat ( int [ ] candiesCount , int [ ] [ ] queries ) { final int n = candiesCount . length ; boolean [ ] ans = new boolean [ queries . length ] ; long [ ] prefix = new long [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) prefix [ i + 1 ] = prefix [ i ] + candiesCount [ i ] ; for ( int i = 0 ; i < queries . length ; ++ i ) { final int type = queries [ i ] [ 0 ] ; final long day = ( long ) queries [ i ] [ 1 ] ; final long cap = ( long ) queries [ i ] [ 2 ] ; final long minDay = prefix [ type ] / cap ; final long maxDay = prefix [ type + 1 ] - 1 ; ans [ i ] = minDay <= day && day <= maxDay ; } return ans ; } }
class Solution { public boolean checkPartitioning ( String s ) { final int n = s . length ( ) ; dp = new int [ n ] [ n ] ; Arrays . stream ( dp ) . forEach ( A -> Arrays . fill ( A , - 1 ) ) ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i + 1 ; j < n ; ++ j ) if ( isPalindrome ( s , 0 , i ) == 1 && isPalindrome ( s , i + 1 , j ) == 1 && isPalindrome ( s , j + 1 , n - 1 ) == 1 ) return true ; return false ; } private int [ ] [ ] dp ; int isPalindrome ( final String s , int i , int j ) { if ( i > j ) return 1 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( s . charAt ( i ) == s . charAt ( j ) ) return dp [ i ] [ j ] = isPalindrome ( s , i + 1 , j - 1 ) ; return dp [ i ] [ j ] = 0 ; } }
class Solution { public int maxValue ( int [ ] [ ] events , int k ) { dp = new Integer [ events . length ] [ k + 1 ] ; Arrays . sort ( events , ( a , b ) -> a [ 0 ] == b [ 0 ] ? a [ 1 ] - b [ 1 ] : a [ 0 ] - b [ 0 ] ) ; return maxValue ( events , 0 , k ) ; } private Integer [ ] [ ] dp ; private int maxValue ( int [ ] [ ] e , int i , int k ) { if ( k == 0 || i == e . length ) return 0 ; if ( dp [ i ] [ k ] != null ) return dp [ i ] [ k ] ; final int j = binarySearch ( e , i + 1 , e [ i ] [ 1 ] + 1 ) ; return dp [ i ] [ k ] = Math . max ( e [ i ] [ 2 ] + maxValue ( e , j , k - 1 ) , maxValue ( e , i + 1 , k ) ) ; } private int binarySearch ( int [ ] [ ] e , int l , int target ) { int r = e . length ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( e [ m ] [ 0 ] >= target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public int minAbsDifference ( int [ ] nums , int goal ) { final int n = nums . length / 2 ; final int [ ] lNums = Arrays . copyOfRange ( nums , 0 , n ) ; final int [ ] rNums = Arrays . copyOfRange ( nums , n , nums . length ) ; int ans = Integer . MAX_VALUE ; List < Integer > lSums = new ArrayList < > ( ) ; List < Integer > rSums = new ArrayList < > ( ) ; dfs ( lNums , 0 , 0 , lSums ) ; dfs ( rNums , 0 , 0 , rSums ) ; Collections . sort ( rSums ) ; for ( final int lSum : lSums ) { final int i = firstGreaterEqual ( rSums , goal - lSum ) ; if ( i < rSums . size ( ) ) ans = Math . min ( ans , Math . abs ( goal - lSum - rSums . get ( i ) ) ) ; if ( i > 0 ) ans = Math . min ( ans , Math . abs ( goal - lSum - rSums . get ( i - 1 ) ) ) ; } return ans ; } private void dfs ( int [ ] A , int i , int path , List < Integer > sums ) { if ( i == A . length ) { sums . add ( path ) ; return ; } dfs ( A , i + 1 , path + A [ i ] , sums ) ; dfs ( A , i + 1 , path , sums ) ; } private int firstGreaterEqual ( List < Integer > A , int target ) { int l = 0 ; int r = A . size ( ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A . get ( m ) >= target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public int [ ] findBuildings ( int [ ] heights ) { Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < heights . length ; ++ i ) { while ( ! stack . isEmpty ( ) && heights [ stack . peek ( ) ] <= heights [ i ] ) stack . pop ( ) ; stack . push ( i ) ; } int [ ] ans = new int [ stack . size ( ) ] ; for ( int i = 0 ; i < ans . length ; ++ i ) ans [ ans . length - 1 - i ] = stack . pop ( ) ; return ans ; } }
class Solution { public String mergeAlternately ( String word1 , String word2 ) { final int n = Math . min ( word1 . length ( ) , word2 . length ( ) ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; ++ i ) { sb . append ( word1 . charAt ( i ) ) ; sb . append ( word2 . charAt ( i ) ) ; } return sb . append ( word1 . substring ( n ) ) . append ( word2 . substring ( n ) ) . toString ( ) ; } }
class Solution { public int maximumScore ( int [ ] nums , int [ ] multipliers ) { dp = new Integer [ multipliers . length ] [ multipliers . length ] ; return maximumScore ( nums , 0 , multipliers , 0 ) ; } private Integer [ ] [ ] dp ; int maximumScore ( int [ ] nums , int s , int [ ] multipliers , int i ) { if ( i == multipliers . length ) return 0 ; if ( dp [ s ] [ i ] != null ) return dp [ s ] [ i ] ; final int e = nums . length - ( i - s ) - 1 ; final int pickStart = nums [ s ] * multipliers [ i ] + maximumScore ( nums , s + 1 , multipliers , i + 1 ) ; final int pickEnd = nums [ e ] * multipliers [ i ] + maximumScore ( nums , s , multipliers , i + 1 ) ; return dp [ s ] [ i ] = Math . max ( pickStart , pickEnd ) ; } }
class Car { public int pos ; public int speed ; public double collisionTime ; public Car ( int pos , int speed , double collisionTime ) { this . pos = pos ; this . speed = speed ; this . collisionTime = collisionTime ; } } class Solution { public double [ ] getCollisionTimes ( int [ ] [ ] cars ) { double [ ] ans = new double [ cars . length ] ; Deque < Car > stack = new ArrayDeque < > ( ) ; for ( int i = cars . length - 1 ; i >= 0 ; -- i ) { final int pos = cars [ i ] [ 0 ] ; final int speed = cars [ i ] [ 1 ] ; while ( ! stack . isEmpty ( ) && ( speed <= stack . peek ( ) . speed || getCollisionTime ( stack . peek ( ) , pos , speed ) >= stack . peek ( ) . collisionTime ) ) stack . pop ( ) ; if ( stack . isEmpty ( ) ) { stack . push ( new Car ( pos , speed , Integer . MAX_VALUE ) ) ; ans [ i ] = - 1 ; } else { final double collisionTime = getCollisionTime ( stack . peek ( ) , pos , speed ) ; stack . push ( new Car ( pos , speed , collisionTime ) ) ; ans [ i ] = collisionTime ; } } return ans ; } private double getCollisionTime ( Car car , int pos , int speed ) { return ( double ) ( car . pos - pos ) / ( speed - car . speed ) ; } }
class Solution { public boolean checkPowersOfThree ( int n ) { while ( n > 1 ) { const int r = n % 3 ; if ( r == 2 ) return false ; n /= 3 ; } return true ; } }
class Solution { public int [ ] countPairs ( int n , int [ ] [ ] edges , int [ ] queries ) { int [ ] ans = new int [ queries . length ] ; int [ ] count = new int [ n + 1 ] ; Map < Integer , Integer > [ ] shared = new Map [ n + 1 ] ; for ( int i = 1 ; i <= n ; ++ i ) shared [ i ] = new HashMap < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; ++ count [ u ] ; ++ count [ v ] ; shared [ Math . min ( u , v ) ] . merge ( Math . max ( u , v ) , 1 , Integer :: sum ) ; } int [ ] sortedCount = count . clone ( ) ; Arrays . sort ( sortedCount ) ; int k = 0 ; for ( final int q : queries ) { for ( int i = 1 , j = n ; i < j ; ) if ( sortedCount [ i ] + sortedCount [ j ] > q ) ans [ k ] += ( j -- ) - i ; else ++ i ; for ( int i = 1 ; i <= n ; ++ i ) for ( Map . Entry < Integer , Integer > p : shared [ i ] . entrySet ( ) ) { final int j = p . getKey ( ) ; final int sh = p . getValue ( ) ; if ( count [ i ] + count [ j ] > q && count [ i ] + count [ j ] - sh <= q ) -- ans [ k ] ; } ++ k ; } return ans ; } }
class Solution { public boolean checkOnesSegment ( String s ) { return ! s . contains ( "01" ) ; } }
class Solution { public List < List < Integer > > fourSum ( int [ ] nums , int target ) { List < List < Integer > > ans = new ArrayList < > ( ) ; Arrays . sort ( nums ) ; nSum ( nums , 4 , target , 0 , nums . length - 1 , new ArrayList < > ( ) , ans ) ; return ans ; } private void nSum ( int [ ] nums , long n , long target , int l , int r , List < Integer > path , List < List < Integer > > ans ) { if ( r - l + 1 < n || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { while ( l < r ) { final int sum = nums [ l ] + nums [ r ] ; if ( sum == target ) { path . add ( nums [ l ] ) ; path . add ( nums [ r ] ) ; ans . add ( new ArrayList < > ( path ) ) ; path . remove ( path . size ( ) - 1 ) ; path . remove ( path . size ( ) - 1 ) ; ++ l ; -- r ; while ( l < r && nums [ l ] == nums [ l - 1 ] ) ++ l ; while ( l < r && nums [ r ] == nums [ r + 1 ] ) -- r ; } else if ( sum < target ) { ++ l ; } else { -- r ; } } return ; } for ( int i = l ; i <= r ; ++ i ) { if ( i > l && nums [ i ] == nums [ i - 1 ] ) continue ; path . add ( nums [ i ] ) ; nSum ( nums , n - 1 , target - nums [ i ] , i + 1 , r , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; } } }
class Solution { public boolean areSentencesSimilar ( String sentence1 , String sentence2 ) { if ( sentence1 . length ( ) == sentence2 . length ( ) ) return sentence1 . equals ( sentence2 ) ; String [ ] words1 = sentence1 . split ( " ▁ " ) ; String [ ] words2 = sentence2 . split ( " ▁ " ) ; final int m = words1 . length ; final int n = words2 . length ; if ( m > n ) return areSentencesSimilar ( sentence2 , sentence1 ) ; int i = 0 ; while ( i < m && words1 [ i ] . equals ( words2 [ i ] ) ) ++ i ; while ( i < m && words1 [ i ] . equals ( words2 [ i + n - m ] ) ) ++ i ; return i == m ; } }
class Solution { public int countNicePairs ( int [ ] nums ) { final int kMod = 1_000_000_007 ; long ans = 0 ; Map < Integer , Long > count = new HashMap < > ( ) ; for ( final int num : nums ) { final int key = num - rev ( num ) ; count . put ( key , count . getOrDefault ( key , 0L ) + 1 ) ; } for ( final long freq : count . values ( ) ) { ans += freq * ( freq - 1 ) / 2 ; ans %= kMod ; } return ( int ) ans ; } private int rev ( int n ) { int x = 0 ; while ( n > 0 ) { x = x * 10 + ( n % 10 ) ; n /= 10 ; } return x ; } }
class Solution { public int maxHappyGroups ( int batchSize , int [ ] groups ) { int happy = 0 ; int [ ] freq = new int [ batchSize ] ; for ( int g : groups ) { g %= batchSize ; if ( g == 0 ) { ++ happy ; } else if ( freq [ batchSize - g ] > 0 ) { -- freq [ batchSize - g ] ; ++ happy ; } else { ++ freq [ g ] ; } } return happy + dp ( freq , 0 , batchSize ) ; } private Map < String , Integer > memo = new HashMap < > ( ) ; private int dp ( int [ ] freq , int r , int batchSize ) { final String hashed = hash ( freq ) ; if ( memo . containsKey ( hashed ) ) return memo . get ( hashed ) ; int ans = 0 ; if ( Arrays . stream ( freq ) . anyMatch ( f -> f != 0 ) ) { for ( int i = 0 ; i < freq . length ; ++ i ) if ( freq [ i ] > 0 ) { int [ ] newFreq = freq . clone ( ) ; -- newFreq [ i ] ; ans = Math . max ( ans , dp ( newFreq , ( r + i ) % batchSize , batchSize ) ) ; } if ( r == 0 ) ++ ans ; } memo . put ( hash ( freq ) , ans ) ; return ans ; } private String hash ( int [ ] freq ) { StringBuilder sb = new StringBuilder ( ) ; for ( final int f : freq ) sb . append ( " # " ) . append ( f ) ; return sb . toString ( ) ; } }
class Solution { public String truncateSentence ( String s , int k ) { String [ ] words = s . split ( " ▁ " ) ; String [ ] truncated = new String [ k ] ; for ( int i = 0 ; i < k ; ++ i ) truncated [ i ] = words [ i ] ; return String . join ( " ▁ " , truncated ) ; } }
class Solution { public int [ ] findingUsersActiveMinutes ( int [ ] [ ] logs , int k ) { int [ ] ans = new int [ k ] ; Map < Integer , Set < Integer > > idToTimes = new HashMap < > ( ) ; for ( int [ ] log : logs ) { idToTimes . putIfAbsent ( log [ 0 ] , new HashSet < > ( ) ) ; idToTimes . get ( log [ 0 ] ) . add ( log [ 1 ] ) ; } for ( final int id : idToTimes . keySet ( ) ) ++ ans [ idToTimes . get ( id ) . size ( ) - 1 ] ; return ans ; } }
class Solution { public int minAbsoluteSumDiff ( int [ ] nums1 , int [ ] nums2 ) { final int kMod = 1_000_000_007 ; long sumDiff = 0 ; long maxDecrement = 0 ; TreeSet < Integer > sorted = new TreeSet < > ( ) ; for ( final int num : nums1 ) sorted . add ( num ) ; for ( int i = 0 ; i < nums1 . length ; ++ i ) { final long currDiff = ( long ) Math . abs ( nums1 [ i ] - nums2 [ i ] ) ; sumDiff += currDiff ; Integer ceiling = sorted . ceiling ( nums2 [ i ] ) ; Integer floor = sorted . floor ( nums2 [ i ] ) ; if ( ceiling != null ) maxDecrement = Math . max ( maxDecrement , currDiff - ( long ) Math . abs ( ceiling - nums2 [ i ] ) ) ; if ( floor != null ) maxDecrement = Math . max ( maxDecrement , currDiff - ( long ) Math . abs ( floor - nums2 [ i ] ) ) ; } return ( int ) ( ( sumDiff - maxDecrement ) % kMod ) ; } }
class Solution { public int maximumInvitations ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int ans = 0 ; int [ ] mate = new int [ n ] ; Arrays . fill ( mate , - 1 ) ; for ( int i = 0 ; i < m ; ++ i ) if ( canInvite ( grid , i , new boolean [ n ] , mate ) ) ++ ans ; return ans ; } private boolean canInvite ( int [ ] [ ] grid , int i , boolean [ ] seen , int [ ] mate ) { for ( int j = 0 ; j < seen . length ; ++ j ) { if ( grid [ i ] [ j ] == 0 || seen [ j ] ) continue ; seen [ j ] = true ; if ( mate [ j ] == - 1 || canInvite ( grid , mate [ j ] , seen , mate ) ) { mate [ j ] = i ; return true ; } } return false ; } }
class Solution { public int arraySign ( int [ ] nums ) { int sign = 1 ; for ( final int num : nums ) { if ( num == 0 ) return 0 ; if ( num < 0 ) sign = - sign ; } return sign ; } }
class Solution { public int findTheWinner ( int n , int k ) { boolean [ ] friends = new boolean [ n ] ; int friendCount = n ; int fp = n ; while ( friendCount > 1 ) { for ( int i = 0 ; i < k ; ++ i , ++ fp ) while ( friends [ fp % n ] ) ++ fp ; friends [ ( fp - 1 ) % n ] = true ; -- friendCount ; } for ( fp = 0 ; friends [ fp ] ; ++ fp ) ; return fp + 1 ; } }
class Solution { public int minSideJumps ( int [ ] obstacles ) { final int kInf = ( int ) 1e6 ; int [ ] dp = { kInf , 1 , 0 , 1 } ; for ( final int obstacle : obstacles ) { if ( obstacle > 0 ) dp [ obstacle ] = kInf ; for ( int i = 1 ; i <= 3 ; ++ i ) if ( i != obstacle ) for ( int j = 1 ; j <= 3 ; ++ j ) dp [ i ] = Math . min ( dp [ i ] , dp [ j ] + ( i == j ? 0 : 1 ) ) ; } return Arrays . stream ( dp ) . min ( ) . getAsInt ( ) ; } }
class Solution { public int badSensor ( int [ ] sensor1 , int [ ] sensor2 ) { final boolean oneDefect = canReplace ( sensor2 , sensor1 ) ; final boolean twoDefect = canReplace ( sensor1 , sensor2 ) ; if ( oneDefect && twoDefect ) return - 1 ; if ( ! oneDefect && ! twoDefect ) return - 1 ; return oneDefect ? 1 : 2 ; } private boolean canReplace ( int [ ] A , int [ ] B ) { int i = 0 ; int j = 0 ; int droppedValue = - 1 ; while ( i < A . length ) if ( A [ i ] == B [ j ] ) { ++ i ; ++ j ; } else { droppedValue = A [ i ] ; ++ i ; } return j == B . length - 1 && B [ j ] != droppedValue ; } }
class Solution { public int minOperations ( int [ ] nums ) { int ans = 0 ; int last = 0 ; for ( final int num : nums ) { ans += Math . max ( 0 , last - num + 1 ) ; last = Math . max ( num , last + 1 ) ; } return ans ; } }
class Solution { public int [ ] countPoints ( int [ ] [ ] points , int [ ] [ ] queries ) { int [ ] ans = new int [ queries . length ] ; for ( int i = 0 ; i < queries . length ; ++ i ) { int [ ] q = queries [ i ] ; final int rSquared = q [ 2 ] * q [ 2 ] ; int count = 0 ; for ( int [ ] p : points ) if ( squared ( p [ 0 ] - q [ 0 ] ) + squared ( p [ 1 ] - q [ 1 ] ) <= rSquared ) ++ count ; ans [ i ] = count ; } return ans ; } private int squared ( int x ) { return x * x ; } }
class Solution { public int [ ] getMaximumXor ( int [ ] nums , int maximumBit ) { final int n = nums . length ; final int max = ( 1 << maximumBit ) - 1 ; int [ ] ans = new int [ n ] ; int xors = 0 ; for ( int i = 0 ; i < n ; ++ i ) { xors ^= nums [ i ] ; ans [ n - i - 1 ] = xors ^ max ; } return ans ; } }
class Solution { public boolean checkIfPangram ( String sentence ) { Set < Character > seen = new HashSet < > ( ) ; for ( final char c : sentence . toCharArray ( ) ) seen . add ( c ) ; return seen . size ( ) == 26 ; } }
class Solution { public int maxIceCream ( int [ ] costs , int coins ) { Arrays . sort ( costs ) ; for ( int i = 0 ; i < costs . length ; ++ i ) if ( coins >= costs [ i ] ) coins -= costs [ i ] ; else return i ; return costs . length ; } }
class T { public int procTime ; public int index ; public T ( int procTime , int index ) { this . procTime = procTime ; this . index = index ; } } class Solution { public int [ ] getOrder ( int [ ] [ ] tasks ) { final int n = tasks . length ; int [ ] [ ] A = new int [ n ] [ 3 ] ; for ( int i = 0 ; i < n ; ++ i ) { A [ i ] [ 0 ] = tasks [ i ] [ 0 ] ; A [ i ] [ 1 ] = tasks [ i ] [ 1 ] ; A [ i ] [ 2 ] = i ; } int [ ] ans = new int [ n ] ; int ansIndex = 0 ; Queue < T > minHeap = new PriorityQueue < > ( ( a , b ) -> a . procTime == b . procTime ? a . index - b . index : a . procTime - b . procTime ) ; int i = 0 ; long time = 0 ; Arrays . sort ( A , Comparator . comparing ( a -> a [ 0 ] ) ) ; while ( i < n || ! minHeap . isEmpty ( ) ) { if ( minHeap . isEmpty ( ) ) time = Math . max ( time , ( long ) A [ i ] [ 0 ] ) ; while ( i < n && time >= ( long ) A [ i ] [ 0 ] ) { minHeap . offer ( new T ( A [ i ] [ 1 ] , A [ i ] [ 2 ] ) ) ; ++ i ; } final int procTime = minHeap . peek ( ) . procTime ; final int index = minHeap . poll ( ) . index ; time += procTime ; ans [ ansIndex ++ ] = index ; } return ans ; } }
class Solution { public int getXORSum ( int [ ] arr1 , int [ ] arr2 ) { final int xors1 = Arrays . stream ( arr1 ) . reduce ( ( a , b ) -> a ^ b ) . getAsInt ( ) ; final int xors2 = Arrays . stream ( arr2 ) . reduce ( ( a , b ) -> a ^ b ) . getAsInt ( ) ; return xors1 & xors2 ; } }
class Solution { public ListNode deleteDuplicatesUnsorted ( ListNode head ) { ListNode dummy = new ListNode ( 0 , head ) ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) count . put ( curr . val , count . getOrDefault ( curr . val , 0 ) + 1 ) ; ListNode curr = dummy ; while ( curr != null ) { while ( curr . next != null && count . containsKey ( curr . next . val ) && count . get ( curr . next . val ) > 1 ) curr . next = curr . next . next ; curr = curr . next ; } return dummy . next ; } }
class Solution { public int sumBase ( int n , int k ) { int ans = 0 ; while ( n > 0 ) { ans += n % k ; n /= k ; } return ans ; } }
class Solution { public int maxFrequency ( int [ ] nums , int k ) { int ans = 0 ; long sum = 0 ; Arrays . sort ( nums ) ; for ( int l = 0 , r = 0 ; r < nums . length ; ++ r ) { sum += nums [ r ] ; while ( sum + k < ( long ) nums [ r ] * ( r - l + 1 ) ) sum -= nums [ l ++ ] ; ans = Math . max ( ans , r - l + 1 ) ; } return ans ; } }
class Solution { public int longestBeautifulSubstring ( String word ) { int ans = 0 ; int count = 1 ; for ( int l = 0 , r = 1 ; r < word . length ( ) ; ++ r ) { final char curr = word . charAt ( r ) ; final char prev = word . charAt ( r - 1 ) ; if ( curr >= prev ) { if ( curr > prev ) ++ count ; if ( count == 5 ) ans = Math . max ( ans , r - l + 1 ) ; } else { count = 1 ; l = r ; } } return ans ; } }
class Solution { public int maxBuilding ( int n , int [ ] [ ] restrictions ) { final int k = restrictions . length ; int [ ] [ ] A = new int [ k + 2 ] [ 2 ] ; System . arraycopy ( restrictions , 0 , A , 0 , k ) ; A [ k ] = new int [ ] { 1 , 0 } ; A [ k + 1 ] = new int [ ] { n , n - 1 } ; Arrays . sort ( A , ( a , b ) -> a [ 0 ] == b [ 0 ] ? a [ 1 ] - b [ 1 ] : a [ 0 ] - b [ 0 ] ) ; for ( int i = 1 ; i < A . length ; ++ i ) { final int dist = A [ i ] [ 0 ] - A [ i - 1 ] [ 0 ] ; A [ i ] [ 1 ] = Math . min ( A [ i ] [ 1 ] , A [ i - 1 ] [ 1 ] + dist ) ; } for ( int i = A . length - 2 ; i >= 0 ; -- i ) { final int dist = A [ i + 1 ] [ 0 ] - A [ i ] [ 0 ] ; A [ i ] [ 1 ] = Math . min ( A [ i ] [ 1 ] , A [ i + 1 ] [ 1 ] + dist ) ; } int ans = 0 ; for ( int i = 1 ; i < A . length ; ++ i ) { final int l = A [ i - 1 ] [ 0 ] ; final int r = A [ i ] [ 0 ] ; final int hL = A [ i - 1 ] [ 1 ] ; final int hR = A [ i ] [ 1 ] ; ans = Math . max ( ans , Math . max ( hL , hR ) + ( r - l - Math . abs ( hL - hR ) ) / 2 ) ; } return ans ; } }
class Solution { public String nextPalindrome ( String num ) { final int n = num . length ( ) ; int [ ] A = new int [ n / 2 ] ; for ( int i = 0 ; i < A . length ; ++ i ) A [ i ] = num . charAt ( i ) - '0' ; if ( ! nextPermutation ( A ) ) return " " ; StringBuilder sb = new StringBuilder ( ) ; for ( final int a : A ) sb . append ( a ) ; if ( ( n & 1 ) == 1 ) return sb . toString ( ) + num . charAt ( n / 2 ) + sb . reverse ( ) . toString ( ) ; return sb . toString ( ) + sb . reverse ( ) . toString ( ) ; } private boolean nextPermutation ( int [ ] nums ) { final int n = nums . length ; int i ; for ( i = n - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ] ) break ; if ( i < 0 ) return false ; for ( int j = n - 1 ; j > i ; -- j ) if ( nums [ j ] > nums [ i ] ) { swap ( nums , i , j ) ; break ; } reverse ( nums , i + 1 , n - 1 ) ; return true ; } private void reverse ( int [ ] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++ , r -- ) ; } private void swap ( int [ ] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } }
class Solution { public String replaceDigits ( String s ) { char [ ] A = s . toCharArray ( ) ; for ( int i = 1 ; i < A . length ; i += 2 ) A [ i ] += ( char ) ( A [ i - 1 ] - '0' ) ; return String . valueOf ( A ) ; } }
class SeatManager { public SeatManager ( int n ) { } public int reserve ( ) { if ( minHeap . isEmpty ( ) ) return ++ num ; return minHeap . poll ( ) ; } public void unreserve ( int seatNumber ) { minHeap . offer ( seatNumber ) ; } private Queue < Integer > minHeap = new PriorityQueue < > ( ) ; private int num = 0 ; }
class Solution { public int maximumElementAfterDecrementingAndRearranging ( int [ ] arr ) { Arrays . sort ( arr ) ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < arr . length ; ++ i ) arr [ i ] = Math . min ( arr [ i ] , arr [ i - 1 ] + 1 ) ; return arr [ arr . length - 1 ] ; } }
class Solution { public int [ ] closestRoom ( int [ ] [ ] rooms , int [ ] [ ] queries ) { int [ ] ans = new int [ queries . length ] ; Integer [ ] indices = new Integer [ queries . length ] ; TreeSet < Integer > roomIds = new TreeSet < > ( ) ; for ( int i = 0 ; i < queries . length ; ++ i ) indices [ i ] = i ; Arrays . sort ( rooms , ( a , b ) -> b [ 1 ] - a [ 1 ] ) ; Arrays . sort ( indices , ( a , b ) -> queries [ b ] [ 1 ] - queries [ a ] [ 1 ] ) ; int i = 0 ; for ( final int index : indices ) { while ( i < rooms . length && rooms [ i ] [ 1 ] >= queries [ index ] [ 1 ] ) roomIds . add ( rooms [ i ++ ] [ 0 ] ) ; ans [ index ] = searchClosestRoomId ( roomIds , queries [ index ] [ 0 ] ) ; } return ans ; } private int searchClosestRoomId ( TreeSet < Integer > roomIds , int preferred ) { Integer floor = roomIds . floor ( preferred ) ; Integer ceiling = roomIds . ceiling ( preferred ) ; final int id1 = floor == null ? - 1 : floor ; final int id2 = ceiling == null ? - 1 : ceiling ; if ( id1 == - 1 ) return id2 ; if ( id2 == - 1 ) return id1 ; if ( Math . abs ( preferred - id1 ) <= Math . abs ( preferred - id2 ) ) return id1 ; return id2 ; } }
class Solution { public int getMinDistance ( int [ ] nums , int target , int start ) { int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] == target ) ans = Math . min ( ans , Math . abs ( i - start ) ) ; return ans ; } }
class Solution { public boolean splitString ( String s ) { return isValid ( s , 0 , - 1 , 0 ) ; } private boolean isValid ( final String s , int start , long prev , int segment ) { if ( start == s . length ( ) && segment > 1 ) return true ; long curr = 0 ; for ( int i = start ; i < s . length ( ) ; ++ i ) { curr = curr * 10 + s . charAt ( i ) - '0' ; if ( curr > 9999999999 ) return false ; if ( ( prev == - 1 || curr == prev - 1 ) && isValid ( s , i + 1 , curr , segment + 1 ) ) return true ; } return false ; } }
class Solution { public int getMinSwaps ( String num , int k ) { int [ ] A = new int [ num . length ( ) ] ; for ( int i = 0 ; i < A . length ; ++ i ) A [ i ] = num . charAt ( i ) - '0' ; int [ ] B = A . clone ( ) ; for ( int i = 0 ; i < k ; ++ i ) nextPermutation ( B ) ; return countSteps ( A , B ) ; } public void nextPermutation ( int [ ] nums ) { final int n = nums . length ; int i ; for ( i = n - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ] ) break ; if ( i >= 0 ) for ( int j = n - 1 ; j > i ; -- j ) if ( nums [ j ] > nums [ i ] ) { swap ( nums , i , j ) ; break ; } reverse ( nums , i + 1 , n - 1 ) ; } private void reverse ( int [ ] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++ , r -- ) ; } private void swap ( int [ ] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } private int countSteps ( int [ ] A , int [ ] B ) { int count = 0 ; for ( int i = 0 , j = 0 ; i < A . length ; ++ i ) { j = i ; while ( A [ i ] != B [ j ] ) ++ j ; while ( i < j ) { swap ( B , j , j - 1 ) ; -- j ; ++ count ; } } return count ; } }
class Solution { public int maxDistance ( int [ ] nums1 , int [ ] nums2 ) { int ans = 0 ; int i = 0 ; int j = 0 ; while ( i < nums1 . length && j < nums2 . length ) if ( nums1 [ i ] > nums2 [ j ] ) ++ i ; else ans = Math . max ( ans , j ++ - i ) ; return ans ; } }
class Solution { public int maxSumMinProduct ( int [ ] nums ) { final int kMod = 1_000_000_007 ; long ans = 0 ; Deque < Integer > stack = new ArrayDeque < > ( ) ; long [ ] prefix = new long [ nums . length + 1 ] ; for ( int i = 0 ; i < nums . length ; ++ i ) prefix [ i + 1 ] = prefix [ i ] + nums [ i ] ; for ( int i = 0 ; i <= nums . length ; ++ i ) { while ( ! stack . isEmpty ( ) && ( i == nums . length || nums [ stack . peek ( ) ] > nums [ i ] ) ) { final int minVal = nums [ stack . pop ( ) ] ; final long sum = stack . isEmpty ( ) ? prefix [ i ] : prefix [ i ] - prefix [ stack . peek ( ) + 1 ] ; ans = Math . max ( ans , minVal * sum ) ; } stack . push ( i ) ; } return ( int ) ( ans % kMod ) ; } }
class Solution { public int largestPathValue ( String colors , int [ ] [ ] edges ) { final int n = colors . length ( ) ; int ans = 0 ; int processed = 0 ; List < Integer > [ ] graph = new List [ n ] ; int [ ] inDegree = new int [ n ] ; int [ ] [ ] count = new int [ n ] [ 26 ] ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; graph [ u ] . add ( v ) ; ++ inDegree [ v ] ; } Queue < Integer > q = IntStream . range ( 0 , n ) . filter ( i -> inDegree [ i ] == 0 ) . boxed ( ) . collect ( Collectors . toCollection ( ArrayDeque :: new ) ) ; while ( ! q . isEmpty ( ) ) { final int out = q . poll ( ) ; ++ processed ; ans = Math . max ( ans , ++ count [ out ] [ colors . charAt ( out ) - ' a ' ] ) ; for ( final int in : graph [ out ] ) { for ( int i = 0 ; i < 26 ; ++ i ) count [ in ] [ i ] = Math . max ( count [ in ] [ i ] , count [ out ] [ i ] ) ; if ( -- inDegree [ in ] == 0 ) q . offer ( in ) ; } } return processed == n ? ans : - 1 ; } }
class TrieNode { public TrieNode [ ] children = new TrieNode [ 26 ] ; public boolean isWord = false ; } class Solution { public String longestWord ( String [ ] words ) { String ans = " " ; for ( final String word : words ) insert ( word ) ; for ( final String word : words ) { if ( ! allPrefixed ( word ) ) continue ; if ( ans . length ( ) < word . length ( ) || ( ans . length ( ) == word . length ( ) && ans . compareTo ( word ) > 0 ) ) ans = word ; } return ans ; } private TrieNode root = new TrieNode ( ) ; private void insert ( final String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ( ) ) { final int i = c - ' a ' ; if ( node . children [ i ] == null ) node . children [ i ] = new TrieNode ( ) ; node = node . children [ i ] ; } node . isWord = true ; } private boolean allPrefixed ( final String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ( ) ) { final int i = c - ' a ' ; node = node . children [ i ] ; if ( ! node . isWord ) return false ; } return true ; } }
class Solution { public String sortSentence ( String s ) { String [ ] words = s . split ( " ▁ " ) ; Arrays . sort ( words , ( a , b ) -> a . charAt ( a . length ( ) - 1 ) - b . charAt ( b . length ( ) - 1 ) ) ; StringBuilder sb = new StringBuilder ( trim ( words [ 0 ] ) ) ; for ( int i = 1 ; i < words . length ; ++ i ) sb . append ( " ▁ " ) . append ( trim ( words [ i ] ) ) ; return sb . toString ( ) ; } private String trim ( final String s ) { return s . substring ( 0 , s . length ( ) - 1 ) ; } }
class Solution { public void reverseWords ( char [ ] s ) { reverse ( s , 0 , s . length - 1 ) ; reverseWords ( s , s . length ) ; } private void reverse ( char [ ] s , int l , int r ) { while ( l < r ) { final char c = s [ l ] ; s [ l ++ ] = s [ r ] ; s [ r -- ] = c ; } } private void reverseWords ( char [ ] s , int n ) { int i = 0 ; int j = 0 ; while ( i < n ) { while ( i < j || i < n && s [ i ] == ' ▁ ' ) ++ i ; while ( j < i || j < n && s [ j ] != ' ▁ ' ) ++ j ; reverse ( s , i , j - 1 ) ; } } }
class Solution { public int [ ] memLeak ( int memory1 , int memory2 ) { int i = 1 ; while ( memory1 >= i || memory2 >= i ) { if ( memory1 >= memory2 ) memory1 -= i ; else memory2 -= i ; ++ i ; } return new int [ ] { i , memory1 , memory2 } ; } }
class Solution { public char [ ] [ ] rotateTheBox ( char [ ] [ ] box ) { final int m = box . length ; final int n = box [ 0 ] . length ; char [ ] [ ] ans = new char [ n ] [ m ] ; Arrays . stream ( ans ) . forEach ( row -> Arrays . fill ( row , ' . ' ) ) ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = n - 1 , k = n - 1 ; j >= 0 ; -- j ) if ( box [ i ] [ j ] != ' . ' ) { if ( box [ i ] [ j ] == ' * ' ) k = j ; ans [ k -- ] [ m - i - 1 ] = box [ i ] [ j ] ; } return ans ; } }
class Solution { public int sumOfFlooredPairs ( int [ ] nums ) { final int kMod = 1_000_000_007 ; final int kMax = Arrays . stream ( nums ) . max ( ) . getAsInt ( ) ; long ans = 0 ; int [ ] count = new int [ kMax + 1 ] ; for ( final int num : nums ) ++ count [ num ] ; for ( int i = 1 ; i <= kMax ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( int i = 1 ; i <= kMax ; ++ i ) if ( count [ i ] > count [ i - 1 ] ) { long sum = 0 ; for ( int j = 1 ; i * j <= kMax ; ++ j ) { final int lo = i * j - 1 ; final int hi = i * ( j + 1 ) - 1 ; sum += ( count [ Math . min ( hi , kMax ) ] - count [ lo ] ) * ( long ) j ; } ans += sum * ( count [ i ] - count [ i - 1 ] ) ; ans %= kMod ; } return ( int ) ans ; } }
class Solution { public int subsetXORSum ( int [ ] nums ) { return dfs ( nums , 0 , 0 ) ; } private int dfs ( int [ ] nums , int i , int xors ) { if ( i == nums . length ) return xors ; final int x = dfs ( nums , i + 1 , xors ) ; final int y = dfs ( nums , i + 1 , nums [ i ] ^ xors ) ; return x + y ; } }
class Solution { public int minSwaps ( String s ) { final int ones = ( int ) s . chars ( ) . filter ( c -> c == '1' ) . count ( ) ; final int zeros = s . length ( ) - ones ; if ( Math . abs ( ones - zeros ) > 1 ) return - 1 ; if ( ones > zeros ) return countSwaps ( s , '1' ) ; if ( zeros > ones ) return countSwaps ( s , '0' ) ; return Math . min ( countSwaps ( s , '1' ) , countSwaps ( s , '0' ) ) ; } private int countSwaps ( final String s , char curr ) { int swaps = 0 ; for ( final char c : s . toCharArray ( ) ) { if ( c != curr ) ++ swaps ; curr ^= 1 ; } return swaps / 2 ; } }
class FindSumPairs { public FindSumPairs ( int [ ] nums1 , int [ ] nums2 ) { this . nums1 = nums1 ; this . nums2 = nums2 ; for ( final int num : nums2 ) count2 . merge ( num , 1 , Integer :: sum ) ; } public void add ( int index , int val ) { count2 . merge ( nums2 [ index ] , - 1 , Integer :: sum ) ; nums2 [ index ] += val ; count2 . merge ( nums2 [ index ] , 1 , Integer :: sum ) ; } public int count ( int tot ) { int ans = 0 ; for ( final int num : nums1 ) ans += count2 . getOrDefault ( tot - num , 0 ) ; return ans ; } private int [ ] nums1 ; private int [ ] nums2 ; private Map < Integer , Integer > count2 = new HashMap < > ( ) ; }
class Solution { public int rearrangeSticks ( int n , int k ) { if ( n == k ) return 1 ; if ( k == 0 ) return 0 ; if ( dp [ n ] [ k ] != 0 ) return dp [ n ] [ k ] ; return dp [ n ] [ k ] = ( int ) ( ( ( long ) rearrangeSticks ( n - 1 , k - 1 ) + ( long ) rearrangeSticks ( n - 1 , k ) * ( n - 1 ) ) % kMod ) ; } private static final int kMod = 1_000_000_007 ; private int [ ] [ ] dp = new int [ 1001 ] [ 1001 ] ; }
class Solution { public List < List < Integer > > findRLEArray ( int [ ] [ ] encoded1 , int [ ] [ ] encoded2 ) { List < List < Integer > > ans = new ArrayList < > ( ) ; int i = 0 ; int j = 0 ; while ( i < encoded1 . length && j < encoded2 . length ) { final int mult = encoded1 [ i ] [ 0 ] * encoded2 [ j ] [ 0 ] ; final int minFreq = Math . min ( encoded1 [ i ] [ 1 ] , encoded2 [ j ] [ 1 ] ) ; if ( ! ans . isEmpty ( ) && mult == ans . get ( ans . size ( ) - 1 ) . get ( 0 ) ) ans . get ( ans . size ( ) - 1 ) . set ( 1 , ans . get ( ans . size ( ) - 1 ) . get ( 1 ) + minFreq ) ; else ans . add ( Arrays . asList ( mult , minFreq ) ) ; encoded1 [ i ] [ 1 ] -= minFreq ; encoded2 [ j ] [ 1 ] -= minFreq ; if ( encoded1 [ i ] [ 1 ] == 0 ) ++ i ; if ( encoded2 [ j ] [ 1 ] == 0 ) ++ j ; } return ans ; } }
class Solution { public boolean checkZeroOnes ( String s ) { int longestOnes = 0 ; int longestZeros = 0 ; int currentOnes = 0 ; int currentZeros = 0 ; for ( final char c : s . toCharArray ( ) ) if ( c == '0' ) { currentOnes = 0 ; longestZeros = Math . max ( longestZeros , ++ currentZeros ) ; } else { currentZeros = 0 ; longestOnes = Math . max ( longestOnes , ++ currentOnes ) ; } return longestOnes > longestZeros ; } }
class Solution { public List < String > findRepeatedDnaSequences ( String s ) { Set < String > ans = new HashSet < > ( ) ; Set < String > seen = new HashSet < > ( ) ; for ( int i = 0 ; i + 10 <= s . length ( ) ; ++ i ) { final String seq = s . substring ( i , i + 10 ) ; if ( seen . contains ( seq ) ) ans . add ( seq ) ; seen . add ( seq ) ; } return new ArrayList < > ( ans ) ; } }
class Solution { public int minSpeedOnTime ( int [ ] dist , double hour ) { int ans = - 1 ; int l = 1 ; int r = ( int ) 1e7 ; while ( l <= r ) { final int m = ( l + r ) / 2 ; if ( time ( dist , hour , m ) > hour ) { l = m + 1 ; } else { ans = m ; r = m - 1 ; } } return ans ; } private double time ( int [ ] dist , double hour , int speed ) { double sum = 0 ; for ( int i = 0 ; i < dist . length - 1 ; ++ i ) sum += Math . ceil ( ( double ) dist [ i ] / speed ) ; return sum + ( double ) dist [ dist . length - 1 ] / speed ; } }
class Solution { public boolean canReach ( String s , int minJump , int maxJump ) { int count = 0 ; boolean dp [ ] = new boolean [ s . length ( ) ] ; dp [ 0 ] = true ; for ( int i = minJump ; i < s . length ( ) ; ++ i ) { count += dp [ i - minJump ] ? 1 : 0 ; if ( i - maxJump > 0 ) count -= dp [ i - maxJump - 1 ] ? 1 : 0 ; dp [ i ] = count > 0 && s . charAt ( i ) == '0' ; } return dp [ dp . length - 1 ] ; } }
class Solution { public int stoneGameVIII ( int [ ] stones ) { final int n = stones . length ; int [ ] prefix = stones . clone ( ) ; int [ ] dp = new int [ n ] ; Arrays . fill ( dp , Integer . MIN_VALUE ) ; for ( int i = 1 ; i < prefix . length ; ++ i ) prefix [ i ] += prefix [ i - 1 ] ; dp [ n - 2 ] = prefix [ n - 1 ] ; for ( int i = n - 3 ; i >= 0 ; -- i ) dp [ i ] = Math . max ( dp [ i + 1 ] , prefix [ i + 1 ] - dp [ i + 1 ] ) ; return dp [ 0 ] ; } }
class Solution { public int minProductSum ( int [ ] nums1 , int [ ] nums2 ) { final int n = nums1 . length ; int ans = 0 ; Arrays . sort ( nums1 ) ; Arrays . sort ( nums2 ) ; for ( int i = 0 ; i < n ; ++ i ) ans += nums1 [ i ] * nums2 [ n - i - 1 ] ; return ans ; } }
class Solution { public int countGoodSubstrings ( String s ) { int ans = 0 ; for ( int i = 0 ; i < s . length ( ) - 2 ; ++ i ) { final char a = s . charAt ( i ) ; final char b = s . charAt ( i + 1 ) ; final char c = s . charAt ( i + 2 ) ; if ( a == b || a == c || b == c ) continue ; ++ ans ; } return ans ; } }
class Solution { public int minPairSum ( int [ ] nums ) { int ans = 0 ; Arrays . sort ( nums ) ; for ( int i = 0 , j = nums . length - 1 ; i < j ; ) ans = Math . max ( ans , nums [ i ++ ] + nums [ j -- ] ) ; return ans ; } }
class Solution { public int minimumXORSum ( int [ ] nums1 , int [ ] nums2 ) { int [ ] dp = new int [ 1 << nums2 . length ] ; Arrays . fill ( dp , Integer . MAX_VALUE ) ; return dfs ( nums1 , nums2 , dp , 0 , 0 ) ; } private int dfs ( int [ ] A , int [ ] B , int [ ] dp , int i , int mask ) { if ( i == A . length ) return 0 ; if ( dp [ mask ] < Integer . MAX_VALUE ) return dp [ mask ] ; for ( int j = 0 ; j < B . length ; ++ j ) if ( ( mask >> j & 1 ) == 0 ) dp [ mask ] = Math . min ( dp [ mask ] , ( A [ i ] ^ B [ j ] ) + dfs ( A , B , dp , i + 1 , mask | 1 << j ) ) ; return dp [ mask ] ; } }
class Solution { public int maxProfit ( int k , int [ ] prices ) { if ( k >= prices . length / 2 ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( final int price : prices ) { sell = Math . max ( sell , hold + price ) ; hold = Math . max ( hold , sell - price ) ; } return sell ; } int [ ] sell = new int [ k + 1 ] ; int [ ] hold = new int [ k + 1 ] ; Arrays . fill ( hold , Integer . MIN_VALUE ) ; for ( final int price : prices ) for ( int i = k ; i > 0 ; -- i ) { sell [ i ] = Math . max ( sell [ i ] , hold [ i ] + price ) ; hold [ i ] = Math . max ( hold [ i ] , sell [ i - 1 ] - price ) ; } return sell [ k ] ; } }
class Solution { public String maxValue ( String n , int x ) { boolean isNegative = n . charAt ( 0 ) == ' - ' ; for ( int i = 0 ; i < n . length ( ) ; ++ i ) if ( ! isNegative && n . charAt ( i ) - '0' < x || isNegative && n . charAt ( i ) - '0' > x ) return n . substring ( 0 , i ) + x + n . substring ( i ) ; return n + x ; } }
class T { public int weight ; public int index ; public int freeTime ; public T ( int weight , int index , int freeTime ) { this . weight = weight ; this . index = index ; this . freeTime = freeTime ; } } class Solution { public int [ ] assignTasks ( int [ ] servers , int [ ] tasks ) { final int n = servers . length ; final int m = tasks . length ; int [ ] ans = new int [ m ] ; Queue < T > free = new PriorityQueue < > ( ( a , b ) -> a . weight == b . weight ? a . index - b . index : a . weight - b . weight ) ; Queue < T > used = new PriorityQueue < > ( new Comparator < T > ( ) { @ Override public int compare ( T a , T b ) { if ( a . freeTime != b . freeTime ) return a . freeTime - b . freeTime ; if ( a . weight != b . weight ) return a . weight - b . weight ; return a . index - b . index ; } } ) ; for ( int i = 0 ; i < n ; ++ i ) free . offer ( new T ( servers [ i ] , i , 0 ) ) ; for ( int i = 0 ; i < m ; ++ i ) { final int executionTime = tasks [ i ] ; while ( ! used . isEmpty ( ) && used . peek ( ) . freeTime <= i ) free . offer ( used . poll ( ) ) ; if ( free . isEmpty ( ) ) { T server = used . poll ( ) ; ans [ i ] = server . index ; server . freeTime += executionTime ; used . offer ( server ) ; } else { T server = free . poll ( ) ; ans [ i ] = server . index ; server . freeTime = i + executionTime ; used . offer ( server ) ; } } return ans ; } }
class Solution { public int minSkips ( int [ ] dist , int speed , int hoursBefore ) { final double kInf = 1e7 ; final double kEps = 1e-9 ; final int n = dist . length ; double [ ] [ ] dp = new double [ n + 1 ] [ n + 1 ] ; Arrays . stream ( dp ) . forEach ( row -> Arrays . fill ( row , kInf ) ) ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { final double d = dist [ i - 1 ] ; dp [ i ] [ 0 ] = Math . ceil ( dp [ i - 1 ] [ 0 ] + d / speed - kEps ) ; for ( int j = 1 ; j <= i ; ++ j ) dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j - 1 ] + d / speed , Math . ceil ( dp [ i - 1 ] [ j ] + d / speed - kEps ) ) ; } for ( int j = 0 ; j <= n ; ++ j ) if ( dp [ n ] [ j ] <= hoursBefore ) return j ; return - 1 ; } }
class Solution { public long countPairs ( int [ ] nums1 , int [ ] nums2 ) { long ans = 0 ; int [ ] A = new int [ nums1 . length ] ; for ( int i = 0 ; i < A . length ; ++ i ) A [ i ] = nums1 [ i ] - nums2 [ i ] ; Arrays . sort ( A ) ; for ( int i = 0 ; i < A . length ; ++ i ) { final int index = firstGreater ( A , - A [ i ] ) ; ans += A . length - Math . max ( i + 1 , index ) ; } return ans ; } private int firstGreater ( int [ ] A , int target ) { int l = 0 ; int r = A . length ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A [ m ] > target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public boolean findRotation ( int [ ] [ ] mat , int [ ] [ ] target ) { for ( int i = 0 ; i < 4 ; ++ i ) { if ( Arrays . deepEquals ( mat , target ) ) return true ; rotate ( mat ) ; } return false ; } private void rotate ( int [ ] [ ] M ) { for ( int i = 0 , j = M . length - 1 ; i < j ; ++ i , -- j ) { int [ ] temp = M [ i ] ; M [ i ] = M [ j ] ; M [ j ] = temp ; } for ( int i = 0 ; i < M . length ; ++ i ) for ( int j = i + 1 ; j < M . length ; ++ j ) { final int temp = M [ i ] [ j ] ; M [ i ] [ j ] = M [ j ] [ i ] ; M [ j ] [ i ] = temp ; } } }
class Solution { public int reductionOperations ( int [ ] nums ) { int ans = 0 ; Arrays . sort ( nums ) ; for ( int i = nums . length - 1 ; i > 0 ; -- i ) if ( nums [ i ] != nums [ i - 1 ] ) ans += nums . length - i ; return ans ; } }
class Solution { public int minFlips ( String s ) { final int n = s . length ( ) ; int [ ] [ ] count = new int [ 2 ] [ 2 ] ; for ( int i = 0 ; i < n ; ++ i ) ++ count [ s . charAt ( i ) - '0' ] [ i % 2 ] ; int ans = Math . min ( count [ 1 ] [ 0 ] + count [ 0 ] [ 1 ] , count [ 0 ] [ 0 ] + count [ 1 ] [ 1 ] ) ; for ( int i = 0 ; i < n ; ++ i ) { -- count [ s . charAt ( i ) - '0' ] [ i % 2 ] ; ++ count [ s . charAt ( i ) - '0' ] [ ( n + i ) % 2 ] ; ans = Math . min ( ans , Math . min ( count [ 1 ] [ 0 ] + count [ 0 ] [ 1 ] , count [ 0 ] [ 0 ] + count [ 1 ] [ 1 ] ) ) ; } return ans ; } }
class Solution { public int minWastedSpace ( int [ ] packages , int [ ] [ ] boxes ) { final int kMod = 1_000_000_007 ; final long kInf = ( long ) 1e11 ; final long packagesSum = Arrays . stream ( packages ) . mapToLong ( p -> p ) . sum ( ) ; long minBoxesSum = kInf ; Arrays . sort ( packages ) ; for ( int [ ] box : boxes ) { Arrays . sort ( box ) ; if ( box [ box . length - 1 ] < packages [ packages . length - 1 ] ) continue ; long accu = 0 ; long i = 0 ; for ( final int b : box ) { final long j = firstGreaterEqual ( packages , b + 1 ) ; accu += b * ( j - i ) ; i = j ; } minBoxesSum = Math . min ( minBoxesSum , accu ) ; } return minBoxesSum == kInf ? - 1 : ( int ) ( ( minBoxesSum - packagesSum ) % kMod ) ; } private int firstGreaterEqual ( int [ ] A , int target ) { int l = 0 ; int r = A . length ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A [ m ] >= target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public void rotate ( int [ ] nums , int k ) { k %= nums . length ; reverse ( nums , 0 , nums . length - 1 ) ; reverse ( nums , 0 , k - 1 ) ; reverse ( nums , k , nums . length - 1 ) ; } private void reverse ( int [ ] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++ , r -- ) ; } private void swap ( int [ ] nums , int l , int r ) { final int temp = nums [ l ] ; nums [ l ] = nums [ r ] ; nums [ r ] = temp ; } }
class Solution { public int maxLength ( int [ ] ribbons , int k ) { int l = 1 ; int r = ( int ) ( Arrays . stream ( ribbons ) . asLongStream ( ) . sum ( ) / k ) + 1 ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( ! isCutPossible ( ribbons , m , k ) ) r = m ; else l = m + 1 ; } return l - 1 ; } private boolean isCutPossible ( int [ ] ribbons , int length , int k ) { int count = 0 ; for ( final int ribbon : ribbons ) count += ribbon / length ; return count >= k ; } }
class Solution { public boolean isCovered ( int [ ] [ ] ranges , int left , int right ) { for ( int i = left ; i <= right ; ++ i ) { boolean seen = false ; for ( int [ ] range : ranges ) if ( i >= range [ 0 ] && i <= range [ 1 ] ) { seen = true ; break ; } if ( ! seen ) return false ; } return true ; } }
class Solution { public int chalkReplacer ( int [ ] chalk , int k ) { k %= Arrays . stream ( chalk ) . asLongStream ( ) . sum ( ) ; if ( k == 0 ) return 0 ; for ( int i = 0 ; i < chalk . length ; ++ i ) { k -= chalk [ i ] ; if ( k < 0 ) return i ; } throw new IllegalArgumentException ( ) ; } }
class Solution { public boolean makeEqual ( String [ ] words ) { int [ ] count = new int [ 26 ] ; for ( final String word : words ) for ( final char c : word . toCharArray ( ) ) ++ count [ c - ' a ' ] ; return Arrays . stream ( count ) . allMatch ( c -> c % words . length == 0 ) ; } }
class Solution { public int maximumRemovals ( String s , String p , int [ ] removable ) { int l = 0 ; int r = removable . length + 1 ; while ( l < r ) { final int m = ( l + r ) / 2 ; final String removed = remove ( s , removable , m ) ; if ( isSubsequence ( p , removed ) ) l = m + 1 ; else r = m ; } return l - 1 ; } private String remove ( final String s , int [ ] removable , int k ) { StringBuilder sb = new StringBuilder ( s ) ; for ( int i = 0 ; i < k ; ++ i ) sb . setCharAt ( removable [ i ] , ' * ' ) ; return sb . toString ( ) ; } private boolean isSubsequence ( final String p , final String s ) { int i = 0 ; for ( int j = 0 ; j < s . length ( ) ; ++ j ) if ( p . charAt ( i ) == s . charAt ( j ) ) if ( ++ i == p . length ( ) ) return true ; return false ; } }
class Solution { public boolean mergeTriplets ( int [ ] [ ] triplets , int [ ] target ) { int [ ] merged = new int [ target . length ] ; for ( int [ ] t : triplets ) if ( t [ 0 ] <= target [ 0 ] && t [ 1 ] <= target [ 1 ] && t [ 2 ] <= target [ 2 ] ) for ( int i = 0 ; i < target . length ; ++ i ) merged [ i ] = Math . max ( merged [ i ] , t [ i ] ) ; return Arrays . equals ( merged , target ) ; } }
class Solution { public ListNode removeNthFromEnd ( ListNode head , int n ) { ListNode slow = head ; ListNode fast = head ; while ( n -- > 0 ) fast = fast . next ; if ( fast == null ) return head . next ; while ( fast . next != null ) { slow = slow . next ; fast = fast . next ; } slow . next = slow . next . next ; return head ; } }
public class Solution { public int reverseBits ( int n ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if ( ( n >> i & 1 ) == 1 ) ans |= 1 << 31 - i ; return ans ; } }
class Solution { public int [ ] earliestAndLatest ( int n , int firstPlayer , int secondPlayer ) { dp = new int [ n + 1 ] [ n + 1 ] [ n + 1 ] [ 2 ] ; return solve ( firstPlayer , n - secondPlayer + 1 , n ) ; } private int [ ] [ ] [ ] [ ] dp ; private int [ ] solve ( int l , int r , int k ) { if ( l == r ) return new int [ ] { 1 , 1 } ; if ( l > r ) return solve ( r , l , k ) ; if ( ! Arrays . equals ( dp [ l ] [ r ] [ k ] , new int [ ] { 0 , 0 } ) ) return dp [ l ] [ r ] [ k ] ; int a = Integer . MAX_VALUE ; int b = Integer . MIN_VALUE ; for ( int i = 1 ; i <= l ; ++ i ) for ( int j = l - i + 1 ; j <= r - i ; ++ j ) { if ( i + j > ( k + 1 ) / 2 || i + j < l + r - k / 2 ) continue ; int [ ] res = solve ( i , j , ( k + 1 ) / 2 ) ; a = Math . min ( a , res [ 0 ] + 1 ) ; b = Math . max ( b , res [ 1 ] + 1 ) ; } return dp [ l ] [ r ] [ k ] = new int [ ] { a , b } ; } }
class Solution { public int [ ] findPeakGrid ( int [ ] [ ] mat ) { int l = 0 ; int r = mat . length - 1 ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( Arrays . stream ( mat [ m ] ) . max ( ) . getAsInt ( ) >= Arrays . stream ( mat [ m + 1 ] ) . max ( ) . getAsInt ( ) ) r = m ; else l = m + 1 ; } return new int [ ] { l , getMaxIndex ( mat [ l ] ) } ; } private int getMaxIndex ( int [ ] A ) { int [ ] res = { 0 , A [ 0 ] } ; for ( int i = 1 ; i < A . length ; ++ i ) if ( A [ i ] > res [ 1 ] ) res = new int [ ] { i , A [ i ] } ; return res [ 0 ] ; } }
class Solution { public String largestOddNumber ( String num ) { for ( int i = num . length ( ) - 1 ; i >= 0 ; -- i ) if ( ( num . charAt ( i ) - '0' ) % 2 == 1 ) return num . substring ( 0 , i + 1 ) ; return " " ; } }
class Solution { public int numberOfRounds ( String startTime , String finishTime ) { final int start = getMinutes ( startTime ) ; int finish = getMinutes ( finishTime ) ; if ( start > finish ) finish += 60 * 24 ; return Math . max ( 0 , finish / 15 - ( start + 14 ) / 15 ) ; } private int getMinutes ( final String s ) { return 60 * Integer . valueOf ( s . substring ( 0 , 2 ) ) + Integer . valueOf ( s . substring ( 3 ) ) ; } }
class Solution { public int countSubIslands ( int [ ] [ ] grid1 , int [ ] [ ] grid2 ) { int ans = 0 ; for ( int i = 0 ; i < grid2 . length ; ++ i ) for ( int j = 0 ; j < grid2 [ 0 ] . length ; ++ j ) if ( grid2 [ i ] [ j ] == 1 ) ans += dfs ( grid1 , grid2 , i , j ) ; return ans ; } private int dfs ( int [ ] [ ] grid1 , int [ ] [ ] grid2 , int i , int j ) { if ( i < 0 || i == grid1 . length || j < 0 || j == grid2 [ 0 ] . length ) return 1 ; if ( grid2 [ i ] [ j ] != 1 ) return 1 ; grid2 [ i ] [ j ] = 2 ; return dfs ( grid1 , grid2 , i + 1 , j ) & dfs ( grid1 , grid2 , i - 1 , j ) & dfs ( grid1 , grid2 , i , j + 1 ) & dfs ( grid1 , grid2 , i , j - 1 ) & grid1 [ i ] [ j ] ; } }
class Solution { public int [ ] minDifference ( int [ ] nums , int [ ] [ ] queries ) { int [ ] ans = new int [ queries . length ] ; List < Integer > [ ] numToIndices = new List [ 101 ] ; for ( int i = 1 ; i <= 100 ; ++ i ) numToIndices [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) numToIndices [ nums [ i ] ] . add ( i ) ; if ( numToIndices [ nums [ 0 ] ] . size ( ) == nums . length ) { Arrays . fill ( ans , - 1 ) ; return ans ; } for ( int i = 0 ; i < queries . length ; ++ i ) { final int l = queries [ i ] [ 0 ] ; final int r = queries [ i ] [ 1 ] ; int prevNum = - 1 ; int minDiff = 101 ; for ( int num = 1 ; num <= 100 ; ++ num ) { List < Integer > indices = numToIndices [ num ] ; final int j = firstGreaterEqual ( indices , l ) ; if ( j == indices . size ( ) || indices . get ( j ) > r ) continue ; if ( prevNum != - 1 ) minDiff = Math . min ( minDiff , num - prevNum ) ; prevNum = num ; } ans [ i ] = minDiff == 101 ? - 1 : minDiff ; } return ans ; } private int firstGreaterEqual ( List < Integer > A , int target ) { int l = 0 ; int r = A . size ( ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A . get ( m ) >= target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public boolean canBeIncreasing ( int [ ] nums ) { boolean removed = false ; for ( int i = 1 ; i < nums . length ; ++ i ) if ( nums [ i - 1 ] >= nums [ i ] ) { if ( removed ) return false ; removed = true ; if ( i > 1 && nums [ i - 2 ] >= nums [ i ] ) nums [ i ] = nums [ i - 1 ] ; } return true ; } }
public class Solution { public int hammingWeight ( int n ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if ( ( ( n >> i ) & 1 ) == 1 ) ++ ans ; return ans ; } }
class Solution { public String removeOccurrences ( String s , String part ) { final int n = s . length ( ) ; final int k = part . length ( ) ; StringBuilder sb = new StringBuilder ( s ) ; int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sb . setCharAt ( j ++ , s . charAt ( i ) ) ; if ( j >= k && sb . substring ( j - k , j ) . toString ( ) . equals ( part ) ) j -= k ; } return sb . substring ( 0 , j ) . toString ( ) ; } }
class Solution { public long maxAlternatingSum ( int [ ] nums ) { long even = 0 ; long odd = 0 ; for ( final int num : nums ) { even = Math . max ( even , odd + num ) ; odd = even - num ; } return even ; } }
class Entry { public int price ; public int shop ; public int movie ; public Entry ( int price , int shop , int movie ) { this . price = price ; this . shop = shop ; this . movie = movie ; } } class MovieRentingSystem { public MovieRentingSystem ( int n , int [ ] [ ] entries ) { for ( int [ ] e : entries ) { final int shop = e [ 0 ] ; final int movie = e [ 1 ] ; final int price = e [ 2 ] ; unrented . putIfAbsent ( movie , new TreeSet < > ( comparator ) ) ; unrented . get ( movie ) . add ( new Entry ( price , shop , movie ) ) ; shopAndMovieToPrice . put ( new Pair < > ( shop , movie ) , price ) ; } } public List < Integer > search ( int movie ) { return unrented . getOrDefault ( movie , Collections . emptySet ( ) ) . stream ( ) . limit ( 5 ) . map ( e -> e . shop ) . collect ( Collectors . toList ( ) ) ; } public void rent ( int shop , int movie ) { final int price = shopAndMovieToPrice . get ( new Pair < > ( shop , movie ) ) ; unrented . get ( movie ) . remove ( new Entry ( price , shop , movie ) ) ; rented . add ( new Entry ( price , shop , movie ) ) ; } public void drop ( int shop , int movie ) { final int price = shopAndMovieToPrice . get ( new Pair < > ( shop , movie ) ) ; unrented . get ( movie ) . add ( new Entry ( price , shop , movie ) ) ; rented . remove ( new Entry ( price , shop , movie ) ) ; } public List < List < Integer > > report ( ) { return rented . stream ( ) . limit ( 5 ) . map ( e -> List . of ( e . shop , e . movie ) ) . collect ( Collectors . toList ( ) ) ; } private Comparator < Entry > comparator = ( a , b ) -> { if ( a . price != b . price ) return Integer . compare ( a . price , b . price ) ; if ( a . shop != b . shop ) return Integer . compare ( a . shop , b . shop ) ; return Integer . compare ( a . movie , b . movie ) ; } ; private Map < Integer , Set < Entry > > unrented = new HashMap < > ( ) ; private Map < Pair < Integer , Integer > , Integer > shopAndMovieToPrice = new HashMap < > ( ) ; private Set < Entry > rented = new TreeSet < > ( comparator ) ; }
class Solution { public int maxProductDifference ( int [ ] nums ) { int max1 = Integer . MIN_VALUE ; int max2 = Integer . MIN_VALUE ; int min1 = Integer . MAX_VALUE ; int min2 = Integer . MAX_VALUE ; for ( final int num : nums ) { if ( num > max1 ) { max2 = max1 ; max1 = num ; } else if ( num > max2 ) { max2 = num ; } if ( num < min1 ) { min2 = min1 ; min1 = num ; } else if ( num < min2 ) { min2 = num ; } } return max1 * max2 - min1 * min2 ; } }
class Solution { public int [ ] [ ] rotateGrid ( int [ ] [ ] grid , int k ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int t = 0 ; int l = 0 ; int b = m - 1 ; int r = n - 1 ; while ( t < b && l < r ) { final int elementInThisLayer = 2 * ( b - t + 1 ) + 2 * ( r - l + 1 ) - 4 ; final int netRotations = k % elementInThisLayer ; for ( int rotate = 0 ; rotate < netRotations ; ++ rotate ) { final int topLeft = grid [ t ] [ l ] ; for ( int j = l ; j < r ; ++ j ) grid [ t ] [ j ] = grid [ t ] [ j + 1 ] ; for ( int i = t ; i < b ; ++ i ) grid [ i ] [ r ] = grid [ i + 1 ] [ r ] ; for ( int j = r ; j > l ; -- j ) grid [ b ] [ j ] = grid [ b ] [ j - 1 ] ; for ( int i = b ; i > t ; -- i ) grid [ i ] [ l ] = grid [ i - 1 ] [ l ] ; grid [ t + 1 ] [ l ] = topLeft ; } ++ t ; ++ l ; -- b ; -- r ; } return grid ; } }
class Solution { public long wonderfulSubstrings ( String word ) { long ans = 0 ; int prefix = 0 ; int [ ] count = new int [ 1024 ] ; count [ 0 ] = 1 ; for ( final char c : word . toCharArray ( ) ) { prefix ^= 1 << c - ' a ' ; ans += count [ prefix ] ; for ( int i = 0 ; i < 10 ; ++ i ) ans += count [ prefix ^ 1 << i ] ; ++ count [ prefix ] ; } return ans ; } }
class Solution { public int [ ] buildArray ( int [ ] nums ) { final int n = nums . length ; for ( int i = 0 ; i < n ; ++ i ) nums [ i ] += n * ( nums [ nums [ i ] ] % n ) ; for ( int i = 0 ; i < n ; ++ i ) nums [ i ] /= n ; return nums ; } }
class Solution { public int eliminateMaximum ( int [ ] dist , int [ ] speed ) { final int n = dist . length ; int [ ] arrivalTime = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) arrivalTime [ i ] = ( dist [ i ] - 1 ) / speed [ i ] ; Arrays . sort ( arrivalTime ) ; for ( int i = 0 ; i < n ; ++ i ) if ( i > arrivalTime [ i ] ) return i ; return n ; } }
class Solution { public int countGoodNumbers ( long n ) { return ( int ) ( myPow ( 4 * 5 , n / 2 ) * ( n % 2 == 1 ? 5 : 1 ) % kMod ) ; } private static final int kMod = 1_000_000_007 ; private long myPow ( long x , long n ) { if ( n == 0 ) return 1 ; if ( n % 2 == 1 ) return x * myPow ( x , n - 1 ) % kMod ; return myPow ( x * x % kMod , n / 2 ) ; } }
class Solution { public int countTriples ( int n ) { int ans = 0 ; Set < Integer > squared = new HashSet < > ( ) ; for ( int i = 1 ; i <= n ; ++ i ) squared . add ( i * i ) ; for ( final int a : squared ) for ( final int b : squared ) if ( squared . contains ( a + b ) ) ++ ans ; return ans ; } }
class Solution { public int nearestExit ( char [ ] [ ] maze , int [ ] entrance ) { final int m = maze . length ; final int n = maze [ 0 ] . length ; final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; int ans = 0 ; Queue < int [ ] > q = new ArrayDeque < > ( Arrays . asList ( new int [ ] { entrance [ 0 ] , entrance [ 1 ] } ) ) ; boolean [ ] [ ] seen = new boolean [ m ] [ n ] ; seen [ entrance [ 0 ] ] [ entrance [ 1 ] ] = true ; while ( ! q . isEmpty ( ) ) { ++ ans ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int i = q . peek ( ) [ 0 ] ; final int j = q . poll ( ) [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seen [ x ] [ y ] || maze [ x ] [ y ] == ' + ' ) continue ; if ( x == 0 || x == m - 1 || y == 0 || y == n - 1 ) return ans ; q . offer ( new int [ ] { x , y } ) ; seen [ x ] [ y ] = true ; } } } return - 1 ; } }
class Solution { public boolean sumGame ( String num ) { final int n = num . length ( ) ; double ans = 0.0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) ans += getExpectation ( num . charAt ( i ) ) ; for ( int i = n / 2 ; i < n ; ++ i ) ans -= getExpectation ( num . charAt ( i ) ) ; return ans != 0.0 ; } private double getExpectation ( char c ) { return c == ' ? ' ? 4.5 : c - '0' ; } }
class T { public int node ; public int cost ; public int time ; public T ( int node , int cost , int time ) { this . node = node ; this . cost = cost ; this . time = time ; } } class Solution { public int minCost ( int maxTime , int [ ] [ ] edges , int [ ] passingFees ) { final int n = passingFees . length ; List < Pair < Integer , Integer > > [ ] graph = new List [ n ] ; Queue < T > minHeap = new PriorityQueue < > ( ( a , b ) -> a . cost == b . cost ? a . time - b . time : a . cost - b . cost ) ; int [ ] cost = new int [ n ] ; int [ ] time = new int [ n ] ; Arrays . fill ( cost , Integer . MAX_VALUE ) ; Arrays . fill ( time , Integer . MAX_VALUE ) ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : edges ) { final int x = e [ 0 ] ; final int y = e [ 1 ] ; final int t = e [ 2 ] ; graph [ x ] . add ( new Pair < > ( y , t ) ) ; graph [ y ] . add ( new Pair < > ( x , t ) ) ; } minHeap . offer ( new T ( 0 , passingFees [ 0 ] , 0 ) ) ; cost [ 0 ] = passingFees [ 0 ] ; time [ 0 ] = 0 ; while ( ! minHeap . isEmpty ( ) ) { final int x = minHeap . peek ( ) . node ; final int currCost = minHeap . peek ( ) . cost ; final int currTime = minHeap . poll ( ) . time ; for ( Pair < Integer , Integer > node : graph [ x ] ) { final int y = node . getKey ( ) ; final int pathTime = node . getValue ( ) ; if ( currTime + pathTime <= maxTime ) { final int newCost = currCost + passingFees [ y ] ; final int newTime = currTime + pathTime ; if ( cost [ y ] > newCost ) { cost [ y ] = newCost ; time [ y ] = newTime ; minHeap . offer ( new T ( y , newCost , newTime ) ) ; } else if ( time [ y ] > newTime ) { time [ y ] = newTime ; minHeap . offer ( new T ( y , newCost , newTime ) ) ; } } } } return cost [ n - 1 ] == Integer . MAX_VALUE ? - 1 : cost [ n - 1 ] ; } }
class Solution { public int [ ] getConcatenation ( int [ ] nums ) { final int n = nums . length ; int [ ] ans = new int [ n * 2 ] ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = ans [ i + n ] = nums [ i ] ; return ans ; } }
class Solution { public int countPalindromicSubsequence ( String s ) { int ans = 0 ; int [ ] first = new int [ 26 ] ; int [ ] last = new int [ 26 ] ; Arrays . fill ( first , s . length ( ) ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { final int index = s . charAt ( i ) - ' a ' ; first [ index ] = Math . min ( first [ index ] , i ) ; last [ index ] = i ; } for ( int i = 0 ; i < 26 ; ++ i ) if ( first [ i ] < last [ i ] ) ans += s . substring ( first [ i ] + 1 , last [ i ] ) . chars ( ) . distinct ( ) . count ( ) ; return ans ; } }
class Solution { public int colorTheGrid ( int m , int n ) { this . m = m ; this . n = n ; return dp ( 0 , 0 , 0 , 0 ) ; } private static final int kMod = 1_000_000_007 ; private int m ; private int n ; private int [ ] [ ] memo = new int [ 1000 ] [ 1024 ] ; private int dp ( int r , int c , int prevColMask , int currColMask ) { if ( c == n ) return 1 ; if ( memo [ c ] [ prevColMask ] != 0 ) return memo [ c ] [ prevColMask ] ; if ( r == m ) return dp ( 0 , c + 1 , currColMask , 0 ) ; int ans = 0 ; for ( int color = 1 ; color <= 3 ; ++ color ) { if ( getColor ( prevColMask , r ) == color ) continue ; if ( r > 0 && getColor ( currColMask , r - 1 ) == color ) continue ; ans += dp ( r + 1 , c , prevColMask , setColor ( currColMask , r , color ) ) ; ans %= kMod ; } if ( r == 0 ) memo [ c ] [ prevColMask ] = ans ; return ans ; } private int getColor ( int mask , int r ) { return mask >> r * 2 & 3 ; } private int setColor ( int mask , int r , int color ) { return mask | color << r * 2 ; } }
class Solution { public TreeNode canMerge ( List < TreeNode > trees ) { Map < Integer , TreeNode > valToNode = new HashMap < > ( ) ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( TreeNode tree : trees ) { valToNode . put ( tree . val , tree ) ; count . merge ( tree . val , 1 , Integer :: sum ) ; if ( tree . left != null ) count . merge ( tree . left . val , 1 , Integer :: sum ) ; if ( tree . right != null ) count . merge ( tree . right . val , 1 , Integer :: sum ) ; } for ( TreeNode tree : trees ) if ( count . get ( tree . val ) == 1 ) { if ( isValidBST ( tree , null , null , valToNode ) && valToNode . size ( ) <= 1 ) return tree ; return null ; } return null ; } private boolean isValidBST ( TreeNode tree , TreeNode minNode , TreeNode maxNode , Map < Integer , TreeNode > valToNode ) { if ( tree == null ) return true ; if ( minNode != null && tree . val <= minNode . val ) return false ; if ( maxNode != null && tree . val >= maxNode . val ) return false ; if ( tree . left == null && tree . right == null && valToNode . containsKey ( tree . val ) ) { final int val = tree . val ; tree . left = valToNode . get ( val ) . left ; tree . right = valToNode . get ( val ) . right ; valToNode . remove ( val ) ; } return isValidBST ( tree . left , minNode , tree , valToNode ) && isValidBST ( tree . right , tree , maxNode , valToNode ) ; } }
class Solution { public int canBeTypedWords ( String text , String brokenLetters ) { int ans = 0 ; boolean [ ] broken = new boolean [ 26 ] ; for ( final char c : brokenLetters . toCharArray ( ) ) broken [ c - ' a ' ] = true ; for ( final String word : text . split ( " ▁ " ) ) ans += canBeTyped ( word , broken ) ; return ans ; } private int canBeTyped ( final String word , boolean [ ] broken ) { for ( final char c : word . toCharArray ( ) ) if ( broken [ c - ' a ' ] ) return 0 ; return 1 ; } }
class Solution { public int addRungs ( int [ ] rungs , int dist ) { int ans = 0 ; int prev = 0 ; for ( final int rung : rungs ) { ans += ( rung - prev - 1 ) / dist ; prev = rung ; } return ans ; } }
class Solution { public long maxPoints ( int [ ] [ ] points ) { final int n = points [ 0 ] . length ; long [ ] dp = new long [ n ] ; for ( int [ ] row : points ) { long [ ] leftToRight = new long [ n ] ; long runningMax = 0 ; for ( int j = 0 ; j < n ; ++ j ) { runningMax = Math . max ( runningMax - 1 , dp [ j ] ) ; leftToRight [ j ] = runningMax ; } long [ ] rightToLeft = new long [ n ] ; runningMax = 0 ; for ( int j = n - 1 ; j >= 0 ; -- j ) { runningMax = Math . max ( runningMax - 1 , dp [ j ] ) ; rightToLeft [ j ] = runningMax ; } for ( int j = 0 ; j < n ; ++ j ) dp [ j ] = Math . max ( leftToRight [ j ] , rightToLeft [ j ] ) + row [ j ] ; } return Arrays . stream ( dp ) . max ( ) . getAsLong ( ) ; } }
class TrieNode { public TrieNode [ ] children = new TrieNode [ 2 ] ; public int count = 0 ; } class Trie { public void update ( int num , int val ) { TrieNode node = root ; for ( int i = kHeight ; i >= 0 ; -- i ) { final int bit = ( num >> i ) & 1 ; if ( node . children [ bit ] == null ) node . children [ bit ] = new TrieNode ( ) ; node = node . children [ bit ] ; node . count += val ; } } public int query ( int num ) { int ans = 0 ; TrieNode node = root ; for ( int i = kHeight ; i >= 0 ; -- i ) { final int bit = ( num >> i ) & 1 ; final int targetBit = bit ^ 1 ; if ( node . children [ targetBit ] != null && node . children [ targetBit ] . count > 0 ) { ans += 1 << i ; node = node . children [ targetBit ] ; } else { node = node . children [ targetBit ^ 1 ] ; } } return ans ; } private static final int kHeight = 17 ; TrieNode root = new TrieNode ( ) ; } class Solution { public int [ ] maxGeneticDifference ( int [ ] parents , int [ ] [ ] queries ) { final int n = parents . length ; int [ ] ans = new int [ queries . length ] ; int rootVal = - 1 ; List < Integer > [ ] tree = new List [ n ] ; for ( int i = 0 ; i < n ; ++ i ) tree [ i ] = new ArrayList < > ( ) ; Map < Integer , List < Pair < Integer , Integer > > > nodeToQueries = new HashMap < > ( ) ; Trie trie = new Trie ( ) ; for ( int i = 0 ; i < parents . length ; ++ i ) if ( parents [ i ] == - 1 ) rootVal = i ; else tree [ parents [ i ] ] . add ( i ) ; for ( int i = 0 ; i < queries . length ; ++ i ) { final int node = queries [ i ] [ 0 ] ; final int val = queries [ i ] [ 1 ] ; nodeToQueries . putIfAbsent ( node , new ArrayList < > ( ) ) ; nodeToQueries . get ( node ) . add ( new Pair < > ( i , val ) ) ; } dfs ( rootVal , trie , tree , nodeToQueries , ans ) ; return ans ; } private void dfs ( int node , Trie trie , List < Integer > [ ] tree , Map < Integer , List < Pair < Integer , Integer > > > nodeToQueries , int [ ] ans ) { trie . update ( node , 1 ) ; if ( nodeToQueries . containsKey ( node ) ) for ( Pair < Integer , Integer > query : nodeToQueries . get ( node ) ) { final int i = query . getKey ( ) ; final int val = query . getValue ( ) ; ans [ i ] = trie . query ( val ) ; } for ( final int child : tree [ node ] ) dfs ( child , trie , tree , nodeToQueries , ans ) ; trie . update ( node , - 1 ) ; } }
class Solution { public int [ ] canSeePersonsCount ( int [ ] heights ) { final int n = heights . length ; int [ ] ans = new int [ n ] ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! stack . isEmpty ( ) && heights [ stack . peek ( ) ] <= heights [ i ] ) ++ ans [ stack . pop ( ) ] ; if ( ! stack . isEmpty ( ) ) ++ ans [ stack . peek ( ) ] ; stack . push ( i ) ; } return ans ; } }
class TrieNode { public Map < String , TrieNode > children = new HashMap < > ( ) ; public boolean deleted = false ; } class Solution { public List < List < String > > deleteDuplicateFolder ( List < List < String > > paths ) { List < List < String > > ans = new ArrayList < > ( ) ; Map < String , List < TrieNode > > subtreeToNodes = new HashMap < > ( ) ; Collections . sort ( paths , ( a , b ) -> { for ( int i = 0 ; i < Math . min ( a . size ( ) , b . size ( ) ) ; ++ i ) { final int c = a . get ( i ) . compareTo ( b . get ( i ) ) ; if ( c != 0 ) return c ; } return Integer . compare ( a . size ( ) , b . size ( ) ) ; } ) ; for ( List < String > path : paths ) { TrieNode node = root ; for ( final String s : path ) { node . children . putIfAbsent ( s , new TrieNode ( ) ) ; node = node . children . get ( s ) ; } } buildSubtreeToRoots ( root , subtreeToNodes ) ; for ( List < TrieNode > nodes : subtreeToNodes . values ( ) ) if ( nodes . size ( ) > 1 ) for ( TrieNode node : nodes ) node . deleted = true ; constructPath ( root , new ArrayList < > ( ) , ans ) ; return ans ; } private TrieNode root = new TrieNode ( ) ; private StringBuilder buildSubtreeToRoots ( TrieNode node , Map < String , List < TrieNode > > subtreeToNodes ) { StringBuilder sb = new StringBuilder ( " ( " ) ; for ( final String s : node . children . keySet ( ) ) { TrieNode child = node . children . get ( s ) ; sb . append ( s ) . append ( buildSubtreeToRoots ( child , subtreeToNodes ) ) ; } sb . append ( " ) " ) ; final String subtree = sb . toString ( ) ; if ( ! subtree . equals ( " ( ) " ) ) { subtreeToNodes . putIfAbsent ( subtree , new ArrayList < > ( ) ) ; subtreeToNodes . get ( subtree ) . add ( node ) ; } return sb ; } private void constructPath ( TrieNode node , List < String > path , List < List < String > > ans ) { for ( final String s : node . children . keySet ( ) ) { TrieNode child = node . children . get ( s ) ; if ( ! child . deleted ) { path . add ( s ) ; constructPath ( child , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; } } if ( ! path . isEmpty ( ) ) ans . add ( new ArrayList < > ( path ) ) ; } }
class Solution { public int countSpecialSubsequences ( int [ ] nums ) { dp = new int [ nums . length ] [ 4 ] ; Arrays . stream ( dp ) . forEach ( row -> Arrays . fill ( row , - 1 ) ) ; return countSpecialSubsequences ( nums , 0 , - 1 ) ; } private static final int kMod = 1_000_000_007 ; private int [ ] [ ] dp ; int countSpecialSubsequences ( int [ ] nums , int i , int prev ) { if ( i == nums . length ) return prev == 2 ? 1 : 0 ; if ( dp [ i ] [ prev + 1 ] != - 1 ) return dp [ i ] [ prev + 1 ] ; long ans = 0 ; ans += countSpecialSubsequences ( nums , i + 1 , prev ) ; if ( nums [ i ] == prev ) ans += countSpecialSubsequences ( nums , i + 1 , prev ) ; if ( prev == - 1 && nums [ i ] == 0 ) ans += countSpecialSubsequences ( nums , i + 1 , 0 ) ; if ( prev == 0 && nums [ i ] == 1 ) ans += countSpecialSubsequences ( nums , i + 1 , 1 ) ; if ( prev == 1 && nums [ i ] == 2 ) ans += countSpecialSubsequences ( nums , i + 1 , 2 ) ; ans %= kMod ; return dp [ i ] [ prev + 1 ] = ( int ) ans ; } }
class Solution { public long maxProduct ( String s ) { final int n = s . length ( ) ; long ans = 1 ; int [ ] l = manacher ( s , n ) ; int [ ] r = manacher ( new StringBuilder ( s ) . reverse ( ) . toString ( ) , n ) ; reverse ( r , 0 , n - 1 ) ; for ( int i = 0 ; i + 1 < n ; ++ i ) ans = Math . max ( ans , ( long ) l [ i ] * r [ i + 1 ] ) ; return ans ; } private int [ ] manacher ( final String s , int n ) { int [ ] maxExtends = new int [ n ] ; int [ ] l2r = new int [ n ] ; Arrays . fill ( l2r , 1 ) ; int center = 0 ; for ( int i = 0 ; i < n ; ++ i ) { final int r = center + maxExtends [ center ] - 1 ; final int mirrorIndex = center - ( i - center ) ; int extend = i > r ? 1 : Math . min ( maxExtends [ mirrorIndex ] , r - i + 1 ) ; while ( i - extend >= 0 && i + extend < n && s . charAt ( i - extend ) == s . charAt ( i + extend ) ) { l2r [ i + extend ] = 2 * extend + 1 ; ++ extend ; } maxExtends [ i ] = extend ; if ( i + maxExtends [ i ] >= r ) center = i ; } for ( int i = 1 ; i < n ; ++ i ) l2r [ i ] = Math . max ( l2r [ i ] , l2r [ i - 1 ] ) ; return l2r ; } private void reverse ( int [ ] A , int l , int r ) { while ( l < r ) swap ( A , l ++ , r -- ) ; } private void swap ( int [ ] A , int i , int j ) { final int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } }
class Solution { public int [ ] longestObstacleCourseAtEachPosition ( int [ ] obstacles ) { List < Integer > ans = new ArrayList < > ( ) ; List < Integer > tail = new ArrayList < > ( ) ; for ( final int obstacle : obstacles ) if ( tail . isEmpty ( ) || obstacle >= tail . get ( tail . size ( ) - 1 ) ) { tail . add ( obstacle ) ; ans . add ( tail . size ( ) ) ; } else { final int index = firstGreater ( tail , obstacle ) ; tail . set ( index , obstacle ) ; ans . add ( index + 1 ) ; } return ans . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; } private int firstGreater ( List < Integer > A , int target ) { int l = 0 ; int r = A . size ( ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A . get ( m ) > target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public int latestDayToCross ( int row , int col , int [ ] [ ] cells ) { int ans = 0 ; int l = 1 ; int r = cells . length - 1 ; while ( l <= r ) { final int m = ( l + r ) / 2 ; if ( canWalk ( m , row , col , cells ) ) { ans = m ; l = m + 1 ; } else { r = m - 1 ; } } return ans ; } private static final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; private boolean canWalk ( int day , int row , int col , int [ ] [ ] cells ) { int [ ] [ ] matrix = new int [ row ] [ col ] ; for ( int i = 0 ; i < day ; ++ i ) { final int x = cells [ i ] [ 0 ] - 1 ; final int y = cells [ i ] [ 1 ] - 1 ; matrix [ x ] [ y ] = 1 ; } Queue < int [ ] > q = new ArrayDeque < > ( ) ; for ( int j = 0 ; j < col ; ++ j ) if ( matrix [ 0 ] [ j ] == 0 ) { q . offer ( new int [ ] { 0 , j } ) ; matrix [ 0 ] [ j ] = 1 ; } while ( ! q . isEmpty ( ) ) { final int i = q . peek ( ) [ 0 ] ; final int j = q . poll ( ) [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == row || y < 0 || y == col ) continue ; if ( matrix [ x ] [ y ] == 1 ) continue ; if ( x == row - 1 ) return true ; q . offer ( new int [ ] { x , y } ) ; matrix [ x ] [ y ] = 1 ; } } return false ; } }
class Solution { public int rob ( int [ ] nums ) { final int n = nums . length ; if ( n == 0 ) return 0 ; if ( n == 1 ) return nums [ 0 ] ; int [ ] dp = new int [ n ] ; dp [ 0 ] = nums [ 0 ] ; dp [ 1 ] = Math . max ( nums [ 0 ] , nums [ 1 ] ) ; for ( int i = 2 ; i < n ; ++ i ) dp [ i ] = Math . max ( dp [ i - 1 ] , dp [ i - 2 ] + nums [ i ] ) ; return dp [ n - 1 ] ; } }
class Solution { public List < Integer > rightSideView ( TreeNode root ) { if ( root == null ) return new ArrayList < > ( ) ; List < Integer > ans = new ArrayList < > ( ) ; Queue < TreeNode > q = new ArrayDeque < > ( Arrays . asList ( root ) ) ; while ( ! q . isEmpty ( ) ) { final int size = q . size ( ) ; for ( int i = 0 ; i < size ; ++ i ) { TreeNode node = q . poll ( ) ; if ( i == size - 1 ) ans . add ( node . val ) ; if ( node . left != null ) q . offer ( node . left ) ; if ( node . right != null ) q . offer ( node . right ) ; } } return ans ; } }
class Solution { public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { ListNode dummy = new ListNode ( 0 ) ; ListNode curr = dummy ; int carry = 0 ; while ( l1 != null || l2 != null || carry > 0 ) { if ( l1 != null ) { carry += l1 . val ; l1 = l1 . next ; } if ( l2 != null ) { carry += l2 . val ; l2 = l2 . next ; } curr . next = new ListNode ( carry % 10 ) ; carry /= 10 ; curr = curr . next ; } return dummy . next ; } }
class Solution { public boolean isValid ( String s ) { Deque < Character > stack = new ArrayDeque < > ( ) ; for ( final char c : s . toCharArray ( ) ) if ( c == ' ( ' ) stack . push ( ' ) ' ) ; else if ( c == ' { ' ) stack . push ( ' } ' ) ; else if ( c == ' [ ' ) stack . push ( ' ] ' ) ; else if ( stack . isEmpty ( ) || stack . pop ( ) != c ) return false ; return stack . isEmpty ( ) ; } }
class Solution { public int numIslands ( char [ ] [ ] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) if ( grid [ i ] [ j ] == '1' ) { bfs ( grid , i , j ) ; ++ ans ; } return ans ; } private static final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; private void bfs ( char [ ] [ ] grid , int r , int c ) { Queue < int [ ] > q = new ArrayDeque < > ( ) ; q . offer ( new int [ ] { r , c } ) ; grid [ r ] [ c ] = '2' ; while ( ! q . isEmpty ( ) ) { final int i = q . peek ( ) [ 0 ] ; final int j = q . poll ( ) [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == grid . length || y < 0 || y == grid [ 0 ] . length ) continue ; if ( grid [ x ] [ y ] != '1' ) continue ; q . offer ( new int [ ] { x , y } ) ; grid [ x ] [ y ] = '2' ; } } } }
class Solution { public String reversePrefix ( String word , char ch ) { final int i = word . indexOf ( ch ) + 1 ; return new StringBuilder ( word . substring ( 0 , i ) ) . reverse ( ) . append ( word . substring ( i ) ) . toString ( ) ; } }
class Solution { public long interchangeableRectangles ( int [ ] [ ] rectangles ) { long ans = 0 ; Map < Double , Integer > ratioCount = new HashMap < > ( ) ; for ( int [ ] r : rectangles ) ratioCount . merge ( ( double ) r [ 0 ] / r [ 1 ] , 1 , Integer :: sum ) ; for ( final int count : ratioCount . values ( ) ) ans += ( long ) count * ( count - 1 ) / 2 ; return ans ; } }
class Solution { public int maxProduct ( String s ) { dfs ( s , 0 , new StringBuilder ( ) , new StringBuilder ( ) ) ; return ans ; } private int ans = 0 ; private void dfs ( final String s , int i , StringBuilder sb1 , StringBuilder sb2 ) { if ( i == s . length ( ) ) { if ( isPalindrome ( sb1 ) && isPalindrome ( sb2 ) ) ans = Math . max ( ans , sb1 . length ( ) * sb2 . length ( ) ) ; return ; } final int sb1Length = sb1 . length ( ) ; dfs ( s , i + 1 , sb1 . append ( s . charAt ( i ) ) , sb2 ) ; sb1 . setLength ( sb1Length ) ; final int sb2Length = sb2 . length ( ) ; dfs ( s , i + 1 , sb1 , sb2 . append ( s . charAt ( i ) ) ) ; sb2 . setLength ( sb2Length ) ; dfs ( s , i + 1 , sb1 , sb2 ) ; } private boolean isPalindrome ( StringBuilder sb ) { int i = 0 ; int j = sb . length ( ) - 1 ; while ( i < j ) { if ( sb . charAt ( i ) != sb . charAt ( j ) ) return false ; ++ i ; -- j ; } return true ; } }
class Solution { public int [ ] smallestMissingValueSubtree ( int [ ] parents , int [ ] nums ) { final int n = parents . length ; int [ ] ans = new int [ n ] ; Arrays . fill ( ans , 1 ) ; List < Integer > [ ] graph = new List [ n ] ; Set < Integer > seen = new HashSet < > ( ) ; int minMiss = 1 ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int i = 1 ; i < n ; ++ i ) graph [ parents [ i ] ] . add ( i ) ; final int nodeThatsOne = getNode ( nums ) ; if ( nodeThatsOne == - 1 ) return ans ; int u = nodeThatsOne ; int prev = - 1 ; while ( u != - 1 ) { for ( final int v : graph [ u ] ) { if ( v == prev ) continue ; dfs ( v , graph , seen , nums ) ; } seen . add ( nums [ u ] ) ; while ( seen . contains ( minMiss ) ) ++ minMiss ; ans [ u ] = minMiss ; prev = u ; u = parents [ u ] ; } return ans ; } private void dfs ( int u , List < Integer > [ ] graph , Set < Integer > seen , int [ ] nums ) { seen . add ( nums [ u ] ) ; for ( final int v : graph [ u ] ) dfs ( v , graph , seen , nums ) ; } private int getNode ( int [ ] nums ) { for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] == 1 ) return i ; return - 1 ; } }
class Solution { public boolean findGameWinner ( int n ) { return n % 6 != 1 ; } }
class Solution { public int countKDifference ( int [ ] nums , int k ) { final int kMax = 100 ; int ans = 0 ; int [ ] count = new int [ kMax + 1 ] ; for ( final int num : nums ) ++ count [ num ] ; for ( int i = k + 1 ; i <= kMax ; ++ i ) ans += count [ i ] * count [ i - k ] ; return ans ; } }
class Solution { public int [ ] findOriginalArray ( int [ ] changed ) { List < Integer > ans = new ArrayList < > ( ) ; Queue < Integer > q = new ArrayDeque < > ( ) ; Arrays . sort ( changed ) ; for ( final int num : changed ) if ( ! q . isEmpty ( ) && num == q . peek ( ) ) { q . poll ( ) ; } else { q . offer ( num * 2 ) ; ans . add ( num ) ; } return q . isEmpty ( ) ? ans . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) : new int [ ] { } ; } }
class Solution { public long maxTaxiEarnings ( int n , int [ ] [ ] rides ) { List < Pair < Integer , Integer > > [ ] startToEndAndEarns = new List [ n ] ; long [ ] dp = new long [ n + 1 ] ; for ( int i = 1 ; i < n ; ++ i ) startToEndAndEarns [ i ] = new ArrayList < > ( ) ; for ( int [ ] ride : rides ) { final int start = ride [ 0 ] ; final int end = ride [ 1 ] ; final int tip = ride [ 2 ] ; final int earn = end - start + tip ; startToEndAndEarns [ start ] . add ( new Pair < > ( end , earn ) ) ; } for ( int i = n - 1 ; i >= 1 ; -- i ) { dp [ i ] = dp [ i + 1 ] ; for ( Pair < Integer , Integer > pair : startToEndAndEarns [ i ] ) { final int end = pair . getKey ( ) ; final int earn = pair . getValue ( ) ; dp [ i ] = Math . max ( dp [ i ] , dp [ end ] + earn ) ; } } return dp [ 1 ] ; } }
class Solution { public int minOperations ( int [ ] nums ) { final int n = nums . length ; int ans = n ; Arrays . sort ( nums ) ; nums = Arrays . stream ( nums ) . distinct ( ) . toArray ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { final int start = nums [ i ] ; final int end = start + n - 1 ; final int index = firstGreater ( nums , end ) ; final int uniqueLength = index - i ; ans = Math . min ( ans , n - uniqueLength ) ; } return ans ; } private int firstGreater ( int [ ] nums , int target ) { int l = 0 ; int r = nums . length ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( nums [ m ] > target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public int rangeBitwiseAnd ( int m , int n ) { int shiftBits = 0 ; while ( m != n ) { m >>= 1 ; n >>= 1 ; ++ shiftBits ; } return m << shiftBits ; } }
class Solution { public int finalValueAfterOperations ( String [ ] operations ) { int ans = 0 ; for ( final String op : operations ) ans += op . charAt ( 1 ) == ' + ' ? 1 : - 1 ; return ans ; } }
class Solution { public int sumOfBeauties ( int [ ] nums ) { final int n = nums . length ; int ans = 0 ; int [ ] minOfRight = new int [ n ] ; minOfRight [ n - 1 ] = nums [ n - 1 ] ; for ( int i = n - 2 ; i >= 2 ; -- i ) minOfRight [ i ] = Math . min ( nums [ i ] , minOfRight [ i + 1 ] ) ; int maxOfLeft = nums [ 0 ] ; for ( int i = 1 ; i <= n - 2 ; ++ i ) { if ( maxOfLeft < nums [ i ] && nums [ i ] < minOfRight [ i + 1 ] ) ans += 2 ; else if ( nums [ i - 1 ] < nums [ i ] && nums [ i ] < nums [ i + 1 ] ) ans += 1 ; maxOfLeft = Math . max ( maxOfLeft , nums [ i ] ) ; } return ans ; } }
class DetectSquares { public void add ( int [ ] point ) { pointCount . merge ( hash ( point [ 0 ] , point [ 1 ] ) , 1 , Integer :: sum ) ; } public int count ( int [ ] point ) { final int x1 = point [ 0 ] ; final int y1 = point [ 1 ] ; int ans = 0 ; for ( final int hashed : pointCount . keySet ( ) ) { final int count = pointCount . get ( hashed ) ; final int x3 = hashed >> 10 ; final int y3 = hashed & 1023 ; if ( x1 != x3 && Math . abs ( x1 - x3 ) == Math . abs ( y1 - y3 ) ) { final int p = hash ( x1 , y3 ) ; final int q = hash ( x3 , y1 ) ; if ( pointCount . containsKey ( p ) && pointCount . containsKey ( q ) ) ans += count * pointCount . get ( p ) * pointCount . get ( q ) ; } } return ans ; } private Map < Integer , Integer > pointCount = new HashMap < > ( ) ; private int hash ( int i , int j ) { return i << 10 | j ; } }
public class Solution { public String longestSubsequenceRepeatedK ( String s , int k ) { String ans = " " ; int [ ] count = new int [ 26 ] ; List < Character > possibleChars = new ArrayList < > ( ) ; Queue < String > q = new ArrayDeque < > ( Arrays . asList ( " " ) ) ; for ( final char c : s . toCharArray ( ) ) ++ count [ c - ' a ' ] ; for ( char c = ' a ' ; c <= ' z ' ; ++ c ) if ( count [ c - ' a ' ] >= k ) possibleChars . add ( c ) ; while ( ! q . isEmpty ( ) ) { final String currSubseq = q . poll ( ) ; if ( currSubseq . length ( ) * k > s . length ( ) ) return ans ; for ( final char c : possibleChars ) { final String newSubseq = currSubseq + c ; if ( isSubsequence ( newSubseq , s , k ) ) { q . offer ( newSubseq ) ; ans = newSubseq ; } } } return ans ; } private boolean isSubsequence ( final String subseq , final String s , int k ) { int i = 0 ; for ( final char c : s . toCharArray ( ) ) if ( c == subseq . charAt ( i ) ) if ( ++ i == subseq . length ( ) ) { if ( -- k == 0 ) return true ; i = 0 ; } return false ; } }
class Solution { public int [ ] [ ] averageHeightOfBuildings ( int [ ] [ ] buildings ) { List < int [ ] > ans = new ArrayList < > ( ) ; List < Pair < Integer , Integer > > events = new ArrayList < > ( ) ; for ( int [ ] b : buildings ) { final int start = b [ 0 ] ; final int end = b [ 1 ] ; final int height = b [ 2 ] ; events . add ( new Pair < > ( start , height ) ) ; events . add ( new Pair < > ( end , - height ) ) ; } Collections . sort ( events , Comparator . comparing ( Pair :: getKey ) ) ; int prev = 0 ; int count = 0 ; int sumHeight = 0 ; for ( Pair < Integer , Integer > event : events ) { final int curr = event . getKey ( ) ; final int h = event . getValue ( ) ; final int height = Math . abs ( h ) ; if ( sumHeight > 0 && curr > prev ) { final int avgHeight = sumHeight / count ; if ( ! ans . isEmpty ( ) && ans . get ( ans . size ( ) - 1 ) [ 1 ] == prev && avgHeight == ans . get ( ans . size ( ) - 1 ) [ 2 ] ) ans . get ( ans . size ( ) - 1 ) [ 1 ] = curr ; else ans . add ( new int [ ] { prev , curr , avgHeight } ) ; } sumHeight += h ; count += h > 0 ? 1 : - 1 ; prev = curr ; } return ans . toArray ( new int [ ans . size ( ) ] [ ] ) ; } }
class Solution { public int maximumDifference ( int [ ] nums ) { int ans = - 1 ; int min = nums [ 0 ] ; for ( int i = 1 ; i < nums . length ; ++ i ) { if ( nums [ i ] > min ) ans = Math . max ( ans , nums [ i ] - min ) ; min = Math . min ( min , nums [ i ] ) ; } return ans ; } }
class Solution { public long gridGame ( int [ ] [ ] grid ) { final int n = grid [ 0 ] . length ; long ans = Long . MAX_VALUE ; long sumRow0 = Arrays . stream ( grid [ 0 ] ) . asLongStream ( ) . sum ( ) ; long sumRow1 = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sumRow0 -= grid [ 0 ] [ i ] ; ans = Math . min ( ans , Math . max ( sumRow0 , sumRow1 ) ) ; sumRow1 += grid [ 1 ] [ i ] ; } return ans ; } }
class Solution { public boolean placeWordInCrossword ( char [ ] [ ] board , String word ) { for ( char [ ] [ ] state : new char [ ] [ ] [ ] { board , getRotated ( board ) } ) for ( char [ ] chars : state ) for ( final String token : String . valueOf ( chars ) . split ( " # " ) ) for ( final String letters : new String [ ] { word , new StringBuilder ( word ) . reverse ( ) . toString ( ) } ) if ( letters . length ( ) == token . length ( ) ) if ( canFit ( letters , token ) ) return true ; return false ; } private char [ ] [ ] getRotated ( char [ ] [ ] board ) { final int m = board . length ; final int n = board [ 0 ] . length ; char [ ] [ ] rotated = new char [ n ] [ m ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) rotated [ j ] [ i ] = board [ i ] [ j ] ; return rotated ; } private boolean canFit ( final String letters , final String token ) { for ( int i = 0 ; i < letters . length ( ) ; ++ i ) if ( token . charAt ( i ) != ' ▁ ' && token . charAt ( i ) != letters . charAt ( i ) ) return false ; return true ; } }
class Solution { public int scoreOfStudents ( String s , int [ ] answers ) { final int n = s . length ( ) / 2 + 1 ; int ans = 0 ; Set < Integer > [ ] [ ] dp = new Set [ n ] [ n ] ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) dp [ i ] [ j ] = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ] [ i ] . add ( s . charAt ( i * 2 ) - '0' ) ; for ( int d = 1 ; d < n ; ++ d ) for ( int i = 0 ; i + d < n ; ++ i ) { final int j = i + d ; for ( int k = i ; k < j ; ++ k ) { final char op = s . charAt ( k * 2 + 1 ) ; for ( final int a : dp [ i ] [ k ] ) for ( final int b : dp [ k + 1 ] [ j ] ) { final int res = func ( op , a , b ) ; if ( res <= 1000 ) dp [ i ] [ j ] . add ( res ) ; } } } final int correctAnswer = eval ( s ) ; for ( final int answer : answers ) count . merge ( answer , 1 , Integer :: sum ) ; for ( final int answer : count . keySet ( ) ) if ( answer == correctAnswer ) ans += 5 * count . get ( answer ) ; else if ( dp [ 0 ] [ n - 1 ] . contains ( answer ) ) ans += 2 * count . get ( answer ) ; return ans ; } private int eval ( final String s ) { int ans = 0 ; int currNum = 0 ; int prevNum = 0 ; char op = ' + ' ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { final char c = s . charAt ( i ) ; if ( Character . isDigit ( c ) ) currNum = currNum * 10 + ( c - '0' ) ; if ( ! Character . isDigit ( c ) || i == s . length ( ) - 1 ) { if ( op == ' + ' ) { ans += prevNum ; prevNum = currNum ; } else if ( op == ' * ' ) { prevNum = prevNum * currNum ; } op = c ; currNum = 0 ; } } return ans + prevNum ; } private int func ( char op , int a , int b ) { if ( op == ' + ' ) return a + b ; return a * b ; } }
class Solution { public boolean isHappy ( int n ) { int slow = squaredSum ( n ) ; int fast = squaredSum ( squaredSum ( n ) ) ; while ( slow != fast ) { slow = squaredSum ( slow ) ; fast = squaredSum ( squaredSum ( fast ) ) ; } return slow == 1 ; } private int squaredSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += Math . pow ( n % 10 , 2 ) ; n /= 10 ; } return sum ; } }
class Solution { public int brightestPosition ( int [ ] [ ] lights ) { int ans = Integer . MAX_VALUE ; int maxBrightness = - 1 ; int currBrightness = 0 ; Map < Integer , Integer > timeline = new TreeMap < > ( ) ; for ( int [ ] light : lights ) { final int position = light [ 0 ] ; final int range = light [ 1 ] ; timeline . merge ( position - range , 1 , Integer :: sum ) ; timeline . merge ( position + range + 1 , - 1 , Integer :: sum ) ; } for ( final int pos : timeline . keySet ( ) ) { final int brightness = timeline . get ( pos ) ; currBrightness += brightness ; if ( currBrightness > maxBrightness ) { maxBrightness = currBrightness ; ans = pos ; } } return ans ; } }
class Solution { public int [ ] [ ] construct2DArray ( int [ ] original , int m , int n ) { if ( original . length != m * n ) return new int [ ] [ ] { } ; int [ ] [ ] ans = new int [ m ] [ n ] ; for ( int i = 0 ; i < original . length ; ++ i ) ans [ i / n ] [ i % n ] = original [ i ] ; return ans ; } }
class Solution { public int numOfPairs ( String [ ] nums , String target ) { final int n = target . length ( ) ; int ans = 0 ; Map < String , Integer > count = new HashMap < > ( ) ; for ( final String num : nums ) { final int k = num . length ( ) ; if ( k >= n ) continue ; if ( target . substring ( 0 , k ) . equals ( num ) ) ans += count . getOrDefault ( target . substring ( k ) , 0 ) ; if ( target . substring ( n - k ) . equals ( num ) ) ans += count . getOrDefault ( target . substring ( 0 , n - k ) , 0 ) ; count . merge ( num , 1 , Integer :: sum ) ; } return ans ; } }
class Solution { public int maxConsecutiveAnswers ( String answerKey , int k ) { int ans = 0 ; int maxCount = 0 ; int [ ] count = new int [ 2 ] ; for ( int l = 0 , r = 0 ; r < answerKey . length ( ) ; ++ r ) { maxCount = Math . max ( maxCount , ++ count [ answerKey . charAt ( r ) == ' T ' ? 1 : 0 ] ) ; while ( maxCount + k < r - l + 1 ) -- count [ answerKey . charAt ( l ++ ) == ' T ' ? 1 : 0 ] ; ans = Math . max ( ans , r - l + 1 ) ; } return ans ; } }
class Solution { public int waysToPartition ( int [ ] nums , int k ) { final int n = nums . length ; final long sum = Arrays . stream ( nums ) . asLongStream ( ) . sum ( ) ; long prefix = 0 ; Map < Long , Integer > l = new HashMap < > ( ) ; Map < Long , Integer > r = new HashMap < > ( ) ; for ( int pivot = 1 ; pivot < n ; ++ pivot ) { prefix += nums [ pivot - 1 ] ; final long suffix = sum - prefix ; r . merge ( prefix - suffix , 1 , Integer :: sum ) ; } int ans = r . getOrDefault ( 0L , 0 ) ; prefix = 0 ; for ( final int num : nums ) { final long change = ( long ) k - num ; ans = Math . max ( ans , l . getOrDefault ( change , 0 ) + r . getOrDefault ( - change , 0 ) ) ; prefix += num ; final long suffix = sum - prefix ; final long diff = prefix - suffix ; r . merge ( diff , - 1 , Integer :: sum ) ; l . merge ( diff , 1 , Integer :: sum ) ; } return ans ; } }
class Solution { public int [ ] missingRolls ( int [ ] rolls , int mean , int n ) { final int targetSum = ( rolls . length + n ) * mean ; int missingSum = targetSum - Arrays . stream ( rolls ) . sum ( ) ; if ( missingSum > n * 6 || missingSum < n ) return new int [ ] { } ; int [ ] ans = new int [ n ] ; Arrays . fill ( ans , missingSum / n ) ; missingSum %= n ; for ( int i = 0 ; i < missingSum ; ++ i ) ++ ans [ i ] ; return ans ; } }
class Solution { public boolean stoneGameIX ( int [ ] stones ) { int [ ] count = new int [ 3 ] ; for ( final int stone : stones ) ++ count [ stone % 3 ] ; if ( count [ 0 ] % 2 == 0 ) return Math . min ( count [ 1 ] , count [ 2 ] ) > 0 ; return Math . abs ( count [ 1 ] - count [ 2 ] ) > 2 ; } }
class Solution { public ListNode removeElements ( ListNode head , int val ) { ListNode dummy = new ListNode ( 0 , head ) ; ListNode prev = dummy ; for ( ; head != null ; head = head . next ) if ( head . val != val ) { prev . next = head ; prev = prev . next ; } prev . next = null ; return dummy . next ; } }
class Solution { public String smallestSubsequence ( String s , int k , char letter , int repetition ) { StringBuilder sb = new StringBuilder ( ) ; Deque < Character > stack = new ArrayDeque < > ( ) ; int required = repetition ; int nLetters = ( int ) s . chars ( ) . filter ( c -> c == letter ) . count ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { final char c = s . charAt ( i ) ; while ( ! stack . isEmpty ( ) && stack . peek ( ) > c && stack . size ( ) + s . length ( ) - i - 1 >= k && ( stack . peek ( ) != letter || nLetters > required ) ) if ( stack . pop ( ) == letter ) ++ required ; if ( stack . size ( ) < k ) if ( c == letter ) { stack . push ( c ) ; -- required ; } else if ( k - stack . size ( ) > required ) { stack . push ( c ) ; } if ( c == letter ) -- nLetters ; } for ( final char c : stack ) sb . append ( c ) ; return sb . reverse ( ) . toString ( ) ; } }
class FenwickTree { public FenwickTree ( int n ) { this . n = n ; sums = new int [ 2 * n + 1 ] ; } public void update ( int i , int delta ) { i += n + 1 ; while ( i < sums . length ) { sums [ i ] += delta ; i += i & - i ; } } public int get ( int i ) { i += n + 1 ; int sum = 0 ; while ( i > 0 ) { sum += sums [ i ] ; i -= i & - i ; } return sum ; } private int n ; private int [ ] sums ; } class Solution { public int subarraysWithMoreZerosThanOnes ( int [ ] nums ) { final int kMod = 1_000_000_007 ; int ans = 0 ; int prefix = 0 ; FenwickTree tree = new FenwickTree ( nums . length ) ; tree . update ( 0 , 1 ) ; for ( final int num : nums ) { prefix += num == 0 ? - 1 : 1 ; ans += tree . get ( prefix - 1 ) ; ans %= kMod ; tree . update ( prefix , 1 ) ; } return ans ; } }
class Solution { public List < Integer > twoOutOfThree ( int [ ] nums1 , int [ ] nums2 , int [ ] nums3 ) { List < Integer > ans = new ArrayList < > ( ) ; int [ ] count = new int [ 101 ] ; for ( int [ ] nums : new int [ ] [ ] { nums1 , nums2 , nums3 } ) update ( count , nums ) ; for ( int i = 1 ; i <= 100 ; ++ i ) if ( count [ i ] >= 2 ) ans . add ( i ) ; return ans ; } private void update ( int [ ] count , int [ ] nums ) { for ( final int num : Arrays . stream ( nums ) . boxed ( ) . collect ( Collectors . toSet ( ) ) ) ++ count [ num ] ; } }
class Solution { public int minOperations ( int [ ] [ ] grid , int x ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int [ ] A = new int [ m * n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) A [ i * n + j ] = grid [ i ] [ j ] ; if ( Arrays . stream ( A ) . anyMatch ( a -> ( a - A [ 0 ] ) % x != 0 ) ) return - 1 ; int ans = 0 ; Arrays . sort ( A ) ; for ( final int a : A ) ans += Math . abs ( a - A [ A . length / 2 ] ) / x ; return ans ; } }
class StockPrice { public void update ( int timestamp , int price ) { if ( timestampToPrice . containsKey ( timestamp ) ) { final int prevPrice = timestampToPrice . get ( timestamp ) ; pricesCount . merge ( prevPrice , - 1 , Integer :: sum ) ; if ( pricesCount . get ( prevPrice ) == 0 ) pricesCount . remove ( prevPrice ) ; } timestampToPrice . put ( timestamp , price ) ; pricesCount . merge ( price , 1 , Integer :: sum ) ; } public int current ( ) { return timestampToPrice . lastEntry ( ) . getValue ( ) ; } public int maximum ( ) { return pricesCount . lastKey ( ) ; } public int minimum ( ) { return pricesCount . firstKey ( ) ; } private TreeMap < Integer , Integer > timestampToPrice = new TreeMap < > ( ) ; private TreeMap < Integer , Integer > pricesCount = new TreeMap < > ( ) ; }
class Solution { public int minimumDifference ( int [ ] nums ) { final int n = nums . length / 2 ; final int sum = Arrays . stream ( nums ) . sum ( ) ; final int goal = sum / 2 ; final int [ ] lNums = Arrays . copyOfRange ( nums , 0 , n ) ; final int [ ] rNums = Arrays . copyOfRange ( nums , n , nums . length ) ; int ans = Integer . MAX_VALUE ; List < Integer > [ ] lSums = new List [ n + 1 ] ; List < Integer > [ ] rSums = new List [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) { lSums [ i ] = new ArrayList < > ( ) ; rSums [ i ] = new ArrayList < > ( ) ; } dfs ( lNums , 0 , 0 , 0 , lSums ) ; dfs ( rNums , 0 , 0 , 0 , rSums ) ; for ( int lCount = 0 ; lCount <= n ; ++ lCount ) { List < Integer > l = lSums [ lCount ] ; List < Integer > r = rSums [ n - lCount ] ; Collections . sort ( r ) ; for ( final int lSum : l ) { final int i = firstGreaterEqual ( r , goal - lSum ) ; if ( i < r . size ( ) ) { final int sumPartOne = sum - lSum - r . get ( i ) ; final int sumPartTwo = sum - sumPartOne ; ans = Math . min ( ans , Math . abs ( sumPartOne - sumPartTwo ) ) ; } if ( i > 0 ) { final int sumPartOne = sum - lSum - r . get ( i - 1 ) ; final int sumPartTwo = sum - sumPartOne ; ans = Math . min ( ans , Math . abs ( sumPartOne - sumPartTwo ) ) ; } } } return ans ; } private void dfs ( int [ ] A , int i , int count , int path , List < Integer > [ ] sums ) { if ( i == A . length ) { sums [ count ] . add ( path ) ; return ; } dfs ( A , i + 1 , count + 1 , path + A [ i ] , sums ) ; dfs ( A , i + 1 , count , path , sums ) ; } private int firstGreaterEqual ( List < Integer > A , int target ) { int l = 0 ; int r = A . size ( ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A . get ( m ) >= target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public long maximumAlternatingSubarraySum ( int [ ] nums ) { long ans = Integer . MIN_VALUE ; long even = 0 ; long odd = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( i % 2 == 0 ) even += nums [ i ] ; else even = Math . max ( 0 , even - nums [ i ] ) ; ans = Math . max ( ans , even ) ; } for ( int i = 1 ; i < nums . length ; ++ i ) { if ( i % 2 == 1 ) odd += nums [ i ] ; else odd = Math . max ( 0 , odd - nums [ i ] ) ; ans = Math . max ( ans , odd ) ; } return ans ; } }
class Solution { public int minMovesToSeat ( int [ ] seats , int [ ] students ) { int res = 0 ; Arrays . sort ( seats ) ; Arrays . sort ( students ) ; for ( int i = 0 ; i < seats . length ; ++ i ) res += Math . abs ( seats [ i ] - students [ i ] ) ; return res ; } }
class Solution { public boolean winnerOfGame ( String colors ) { int countAAA = 0 ; int countBBB = 0 ; for ( int i = 1 ; i + 1 < colors . length ( ) ; ++ i ) if ( colors . charAt ( i - 1 ) == colors . charAt ( i ) && colors . charAt ( i ) == colors . charAt ( i + 1 ) ) if ( colors . charAt ( i ) == ' A ' ) ++ countAAA ; else ++ countBBB ; return countAAA > countBBB ; } }
class Solution { public int networkBecomesIdle ( int [ ] [ ] edges , int [ ] patience ) { final int n = patience . length ; int ans = 0 ; List < Integer > [ ] graph = new List [ n ] ; Queue < Integer > q = new ArrayDeque < > ( Arrays . asList ( 0 ) ) ; int [ ] dist = new int [ n ] ; Arrays . fill ( dist , Integer . MAX_VALUE ) ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } while ( ! q . isEmpty ( ) ) { for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int u = q . poll ( ) ; for ( final int v : graph [ u ] ) if ( dist [ v ] == Integer . MAX_VALUE ) { dist [ v ] = dist [ u ] + 1 ; q . offer ( v ) ; } } } for ( int i = 1 ; i < n ; ++ i ) { final int numResending = ( dist [ i ] * 2 - 1 ) / patience [ i ] ; final int lastResendingTime = patience [ i ] * numResending ; final int lastArrivingTime = lastResendingTime + dist [ i ] * 2 ; ans = Math . max ( ans , lastArrivingTime ) ; } return ans + 1 ; } }
class Solution { public int countPrimes ( int n ) { if ( n <= 2 ) return 0 ; int ans = 0 ; boolean [ ] prime = new boolean [ n ] ; Arrays . fill ( prime , 2 , n , true ) ; for ( int i = 0 ; i < Math . sqrt ( n ) ; ++ i ) if ( prime [ i ] ) for ( int j = i * i ; j < n ; j += i ) prime [ j ] = false ; for ( final boolean p : prime ) if ( p ) ++ ans ; return ans ; } }
class Solution { public long kthSmallestProduct ( int [ ] nums1 , int [ ] nums2 , long k ) { List < Integer > A1 = new ArrayList < > ( ) ; List < Integer > A2 = new ArrayList < > ( ) ; List < Integer > B1 = new ArrayList < > ( ) ; List < Integer > B2 = new ArrayList < > ( ) ; seperate ( nums1 , A1 , A2 ) ; seperate ( nums2 , B1 , B2 ) ; final long negCount = A1 . size ( ) * B2 . size ( ) + A2 . size ( ) * B1 . size ( ) ; int sign = 1 ; if ( k > negCount ) { k -= negCount ; } else { k = negCount - k + 1 ; sign = - 1 ; List < Integer > temp = B1 ; B1 = B2 ; B2 = temp ; } long l = 0 ; long r = ( long ) 1e10 ; while ( l < r ) { final long m = ( l + r ) / 2 ; if ( numProductNoGreaterThan ( A1 , B1 , m ) + numProductNoGreaterThan ( A2 , B2 , m ) >= k ) r = m ; else l = m + 1 ; } return sign * l ; } private void seperate ( int [ ] A , List < Integer > A1 , List < Integer > A2 ) { for ( final int a : A ) if ( a < 0 ) A1 . add ( - a ) ; else A2 . add ( a ) ; Collections . reverse ( A1 ) ; } private long numProductNoGreaterThan ( List < Integer > A , List < Integer > B , long m ) { long count = 0 ; int j = B . size ( ) - 1 ; for ( final long a : A ) { while ( j >= 0 && a * B . get ( j ) > m ) -- j ; count += j + 1 ; } return count ; } }
class Solution { public boolean areNumbersAscending ( String s ) { int prev = 0 ; for ( final String token : s . split ( " ▁ " ) ) if ( Character . isDigit ( token . charAt ( 0 ) ) ) { final int num = Integer . parseInt ( token ) ; if ( num <= prev ) return false ; prev = num ; } return true ; } }
public class Bank { public Bank ( long [ ] balance ) { this . balance = balance ; } public boolean transfer ( int account1 , int account2 , long money ) { if ( ! isValid ( account2 ) ) return false ; return withdraw ( account1 , money ) && deposit ( account2 , money ) ; } public boolean deposit ( int account , long money ) { if ( ! isValid ( account ) ) return false ; balance [ account - 1 ] += money ; return true ; } public boolean withdraw ( int account , long money ) { if ( ! isValid ( account ) ) return false ; if ( balance [ account - 1 ] < money ) return false ; balance [ account - 1 ] -= money ; return true ; } private long [ ] balance ; private boolean isValid ( int account ) { return 1 <= account && account <= balance . length ; } }
class Solution { public int countMaxOrSubsets ( int [ ] nums ) { final int ors = Arrays . stream ( nums ) . reduce ( ( a , b ) -> a | b ) . getAsInt ( ) ; dfs ( nums , 0 , 0 , ors ) ; return ans ; } private int ans = 0 ; private void dfs ( int [ ] nums , int i , int path , final int ors ) { if ( i == nums . length ) { if ( path == ors ) ++ ans ; return ; } dfs ( nums , i + 1 , path , ors ) ; dfs ( nums , i + 1 , path | nums [ i ] , ors ) ; } }
class Solution { public int secondMinimum ( int n , int [ ] [ ] edges , int time , int change ) { List < Integer > [ ] graph = new List [ n + 1 ] ; Queue < int [ ] > q = new ArrayDeque < > ( Arrays . asList ( new int [ ] { 1 , 0 } ) ) ; int [ ] [ ] minTime = new int [ n + 1 ] [ 2 ] ; Arrays . stream ( minTime ) . forEach ( A -> Arrays . fill ( A , Integer . MAX_VALUE ) ) ; minTime [ 1 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } while ( ! q . isEmpty ( ) ) { final int i = q . peek ( ) [ 0 ] ; final int prevTime = q . poll ( ) [ 1 ] ; final int numChangeSignal = prevTime / change ; final int waitTime = ( numChangeSignal & 1 ) == 1 ? change - ( prevTime % change ) : 0 ; final int newTime = prevTime + waitTime + time ; for ( final int j : graph [ i ] ) if ( newTime < minTime [ j ] [ 0 ] ) { minTime [ j ] [ 0 ] = newTime ; q . offer ( new int [ ] { j , newTime } ) ; } else if ( minTime [ j ] [ 0 ] < newTime && newTime < minTime [ j ] [ 1 ] ) { if ( j == n ) return newTime ; minTime [ j ] [ 1 ] = newTime ; q . offer ( new int [ ] { j , newTime } ) ; } } throw new IllegalArgumentException ( ) ; } }
class Solution { public ListNode sortLinkedList ( ListNode head ) { ListNode prev = head ; ListNode curr = head . next ; while ( curr != null ) if ( curr . val < 0 ) { prev . next = curr . next ; curr . next = head ; head = curr ; curr = prev . next ; } else { prev = curr ; curr = curr . next ; } return head ; } }
class Solution { public int countValidWords ( String sentence ) { int ans = 0 ; for ( final String token : sentence . trim ( ) . split ( " \\ s + " ) ) if ( isValid ( token ) ) ++ ans ; return ans ; } private boolean isValid ( final String token ) { int countHyphen = 0 ; for ( int i = 0 ; i < token . length ( ) ; ++ i ) { final char c = token . charAt ( i ) ; if ( Character . isDigit ( c ) ) return false ; if ( c == ' - ' ) { if ( i == 0 || ! Character . isLowerCase ( token . charAt ( i - 1 ) ) ) return false ; if ( i + 1 == token . length ( ) || ! Character . isLowerCase ( token . charAt ( i + 1 ) ) ) return false ; if ( ++ countHyphen > 1 ) return false ; } else if ( c == ' ! ' || c == ' . ' || c == ' , ' ) { if ( i != token . length ( ) - 1 ) return false ; } } return true ; } }
class Solution { public int nextBeautifulNumber ( int n ) { while ( ! isBalance ( ++ n ) ) ; return n ; } private boolean isBalance ( int num ) { int [ ] count = new int [ 10 ] ; while ( num > 0 ) { if ( num % 10 == 0 ) return false ; ++ count [ num % 10 ] ; num /= 10 ; } for ( int i = 1 ; i < 10 ; ++ i ) if ( count [ i ] > 0 && count [ i ] != i ) return false ; return true ; } }
class Solution { public int countHighestScoreNodes ( int [ ] parents ) { List < Integer > [ ] tree = new List [ parents . length ] ; for ( int i = 0 ; i < tree . length ; ++ i ) tree [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < parents . length ; ++ i ) { if ( parents [ i ] == - 1 ) continue ; tree [ parents [ i ] ] . add ( i ) ; } dfs ( tree , 0 ) ; return ans ; } private int ans = 0 ; private long maxScore = 0 ; private int dfs ( List < Integer > [ ] tree , int u ) { int count = 1 ; long score = 1 ; for ( final int v : tree [ u ] ) { final int childCount = dfs ( tree , v ) ; count += childCount ; score *= childCount ; } final int aboveCount = tree . length - count ; score *= Math . max ( aboveCount , 1 ) ; if ( score > maxScore ) { maxScore = score ; ans = 1 ; } else if ( score == maxScore ) { ++ ans ; } return count ; } }
class Solution { public boolean isIsomorphic ( String s , String t ) { Map < Character , Integer > charToIndex_s = new HashMap < > ( ) ; Map < Character , Integer > charToIndex_t = new HashMap < > ( ) ; for ( Integer i = 0 ; i < s . length ( ) ; ++ i ) if ( charToIndex_s . put ( s . charAt ( i ) , i ) != charToIndex_t . put ( t . charAt ( i ) , i ) ) return false ; return true ; } }
class Solution { public int minimumTime ( int n , int [ ] [ ] relations , int [ ] time ) { List < Integer > [ ] graph = new List [ n ] ; int [ ] inDegree = new int [ n ] ; int [ ] dist = time . clone ( ) ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] r : relations ) { final int u = r [ 0 ] - 1 ; final int v = r [ 1 ] - 1 ; graph [ u ] . add ( v ) ; ++ inDegree [ v ] ; } Queue < Integer > q = IntStream . range ( 0 , n ) . filter ( i -> inDegree [ i ] == 0 ) . boxed ( ) . collect ( Collectors . toCollection ( ArrayDeque :: new ) ) ; while ( ! q . isEmpty ( ) ) { final int u = q . poll ( ) ; for ( final int v : graph [ u ] ) { dist [ v ] = Math . max ( dist [ v ] , dist [ u ] + time [ v ] ) ; if ( -- inDegree [ v ] == 0 ) q . offer ( v ) ; } } return Arrays . stream ( dist ) . max ( ) . getAsInt ( ) ; } }
class Solution { public int minimumCost ( String sentence , int k ) { if ( sentence . length ( ) <= k ) return 0 ; String [ ] words = sentence . split ( " ▁ " ) ; int [ ] dp = new int [ words . length + 1 ] ; for ( int i = 1 ; i <= words . length ; ++ i ) { int n = words [ i - 1 ] . length ( ) ; dp [ i ] = dp [ i - 1 ] + ( k - n ) * ( k - n ) ; for ( int j = i - 1 ; j > 0 ; -- j ) { n += words [ j - 1 ] . length ( ) + 1 ; if ( n > k ) break ; dp [ i ] = Math . min ( dp [ i ] , dp [ j - 1 ] + ( k - n ) * ( k - n ) ) ; } } int lastRowLen = words [ words . length - 1 ] . length ( ) ; int i = words . length - 2 ; while ( i > 0 && lastRowLen + words [ i ] . length ( ) + 1 <= k ) lastRowLen += words [ i -- ] . length ( ) ; return Arrays . stream ( dp , i + 1 , words . length ) . min ( ) . getAsInt ( ) ; } }
class Solution { public String kthDistinct ( String [ ] arr , int k ) { Map < String , Integer > count = new HashMap < > ( ) ; for ( final String a : arr ) count . merge ( a , 1 , Integer :: sum ) ; for ( final String a : arr ) if ( count . get ( a ) == 1 && -- k == 0 ) return a ; return " " ; } }
class Event { public int time ; public int value ; public int isStart ; public Event ( int time , int value , int isStart ) { this . time = time ; this . value = value ; this . isStart = isStart ; } } ; class Solution { public int maxTwoEvents ( int [ ] [ ] events ) { int ans = 0 ; int maxValue = 0 ; Event [ ] evts = new Event [ events . length * 2 ] ; for ( int i = 0 ; i < events . length ; ++ i ) { final int start = events [ i ] [ 0 ] ; final int end = events [ i ] [ 1 ] ; final int value = events [ i ] [ 2 ] ; evts [ i * 2 ] = new Event ( start , value , 1 ) ; evts [ i * 2 + 1 ] = new Event ( end + 1 , value , 0 ) ; } Arrays . sort ( evts , ( a , b ) -> a . time == b . time ? a . isStart - b . isStart : a . time - b . time ) ; for ( Event evt : evts ) if ( evt . isStart == 1 ) ans = Math . max ( ans , evt . value + maxValue ) ; else maxValue = Math . max ( maxValue , evt . value ) ; return ans ; } }
class Solution { public int [ ] platesBetweenCandles ( String s , int [ ] [ ] queries ) { int [ ] ans = new int [ queries . length ] ; List < Integer > A = new ArrayList < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( s . charAt ( i ) == ' | ' ) A . add ( i ) ; for ( int i = 0 ; i < queries . length ; ++ i ) { final int left = queries [ i ] [ 0 ] ; final int right = queries [ i ] [ 1 ] ; final int l = firstGreaterEqual ( A , left ) ; final int r = firstGreaterEqual ( A , right + 1 ) - 1 ; if ( l < r ) { final int lengthBetweenCandles = A . get ( r ) - A . get ( l ) + 1 ; final int numCandles = r - l + 1 ; ans [ i ] = lengthBetweenCandles - numCandles ; } } return ans ; } private int firstGreaterEqual ( List < Integer > A , int target ) { int l = 0 ; int r = A . size ( ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A . get ( m ) >= target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public int countCombinations ( String [ ] pieces , int [ ] [ ] positions ) { final int n = pieces . length ; Set < Long > ans = new HashSet < > ( ) ; moves . put ( " rook " , new int [ ] [ ] { { 1 , 0 } , { - 1 , 0 } , { 0 , 1 } , { 0 , - 1 } } ) ; moves . put ( " bishop " , new int [ ] [ ] { { 1 , 1 } , { 1 , - 1 } , { - 1 , 1 } , { - 1 , - 1 } } ) ; moves . put ( " queen " , new int [ ] [ ] { { 1 , 0 } , { - 1 , 0 } , { 0 , 1 } , { 0 , - 1 } , { 1 , 1 } , { 1 , - 1 } , { - 1 , 1 } , { - 1 , - 1 } } ) ; List < List < int [ ] > > combMoves = new ArrayList < > ( ) ; getCombMoves ( pieces , 0 , new ArrayList < > ( ) , combMoves ) ; for ( List < int [ ] > combMove : combMoves ) dfs ( positions , n , combMove , ( 1 << n ) - 1 , ans ) ; return ans . size ( ) ; } private Map < String , int [ ] [ ] > moves = new HashMap < > ( ) ; private void getCombMoves ( String [ ] pieces , int ithPiece , List < int [ ] > path , List < List < int [ ] > > combMoves ) { if ( ithPiece == pieces . length ) { combMoves . add ( new ArrayList < > ( path ) ) ; return ; } for ( int [ ] move : moves . get ( pieces [ ithPiece ] ) ) { path . add ( move ) ; getCombMoves ( pieces , ithPiece + 1 , path , combMoves ) ; path . remove ( path . size ( ) - 1 ) ; } } private void dfs ( int [ ] [ ] board , int n , List < int [ ] > combMove , int activeMask , Set < Long > ans ) { if ( activeMask == 0 ) return ; ans . add ( hash ( board ) ) ; for ( int nextActiveMask = 1 ; nextActiveMask < 1 << n ; ++ nextActiveMask ) { if ( ( activeMask & nextActiveMask ) != nextActiveMask ) continue ; int [ ] [ ] nextBoard = new int [ n ] [ ] ; for ( int i = 0 ; i < n ; ++ i ) nextBoard [ i ] = board [ i ] . clone ( ) ; for ( int i = 0 ; i < n ; ++ i ) if ( ( ( nextActiveMask >> i ) & 1 ) == 1 ) { nextBoard [ i ] [ 0 ] += combMove . get ( i ) [ 0 ] ; nextBoard [ i ] [ 1 ] += combMove . get ( i ) [ 1 ] ; } if ( getUniqueSize ( nextBoard ) < n ) continue ; if ( Arrays . stream ( nextBoard ) . allMatch ( p -> 1 <= p [ 0 ] && p [ 0 ] <= 8 && 1 <= p [ 1 ] && p [ 1 ] <= 8 ) ) dfs ( nextBoard , n , combMove , nextActiveMask , ans ) ; } } private long hash ( int [ ] [ ] board ) { long hashed = 0 ; for ( int [ ] pos : board ) hashed = ( hashed * 64 ) + ( pos [ 0 ] - 1 << 3 ) + ( pos [ 1 ] - 1 ) ; return hashed ; } private int getUniqueSize ( int [ ] [ ] board ) { Set < Integer > unique = new HashSet < > ( ) ; for ( int [ ] pos : board ) unique . add ( pos [ 0 ] * 8 + pos [ 1 ] ) ; return unique . size ( ) ; } }
class Solution { public int smallestEqual ( int [ ] nums ) { for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] == i % 10 ) return i ; return - 1 ; } }
class Solution { public int [ ] nodesBetweenCriticalPoints ( ListNode head ) { int minDistance = Integer . MAX_VALUE ; int firstMaIndex = - 1 ; int prevMaIndex = - 1 ; int index = 1 ; ListNode prev = head ; ListNode curr = head . next ; while ( curr . next != null ) { if ( curr . val > prev . val && curr . val > curr . next . val || curr . val < prev . val && curr . val < curr . next . val ) { if ( firstMaIndex == - 1 ) firstMaIndex = index ; if ( prevMaIndex != - 1 ) minDistance = Math . min ( minDistance , index - prevMaIndex ) ; prevMaIndex = index ; } prev = curr ; curr = curr . next ; ++ index ; } if ( minDistance == Integer . MAX_VALUE ) return new int [ ] { - 1 , - 1 } ; return new int [ ] { minDistance , prevMaIndex - firstMaIndex } ; } }
class Solution { public int minimumOperations ( int [ ] nums , int start , int goal ) { int ans = 0 ; Queue < Integer > q = new ArrayDeque < > ( Arrays . asList ( start ) ) ; boolean [ ] seen = new boolean [ 1001 ] ; seen [ start ] = true ; while ( ! q . isEmpty ( ) ) { ++ ans ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int x = q . poll ( ) ; for ( final int num : nums ) { for ( final int res : new int [ ] { x + num , x - num , x ^ num } ) { if ( res == goal ) return ans ; if ( res < 0 || res > 1000 || seen [ res ] ) continue ; seen [ res ] = true ; q . offer ( res ) ; } } } } return - 1 ; } }
class Solution { public ListNode reverseList ( ListNode head ) { if ( head == null || head . next == null ) return head ; ListNode newHead = reverseList ( head . next ) ; head . next . next = head ; head . next = null ; return newHead ; } }
class Solution { public boolean possiblyEquals ( String s1 , String s2 ) { dp = new Map [ s1 . length ( ) + 1 ] [ s2 . length ( ) + 1 ] ; for ( int i = 0 ; i <= s1 . length ( ) ; ++ i ) for ( int j = 0 ; j <= s2 . length ( ) ; ++ j ) dp [ i ] [ j ] = new HashMap < > ( ) ; return f ( s1 , s2 , 0 , 0 , 0 ) ; } private Map < Integer , Boolean > [ ] [ ] dp ; private boolean f ( final String s1 , final String s2 , int i , int j , int paddingDiff ) { if ( dp [ i ] [ j ] . containsKey ( paddingDiff ) ) return dp [ i ] [ j ] . get ( paddingDiff ) ; if ( i == s1 . length ( ) && j == s2 . length ( ) ) return paddingDiff == 0 ; if ( i < s1 . length ( ) && Character . isDigit ( s1 . charAt ( i ) ) ) { final int nextLetterIndex = getNextLetterIndex ( s1 , i ) ; for ( final int num : getNums ( s1 . substring ( i , nextLetterIndex ) ) ) if ( f ( s1 , s2 , nextLetterIndex , j , paddingDiff + num ) ) return true ; } else if ( j < s2 . length ( ) && Character . isDigit ( s2 . charAt ( j ) ) ) { final int nextLetterIndex = getNextLetterIndex ( s2 , j ) ; for ( final int num : getNums ( s2 . substring ( j , nextLetterIndex ) ) ) if ( f ( s1 , s2 , i , nextLetterIndex , paddingDiff - num ) ) return true ; } else if ( paddingDiff > 0 ) { if ( j < s2 . length ( ) ) return f ( s1 , s2 , i , j + 1 , paddingDiff - 1 ) ; } else if ( paddingDiff < 0 ) { if ( i < s1 . length ( ) ) return f ( s1 , s2 , i + 1 , j , paddingDiff + 1 ) ; } else { if ( i < s1 . length ( ) && j < s2 . length ( ) && s1 . charAt ( i ) == s2 . charAt ( j ) ) return f ( s1 , s2 , i + 1 , j + 1 , 0 ) ; } dp [ i ] [ j ] . put ( paddingDiff , false ) ; return false ; } private int getNextLetterIndex ( final String s , int i ) { int j = i ; while ( j < s . length ( ) && Character . isDigit ( s . charAt ( j ) ) ) ++ j ; return j ; } private List < Integer > getNums ( final String s ) { List < Integer > nums = new ArrayList < > ( Arrays . asList ( Integer . parseInt ( s ) ) ) ; if ( s . length ( ) == 2 ) { nums . add ( Integer . parseInt ( s . substring ( 0 , 1 ) ) + Integer . parseInt ( s . substring ( 1 , 2 ) ) ) ; } else if ( s . length ( ) == 3 ) { nums . add ( Integer . parseInt ( s . substring ( 0 , 1 ) ) + Integer . parseInt ( s . substring ( 1 , 3 ) ) ) ; nums . add ( Integer . parseInt ( s . substring ( 0 , 2 ) ) + Integer . parseInt ( s . substring ( 2 , 3 ) ) ) ; nums . add ( Integer . parseInt ( s . substring ( 0 , 1 ) ) + Integer . parseInt ( s . substring ( 1 , 2 ) ) + Integer . parseInt ( s . substring ( 2 , 3 ) ) ) ; } return nums ; } }
class Solution { public int numberOfCleanRooms ( int [ ] [ ] room ) { final int m = room . length ; final int n = room [ 0 ] . length ; final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; int ans = 1 ; int i = 0 ; int j = 0 ; int state = 0 ; int [ ] [ ] seen = new int [ m ] [ n ] ; seen [ i ] [ j ] |= 1 << state ; room [ i ] [ j ] = 2 ; while ( true ) { final int x = i + dirs [ state ] ; final int y = j + dirs [ state + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n || room [ x ] [ y ] == 1 ) { state = ( state + 1 ) % 4 ; } else { if ( room [ x ] [ y ] == 0 ) { ++ ans ; room [ x ] [ y ] = 2 ; } i = x ; j = y ; } if ( ( ( seen [ i ] [ j ] >> state ) & 1 ) == 1 ) return ans ; seen [ i ] [ j ] |= ( 1 << state ) ; } } }
class Solution { public int countVowelSubstrings ( String word ) { return countVowelSubstringsAtMost ( word , 5 ) - countVowelSubstringsAtMost ( word , 4 ) ; } private int countVowelSubstringsAtMost ( final String s , int goal ) { int ans = 0 ; int k = goal ; int [ ] count = new int [ 26 ] ; for ( int l = 0 , r = 0 ; r < s . length ( ) ; ++ r ) { if ( " aeiou " . indexOf ( s . charAt ( r ) ) == - 1 ) { l = r + 1 ; k = goal ; count = new int [ 26 ] ; continue ; } if ( ++ count [ s . charAt ( r ) - ' a ' ] == 1 ) -- k ; while ( k == - 1 ) if ( -- count [ s . charAt ( l ++ ) - ' a ' ] == 0 ) ++ k ; ans += r - l + 1 ; } return ans ; } }
class Solution { public long countVowels ( String word ) { long [ ] dp = new long [ word . length ( ) + 1 ] ; for ( int i = 1 ; i <= word . length ( ) ; ++ i ) { dp [ i ] = dp [ i - 1 ] ; if ( " aeiou " . indexOf ( word . charAt ( i - 1 ) ) != - 1 ) dp [ i ] += i ; } return Arrays . stream ( dp ) . sum ( ) ; } }
class Solution { public int minimizedMaximum ( int n , int [ ] quantities ) { int l = 1 ; int r = Arrays . stream ( quantities ) . max ( ) . getAsInt ( ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( numOfStores ( quantities , m ) <= n ) r = m ; else l = m + 1 ; } return l ; } private int numOfStores ( int [ ] quantities , int m ) { return Arrays . stream ( quantities ) . reduce ( 0 , ( subtotal , q ) -> subtotal + ( q - 1 ) / m + 1 ) ; } }
class Solution { public int maximalPathQuality ( int [ ] values , int [ ] [ ] edges , int maxTime ) { final int n = values . length ; List < Pair < Integer , Integer > > [ ] graph = new List [ n ] ; int [ ] seen = new int [ n ] ; seen [ 0 ] = 1 ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; final int time = e [ 2 ] ; graph [ u ] . add ( new Pair < > ( v , time ) ) ; graph [ v ] . add ( new Pair < > ( u , time ) ) ; } dfs ( graph , values , 0 , values [ 0 ] , maxTime , seen ) ; return ans ; } private int ans = 0 ; private void dfs ( List < Pair < Integer , Integer > > [ ] graph , int [ ] values , int u , int quality , int remainingTime , int [ ] seen ) { if ( u == 0 ) ans = Math . max ( ans , quality ) ; for ( Pair < Integer , Integer > pair : graph [ u ] ) { final int v = pair . getKey ( ) ; final int time = pair . getValue ( ) ; if ( time > remainingTime ) continue ; final int newQuality = quality + values [ v ] * ( seen [ v ] == 0 ? 1 : 0 ) ; ++ seen [ v ] ; dfs ( graph , values , v , newQuality , remainingTime - time , seen ) ; -- seen [ v ] ; } } }
class Solution { public int equalCountSubstrings ( String s , int count ) { final int maxUnique = s . chars ( ) . mapToObj ( c -> ( char ) c ) . collect ( Collectors . toSet ( ) ) . size ( ) ; int ans = 0 ; for ( int unique = 1 ; unique <= maxUnique ; ++ unique ) { final int windowSize = unique * count ; int [ ] lettersCount = new int [ 26 ] ; int uniqueCount = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( ++ lettersCount [ s . charAt ( i ) - ' a ' ] == count ) ++ uniqueCount ; if ( i >= windowSize && -- lettersCount [ s . charAt ( i - windowSize ) - ' a ' ] == count - 1 ) -- uniqueCount ; ans += uniqueCount == unique ? 1 : 0 ; } } return ans ; } }
class Robot { public Robot ( int width , int height ) { pos . add ( new Pair < > ( new int [ ] { 0 , 0 } , " South " ) ) ; for ( int i = 1 ; i < width ; ++ i ) pos . add ( new Pair < > ( new int [ ] { i , 0 } , " East " ) ) ; for ( int j = 1 ; j < height ; ++ j ) pos . add ( new Pair < > ( new int [ ] { width - 1 , j } , " North " ) ) ; for ( int i = width - 2 ; i >= 0 ; -- i ) pos . add ( new Pair < > ( new int [ ] { i , height - 1 } , " West " ) ) ; for ( int j = height - 2 ; j > 0 ; -- j ) pos . add ( new Pair < > ( new int [ ] { 0 , j } , " South " ) ) ; } public void step ( int num ) { isOrigin = false ; i = ( i + num ) % pos . size ( ) ; } public int [ ] getPos ( ) { return pos . get ( i ) . getKey ( ) ; } public String getDir ( ) { return isOrigin ? " East " : pos . get ( i ) . getValue ( ) ; } private boolean isOrigin = true ; private int i = 0 ; private List < Pair < int [ ] , String > > pos = new ArrayList < > ( ) ; }
enum State { INIT , VISITING , VISITED } class Solution { public boolean canFinish ( int numCourses , int [ ] [ ] prerequisites ) { List < Integer > [ ] graph = new List [ numCourses ] ; State [ ] state = new State [ numCourses ] ; for ( int i = 0 ; i < numCourses ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] p : prerequisites ) graph [ p [ 1 ] ] . add ( p [ 0 ] ) ; for ( int i = 0 ; i < numCourses ; ++ i ) if ( hasCycle ( graph , i , state ) ) return false ; return true ; } private boolean hasCycle ( List < Integer > [ ] graph , int u , State [ ] state ) { if ( state [ u ] == State . VISITING ) return true ; if ( state [ u ] == State . VISITED ) return false ; state [ u ] = State . VISITING ; for ( final int v : graph [ u ] ) if ( hasCycle ( graph , v , state ) ) return true ; state [ u ] = State . VISITED ; return false ; } }
class Solution { public int [ ] maximumBeauty ( int [ ] [ ] items , int [ ] queries ) { int [ ] ans = new int [ queries . length ] ; int [ ] prices = new int [ items . length ] ; int [ ] maxBeautySoFar = new int [ items . length + 1 ] ; Arrays . sort ( items , ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; for ( int i = 0 ; i < items . length ; ++ i ) maxBeautySoFar [ i + 1 ] = Math . max ( maxBeautySoFar [ i ] , items [ i ] [ 1 ] ) ; for ( int i = 0 ; i < queries . length ; ++ i ) { final int index = firstGreater ( items , queries [ i ] ) ; ans [ i ] = maxBeautySoFar [ index ] ; } return ans ; } private int firstGreater ( int [ ] [ ] items , int q ) { int l = 0 ; int r = items . length ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( items [ m ] [ 0 ] > q ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public int maxTaskAssign ( int [ ] tasks , int [ ] workers , int pills , int strength ) { int ans = 0 ; int l = 0 ; int r = Math . min ( tasks . length , workers . length ) ; Arrays . sort ( tasks ) ; Arrays . sort ( workers ) ; while ( l <= r ) { final int m = ( l + r ) / 2 ; if ( canComplete ( tasks , workers , pills , strength , m ) ) { ans = m ; l = m + 1 ; } else { r = m - 1 ; } } return ans ; } private boolean canComplete ( int [ ] tasks , int [ ] workers , int pillsLeft , int strength , int k ) { TreeMap < Integer , Integer > sortedWorkers = new TreeMap < > ( ) ; for ( int i = workers . length - k ; i < workers . length ; ++ i ) sortedWorkers . merge ( workers [ i ] , 1 , Integer :: sum ) ; for ( int i = k - 1 ; i >= 0 ; -- i ) { Integer lo = sortedWorkers . ceilingKey ( tasks [ i ] ) ; if ( lo != null ) { sortedWorkers . merge ( lo , - 1 , Integer :: sum ) ; if ( sortedWorkers . get ( lo ) == 0 ) { sortedWorkers . remove ( lo ) ; } } else if ( pillsLeft > 0 ) { lo = sortedWorkers . ceilingKey ( tasks [ i ] - strength ) ; if ( lo != null ) { sortedWorkers . merge ( lo , - 1 , Integer :: sum ) ; if ( sortedWorkers . get ( lo ) == 0 ) { sortedWorkers . remove ( lo ) ; } -- pillsLeft ; } else { return false ; } } else { return false ; } } return true ; } }
class Solution { public int timeRequiredToBuy ( int [ ] tickets , int k ) { int ans = 0 ; for ( int i = 0 ; i < tickets . length ; ++ i ) if ( i <= k ) ans += Math . min ( tickets [ i ] , tickets [ k ] ) ; else ans += Math . min ( tickets [ i ] , tickets [ k ] - 1 ) ; return ans ; } }
class Solution { public ListNode reverseEvenLengthGroups ( ListNode head ) { ListNode dummy = new ListNode ( 0 , head ) ; ListNode prev = dummy ; ListNode tail = head ; ListNode next = head . next ; int groupLength = 1 ; while ( true ) { if ( ( groupLength & 1 ) == 1 ) { prev . next = head ; prev = tail ; } else { tail . next = null ; prev . next = reverse ( head ) ; head . next = next ; prev = head ; } if ( next == null ) break ; head = next ; Pair < ListNode , Integer > res = getTailAndLength ( head , groupLength + 1 ) ; tail = res . getKey ( ) ; next = tail . next ; groupLength = res . getValue ( ) ; } return dummy . next ; } private Pair < ListNode , Integer > getTailAndLength ( ListNode head , int groupLength ) { int length = 1 ; ListNode tail = head ; while ( length < groupLength && tail . next != null ) { tail = tail . next ; ++ length ; } return new Pair < > ( tail , length ) ; } ListNode reverse ( ListNode head ) { ListNode prev = null ; while ( head != null ) { ListNode next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } }
class UnionFind { public UnionFind ( int n ) { id = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) id [ i ] = i ; } public void union ( int u , int v ) { id [ u ] = v ; } public int find ( int u ) { return id [ u ] == u ? u : ( id [ u ] = find ( id [ u ] ) ) ; } private int [ ] id ; } class Solution { public boolean [ ] friendRequests ( int n , int [ ] [ ] restrictions , int [ ] [ ] requests ) { boolean [ ] ans = new boolean [ requests . length ] ; UnionFind uf = new UnionFind ( n ) ; for ( int i = 0 ; i < requests . length ; ++ i ) { final int pu = uf . find ( requests [ i ] [ 0 ] ) ; final int pv = uf . find ( requests [ i ] [ 1 ] ) ; boolean isValid = true ; if ( pu != pv ) for ( int [ ] restriction : restrictions ) { final int px = uf . find ( restriction [ 0 ] ) ; final int py = uf . find ( restriction [ 1 ] ) ; if ( pu == px && pv == py || pu == py && pv == px ) { isValid = false ; break ; } } ans [ i ] = isValid ; if ( isValid ) uf . union ( pu , pv ) ; } return ans ; } }
class TrieNode { public TrieNode [ ] children = new TrieNode [ 26 ] ; public boolean isWord = false ; } class Trie { public void insert ( String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ( ) ) { final int i = c - ' a ' ; if ( node . children [ i ] == null ) node . children [ i ] = new TrieNode ( ) ; node = node . children [ i ] ; } node . isWord = true ; } public boolean search ( String word ) { TrieNode node = find ( word ) ; return node != null && node . isWord ; } public boolean startsWith ( String prefix ) { return find ( prefix ) != null ; } private TrieNode root = new TrieNode ( ) ; private TrieNode find ( String prefix ) { TrieNode node = root ; for ( final char c : prefix . toCharArray ( ) ) { final int i = c - ' a ' ; if ( node . children [ i ] == null ) return null ; node = node . children [ i ] ; } return node ; } }
class Solution { public long numberOfSubstrings ( String s ) { long ans = 0 ; int [ ] count = new int [ 128 ] ; for ( final char c : s . toCharArray ( ) ) { ans += count [ c ] + 1 ; ++ count [ c ] ; } return ans ; } }
class Solution { public int countWords ( String [ ] words1 , String [ ] words2 ) { Map < String , Integer > count = new HashMap < > ( ) ; for ( final String word : words1 ) count . merge ( word , 1 , Integer :: sum ) ; for ( final String word : words2 ) if ( count . containsKey ( word ) && count . get ( word ) < 2 ) count . merge ( word , - 1 , Integer :: sum ) ; return ( int ) count . values ( ) . stream ( ) . filter ( v -> v == 0 ) . count ( ) ; } }
class Solution { public int minimumBuckets ( String street ) { final char [ ] A = street . toCharArray ( ) ; for ( int i = 0 ; i < A . length ; ++ i ) if ( A [ i ] == ' H ' ) { if ( i > 0 && A [ i - 1 ] == ' B ' ) continue ; if ( i + 1 < A . length && A [ i + 1 ] == ' . ' ) A [ i + 1 ] = ' B ' ; else if ( i > 0 && A [ i - 1 ] == ' . ' ) A [ i - 1 ] = ' B ' ; else return - 1 ; } return ( int ) new String ( A ) . chars ( ) . filter ( a -> a == ' B ' ) . count ( ) ; } }
class Solution { public int minCost ( int [ ] startPos , int [ ] homePos , int [ ] rowCosts , int [ ] colCosts ) { int ans = 0 ; int i = startPos [ 0 ] ; int j = startPos [ 1 ] ; int x = homePos [ 0 ] ; int y = homePos [ 1 ] ; while ( i != x ) ans += i < x ? rowCosts [ ++ i ] : rowCosts [ -- i ] ; while ( j != y ) ans += j < y ? colCosts [ ++ j ] : colCosts [ -- j ] ; return ans ; } }
class Solution { public int countPyramids ( int [ ] [ ] grid ) { return count ( reversed ( grid ) ) + count ( grid ) ; } private int count ( int [ ] [ ] dp ) { int ans = 0 ; for ( int i = dp . length - 2 ; i >= 0 ; -- i ) for ( int j = 1 ; j + 1 < dp [ 0 ] . length ; ++ j ) if ( dp [ i ] [ j ] == 1 ) { dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ j - 1 ] , Math . min ( dp [ i + 1 ] [ j ] , dp [ i + 1 ] [ j + 1 ] ) ) + 1 ; ans += dp [ i ] [ j ] - 1 ; } return ans ; } private int [ ] [ ] reversed ( int [ ] [ ] grid ) { int [ ] [ ] A = new int [ grid . length ] [ ] ; for ( int i = 0 ; i < grid . length ; ++ i ) A [ i ] = grid [ grid . length - i - 1 ] . clone ( ) ; return A ; } }
class Solution { public List < Integer > targetIndices ( int [ ] nums , int target ) { List < Integer > ans = new ArrayList < > ( ) ; final int count = ( int ) Arrays . stream ( nums ) . filter ( num -> num == target ) . count ( ) ; int lessThan = ( int ) Arrays . stream ( nums ) . filter ( num -> num < target ) . count ( ) ; for ( int i = 0 ; i < count ; ++ i ) ans . add ( lessThan ++ ) ; return ans ; } }
class Solution { public int minSubArrayLen ( int s , int [ ] nums ) { int ans = Integer . MAX_VALUE ; int sum = 0 ; for ( int l = 0 , r = 0 ; r < nums . length ; ++ r ) { sum += nums [ r ] ; while ( sum >= s ) { ans = Math . min ( ans , r - l + 1 ) ; sum -= nums [ l ++ ] ; } } return ans != Integer . MAX_VALUE ? ans : 0 ; } }
class Solution { public int [ ] getAverages ( int [ ] nums , int k ) { final int n = nums . length ; final int size = 2 * k + 1 ; int [ ] ans = new int [ n ] ; Arrays . fill ( ans , - 1 ) ; if ( size > n ) return ans ; long sum = 0 ; for ( int i = 0 ; i < size ; ++ i ) sum += nums [ i ] ; for ( int i = k ; i + k < n ; ++ i ) { ans [ i ] = ( int ) ( sum / size ) ; if ( i + k + 1 < n ) sum += nums [ i + k + 1 ] - nums [ i - k ] ; } return ans ; } }
class Solution { public int minimumDeletions ( int [ ] nums ) { final int n = nums . length ; int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; int minIndex = - 1 ; int maxIndex = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( nums [ i ] < min ) { min = nums [ i ] ; minIndex = i ; } if ( nums [ i ] > max ) { max = nums [ i ] ; maxIndex = i ; } } final int a = Math . min ( minIndex , maxIndex ) ; final int b = Math . max ( minIndex , maxIndex ) ; return Math . min ( a + 1 + n - b , Math . min ( b + 1 , n - a ) ) ; } }
class UnionFind { public UnionFind ( int n ) { id = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) id [ i ] = i ; } public void union ( int u , int v ) { id [ find ( u ) ] = id [ find ( v ) ] ; } public boolean connected ( int u , int v ) { return find ( u ) == find ( v ) ; } public void reset ( int u ) { id [ u ] = u ; } private int [ ] id ; private int find ( int u ) { return id [ u ] == u ? u : ( id [ u ] = find ( id [ u ] ) ) ; } } class Solution { public List < Integer > findAllPeople ( int n , int [ ] [ ] meetings , int firstPerson ) { List < Integer > ans = new ArrayList < > ( ) ; UnionFind uf = new UnionFind ( n ) ; TreeMap < Integer , List < Pair < Integer , Integer > > > timeToPairs = new TreeMap < > ( ) ; uf . union ( 0 , firstPerson ) ; for ( int [ ] m : meetings ) { timeToPairs . putIfAbsent ( m [ 2 ] , new ArrayList < > ( ) ) ; timeToPairs . get ( m [ 2 ] ) . add ( new Pair < > ( m [ 0 ] , m [ 1 ] ) ) ; } for ( List < Pair < Integer , Integer > > pairs : timeToPairs . values ( ) ) { Set < Integer > peopleUnioned = new HashSet < > ( ) ; for ( Pair < Integer , Integer > pair : pairs ) { final int x = pair . getKey ( ) ; final int y = pair . getValue ( ) ; uf . union ( x , y ) ; peopleUnioned . add ( x ) ; peopleUnioned . add ( y ) ; } for ( final int person : peopleUnioned ) if ( ! uf . connected ( person , 0 ) ) uf . reset ( person ) ; } for ( int i = 0 ; i < n ; ++ i ) if ( uf . connected ( i , 0 ) ) ans . add ( i ) ; return ans ; } }
class T { public int u ; public int d ; public int leftDiscounts ; public T ( int u , int d , int leftDiscounts ) { this . u = u ; this . d = d ; this . leftDiscounts = leftDiscounts ; } } class Solution { public int minimumCost ( int n , int [ ] [ ] highways , int discounts ) { List < Pair < Integer , Integer > > [ ] graph = new List [ n ] ; Queue < T > minHeap = new PriorityQueue < > ( ( a , b ) -> a . d - b . d ) ; Map < Integer , Integer > minDiscounts = new HashMap < > ( ) ; for ( int i = 0 ; i < graph . length ; i ++ ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] h : highways ) { final int city1 = h [ 0 ] ; final int city2 = h [ 1 ] ; final int toll = h [ 2 ] ; graph [ city1 ] . add ( new Pair < > ( city2 , toll ) ) ; graph [ city2 ] . add ( new Pair < > ( city1 , toll ) ) ; } minHeap . offer ( new T ( 0 , 0 , discounts ) ) ; while ( ! minHeap . isEmpty ( ) ) { final int u = minHeap . peek ( ) . u ; final int d = minHeap . peek ( ) . d ; final int leftDiscounts = minHeap . poll ( ) . leftDiscounts ; if ( u == n - 1 ) return d ; if ( minDiscounts . getOrDefault ( u , - 1 ) >= leftDiscounts ) continue ; minDiscounts . put ( u , leftDiscounts ) ; for ( Pair < Integer , Integer > pair : graph [ u ] ) { final int v = pair . getKey ( ) ; final int w = pair . getValue ( ) ; minHeap . offer ( new T ( v , d + w , leftDiscounts ) ) ; if ( leftDiscounts > 0 ) minHeap . offer ( new T ( v , d + w / 2 , leftDiscounts - 1 ) ) ; } } return - 1 ; } }
class Solution { public int [ ] findEvenNumbers ( int [ ] digits ) { List < Integer > ans = new ArrayList < > ( ) ; int [ ] count = new int [ 10 ] ; for ( final int digit : digits ) ++ count [ digit ] ; for ( int a = 1 ; a <= 9 ; ++ a ) for ( int b = 0 ; b <= 9 ; ++ b ) for ( int c = 0 ; c <= 8 ; c += 2 ) if ( count [ a ] > 0 && count [ b ] > ( b == a ? 1 : 0 ) && count [ c ] > ( c == a ? 1 : 0 ) + ( c == b ? 1 : 0 ) ) ans . add ( a * 100 + b * 10 + c ) ; return ans . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; } }
class Solution { public ListNode deleteMiddle ( ListNode head ) { ListNode dummy = new ListNode ( 0 , head ) ; ListNode slow = dummy ; ListNode fast = dummy ; while ( fast . next != null && fast . next . next != null ) { slow = slow . next ; fast = fast . next . next ; } slow . next = slow . next . next ; return dummy . next ; } }
class Solution { public String getDirections ( TreeNode root , int startValue , int destValue ) { dfs ( lca ( root , startValue , destValue ) , startValue , destValue , new StringBuilder ( ) ) ; return " U " . repeat ( pathToStart . length ( ) ) + pathToDest ; } private String pathToStart = " " ; private String pathToDest = " " ; private TreeNode lca ( TreeNode root , int p , int q ) { if ( root == null || root . val == p || root . val == q ) return root ; TreeNode l = lca ( root . left , p , q ) ; TreeNode r = lca ( root . right , p , q ) ; if ( l != null && r != null ) return root ; return l == null ? r : l ; } private void dfs ( TreeNode root , int p , int q , StringBuilder path ) { if ( root == null ) return ; if ( root . val == p ) pathToStart = path . toString ( ) ; if ( root . val == q ) pathToDest = path . toString ( ) ; dfs ( root . left , p , q , path . append ( ' L ' ) ) ; path . deleteCharAt ( path . length ( ) - 1 ) ; dfs ( root . right , p , q , path . append ( ' R ' ) ) ; path . deleteCharAt ( path . length ( ) - 1 ) ; } }
class Solution { public int [ ] [ ] validArrangement ( int [ ] [ ] pairs ) { List < int [ ] > ans = new ArrayList < > ( ) ; Map < Integer , Deque < Integer > > graph = new HashMap < > ( ) ; Map < Integer , Integer > outDegree = new HashMap < > ( ) ; Map < Integer , Integer > inDegree = new HashMap < > ( ) ; for ( int [ ] pair : pairs ) { final int start = pair [ 0 ] ; final int end = pair [ 1 ] ; graph . putIfAbsent ( start , new ArrayDeque < > ( ) ) ; graph . get ( start ) . push ( end ) ; outDegree . merge ( start , 1 , Integer :: sum ) ; inDegree . merge ( end , 1 , Integer :: sum ) ; } final int startNode = getStartNode ( graph , outDegree , inDegree , pairs ) ; euler ( graph , startNode , ans ) ; Collections . reverse ( ans ) ; return ans . toArray ( new int [ ans . size ( ) ] [ ] ) ; } private int getStartNode ( Map < Integer , Deque < Integer > > graph , Map < Integer , Integer > outDegree , Map < Integer , Integer > inDegree , int [ ] [ ] pairs ) { for ( final int u : graph . keySet ( ) ) if ( outDegree . getOrDefault ( u , 0 ) - inDegree . getOrDefault ( u , 0 ) == 1 ) return u ; return pairs [ 0 ] [ 0 ] ; } private void euler ( Map < Integer , Deque < Integer > > graph , int u , List < int [ ] > ans ) { Deque < Integer > stack = graph . get ( u ) ; while ( stack != null && ! stack . isEmpty ( ) ) { final int v = stack . pop ( ) ; euler ( graph , v , ans ) ; ans . add ( new int [ ] { u , v } ) ; } } }
class Solution { public long largestEvenSum ( int [ ] nums , int k ) { Arrays . sort ( nums ) ; long sum = 0 ; int minOdd = - 1 ; int minEven = - 1 ; int maxOdd = - 1 ; int maxEven = - 1 ; for ( int i = nums . length - 1 ; i + k >= nums . length ; -- i ) { sum += nums [ i ] ; if ( ( nums [ i ] & 1 ) == 1 ) minOdd = nums [ i ] ; else minEven = nums [ i ] ; } if ( sum % 2 == 0 ) return sum ; for ( int i = 0 ; i + k < nums . length ; ++ i ) if ( ( nums [ i ] & 1 ) == 1 ) maxOdd = nums [ i ] ; else maxEven = nums [ i ] ; long ans = - 1 ; if ( maxEven >= 0 && minOdd >= 0 ) ans = Math . max ( ans , sum + maxEven - minOdd ) ; if ( maxOdd >= 0 && minEven >= 0 ) ans = Math . max ( ans , sum + maxOdd - minEven ) ; return ans ; } }
class Solution { public int [ ] maxSubsequence ( int [ ] nums , int k ) { int [ ] ans = new int [ k ] ; int [ ] A = nums . clone ( ) ; Arrays . sort ( A ) ; final int threshold = A [ A . length - k ] ; final int larger = ( int ) Arrays . stream ( nums ) . filter ( num -> num > threshold ) . count ( ) ; int equal = k - larger ; int i = 0 ; for ( final int num : nums ) if ( num > threshold ) { ans [ i ++ ] = num ; } else if ( num == threshold && equal > 0 ) { ans [ i ++ ] = num ; -- equal ; } return ans ; } }
class Solution { public ListNode mergeTwoLists ( ListNode list1 , ListNode list2 ) { if ( list1 == null || list2 == null ) return list1 == null ? list2 : list1 ; if ( list1 . val > list2 . val ) { ListNode temp = list1 ; list1 = list2 ; list2 = temp ; } list1 . next = mergeTwoLists ( list1 . next , list2 ) ; return list1 ; } }
enum State { INIT , VISITING , VISITED } class Solution { public int [ ] findOrder ( int numCourses , int [ ] [ ] prerequisites ) { Deque < Integer > ans = new ArrayDeque < > ( ) ; List < Integer > [ ] graph = new List [ numCourses ] ; State [ ] state = new State [ numCourses ] ; for ( int i = 0 ; i < numCourses ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] p : prerequisites ) graph [ p [ 1 ] ] . add ( p [ 0 ] ) ; for ( int i = 0 ; i < numCourses ; ++ i ) if ( hasCycle ( graph , i , state , ans ) ) return new int [ ] { } ; return ans . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; } private boolean hasCycle ( List < Integer > [ ] graph , int u , State [ ] state , Deque < Integer > ans ) { if ( state [ u ] == State . VISITING ) return true ; if ( state [ u ] == State . VISITED ) return false ; state [ u ] = State . VISITING ; for ( final int v : graph [ u ] ) if ( hasCycle ( graph , v , state , ans ) ) return true ; state [ u ] = State . VISITED ; ans . addFirst ( u ) ; return false ; } }
class Solution { public List < Integer > goodDaysToRobBank ( int [ ] security , int time ) { final int n = security . length ; List < Integer > ans = new ArrayList < > ( ) ; int [ ] dec = new int [ n ] ; int [ ] inc = new int [ n ] ; for ( int i = 1 ; i < n ; ++ i ) if ( security [ i - 1 ] >= security [ i ] ) dec [ i ] = dec [ i - 1 ] + 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) if ( security [ i ] <= security [ i + 1 ] ) inc [ i ] = inc [ i + 1 ] + 1 ; for ( int i = 0 ; i < n ; ++ i ) if ( dec [ i ] >= time && inc [ i ] >= time ) ans . add ( i ) ; return ans ; } }
class Solution { public int maximumDetonation ( int [ ] [ ] bombs ) { final int n = bombs . length ; int ans = 0 ; List < Integer > [ ] graph = new List [ n ] ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( i == j ) continue ; final long ri = bombs [ i ] [ 2 ] ; if ( ri * ri >= squaredDist ( bombs , i , j ) ) graph [ i ] . add ( j ) ; } } for ( int i = 0 ; i < n ; ++ i ) { Set < Integer > seen = new HashSet < > ( Arrays . asList ( i ) ) ; dfs ( graph , i , seen ) ; ans = Math . max ( ans , seen . size ( ) ) ; } return ans ; } private void dfs ( List < Integer > [ ] graph , int u , Set < Integer > seen ) { for ( final int v : graph [ u ] ) { if ( seen . contains ( v ) ) continue ; seen . add ( v ) ; dfs ( graph , v , seen ) ; } } private long squaredDist ( int [ ] [ ] bombs , int i , int j ) { return ( long ) ( bombs [ i ] [ 0 ] - bombs [ j ] [ 0 ] ) * ( bombs [ i ] [ 0 ] - bombs [ j ] [ 0 ] ) + ( long ) ( bombs [ i ] [ 1 ] - bombs [ j ] [ 1 ] ) * ( bombs [ i ] [ 1 ] - bombs [ j ] [ 1 ] ) ; } ; }
class Location { public String name ; public int score ; public Location ( String name , int score ) { this . name = name ; this . score = score ; } } class SORTracker { public void add ( String name , int score ) { l . offer ( new Location ( name , score ) ) ; if ( l . size ( ) > k + 1 ) r . offer ( l . poll ( ) ) ; } public String get ( ) { final String name = l . peek ( ) . name ; if ( ! r . isEmpty ( ) ) l . offer ( r . poll ( ) ) ; ++ k ; return name ; } private Queue < Location > l = new PriorityQueue < > ( ( a , b ) -> a . score == b . score ? - a . name . compareTo ( b . name ) : a . score - b . score ) ; private Queue < Location > r = new PriorityQueue < > ( ( a , b ) -> a . score == b . score ? a . name . compareTo ( b . name ) : b . score - a . score ) ; private int k ; }
class Solution { public int countPoints ( String rings ) { int [ ] colors = new int [ 10 ] ; for ( int i = 0 ; i < rings . length ( ) ; i += 2 ) { final char c = rings . charAt ( i ) ; final int color = c == ' R ' ? 1 : c == ' G ' ? 2 : 4 ; colors [ rings . charAt ( i + 1 ) - '0' ] |= color ; } return ( int ) Arrays . stream ( colors ) . filter ( c -> c == 7 ) . count ( ) ; } }
class Solution { public long subArrayRanges ( int [ ] nums ) { return subarraySum ( nums , ' < ' ) - subarraySum ( nums , ' > ' ) ; } private long subarraySum ( int [ ] A , char op ) { final int n = A . length ; long ans = 0 ; int [ ] prev = new int [ n ] ; int [ ] next = new int [ n ] ; Deque < Integer > stack = new ArrayDeque < > ( ) ; Arrays . fill ( prev , - 1 ) ; Arrays . fill ( next , n ) ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! stack . isEmpty ( ) && func ( op , A [ stack . peek ( ) ] , A [ i ] ) ) { final int index = stack . pop ( ) ; next [ index ] = i ; } if ( ! stack . isEmpty ( ) ) prev [ i ] = stack . peek ( ) ; stack . push ( i ) ; } for ( int i = 0 ; i < n ; ++ i ) ans += ( long ) A [ i ] * ( i - prev [ i ] ) * ( next [ i ] - i ) ; return ans ; } private boolean func ( char op , int a , int b ) { if ( op == ' < ' ) return a < b ; return a > b ; } }
class Solution { public int minimumRefill ( int [ ] plants , int capacityA , int capacityB ) { int ans = 0 ; int i = 0 ; int j = plants . length - 1 ; int canA = capacityA ; int canB = capacityB ; while ( i < j ) { ans += ( canA < plants [ i ] ? 1 : 0 ) + ( canB < plants [ j ] ? 1 : 0 ) ; if ( canA < plants [ i ] ) canA = capacityA ; if ( canB < plants [ j ] ) canB = capacityB ; canA -= plants [ i ++ ] ; canB -= plants [ j -- ] ; } return ans + ( i == j && Math . max ( canA , canB ) < plants [ i ] ? 1 : 0 ) ; } }
class Solution { public int maxTotalFruits ( int [ ] [ ] fruits , int startPos , int k ) { final int maxRight = Math . max ( startPos , fruits [ fruits . length - 1 ] [ 0 ] ) ; int ans = 0 ; int [ ] amounts = new int [ 1 + maxRight ] ; int [ ] prefix = new int [ 2 + maxRight ] ; for ( int [ ] f : fruits ) amounts [ f [ 0 ] ] = f [ 1 ] ; for ( int i = 0 ; i + 1 < prefix . length ; ++ i ) prefix [ i + 1 ] = prefix [ i ] + amounts [ i ] ; final int maxRightSteps = Math . min ( maxRight - startPos , k ) ; for ( int rightSteps = 0 ; rightSteps <= maxRightSteps ; ++ rightSteps ) { final int leftSteps = Math . max ( 0 , k - 2 * rightSteps ) ; ans = Math . max ( ans , getFruits ( startPos , maxRight , leftSteps , rightSteps , prefix ) ) ; } final int maxLeftSteps = Math . min ( startPos , k ) ; for ( int leftSteps = 0 ; leftSteps <= maxLeftSteps ; ++ leftSteps ) { final int rightSteps = Math . max ( 0 , k - 2 * leftSteps ) ; ans = Math . max ( ans , getFruits ( startPos , maxRight , leftSteps , rightSteps , prefix ) ) ; } return ans ; } private int getFruits ( int startPos , int maxRight , int leftSteps , int rightSteps , int [ ] prefix ) { final int l = Math . max ( 0 , startPos - leftSteps ) ; final int r = Math . min ( maxRight , startPos + rightSteps ) ; return prefix [ r + 1 ] - prefix [ l ] ; } }
class Solution { public String firstPalindrome ( String [ ] words ) { for ( final String word : words ) if ( isPalindrome ( word ) ) return word ; return " " ; } private boolean isPalindrome ( final String s ) { int i = 0 ; int j = 0 ; while ( i < j ) if ( s . charAt ( i ++ ) != s . charAt ( j -- ) ) return false ; return true ; } }
class Solution { public String addSpaces ( String s , int [ ] spaces ) { StringBuilder sb = new StringBuilder ( ) ; int j = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( j < spaces . length && i == spaces [ j ] ) { sb . append ( ' ▁ ' ) ; ++ j ; } sb . append ( s . charAt ( i ) ) ; } return sb . toString ( ) ; } }
class TrieNode { public TrieNode [ ] children = new TrieNode [ 26 ] ; public boolean isWord = false ; } class WordDictionary { public void addWord ( String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ( ) ) { final int i = c - ' a ' ; if ( node . children [ i ] == null ) node . children [ i ] = new TrieNode ( ) ; node = node . children [ i ] ; } node . isWord = true ; } public boolean search ( String word ) { return dfs ( word , 0 , root ) ; } private TrieNode root = new TrieNode ( ) ; private boolean dfs ( String word , int s , TrieNode node ) { if ( s == word . length ( ) ) return node . isWord ; if ( word . charAt ( s ) != ' . ' ) { TrieNode next = node . children [ word . charAt ( s ) - ' a ' ] ; return next == null ? false : dfs ( word , s + 1 , next ) ; } for ( int i = 0 ; i < 26 ; ++ i ) if ( node . children [ i ] != null && dfs ( word , s + 1 , node . children [ i ] ) ) return true ; return false ; } }
class Solution { public long getDescentPeriods ( int [ ] prices ) { long ans = 1 ; int dp = 1 ; for ( int i = 1 ; i < prices . size ( ) ; ++ i ) { if ( prices [ i ] == prices [ i - 1 ] - 1 ) { ++ dp ; } else { dp = 1 ; } ans += dp ; } return ans ; } }
class Solution { public int kIncreasing ( int [ ] arr , int k ) { int ans = 0 ; for ( int i = 0 ; i < k ; ++ i ) { List < Integer > A = new ArrayList < > ( ) ; for ( int j = i ; j < arr . length ; j += k ) A . add ( arr [ j ] ) ; ans += numReplaced ( A ) ; } return ans ; } private int numReplaced ( List < Integer > A ) { List < Integer > tail = new ArrayList < > ( ) ; for ( final int a : A ) if ( tail . isEmpty ( ) || tail . get ( tail . size ( ) - 1 ) <= a ) tail . add ( a ) ; else tail . set ( firstGreater ( tail , a ) , a ) ; return A . size ( ) - tail . size ( ) ; } private int firstGreater ( List < Integer > tail , int target ) { int l = 0 ; int r = tail . size ( ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( tail . get ( m ) > target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public int [ ] elementInNums ( int [ ] nums , int [ ] [ ] queries ) { int [ ] ans = new int [ queries . length ] ; for ( int i = 0 ; i < queries . length ; ++ i ) { final int time = queries [ i ] [ 0 ] ; final int index = queries [ i ] [ 1 ] ; ans [ i ] = f ( nums , time % ( 2 * nums . length ) , index ) ; } return ans ; } private int f ( int [ ] A , int time , int index ) { final int n = A . length ; if ( time < n ) { index += time ; return index >= n ? - 1 : A [ index ] ; } else { return index >= time - n ? - 1 : A [ index ] ; } } }
class Solution { public int mostWordsFound ( String [ ] sentences ) { return 1 + Stream . of ( sentences ) . mapToInt ( s -> ( int ) s . chars ( ) . filter ( c -> c == ' ▁ ' ) . count ( ) ) . max ( ) . getAsInt ( ) ; } }
class Solution { public List < String > findAllRecipes ( String [ ] recipes , List < List < String > > ingredients , String [ ] supplies ) { List < String > ans = new ArrayList < > ( ) ; Set < String > suppliesSet = new HashSet < > ( ) ; for ( final String supply : supplies ) suppliesSet . add ( supply ) ; Map < String , List < String > > graph = new HashMap < > ( ) ; Map < String , Integer > inDegree = new HashMap < > ( ) ; for ( int i = 0 ; i < recipes . length ; ++ i ) for ( final String ingredient : ingredients . get ( i ) ) if ( ! suppliesSet . contains ( ingredient ) ) { graph . putIfAbsent ( ingredient , new ArrayList < > ( ) ) ; graph . get ( ingredient ) . add ( recipes [ i ] ) ; inDegree . merge ( recipes [ i ] , 1 , Integer :: sum ) ; } Queue < String > q = Arrays . stream ( recipes ) . filter ( recipe -> inDegree . getOrDefault ( recipe , 0 ) == 0 ) . collect ( Collectors . toCollection ( ArrayDeque :: new ) ) ; while ( ! q . isEmpty ( ) ) { final String u = q . poll ( ) ; ans . add ( u ) ; if ( ! graph . containsKey ( u ) ) continue ; for ( final String v : graph . get ( u ) ) { inDegree . merge ( v , - 1 , Integer :: sum ) ; if ( inDegree . get ( v ) == 0 ) q . offer ( v ) ; } } return ans ; } }
class Solution { public boolean canBeValid ( String s , String locked ) { if ( s . length ( ) % 2 == 1 ) return false ; return check ( s , locked , true ) && check ( new StringBuilder ( s ) . reverse ( ) . toString ( ) , new StringBuilder ( locked ) . reverse ( ) . toString ( ) , false ) ; } private boolean check ( final String s , final String locked , boolean isForward ) { int changeable = 0 ; int l = 0 ; int r = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { final char c = s . charAt ( i ) ; final char lock = locked . charAt ( i ) ; if ( lock == '0' ) ++ changeable ; else if ( c == ' ( ' ) ++ l ; else ++ r ; if ( isForward && changeable + l - r < 0 ) return false ; if ( ! isForward && changeable + r - l < 0 ) return false ; } return true ; } }
class Solution { public String abbreviateProduct ( int left , int right ) { final long maxSuf = 100000000000L ; double prod = 1.0 ; long suf = 1 ; int countDigits = 0 ; int countZeros = 0 ; for ( int num = left ; num <= right ; ++ num ) { prod *= num ; while ( prod >= 1.0 ) { prod /= 10 ; ++ countDigits ; } suf *= num ; while ( suf % 10 == 0 ) { suf /= 10 ; ++ countZeros ; } if ( suf > maxSuf ) suf %= maxSuf ; } if ( countDigits - countZeros <= 10 ) { final long tens = ( long ) Math . pow ( 10 , countDigits - countZeros ) ; return String . valueOf ( ( long ) ( prod * tens + 0.5 ) ) + " e " + String . valueOf ( countZeros ) ; } final String pre = String . valueOf ( ( long ) ( prd * Math . pow ( 10 , 5 ) ) ) ; String sufStr = String . valueOf ( suf ) ; sufStr = sufStr . substring ( sufStr . length ( ) - 5 ) ; return pre + " . . . " + sufStr + " e " + String . valueOf ( countZeros ) ; } }
class Solution { public boolean isSameAfterReversals ( int num ) { final int reversed1 = getReversed ( num ) ; final int reversed2 = getReversed ( reversed1 ) ; return reversed2 == num ; } private int getReversed ( int num ) { int reversed = 0 ; while ( num > 0 ) { reversed = reversed * 10 + num % 10 ; num /= 10 ; } return reversed ; } }
class TrieNode { public TrieNode [ ] children = new TrieNode [ 26 ] ; public String word ; } class Solution { public List < String > findWords ( char [ ] [ ] board , String [ ] words ) { for ( final String word : words ) insert ( word ) ; List < String > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i < board . length ; ++ i ) for ( int j = 0 ; j < board [ 0 ] . length ; ++ j ) dfs ( board , i , j , root , ans ) ; return ans ; } private TrieNode root = new TrieNode ( ) ; private void insert ( final String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ( ) ) { final int i = c - ' a ' ; if ( node . children [ i ] == null ) node . children [ i ] = new TrieNode ( ) ; node = node . children [ i ] ; } node . word = word ; } private void dfs ( char [ ] [ ] board , int i , int j , TrieNode node , List < String > ans ) { if ( i < 0 || i == board . length || j < 0 || j == board [ 0 ] . length ) return ; if ( board [ i ] [ j ] == ' * ' ) return ; final char c = board [ i ] [ j ] ; TrieNode child = node . children [ c - ' a ' ] ; if ( child == null ) return ; if ( child . word != null ) { ans . add ( child . word ) ; child . word = null ; } board [ i ] [ j ] = ' * ' ; dfs ( board , i + 1 , j , child , ans ) ; dfs ( board , i - 1 , j , child , ans ) ; dfs ( board , i , j + 1 , child , ans ) ; dfs ( board , i , j - 1 , child , ans ) ; board [ i ] [ j ] = c ; } }
class Solution { public int [ ] executeInstructions ( int n , int [ ] startPos , String s ) { final int m = s . length ( ) ; final int uMost = startPos [ 0 ] + 1 ; final int dMost = n - startPos [ 0 ] ; final int lMost = startPos [ 1 ] + 1 ; final int rMost = n - startPos [ 1 ] ; Map < Character , Pair < Integer , Integer > > moves = new HashMap < > ( ) ; moves . put ( ' L ' , new Pair < > ( 0 , - 1 ) ) ; moves . put ( ' R ' , new Pair < > ( 0 , 1 ) ) ; moves . put ( ' U ' , new Pair < > ( - 1 , 0 ) ) ; moves . put ( ' D ' , new Pair < > ( 1 , 0 ) ) ; int [ ] ans = new int [ m ] ; Map < Integer , Integer > reachX = new HashMap < > ( ) ; Map < Integer , Integer > reachY = new HashMap < > ( ) ; reachX . put ( 0 , m ) ; reachY . put ( 0 , m ) ; int x = 0 ; int y = 0 ; for ( int i = m - 1 ; i >= 0 ; -- i ) { Pair < Integer , Integer > pair = moves . get ( s . charAt ( i ) ) ; final int dx = pair . getKey ( ) ; final int dy = pair . getValue ( ) ; x -= dx ; y -= dy ; reachX . put ( x , i ) ; reachY . put ( y , i ) ; final int out = Math . min ( Math . min ( reachX . getOrDefault ( x - uMost , Integer . MAX_VALUE ) , reachX . getOrDefault ( x + dMost , Integer . MAX_VALUE ) ) , Math . min ( reachY . getOrDefault ( y - lMost , Integer . MAX_VALUE ) , reachY . getOrDefault ( y + rMost , Integer . MAX_VALUE ) ) ) ; ans [ i ] = out == Integer . MAX_VALUE ? m - i : out - i - 1 ; } return ans ; } }
class Solution { public long [ ] getDistances ( int [ ] arr ) { final int n = arr . length ; long [ ] ans = new long [ n ] ; long [ ] prefix = new long [ n ] ; long [ ] suffix = new long [ n ] ; Map < Integer , List < Integer > > numToIndices = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { numToIndices . putIfAbsent ( arr [ i ] , new ArrayList < > ( ) ) ; numToIndices . get ( arr [ i ] ) . add ( i ) ; } for ( List < Integer > indices : numToIndices . values ( ) ) { for ( int i = 1 ; i < indices . size ( ) ; ++ i ) { final int currIndex = indices . get ( i ) ; final int prevIndex = indices . get ( i - 1 ) ; prefix [ currIndex ] += prefix [ prevIndex ] + i * ( currIndex - prevIndex ) ; } for ( int i = indices . size ( ) - 2 ; i >= 0 ; -- i ) { final int currIndex = indices . get ( i ) ; final int prevIndex = indices . get ( i + 1 ) ; suffix [ currIndex ] += suffix [ prevIndex ] + ( indices . size ( ) - i - 1 ) * ( prevIndex - currIndex ) ; } } for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = prefix [ i ] + suffix [ i ] ; return ans ; } }
class Solution { public int [ ] recoverArray ( int [ ] nums ) { final int n = nums . length ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( final int num : nums ) count . merge ( num , 1 , Integer :: sum ) ; Arrays . sort ( nums ) ; for ( int i = 1 ; i < n ; ++ i ) { final int x = nums [ i ] - nums [ 0 ] ; if ( x <= 0 || x % 2 == 1 ) continue ; Map < Integer , Integer > countCopy = new HashMap < > ( ) ; countCopy . putAll ( count ) ; int [ ] A = getArray ( nums , x , countCopy ) ; if ( A . length == n / 2 ) return A ; } throw new IllegalArgumentException ( ) ; } private int [ ] getArray ( int [ ] nums , int x , Map < Integer , Integer > count ) { List < Integer > A = new ArrayList < > ( ) ; for ( final int num : nums ) { if ( count . getOrDefault ( num , 0 ) == 0 ) continue ; if ( count . getOrDefault ( num + x , 0 ) == 0 ) return new int [ ] { } ; count . merge ( num , - 1 , Integer :: sum ) ; count . merge ( num + x , - 1 , Integer :: sum ) ; A . add ( num + x / 2 ) ; } return A . stream ( ) . mapToInt ( i -> i ) . toArray ( ) ; } }
class Solution { public int minimumOperations ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int ans = 0 ; int [ ] [ ] seen = new int [ m ] [ n ] ; int [ ] [ ] match = new int [ m ] [ n ] ; Arrays . stream ( match ) . forEach ( A -> Arrays . fill ( A , - 1 ) ) ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ] [ j ] == 1 && match [ i ] [ j ] == - 1 ) { final int sessionId = i * n + j ; seen [ i ] [ j ] = sessionId ; if ( dfs ( grid , i , j , sessionId , seen , match ) ) ++ ans ; } return ans ; } private static final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; private boolean dfs ( final int [ ] [ ] grid , int i , int j , int sessionId , int [ ] [ ] seen , int [ ] [ ] match ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( grid [ x ] [ y ] == 0 || seen [ x ] [ y ] == sessionId ) continue ; seen [ x ] [ y ] = sessionId ; if ( match [ x ] [ y ] == - 1 || dfs ( grid , match [ x ] [ y ] / n , match [ x ] [ y ] % n , sessionId , seen , match ) ) { match [ x ] [ y ] = i * n + j ; match [ i ] [ j ] = x * n + y ; return true ; } } return false ; } }
class Solution { public boolean checkString ( String s ) { return ! s . contains ( " ba " ) ; } }
class Solution { public int numberOfBeams ( String [ ] bank ) { int ans = 0 ; int prevOnes = 0 ; for ( final String row : bank ) { final int ones = ( int ) row . chars ( ) . filter ( c -> c == '1' ) . count ( ) ; if ( ones > 0 ) { ans += prevOnes * ones ; prevOnes = ones ; } } return ans ; } }
class Solution { public boolean asteroidsDestroyed ( int mass , int [ ] asteroids ) { Arrays . sort ( asteroids ) ; long m = mass ; for ( final int asteroid : asteroids ) if ( m >= asteroid ) m += asteroid ; else return false ; return true ; } }
enum State { INIT , VISITING , VISITED } class Solution { public int maximumInvitations ( int [ ] favorite ) { final int n = favorite . length ; int sumComponentsLength = 0 ; List < Integer > [ ] graph = new List [ n ] ; int [ ] inDegree = new int [ n ] ; int [ ] maxChainLength = new int [ n ] ; Arrays . fill ( maxChainLength , 1 ) ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { graph [ i ] . add ( favorite [ i ] ) ; ++ inDegree [ favorite [ i ] ] ; } Queue < Integer > q = IntStream . range ( 0 , n ) . filter ( i -> inDegree [ i ] == 0 ) . boxed ( ) . collect ( Collectors . toCollection ( ArrayDeque :: new ) ) ; while ( ! q . isEmpty ( ) ) { final int u = q . poll ( ) ; for ( final int v : graph [ u ] ) { if ( -- inDegree [ v ] == 0 ) q . offer ( v ) ; maxChainLength [ v ] = Math . max ( maxChainLength [ v ] , 1 + maxChainLength [ u ] ) ; } } for ( int i = 0 ; i < n ; ++ i ) if ( favorite [ favorite [ i ] ] == i ) sumComponentsLength += maxChainLength [ i ] + maxChainLength [ favorite [ i ] ] ; int [ ] parent = new int [ n ] ; Arrays . fill ( parent , - 1 ) ; boolean [ ] seen = new boolean [ n ] ; State [ ] state = new State [ n ] ; for ( int i = 0 ; i < n ; ++ i ) if ( ! seen [ i ] ) findCycle ( graph , i , parent , seen , state ) ; return Math . max ( sumComponentsLength / 2 , maxCycleLength ) ; } private int maxCycleLength = 0 ; private void findCycle ( List < Integer > [ ] graph , int u , int [ ] parent , boolean [ ] seen , State [ ] state ) { seen [ u ] = true ; state [ u ] = State . VISITING ; for ( final int v : graph [ u ] ) { if ( ! seen [ v ] ) { parent [ v ] = u ; findCycle ( graph , v , parent , seen , state ) ; } else if ( state [ v ] == State . VISITING ) { int curr = u ; int cycleLength = 1 ; while ( curr != v ) { curr = parent [ curr ] ; ++ cycleLength ; } maxCycleLength = Math . max ( maxCycleLength , cycleLength ) ; } } state [ u ] = State . VISITED ; } }
class Solution { public boolean removeOnes ( int [ ] [ ] grid ) { int [ ] revRow = getRevRow ( grid [ 0 ] ) ; return Arrays . stream ( grid ) . allMatch ( row -> Arrays . equals ( row , grid [ 0 ] ) || Arrays . equals ( row , revRow ) ) ; } private int [ ] getRevRow ( int [ ] row ) { int [ ] revRow = new int [ row . length ] ; for ( int i = 0 ; i < row . length ; ++ i ) revRow [ i ] = row [ i ] ^ 1 ; return revRow ; } }
class Solution { public String capitalizeTitle ( String title ) { StringBuilder sb = new StringBuilder ( title . toLowerCase ( ) ) ; int i = 0 ; int j = 0 ; while ( j < sb . length ( ) ) { while ( j < sb . length ( ) && sb . charAt ( j ) != ' ▁ ' ) ++ j ; if ( j - i > 2 ) sb . setCharAt ( i , Character . toUpperCase ( sb . charAt ( i ) ) ) ; i = j + 1 ; ++ j ; } return sb . toString ( ) ; } }
class Solution { public int rob ( int [ ] nums ) { if ( nums . length == 0 ) return 0 ; if ( nums . length == 1 ) return nums [ 0 ] ; return Math . max ( rob ( nums , 0 , nums . length - 2 ) , rob ( nums , 1 , nums . length - 1 ) ) ; } private int rob ( int [ ] nums , int l , int r ) { int prev1 = 0 ; int prev2 = 0 ; for ( int i = l ; i <= r ; ++ i ) { final int dp = Math . max ( prev1 , prev2 + nums [ i ] ) ; prev2 = prev1 ; prev1 = dp ; } return prev1 ; } }
class Solution { public int pairSum ( ListNode head ) { int ans = 0 ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } ListNode tail = reverseList ( slow ) ; while ( tail != null ) { ans = Math . max ( ans , head . val + tail . val ) ; head = head . next ; tail = tail . next ; } return ans ; } private ListNode reverseList ( ListNode head ) { ListNode prev = null ; while ( head != null ) { ListNode next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } }
class Solution { public int longestPalindrome ( String [ ] words ) { int ans = 0 ; int [ ] [ ] count = new int [ 26 ] [ 26 ] ; for ( final String word : words ) { final int i = word . charAt ( 0 ) - ' a ' ; final int j = word . charAt ( 1 ) - ' a ' ; if ( count [ j ] [ i ] > 0 ) { ans += 4 ; -- count [ j ] [ i ] ; } else { ++ count [ i ] [ j ] ; } } for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] [ i ] > 0 ) return ans + 2 ; return ans ; } }
class Solution { public boolean possibleToStamp ( int [ ] [ ] grid , int stampHeight , int stampWidth ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int [ ] [ ] A = new int [ m + 1 ] [ n + 1 ] ; int [ ] [ ] B = new int [ m + 1 ] [ n + 1 ] ; int [ ] [ ] fit = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { A [ i + 1 ] [ j + 1 ] = A [ i + 1 ] [ j ] + A [ i ] [ j + 1 ] - A [ i ] [ j ] + grid [ i ] [ j ] ; if ( i + 1 >= stampHeight && j + 1 >= stampWidth ) { final int x = i - stampHeight + 1 ; final int y = j - stampWidth + 1 ; if ( A [ i + 1 ] [ j + 1 ] - A [ x ] [ j + 1 ] - A [ i + 1 ] [ y ] + A [ x ] [ y ] == 0 ) fit [ i ] [ j ] = 1 ; } } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) B [ i + 1 ] [ j + 1 ] = B [ i + 1 ] [ j ] + B [ i ] [ j + 1 ] - B [ i ] [ j ] + fit [ i ] [ j ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ] [ j ] == 0 ) { final int x = Math . min ( i + stampHeight , m ) ; final int y = Math . min ( j + stampWidth , n ) ; if ( B [ x ] [ y ] - B [ i ] [ y ] - B [ x ] [ j ] + B [ i ] [ j ] == 0 ) return false ; } return true ; } }
class Solution { public boolean checkValid ( int [ ] [ ] matrix ) { final int n = matrix . length ; for ( int i = 0 ; i < n ; ++ i ) { Set < Integer > row = new HashSet < > ( ) ; Set < Integer > col = new HashSet < > ( ) ; for ( int j = 0 ; j < n ; ++ j ) { row . add ( matrix [ i ] [ j ] ) ; col . add ( matrix [ j ] [ i ] ) ; } if ( Math . min ( row . size ( ) , col . size ( ) ) < n ) return false ; } return true ; } }
class Solution { public int minSwaps ( int [ ] nums ) { final int n = nums . length ; final int k = ( int ) Arrays . stream ( nums ) . filter ( a -> a == 1 ) . count ( ) ; int ones = 0 ; int maxOnes = 0 ; for ( int i = 0 ; i < n * 2 ; ++ i ) { if ( i >= k && nums [ ( i - k ) % n ] == 1 ) -- ones ; if ( nums [ i % n ] == 1 ) ++ ones ; maxOnes = Math . max ( maxOnes , ones ) ; } return k - maxOnes ; } }
class Solution { public int wordCount ( String [ ] startWords , String [ ] targetWords ) { int ans = 0 ; Set < Integer > seen = Arrays . stream ( startWords ) . map ( this :: getMask ) . collect ( Collectors . toSet ( ) ) ; for ( final String w : targetWords ) { final int mask = getMask ( w ) ; for ( final char c : w . toCharArray ( ) ) if ( seen . contains ( mask ^ 1 << c - ' a ' ) ) { ++ ans ; break ; } } return ans ; } private int getMask ( final String s ) { int mask = 0 ; for ( final char c : s . toCharArray ( ) ) mask ^= 1 << c - ' a ' ; return mask ; } }
class Seed { public int p ; public int g ; public Seed ( int p , int g ) { this . p = p ; this . g = g ; } } ; class Solution { public int earliestFullBloom ( int [ ] plantTime , int [ ] growTime ) { int ans = 0 ; int time = 0 ; Seed [ ] seeds = new Seed [ n ] ; for ( int i = 0 ; i < plantTime . length ; ++ i ) seeds [ i ] = new Seed ( plantTime [ i ] , growTime [ i ] ) ; Arrays . sort ( seeds , ( a , b ) -> b . g - a . g ) ; for ( Seed seed : seeds ) { time += seed . p ; ans = Math . max ( ans , time + seed . g ) ; } return ans ; } }
class Solution { public double equalizeWater ( int [ ] buckets , int loss ) { final double kErr = 1e-5 ; final double kPercentage = ( 100 - loss ) / ( double ) 100 ; double l = 0.0 ; double r = Arrays . stream ( buckets ) . max ( ) . getAsInt ( ) ; while ( r - l > kErr ) { final double m = ( l + r ) / 2 ; if ( canFill ( buckets , m , kPercentage ) ) l = m ; else r = m ; } return l ; } private boolean canFill ( int [ ] buckets , double target , double kPercentage ) { double extra = 0.0 ; double need = 0.0 ; for ( final int bucket : buckets ) if ( bucket > target ) extra += bucket - target ; else need += target - bucket ; return extra * kPercentage >= need ; } ; }
class Solution { public String [ ] divideString ( String s , int k , char fill ) { String [ ] ans = new String [ ( s . length ( ) + k - 1 ) / k ] ; for ( int i = 0 , j = 0 ; i < s . length ( ) ; i += k ) ans [ j ++ ] = i + k > s . length ( ) ? s . substring ( i ) + String . valueOf ( fill ) . repeat ( i + k - s . length ( ) ) : s . substring ( i , i + k ) ; return ans ; } }
class Solution { public int minMoves ( int target , int maxDoubles ) { int steps = 0 ; while ( target > 1 && maxDoubles > 0 ) { if ( ( target & 1 ) == 1 ) { -- target ; } else { target /= 2 ; -- maxDoubles ; } ++ steps ; } return steps + target - 1 ; } }
class Solution { public String shortestPalindrome ( String s ) { final String t = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; for ( int i = 0 ; i < t . length ( ) ; ++ i ) if ( s . startsWith ( t . substring ( i ) ) ) return t . substring ( 0 , i ) + s ; return t + s ; } }
class Solution { public long mostPoints ( int [ ] [ ] questions ) { final int n = questions . length ; long [ ] dp = new long [ n + 1 ] ; for ( int i = n - 1 ; i >= 0 ; -- i ) { final int points = questions [ i ] [ 0 ] ; final int brainpower = questions [ i ] [ 1 ] ; final int nextIndex = i + brainpower + 1 ; final long nextPoints = nextIndex < n ? dp [ nextIndex ] : 0 ; dp [ i ] = Math . max ( points + nextPoints , dp [ i + 1 ] ) ; } return dp [ 0 ] ; } }
class Solution { public long maxRunTime ( int n , int [ ] batteries ) { long sum = Arrays . stream ( batteries ) . asLongStream ( ) . sum ( ) ; Arrays . sort ( batteries ) ; int i = batteries . length - 1 ; while ( batteries [ i ] > sum / n ) { sum -= batteries [ i -- ] ; -- n ; } return sum / n ; } }
class Solution { public int countSubranges ( int [ ] nums1 , int [ ] nums2 ) { final int kMod = 1_000_000_007 ; int ans = 0 ; Map < Integer , Integer > dp = new HashMap < > ( ) ; for ( int i = 0 ; i < nums1 . length ; ++ i ) { Map < Integer , Integer > newDp = new HashMap < > ( ) ; newDp . merge ( nums1 [ i ] , 1 , Integer :: sum ) ; newDp . merge ( - nums2 [ i ] , 1 , Integer :: sum ) ; for ( final int prevSum : dp . keySet ( ) ) { final int count = dp . get ( prevSum ) ; final int chooseNums1 = prevSum + nums1 [ i ] ; newDp . put ( chooseNums1 , ( newDp . getOrDefault ( chooseNums1 , 0 ) + count ) % kMod ) ; final int chooseNums2 = prevSum - nums2 [ i ] ; newDp . put ( chooseNums2 , ( newDp . getOrDefault ( chooseNums2 , 0 ) + count ) % kMod ) ; } dp = newDp ; if ( dp . containsKey ( 0 ) ) { ans += dp . get ( 0 ) ; ans %= kMod ; } } return ans ; } }
class Solution { public int minimumCost ( int [ ] cost ) { int ans = 0 ; cost = Arrays . stream ( cost ) . boxed ( ) . sorted ( Collections . reverseOrder ( ) ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; for ( int i = 0 ; i < cost . length ; ++ i ) if ( i % 3 != 2 ) ans += cost [ i ] ; return ans ; } }
class Solution { public int numberOfArrays ( int [ ] differences , int lower , int upper ) { long [ ] prefix = new long [ differences . length + 1 ] ; for ( int i = 0 ; i < differences . length ; ++ i ) prefix [ i + 1 ] += prefix [ i ] + differences [ i ] ; final long max = Arrays . stream ( prefix ) . max ( ) . getAsLong ( ) ; final long min = Arrays . stream ( prefix ) . min ( ) . getAsLong ( ) ; return ( int ) Math . max ( 0L , ( upper - lower ) - ( max - min ) + 1 ) ; } }
class Solution { public List < List < Integer > > highestRankedKItems ( int [ ] [ ] grid , int [ ] pricing , int [ ] start , int k ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; final int low = pricing [ 0 ] ; final int high = pricing [ 1 ] ; final int row = start [ 0 ] ; final int col = start [ 1 ] ; final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; List < List < Integer > > ans = new ArrayList < > ( ) ; if ( low <= grid [ row ] [ col ] && grid [ row ] [ col ] <= high ) { ans . add ( Arrays . asList ( row , col ) ) ; if ( k == 1 ) return ans ; } Queue < Pair < Integer , Integer > > q = new ArrayDeque < > ( Arrays . asList ( new Pair < > ( row , col ) ) ) ; boolean [ ] [ ] seen = new boolean [ m ] [ n ] ; seen [ row ] [ col ] = true ; while ( ! q . isEmpty ( ) ) { List < List < Integer > > neighbors = new ArrayList < > ( ) ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int i = q . peek ( ) . getKey ( ) ; final int j = q . poll ( ) . getValue ( ) ; for ( int t = 0 ; t < 4 ; ++ t ) { final int x = i + dirs [ t ] ; final int y = j + dirs [ t + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( grid [ x ] [ y ] == 0 || seen [ x ] [ y ] ) continue ; if ( low <= grid [ x ] [ y ] && grid [ x ] [ y ] <= high ) neighbors . add ( Arrays . asList ( x , y ) ) ; q . offer ( new Pair < > ( x , y ) ) ; seen [ x ] [ y ] = true ; } } Collections . sort ( neighbors , new Comparator < List < Integer > > ( ) { @ Override public int compare ( List < Integer > a , List < Integer > b ) { final int x1 = a . get ( 0 ) ; final int y1 = a . get ( 1 ) ; final int x2 = b . get ( 0 ) ; final int y2 = b . get ( 1 ) ; if ( grid [ x1 ] [ y1 ] != grid [ x2 ] [ y2 ] ) return grid [ x1 ] [ y1 ] - grid [ x2 ] [ y2 ] ; return x1 == x2 ? y1 - y2 : x1 - x2 ; } } ) ; for ( List < Integer > neighbor : neighbors ) { if ( ans . size ( ) < k ) ans . add ( neighbor ) ; if ( ans . size ( ) == k ) return ans ; } } return ans ; } }
class Solution { public int numberOfWays ( String corridor ) { final int kMod = 1_000_000_007 ; long ans = 1 ; int prevSeat = - 1 ; int numSeats = 0 ; for ( int i = 0 ; i < corridor . length ( ) ; ++ i ) { if ( corridor . charAt ( i ) == ' S ' ) { if ( ++ numSeats > 2 && numSeats % 2 == 1 ) ans = ans * ( i - prevSeat ) % kMod ; prevSeat = i ; } } return numSeats > 1 && numSeats % 2 == 0 ? ( int ) ans : 0 ; } }
class Solution { public int countElements ( int [ ] nums ) { final int min = Arrays . stream ( nums ) . min ( ) . getAsInt ( ) ; final int max = Arrays . stream ( nums ) . max ( ) . getAsInt ( ) ; return ( int ) Arrays . stream ( nums ) . filter ( num -> min < num && num < max ) . count ( ) ; } }
class Solution { public int [ ] rearrangeArray ( int [ ] nums ) { int [ ] ans = new int [ nums . length ] ; List < Integer > pos = new ArrayList < > ( ) ; List < Integer > neg = new ArrayList < > ( ) ; for ( final int num : nums ) ( num > 0 ? pos : neg ) . add ( num ) ; for ( int i = 0 ; i < pos . size ( ) ; ++ i ) { ans [ i * 2 ] = pos . get ( i ) ; ans [ i * 2 + 1 ] = neg . get ( i ) ; } return ans ; } }
class Solution { public int findKthLargest ( int [ ] nums , int k ) { Queue < Integer > minHeap = new PriorityQueue < > ( ( a , b ) -> a - b ) ; for ( final int num : nums ) { minHeap . offer ( num ) ; while ( minHeap . size ( ) > k ) minHeap . poll ( ) ; } return minHeap . peek ( ) ; } }
class Solution { public List < Integer > findLonely ( int [ ] nums ) { List < Integer > ans = new ArrayList < > ( ) ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( final int num : nums ) count . merge ( num , 1 , Integer :: sum ) ; for ( final int num : count . keySet ( ) ) if ( count . get ( num ) == 1 && ! count . containsKey ( num - 1 ) && ! count . containsKey ( num + 1 ) ) ans . add ( num ) ; return ans ; } }
class Solution { public int maximumGood ( int [ ] [ ] statements ) { dfs ( statements , new ArrayList < > ( ) , 0 , 0 ) ; return ans ; } private int ans = 0 ; private void dfs ( int [ ] [ ] statements , List < Integer > good , int i , int count ) { if ( i == statements . length ) { if ( isValid ( statements , good ) ) ans = Math . max ( ans , count ) ; return ; } good . add ( 0 ) ; dfs ( statements , good , i + 1 , count ) ; good . set ( good . size ( ) - 1 , 1 ) ; dfs ( statements , good , i + 1 , count + 1 ) ; good . remove ( good . size ( ) - 1 ) ; } private boolean isValid ( int [ ] [ ] statements , List < Integer > good ) { for ( int i = 0 ; i < good . size ( ) ; ++ i ) { if ( good . get ( i ) == 0 ) continue ; for ( int j = 0 ; j < statements . length ; ++ j ) { if ( statements [ i ] [ j ] == 2 ) continue ; if ( statements [ i ] [ j ] != good . get ( j ) ) return false ; } } return true ; } }
class Solution { public int minimumLines ( int [ ] [ ] points ) { final int allCovered = ( 1 << points . length ) - 1 ; int [ ] memo = new int [ allCovered ] ; Arrays . fill ( memo , - 1 ) ; return dfs ( points , 0 , allCovered , memo ) ; } private int dfs ( int [ ] [ ] points , int covered , int allCovered , int [ ] memo ) { if ( covered == allCovered ) return 0 ; if ( memo [ covered ] != - 1 ) return memo [ covered ] ; final int n = points . length ; int ans = n / 2 + ( ( n & 1 ) == 1 ? 1 : 0 ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( covered >> i & 1 ) == 1 ) continue ; for ( int j = 0 ; j < n ; ++ j ) { if ( i == j ) continue ; int newCovered = covered | 1 << i | 1 << j ; Pair < Integer , Integer > slope = getSlope ( points [ i ] , points [ j ] ) ; for ( int k = 0 ; k < n ; ++ k ) if ( getSlope ( points [ i ] , points [ k ] ) . equals ( slope ) ) newCovered |= 1 << k ; ans = Math . min ( ans , 1 + dfs ( points , newCovered , allCovered , memo ) ) ; } } return memo [ covered ] = ans ; } private Pair < Integer , Integer > getSlope ( int [ ] p , int [ ] q ) { final int dx = p [ 0 ] - q [ 0 ] ; final int dy = p [ 1 ] - q [ 1 ] ; if ( dx == 0 ) return new Pair < > ( 0 , p [ 0 ] ) ; if ( dy == 0 ) return new Pair < > ( p [ 1 ] , 0 ) ; final int d = gcd ( dx , dy ) ; final int x = dx / d ; final int y = dy / d ; return x > 0 ? new Pair < > ( x , y ) : new Pair < > ( - x , - y ) ; } private int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } }
class Solution { public List < Integer > maxScoreIndices ( int [ ] nums ) { final int ones = Arrays . stream ( nums ) . sum ( ) ; final int zeros = nums . length - ones ; List < Integer > ans = new ArrayList < > ( Arrays . asList ( 0 ) ) ; int leftZeros = 0 ; int leftOnes = 0 ; int maxScore = ones ; for ( int i = 0 ; i < nums . length ; ++ i ) { leftZeros += nums [ i ] == 0 ? 1 : 0 ; leftOnes += nums [ i ] == 1 ? 1 : 0 ; final int rightOnes = ones - leftOnes ; final int score = leftZeros + rightOnes ; if ( maxScore == score ) { ans . add ( i + 1 ) ; } else if ( maxScore < score ) { maxScore = score ; ans = new ArrayList < > ( Arrays . asList ( i + 1 ) ) ; } } return ans ; } }
class Solution { public String subStrHash ( String s , int power , int modulo , int k , int hashValue ) { long maxPower = 1 ; long hashed = 0 ; int bestLeft = - 1 ; for ( int i = s . length ( ) - 1 ; i >= 0 ; -- i ) { hashed = ( hashed * power + val ( s . charAt ( i ) ) ) % modulo ; if ( i + k < s . length ( ) ) hashed = ( hashed - val ( s . charAt ( i + k ) ) * maxPower % modulo + modulo ) % modulo ; else maxPower = maxPower * power % modulo ; if ( hashed == hashValue ) bestLeft = i ; } return s . substring ( bestLeft , bestLeft + k ) ; } private int val ( char c ) { return c - ' a ' + 1 ; } }
class UnionFind { public UnionFind ( int n ) { count = n ; id = new int [ n ] ; size = new int [ n ] ; rank = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) id [ i ] = i ; for ( int i = 0 ; i < n ; ++ i ) size [ i ] = 1 ; } public void union ( int u , int v ) { final int i = find ( u ) ; final int j = find ( v ) ; if ( i == j ) return ; if ( rank [ i ] < rank [ j ] ) { id [ i ] = id [ j ] ; size [ j ] += size [ i ] ; } else if ( rank [ i ] > rank [ j ] ) { id [ j ] = id [ i ] ; size [ i ] += size [ j ] ; } else { id [ i ] = id [ j ] ; size [ j ] += size [ i ] ; ++ rank [ j ] ; } -- count ; } public int getCount ( ) { return count ; } public int getMaxSize ( ) { return Arrays . stream ( size ) . max ( ) . getAsInt ( ) ; } private int count ; private int [ ] id ; private int [ ] size ; private int [ ] rank ; private int find ( int u ) { return id [ u ] == u ? u : ( id [ u ] = find ( id [ u ] ) ) ; } } class Solution { public int [ ] groupStrings ( String [ ] words ) { UnionFind uf = new UnionFind ( words . length ) ; Map < Integer , Integer > maskToIndex = new HashMap < > ( ) ; Map < Integer , Integer > deletedMaskToIndex = new HashMap < > ( ) ; for ( int i = 0 ; i < words . length ; ++ i ) { final int mask = getMask ( words [ i ] ) ; for ( int j = 0 ; j < 26 ; ++ j ) if ( ( mask >> j & 1 ) == 1 ) { final int m = mask ^ 1 << j ; if ( maskToIndex . containsKey ( m ) ) uf . union ( i , maskToIndex . get ( m ) ) ; if ( deletedMaskToIndex . containsKey ( m ) ) uf . union ( i , deletedMaskToIndex . get ( m ) ) ; else deletedMaskToIndex . put ( m , i ) ; } else { final int m = mask | 1 << j ; if ( maskToIndex . containsKey ( m ) ) uf . union ( i , maskToIndex . get ( m ) ) ; } maskToIndex . put ( mask , i ) ; } return new int [ ] { uf . getCount ( ) , uf . getMaxSize ( ) } ; } private int getMask ( final String s ) { int mask = 0 ; for ( final char c : s . toCharArray ( ) ) mask |= 1 << c - ' a ' ; return mask ; } }
enum Type { ENTERING , LEAVING } class Event { public int day ; public int index ; public Type type ; public Event ( int day , int index , Type type ) { this . day = day ; this . index = index ; this . type = type ; } } class Solution { public int [ ] amountPainted ( int [ ] [ ] paint ) { final int n = paint . length ; final int minDay = Arrays . stream ( paint ) . mapToInt ( x -> x [ 0 ] ) . min ( ) . getAsInt ( ) ; final int maxDay = Arrays . stream ( paint ) . mapToInt ( x -> x [ 1 ] ) . max ( ) . getAsInt ( ) ; int [ ] ans = new int [ n ] ; TreeSet < Integer > runningIndices = new TreeSet < > ( ) ; List < Event > events = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { final int start = paint [ i ] [ 0 ] ; final int end = paint [ i ] [ 1 ] ; events . add ( new Event ( start , i , Type . ENTERING ) ) ; events . add ( new Event ( end , i , Type . LEAVING ) ) ; } Collections . sort ( events , ( a , b ) -> a . day - b . day ) ; int i = 0 ; for ( int day = minDay ; day < maxDay ; ++ day ) { while ( i < events . size ( ) && events . get ( i ) . day == day ) { if ( events . get ( i ) . type == Type . ENTERING ) runningIndices . add ( events . get ( i ) . index ) ; else runningIndices . remove ( events . get ( i ) . index ) ; ++ i ; } if ( ! runningIndices . isEmpty ( ) ) ++ ans [ runningIndices . first ( ) ] ; } return ans ; } }
class Solution { public List < List < Integer > > combinationSum3 ( int k , int n ) { List < List < Integer > > ans = new ArrayList < > ( ) ; dfs ( k , n , 1 , new ArrayList < > ( ) , ans ) ; return ans ; } private void dfs ( int k , int n , int s , List < Integer > path , List < List < Integer > > ans ) { if ( k == 0 && n == 0 ) { ans . add ( new ArrayList < > ( path ) ) ; return ; } if ( k == 0 || n < 0 ) return ; for ( int i = s ; i <= 9 ; ++ i ) { path . add ( i ) ; dfs ( k - 1 , n - i , i + 1 , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; } } }
class Solution { public int minimumSum ( int num ) { char [ ] chars = String . valueOf ( num ) . toCharArray ( ) ; Arrays . sort ( chars ) ; return ( chars [ 0 ] - '0' ) * 10 + ( chars [ 2 ] - '0' ) + ( chars [ 1 ] - '0' ) * 10 + ( chars [ 3 ] - '0' ) ; } }
class Solution { public int [ ] pivotArray ( int [ ] nums , int pivot ) { int [ ] ans = new int [ nums . length ] ; int i = 0 ; for ( final int num : nums ) if ( num < pivot ) ans [ i ++ ] = num ; for ( final int num : nums ) if ( num == pivot ) ans [ i ++ ] = num ; for ( final int num : nums ) if ( num > pivot ) ans [ i ++ ] = num ; return ans ; } }
class Solution { public int minCostSetTime ( int startAt , int moveCost , int pushCost , int targetSeconds ) { int ans = Integer . MAX_VALUE ; int mins = targetSeconds > 5999 ? 99 : targetSeconds / 60 ; int secs = targetSeconds - mins * 60 ; while ( secs < 100 ) { ans = Math . min ( ans , getCost ( startAt , moveCost , pushCost , mins , secs ) ) ; -- mins ; secs += 60 ; } return ans ; } private int getCost ( int startAt , int moveCost , int pushCost , int mins , int secs ) { int cost = 0 ; char curr = ( char ) ( '0' + startAt ) ; for ( final char c : String . valueOf ( mins * 100 + secs ) . toCharArray ( ) ) if ( c == curr ) { cost += pushCost ; } else { cost += moveCost + pushCost ; curr = c ; } return cost ; } ; }
class Solution { public long minimumDifference ( int [ ] nums ) { final int n = nums . length / 3 ; long ans = Long . MAX_VALUE ; long leftSum = 0 ; long rightSum = 0 ; Queue < Integer > maxHeap = new PriorityQueue < > ( Collections . reverseOrder ( ) ) ; Queue < Integer > minHeap = new PriorityQueue < > ( ) ; long [ ] minLeftSum = new long [ nums . length ] ; for ( int i = 0 ; i < 2 * n ; ++ i ) { maxHeap . offer ( nums [ i ] ) ; leftSum += nums [ i ] ; if ( maxHeap . size ( ) == n + 1 ) leftSum -= maxHeap . poll ( ) ; if ( maxHeap . size ( ) == n ) minLeftSum [ i ] = leftSum ; } for ( int i = nums . length - 1 ; i >= n ; -- i ) { minHeap . offer ( nums [ i ] ) ; rightSum += nums [ i ] ; if ( minHeap . size ( ) == n + 1 ) rightSum -= minHeap . poll ( ) ; if ( minHeap . size ( ) == n ) ans = Math . min ( ans , minLeftSum [ i - 1 ] - rightSum ) ; } return ans ; } }
class Solution { public int [ ] sortEvenOdd ( int [ ] nums ) { final int n = nums . length ; int [ ] ans = new int [ n ] ; int [ ] evenCount = new int [ 101 ] ; int [ ] oddCount = new int [ 101 ] ; for ( int i = 0 ; i < n ; ++ i ) if ( ( i & 1 ) == 1 ) ++ oddCount [ nums [ i ] ] ; else ++ evenCount [ nums [ i ] ] ; int ansIndex = 0 ; for ( int i = 1 ; i < 101 ; ++ i ) while ( evenCount [ i ] -- > 0 ) { ans [ ansIndex ] = i ; ansIndex += 2 ; } ansIndex = 1 ; for ( int i = 100 ; i > 0 ; -- i ) while ( oddCount [ i ] -- > 0 ) { ans [ ansIndex ] = i ; ansIndex += 2 ; } return ans ; } }
class Solution { public long smallestNumber ( long num ) { String [ ] digits = String . valueOf ( Math . abs ( num ) ) . split ( " " ) ; String s = Stream . of ( digits ) . sorted ( ) . collect ( Collectors . joining ( ) ) ; StringBuilder sb = new StringBuilder ( s ) ; if ( num <= 0 ) return - 1 * Long . parseLong ( sb . reverse ( ) . toString ( ) ) ; if ( sb . charAt ( 0 ) == '0' ) { final int firstNonZeroIndex = sb . lastIndexOf ( "0" ) + 1 ; sb . setCharAt ( 0 , sb . charAt ( firstNonZeroIndex ) ) ; sb . setCharAt ( firstNonZeroIndex , '0' ) ; } return Long . parseLong ( sb . toString ( ) ) ; } }
class Bitset { public Bitset ( int size ) { for ( int i = 0 ; i < size ; ++ i ) { sb . append ( '0' ) ; rb . append ( '1' ) ; } } public void fix ( int idx ) { if ( sb . charAt ( idx ) == '0' ) ++ cnt ; sb . setCharAt ( idx , '1' ) ; rb . setCharAt ( idx , '0' ) ; } public void unfix ( int idx ) { if ( sb . charAt ( idx ) == '1' ) -- cnt ; sb . setCharAt ( idx , '0' ) ; rb . setCharAt ( idx , '1' ) ; } public void flip ( ) { StringBuilder temp = sb ; sb = rb ; rb = temp ; cnt = sb . length ( ) - cnt ; } public boolean all ( ) { return cnt == sb . length ( ) ; } public boolean one ( ) { return cnt > 0 ; } public int count ( ) { return cnt ; } public String toString ( ) { return sb . toString ( ) ; } private StringBuilder sb = new StringBuilder ( ) ; private StringBuilder rb = new StringBuilder ( ) ; private int cnt = 0 ; }
class Solution { public int minimumTime ( String s ) { final int n = s . length ( ) ; int [ ] left = new int [ n ] ; left [ 0 ] = s . charAt ( 0 ) - '0' ; int [ ] dp = new int [ n ] ; Arrays . fill ( dp , n ) ; dp [ 0 ] = left [ 0 ] + n - 1 ; for ( int i = 1 ; i < n ; ++ i ) { left [ i ] = Math . min ( left [ i - 1 ] + ( s . charAt ( i ) - '0' ) * 2 , i + 1 ) ; dp [ i ] = Math . min ( dp [ i ] , left [ i ] + n - 1 - i ) ; } return Arrays . stream ( dp ) . min ( ) . getAsInt ( ) ; } }
class Solution { public int equalDigitFrequency ( String s ) { Set < Integer > seen = new HashSet < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) for ( int j = i ; j < s . length ( ) ; ++ j ) if ( isUnique ( s , i , j ) ) seen . add ( getRollingHash ( s , i , j ) ) ; return seen . size ( ) ; } private static final int power = 11 ; private static final int kMod = 1_000_000_007 ; private boolean isUnique ( final String s , int i , int j ) { int [ ] count = new int [ 10 ] ; int unique = 0 ; for ( int k = i ; k <= j ; ++ k ) if ( ++ count [ s . charAt ( k ) - '0' ] == 1 ) ++ unique ; final int maxCount = Arrays . stream ( count ) . max ( ) . getAsInt ( ) ; return maxCount * unique == j - i + 1 ; } private int getRollingHash ( final String s , int i , int j ) { long hashed = 0 ; for ( int k = i ; k <= j ; ++ k ) hashed = ( hashed * power + val ( s . charAt ( k ) ) ) % kMod ; return ( int ) hashed ; } private int val ( char c ) { return c - '0' + 1 ; } }
class Solution { public int countOperations ( int num1 , int num2 ) { int ans = 0 ; while ( num1 > 0 && num2 > 0 ) { if ( num1 < num2 ) { final int temp = num1 ; num1 = num2 ; num2 = temp ; } ans += num1 / num2 ; num1 %= num2 ; } return ans ; } }
class Solution { public boolean containsDuplicate ( int [ ] nums ) { Set < Integer > seen = new HashSet < > ( ) ; for ( final int num : nums ) if ( ! seen . add ( num ) ) return true ; return false ; } }
class T { public Map < Integer , Integer > count = new HashMap < > ( ) ; public int max = 0 ; public int secondMax = 0 ; public int maxFreq = 0 ; public int secondMaxFreq = 0 ; } class Solution { public int minimumOperations ( int [ ] nums ) { T [ ] ts = new T [ 2 ] ; ts [ 0 ] = new T ( ) ; ts [ 1 ] = new T ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { T t = ts [ i & 1 ] ; t . count . merge ( nums [ i ] , 1 , Integer :: sum ) ; final int freq = t . count . get ( nums [ i ] ) ; if ( freq > t . maxFreq ) { t . maxFreq = freq ; t . max = nums [ i ] ; } else if ( freq > t . secondMaxFreq ) { t . secondMaxFreq = freq ; t . secondMax = nums [ i ] ; } } if ( ts [ 0 ] . max == ts [ 1 ] . max ) return nums . length - Math . max ( ts [ 0 ] . maxFreq + ts [ 1 ] . secondMaxFreq , ts [ 1 ] . maxFreq + ts [ 0 ] . secondMaxFreq ) ; return nums . length - ( ts [ 0 ] . maxFreq + ts [ 1 ] . maxFreq ) ; } }
class Solution { public long minimumRemoval ( int [ ] beans ) { final long n = beans . length ; final long sum = Arrays . stream ( beans ) . asLongStream ( ) . sum ( ) ; long ans = Long . MAX_VALUE ; Arrays . sort ( beans ) ; for ( int i = 0 ; i < n ; ++ i ) ans = Math . min ( ans , sum - ( n - i ) * beans [ i ] ) ; return ans ; } }
class Solution { public int maximumANDSum ( int [ ] nums , int numSlots ) { final int n = 2 * numSlots ; final int nSelected = 1 << n ; int [ ] dp = new int [ nSelected ] ; int [ ] A = Arrays . copyOf ( nums , n ) ; for ( int mask = 1 ; mask < nSelected ; ++ mask ) { final int selected = Integer . bitCount ( mask ) ; final int slot = ( selected + 1 ) / 2 ; for ( int i = 0 ; i < n ; ++ i ) if ( ( mask >> i & 1 ) == 1 ) dp [ mask ] = Math . max ( dp [ mask ] , dp [ mask ^ 1 << i ] + ( slot & A [ i ] ) ) ; } return dp [ nSelected - 1 ] ; } }
class Solution { public int removeOnes ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; dp = new int [ 1 << m * n ] ; Arrays . fill ( dp , Integer . MAX_VALUE ) ; return dfs ( encode ( grid , m , n ) , m , n ) ; } private int [ ] dp ; private int dfs ( int mask , int m , int n ) { if ( mask == 0 ) return 0 ; if ( dp [ mask ] < Integer . MAX_VALUE ) return dp [ mask ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( ( mask >> i * n + j & 1 ) == 1 ) { int nextMask = mask ; for ( int k = 0 ; k < n ; ++ k ) nextMask &= ~ ( 1 << i * n + k ) ; for ( int k = 0 ; k < m ; ++ k ) nextMask &= ~ ( 1 << k * n + j ) ; dp [ mask ] = Math . min ( dp [ mask ] , 1 + dfs ( nextMask , m , n ) ) ; } return dp [ mask ] ; } private int encode ( int [ ] [ ] grid , int m , int n ) { int encoded = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ] [ j ] == 1 ) encoded |= 1 << i * n + j ; return encoded ; } }
class Solution { public int countPairs ( int [ ] nums , int k ) { int ans = 0 ; Map < Integer , List < Integer > > numToIndices = new HashMap < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { numToIndices . putIfAbsent ( nums [ i ] , new ArrayList < > ( ) ) ; numToIndices . get ( nums [ i ] ) . add ( i ) ; } for ( List < Integer > indices : numToIndices . values ( ) ) { Map < Integer , Integer > gcds = new HashMap < > ( ) ; for ( final int i : indices ) { final int gcd_i = gcd ( i , k ) ; for ( final int gcd_j : gcds . keySet ( ) ) if ( gcd_i * gcd_j % k == 0 ) ans += gcds . get ( gcd_j ) ; gcds . merge ( gcd_i , 1 , Integer :: sum ) ; } } return ans ; } private int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } }
class Solution { public long [ ] sumOfThree ( long num ) { if ( num % 3 != 0 ) return new long [ ] { } ; final long x = num / 3 ; return new long [ ] { x - 1 , x , x + 1 } ; } }
class Solution { public List < Long > maximumEvenSplit ( long finalSum ) { if ( finalSum % 2 == 1 ) return new ArrayList < > ( ) ; List < Long > ans = new ArrayList < > ( ) ; long needSum = finalSum ; long even = 2 ; while ( needSum - even >= even + 2 ) { ans . add ( even ) ; needSum -= even ; even += 2 ; } ans . add ( needSum ) ; return ans ; } }
class FenwickTree { public FenwickTree ( int n ) { sums = new int [ n + 1 ] ; } public void update ( int i , int delta ) { while ( i < sums . length ) { sums [ i ] += delta ; i += lowbit ( i ) ; } } public int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ] ; i -= lowbit ( i ) ; } return sum ; } private int [ ] sums ; private static int lowbit ( int i ) { return i & - i ; } } class Solution { public long goodTriplets ( int [ ] nums1 , int [ ] nums2 ) { final int n = nums1 . length ; long ans = 0 ; Map < Integer , Integer > numToIndex = new HashMap < > ( ) ; int [ ] A = new int [ n ] ; int [ ] leftSmaller = new int [ n ] ; int [ ] rightLarger = new int [ n ] ; FenwickTree tree1 = new FenwickTree ( n ) ; FenwickTree tree2 = new FenwickTree ( n ) ; for ( int i = 0 ; i < n ; ++ i ) numToIndex . put ( nums1 [ i ] , i ) ; for ( int i = 0 ; i < n ; ++ i ) A [ i ] = numToIndex . get ( nums2 [ i ] ) ; for ( int i = 0 ; i < n ; ++ i ) { leftSmaller [ i ] = tree1 . get ( A [ i ] ) ; tree1 . update ( A [ i ] + 1 , 1 ) ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { rightLarger [ i ] = tree2 . get ( n ) - tree2 . get ( A [ i ] ) ; tree2 . update ( A [ i ] + 1 , 1 ) ; } for ( int i = 0 ; i < n ; ++ i ) ans += ( long ) leftSmaller [ i ] * rightLarger [ i ] ; return ans ; } }
class Solution { public List < List < Integer > > getSkyline ( int [ ] [ ] buildings ) { final int n = buildings . length ; if ( n == 0 ) return new ArrayList < > ( ) ; if ( n == 1 ) { final int left = buildings [ 0 ] [ 0 ] ; final int right = buildings [ 0 ] [ 1 ] ; final int height = buildings [ 0 ] [ 2 ] ; List < List < Integer > > ans = new ArrayList < > ( ) ; ans . add ( new ArrayList < > ( Arrays . asList ( left , height ) ) ) ; ans . add ( new ArrayList < > ( Arrays . asList ( right , 0 ) ) ) ; return ans ; } List < List < Integer > > leftSkyline = getSkyline ( Arrays . copyOfRange ( buildings , 0 , n / 2 ) ) ; List < List < Integer > > rightSkyline = getSkyline ( Arrays . copyOfRange ( buildings , n / 2 , n ) ) ; return merge ( leftSkyline , rightSkyline ) ; } private List < List < Integer > > merge ( List < List < Integer > > left , List < List < Integer > > right ) { List < List < Integer > > ans = new ArrayList < > ( ) ; int i = 0 ; int j = 0 ; int leftY = 0 ; int rightY = 0 ; while ( i < left . size ( ) && j < right . size ( ) ) if ( left . get ( i ) . get ( 0 ) < right . get ( j ) . get ( 0 ) ) { leftY = left . get ( i ) . get ( 1 ) ; addPoint ( ans , left . get ( i ) . get ( 0 ) , Math . max ( left . get ( i ++ ) . get ( 1 ) , rightY ) ) ; } else { rightY = right . get ( j ) . get ( 1 ) ; addPoint ( ans , right . get ( j ) . get ( 0 ) , Math . max ( right . get ( j ++ ) . get ( 1 ) , leftY ) ) ; } while ( i < left . size ( ) ) addPoint ( ans , left . get ( i ) . get ( 0 ) , left . get ( i ++ ) . get ( 1 ) ) ; while ( j < right . size ( ) ) addPoint ( ans , right . get ( j ) . get ( 0 ) , right . get ( j ++ ) . get ( 1 ) ) ; return ans ; } private void addPoint ( List < List < Integer > > ans , int x , int y ) { if ( ! ans . isEmpty ( ) && ans . get ( ans . size ( ) - 1 ) . get ( 0 ) == x ) { ans . get ( ans . size ( ) - 1 ) . set ( 1 , y ) ; return ; } if ( ! ans . isEmpty ( ) && ans . get ( ans . size ( ) - 1 ) . get ( 1 ) == y ) return ; ans . add ( new ArrayList < > ( Arrays . asList ( x , y ) ) ) ; } }
class Solution { public int countEven ( int num ) { if ( sumOfDigit ( num ) % 2 == 0 ) return num / 2 ; return ( num - 1 ) / 2 ; } private int sumOfDigit ( int num ) { int sum = 0 ; while ( num > 0 ) { sum += num % 10 ; num /= 10 ; } return sum ; } }
class Solution { public ListNode mergeNodes ( ListNode head ) { if ( head == null ) return null ; if ( head . next . val == 0 ) { ListNode node = new ListNode ( head . val ) ; node . next = mergeNodes ( head . next . next ) ; return node ; } ListNode next = mergeNodes ( head . next ) ; next . val += head . val ; return next ; } }
class Solution { public String repeatLimitedString ( String s , int repeatLimit ) { StringBuilder sb = new StringBuilder ( ) ; int [ ] count = new int [ 26 ] ; for ( final char c : s . toCharArray ( ) ) ++ count [ c - ' a ' ] ; while ( true ) { final boolean addOne = ! sb . isEmpty ( ) && shouldAddOne ( sb , count ) ; final int i = getLargestChar ( sb , count ) ; if ( i == - 1 ) break ; final int repeats = addOne ? 1 : Math . min ( count [ i ] , repeatLimit ) ; sb . append ( String . valueOf ( ( char ) ( ' a ' + i ) ) . repeat ( repeats ) ) ; count [ i ] -= repeats ; } return sb . toString ( ) ; } private boolean shouldAddOne ( StringBuilder sb , int [ ] count ) { for ( int i = 25 ; i >= 0 ; -- i ) if ( count [ i ] > 0 ) return sb . charAt ( sb . length ( ) - 1 ) == ' a ' + i ; return false ; } private int getLargestChar ( StringBuilder sb , int [ ] count ) { for ( int i = 25 ; i >= 0 ; -- i ) if ( count [ i ] > 0 && ( sb . isEmpty ( ) || sb . charAt ( sb . length ( ) - 1 ) != ' a ' + i ) ) return i ; return - 1 ; } }
class Solution { public long countPairs ( int [ ] nums , int k ) { long ans = 0 ; Map < Long , Integer > gcds = new HashMap < > ( ) ; for ( final int num : nums ) { final long gcd_i = gcd ( num , k ) ; for ( final long gcd_j : gcds . keySet ( ) ) if ( gcd_i * gcd_j % k == 0 ) ans += gcds . get ( gcd_j ) ; gcds . merge ( gcd_i , 1 , Integer :: sum ) ; } return ans ; } private int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } }
class Solution { public int buildWall ( int height , int width , int [ ] bricks ) { final int kMod = 1_000_000_007 ; List < Integer > rows = new ArrayList < > ( ) ; buildRows ( width , bricks , 0 , rows ) ; final int n = rows . size ( ) ; long [ ] dp = new long [ n ] ; List < Integer > [ ] graph = new List [ n ] ; Arrays . fill ( dp , 1 ) ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( ( rows . get ( i ) & rows . get ( j ) ) == 0 ) graph [ i ] . add ( j ) ; for ( int h = 2 ; h <= height ; ++ h ) { long [ ] newDp = new long [ n ] ; for ( int i = 0 ; i < n ; ++ i ) for ( final int v : graph [ i ] ) { newDp [ i ] += dp [ v ] ; newDp [ i ] %= kMod ; } dp = newDp ; } return ( int ) ( Arrays . stream ( dp ) . sum ( ) % kMod ) ; } private void buildRows ( int width , int [ ] bricks , int path , List < Integer > rows ) { for ( final int brick : bricks ) if ( brick == width ) rows . add ( path ) ; else if ( brick < width ) { final int newWidth = width - brick ; buildRows ( newWidth , bricks , path | 1 << newWidth , rows ) ; } } }
class Solution { public int prefixCount ( String [ ] words , String pref ) { return ( int ) Arrays . stream ( words ) . filter ( w -> w . startsWith ( pref ) ) . count ( ) ; } }
class Solution { public int minSteps ( String s , String t ) { int [ ] count = new int [ 26 ] ; s . chars ( ) . forEach ( c -> ++ count [ c - ' a ' ] ) ; t . chars ( ) . forEach ( c -> -- count [ c - ' a ' ] ) ; return Arrays . stream ( count ) . map ( Math :: abs ) . sum ( ) ; } }
class Solution { public long minimumTime ( int [ ] time , int totalTrips ) { long l = 1 ; long r = Arrays . stream ( time ) . min ( ) . getAsInt ( ) * ( long ) totalTrips ; while ( l < r ) { final long m = ( l + r ) / 2 ; if ( numTrips ( time , m ) >= totalTrips ) r = m ; else l = m + 1 ; } return l ; } private long numTrips ( int [ ] time , long m ) { return Arrays . stream ( time ) . asLongStream ( ) . reduce ( 0L , ( subtotal , t ) -> subtotal + m / t ) ; } }
class Solution { public int minimumFinishTime ( int [ ] [ ] tires , int changeTime , int numLaps ) { int [ ] singleTire = new int [ numLaps + 1 ] ; int [ ] dp = new int [ numLaps + 1 ] ; Arrays . fill ( singleTire , Integer . MAX_VALUE / 2 ) ; Arrays . fill ( dp , Integer . MAX_VALUE / 2 ) ; for ( int i = 0 ; i < tires . length ; ++ i ) { final int f = tires [ i ] [ 0 ] ; final int r = tires [ i ] [ 1 ] ; int sumSecs = 0 ; int rPower = 1 ; for ( int j = 1 ; j <= numLaps ; ++ j ) { if ( ( long ) f * rPower >= changeTime + f ) break ; sumSecs += f * rPower ; rPower *= r ; singleTire [ j ] = Math . min ( singleTire [ j ] , sumSecs ) ; } } dp [ 0 ] = 0 ; for ( int i = 1 ; i <= numLaps ; ++ i ) for ( int j = 1 ; j <= i ; ++ j ) dp [ i ] = Math . min ( dp [ i ] , dp [ i - j ] + changeTime + singleTire [ j ] ) ; return dp [ numLaps ] - changeTime ; } }
class Solution { public boolean containsNearbyDuplicate ( int [ ] nums , int k ) { Set < Integer > seen = new HashSet < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( ! seen . add ( nums [ i ] ) ) return true ; if ( i >= k ) seen . remove ( nums [ i - k ] ) ; } return false ; } }
class Solution { public int mostFrequent ( int [ ] nums , int key ) { int [ ] count = new int [ 1001 ] ; int ans = 0 ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) if ( nums [ i ] == key ) ++ count [ nums [ i + 1 ] ] ; for ( int i = 1 ; i < 1001 ; ++ i ) if ( count [ i ] > count [ ans ] ) ans = i ; return ans ; } }
class Solution { public int [ ] sortJumbled ( int [ ] mapping , int [ ] nums ) { int [ ] ans = new int [ nums . length ] ; List < int [ ] > A = new ArrayList < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) A . add ( new int [ ] { getMapped ( nums [ i ] , mapping ) , i , nums [ i ] } ) ; Collections . sort ( A , ( a , b ) -> a [ 0 ] == b [ 0 ] ? a [ 1 ] - b [ 1 ] : a [ 0 ] - b [ 0 ] ) ; return A . stream ( ) . mapToInt ( a -> a [ 2 ] ) . toArray ( ) ; } private int getMapped ( int num , int [ ] mapping ) { StringBuilder sb = new StringBuilder ( ) ; for ( final char c : String . valueOf ( num ) . toCharArray ( ) ) sb . append ( mapping [ c - '0' ] ) ; return Integer . parseInt ( sb . toString ( ) ) ; } }
class Solution { public List < List < Integer > > getAncestors ( int n , int [ ] [ ] edges ) { List < List < Integer > > ans = new ArrayList < > ( ) ; List < Integer > [ ] graph = new List [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { ans . add ( new ArrayList < > ( ) ) ; graph [ i ] = new ArrayList < > ( ) ; } for ( int [ ] e : edges ) graph [ e [ 0 ] ] . add ( e [ 1 ] ) ; for ( int i = 0 ; i < n ; ++ i ) dfs ( graph , i , i , new boolean [ n ] , ans ) ; return ans ; } private void dfs ( List < Integer > [ ] graph , int u , int ancestor , boolean [ ] seen , List < List < Integer > > ans ) { seen [ u ] = true ; for ( final int v : graph [ u ] ) { if ( seen [ v ] ) continue ; ans . get ( v ) . add ( ancestor ) ; dfs ( graph , v , ancestor , seen , ans ) ; } } }
class Solution { public int minMovesToMakePalindrome ( String s ) { int ans = 0 ; StringBuilder sb = new StringBuilder ( s ) ; while ( sb . length ( ) > 1 ) { final int i = sb . indexOf ( sb . substring ( sb . length ( ) - 1 ) ) ; if ( i == sb . length ( ) - 1 ) { ans += i / 2 ; } else { sb . deleteCharAt ( i ) ; ans += i ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return ans ; } }
class Solution { public List < String > cellsInRange ( String s ) { List < String > ans = new ArrayList < > ( ) ; final char startCol = s . charAt ( 0 ) ; final char endCol = s . charAt ( 3 ) ; final char startRow = s . charAt ( 1 ) ; final char endRow = s . charAt ( 4 ) ; for ( char col = startCol ; col <= endCol ; ++ col ) for ( char row = startRow ; row <= endRow ; ++ row ) ans . add ( " " + col + row ) ; return ans ; } }
class Solution { public long minimalKSum ( int [ ] nums , int k ) { long ans = 0 ; Arrays . sort ( nums ) ; if ( nums [ 0 ] > 1 ) { final int l = 1 ; final int r = Math . min ( k , nums [ 0 ] - 1 ) ; ans += ( long ) ( l + r ) * ( r - l + 1 ) / 2 ; k -= r - l + 1 ; if ( k == 0 ) return ans ; } for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { if ( nums [ i ] == nums [ i + 1 ] ) continue ; final int l = nums [ i ] + 1 ; final int r = Math . min ( nums [ i ] + k , nums [ i + 1 ] - 1 ) ; ans += ( long ) ( l + r ) * ( r - l + 1 ) / 2 ; k -= r - l + 1 ; if ( k == 0 ) return ans ; } if ( k > 0 ) { final int l = nums [ nums . length - 1 ] + 1 ; final int r = nums [ nums . length - 1 ] + k ; ans += ( long ) ( l + r ) * ( r - l + 1 ) / 2 ; } return ans ; } }
class Solution { public TreeNode createBinaryTree ( int [ ] [ ] descriptions ) { Map < TreeNode , TreeNode > childToParent = new HashMap < > ( ) ; Map < Integer , TreeNode > valToNode = new HashMap < > ( ) ; for ( int [ ] d : descriptions ) { final int p = d [ 0 ] ; final int c = d [ 1 ] ; final int isLeft = d [ 2 ] ; TreeNode parent = valToNode . getOrDefault ( p , new TreeNode ( p ) ) ; TreeNode child = valToNode . getOrDefault ( c , new TreeNode ( c ) ) ; valToNode . put ( p , parent ) ; valToNode . put ( c , child ) ; childToParent . put ( child , parent ) ; if ( isLeft == 1 ) parent . left = child ; else parent . right = child ; } TreeNode root = childToParent . keySet ( ) . iterator ( ) . next ( ) ; while ( childToParent . containsKey ( root ) ) root = childToParent . get ( root ) ; return root ; } }
class Solution { public List < Integer > replaceNonCoprimes ( int [ ] nums ) { LinkedList < Integer > ans = new LinkedList < > ( ) ; for ( int num : nums ) { while ( ! ans . isEmpty ( ) && gcd ( ans . getLast ( ) , num ) > 1 ) num = lcm ( ans . removeLast ( ) , num ) ; ans . addLast ( num ) ; } return ans ; } private int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } private int lcm ( int a , int b ) { return a * ( b / gcd ( a , b ) ) ; } }
class Solution { public long singleDivisorTriplet ( int [ ] nums ) { long ans = 0 ; int [ ] count = new int [ 101 ] ; for ( final int num : nums ) ++ count [ num ] ; for ( int a = 1 ; a < 101 ; ++ a ) for ( int b = a ; count [ a ] > 0 && b < 101 ; ++ b ) for ( int c = b ; count [ b ] > 0 && c < 101 ; ++ c ) { final int sum = a + b + c ; if ( divisible ( sum , a ) + divisible ( sum , b ) + divisible ( sum , c ) != 1 ) continue ; if ( a == b ) ans += ( long ) count [ a ] * ( count [ a ] - 1 ) / 2 * count [ c ] ; else if ( b == c ) ans += ( long ) count [ b ] * ( count [ b ] - 1 ) / 2 * count [ a ] ; else ans += ( long ) count [ a ] * count [ b ] * count [ c ] ; } return ans * 6 ; } private int divisible ( int sum , int num ) { return sum % num == 0 ? 1 : 0 ; } }
class Solution { public List < String > generateParenthesis ( int n ) { List < String > ans = new ArrayList < > ( ) ; dfs ( n , n , new StringBuilder ( ) , ans ) ; return ans ; } private void dfs ( int l , int r , final StringBuilder sb , List < String > ans ) { if ( l == 0 && r == 0 ) { ans . add ( sb . toString ( ) ) ; return ; } if ( l > 0 ) { sb . append ( " ( " ) ; dfs ( l - 1 , r , sb , ans ) ; sb . deleteCharAt ( sb . length ( ) - 1 ) ; } if ( l < r ) { sb . append ( " ) " ) ; dfs ( l , r - 1 , sb , ans ) ; sb . deleteCharAt ( sb . length ( ) - 1 ) ; } } }
class Solution { public List < Integer > findKDistantIndices ( int [ ] nums , int key , int k ) { final int n = nums . length ; List < Integer > ans = new ArrayList < > ( ) ; for ( int i = 0 , j = 0 ; i < n ; ++ i ) { while ( j < n && ( nums [ j ] != key || j < i - k ) ) ++ j ; if ( j == n ) break ; if ( Math . abs ( i - j ) <= k ) ans . add ( i ) ; } return ans ; } }
class Solution { public int digArtifacts ( int n , int [ ] [ ] artifacts , int [ ] [ ] dig ) { Set < Integer > digged = new HashSet < > ( ) ; for ( int [ ] d : dig ) digged . add ( hash ( d [ 0 ] , d [ 1 ] ) ) ; return ( int ) Arrays . stream ( artifacts ) . filter ( a -> canExtract ( a , digged ) ) . count ( ) ; } private int hash ( int i , int j ) { return i << 16 | j ; } private boolean canExtract ( int [ ] a , Set < Integer > digged ) { for ( int i = a [ 0 ] ; i <= a [ 2 ] ; ++ i ) for ( int j = a [ 1 ] ; j <= a [ 3 ] ; ++ j ) if ( ! digged . contains ( hash ( i , j ) ) ) return false ; return true ; } }
class Solution { public int maximumTop ( int [ ] nums , int k ) { final int n = nums . length ; if ( k == 0 || k == 1 ) return n == k ? - 1 : nums [ k ] ; if ( n == 1 ) return k % 2 == 0 ? nums [ 0 ] : - 1 ; final int max = firstKMax ( nums , k - 1 ) ; if ( k >= n ) return max ; return Math . max ( max , nums [ k ] ) ; } private int firstKMax ( int [ ] nums , int k ) { int max = 0 ; for ( int i = 0 ; i < nums . length && i < k ; ++ i ) max = Math . max ( max , nums [ i ] ) ; return max ; } }
class Solution { public long minimumWeight ( int n , int [ ] [ ] edges , int src1 , int src2 , int dest ) { List < Pair < Integer , Integer > > [ ] graph1 = new List [ n ] ; List < Pair < Integer , Integer > > [ ] graph2 = new List [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { graph1 [ i ] = new ArrayList < > ( ) ; graph2 [ i ] = new ArrayList < > ( ) ; } for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; final int w = e [ 2 ] ; graph1 [ u ] . add ( new Pair < > ( v , w ) ) ; graph2 [ v ] . add ( new Pair < > ( u , w ) ) ; } long [ ] fromSrc1 = dijkstra ( graph1 , src1 ) ; long [ ] fromSrc2 = dijkstra ( graph1 , src2 ) ; long [ ] fromDest = dijkstra ( graph2 , dest ) ; long ans = kMax ; for ( int i = 0 ; i < n ; ++ i ) { if ( fromSrc1 [ i ] == kMax || fromSrc2 [ i ] == kMax || fromDest [ i ] == kMax ) continue ; ans = Math . min ( ans , fromSrc1 [ i ] + fromSrc2 [ i ] + fromDest [ i ] ) ; } return ans == kMax ? - 1 : ans ; } private static long kMax = ( long ) 1e10 ; private long [ ] dijkstra ( List < Pair < Integer , Integer > > [ ] graph , int src ) { Queue < Pair < Long , Integer > > minHeap = new PriorityQueue < > ( Comparator . comparing ( Pair :: getKey ) ) ; long [ ] dist = new long [ graph . length ] ; Arrays . fill ( dist , kMax ) ; minHeap . offer ( new Pair < > ( 0L , src ) ) ; while ( ! minHeap . isEmpty ( ) ) { final long d = minHeap . peek ( ) . getKey ( ) ; final int u = minHeap . poll ( ) . getValue ( ) ; if ( dist [ u ] != kMax ) continue ; dist [ u ] = d ; for ( Pair < Integer , Integer > node : graph [ u ] ) { final int v = node . getKey ( ) ; final int w = node . getValue ( ) ; minHeap . offer ( new Pair < > ( d + w , v ) ) ; } } return dist ; } }
class Solution { public int [ ] distanceToCycle ( int n , int [ ] [ ] edges ) { int [ ] ans = new int [ n ] ; List < Integer > [ ] graph = new List [ n ] ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } int [ ] rank = new int [ n ] ; Arrays . fill ( rank , NO_RANK ) ; List < Integer > cycle = new ArrayList < > ( ) ; getRank ( graph , 0 , 0 , rank , cycle ) ; Queue < Integer > q = cycle . stream ( ) . collect ( Collectors . toCollection ( ArrayDeque :: new ) ) ; boolean [ ] seen = new boolean [ n ] ; for ( final int u : cycle ) seen [ u ] = true ; int dist = 0 ; while ( ! q . isEmpty ( ) ) { ++ dist ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int u = q . poll ( ) ; for ( final int v : graph [ u ] ) { if ( seen [ v ] ) continue ; q . offer ( v ) ; seen [ v ] = true ; ans [ v ] = dist ; } } } return ans ; } private static final int NO_RANK = - 2 ; private int getRank ( List < Integer > [ ] graph , int u , int currRank , int [ ] rank , List < Integer > cycle ) { if ( rank [ u ] != NO_RANK ) return rank [ u ] ; rank [ u ] = currRank ; int minRank = currRank ; for ( final int v : graph [ u ] ) { if ( rank [ u ] == rank . length || rank [ v ] == currRank - 1 ) continue ; final int nextRank = getRank ( graph , v , currRank + 1 , rank , cycle ) ; if ( nextRank <= currRank ) cycle . add ( v ) ; minRank = Math . min ( minRank , nextRank ) ; } rank [ u ] = rank . length ; return minRank ; } }
class Solution { public boolean divideArray ( int [ ] nums ) { int [ ] count = new int [ 501 ] ; for ( final int num : nums ) ++ count [ num ] ; return Arrays . stream ( count ) . allMatch ( c -> c % 2 == 0 ) ; } }
class Solution { public long maximumSubsequenceCount ( String text , String pattern ) { long ans = 0 ; int count0 = 0 ; int count1 = 0 ; for ( int i = 0 ; i < text . length ( ) ; ++ i ) { if ( text . charAt ( i ) == pattern . charAt ( 1 ) ) { ans += count0 ; ++ count1 ; } if ( text . charAt ( i ) == pattern . charAt ( 0 ) ) ++ count0 ; } return ans + Math . max ( count0 , count1 ) ; } }
class Solution { public int halveArray ( int [ ] nums ) { final double halfSum = Arrays . stream ( nums ) . asDoubleStream ( ) . sum ( ) / 2 ; int ans = 0 ; double runningSum = 0 ; Queue < Double > maxHeap = new PriorityQueue < > ( Collections . reverseOrder ( ) ) ; for ( final double num : nums ) maxHeap . offer ( num ) ; while ( runningSum < halfSum ) { final double maxValue = maxHeap . poll ( ) / 2 ; runningSum += maxValue ; maxHeap . offer ( maxValue ) ; ++ ans ; } return ans ; } }
class Solution { public int minimumWhiteTiles ( String floor , int numCarpets , int carpetLen ) { dp = new int [ floor . length ( ) + 1 ] [ numCarpets + 1 ] ; Arrays . stream ( dp ) . forEach ( A -> Arrays . fill ( A , kMax ) ) ; return minimumWhiteTiles ( floor , 0 , numCarpets , carpetLen ) ; } private final static int kMax = 1000 ; private int [ ] [ ] dp ; int minimumWhiteTiles ( final String floor , int i , int j , int carpetLen ) { if ( j < 0 ) return kMax ; if ( i >= floor . length ( ) ) return 0 ; if ( dp [ i ] [ j ] != kMax ) return dp [ i ] [ j ] ; return dp [ i ] [ j ] = Math . min ( minimumWhiteTiles ( floor , i + carpetLen , j - 1 , carpetLen ) , minimumWhiteTiles ( floor , i + 1 , j , carpetLen ) + floor . charAt ( i ) - '0' ) ; } }
class Solution { public int maximalSquare ( char [ ] [ ] matrix ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int [ ] [ ] dp = new int [ m ] [ n ] ; int maxLength = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( i == 0 || j == 0 || matrix [ i ] [ j ] == '0' ) dp [ i ] [ j ] = matrix [ i ] [ j ] == '1' ? 1 : 0 ; else dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j - 1 ] , Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ) + 1 ; maxLength = Math . max ( maxLength , dp [ i ] [ j ] ) ; } return maxLength * maxLength ; } }
class Solution { public int countHillValley ( int [ ] nums ) { int ans = 0 ; int left = nums [ 0 ] ; for ( int i = 1 ; i + 1 < nums . length ; ++ i ) if ( left < nums [ i ] && nums [ i ] > nums [ i + 1 ] || left > nums [ i ] && nums [ i ] < nums [ i + 1 ] ) { ++ ans ; left = nums [ i ] ; } return ans ; } }
class Solution { public int countCollisions ( String directions ) { int ans = 0 ; int l = 0 ; int r = directions . length ( ) - 1 ; while ( l < directions . length ( ) && directions . charAt ( l ) == ' L ' ) ++ l ; while ( r >= 0 && directions . charAt ( r ) == ' R ' ) -- r ; for ( int i = l ; i <= r ; ++ i ) if ( directions . charAt ( i ) != ' S ' ) ++ ans ; return ans ; } }
class Solution { public int [ ] maximumBobPoints ( int numArrows , int [ ] aliceArrows ) { final int allMask = ( 1 << 12 ) - 1 ; int maxPoint = 0 ; int maxMask = 0 ; for ( int mask = 0 ; mask < allMask ; ++ mask ) { Pair < Boolean , Integer > pair = getShotableAndPoint ( mask , numArrows , aliceArrows ) ; final boolean shotable = pair . getKey ( ) ; final int point = pair . getValue ( ) ; if ( shotable && point > maxPoint ) { maxPoint = point ; maxMask = mask ; } } return getBobsArrows ( maxMask , numArrows , aliceArrows ) ; } private Pair < Boolean , Integer > getShotableAndPoint ( int mask , int leftArrows , int [ ] aliceArrows ) { int point = 0 ; for ( int i = 0 ; i < 12 ; ++ i ) if ( ( mask >> i & 1 ) == 1 ) { leftArrows -= aliceArrows [ i ] + 1 ; point += i ; } return new Pair < > ( leftArrows >= 0 , point ) ; } int [ ] getBobsArrows ( int mask , int leftArrows , int [ ] aliceArrows ) { int [ ] bobsArrows = new int [ 12 ] ; for ( int i = 0 ; i < 12 ; ++ i ) if ( ( mask >> i & 1 ) == 1 ) { bobsArrows [ i ] = aliceArrows [ i ] + 1 ; leftArrows -= aliceArrows [ i ] + 1 ; } bobsArrows [ 0 ] = leftArrows ; return bobsArrows ; } }
class Solution { public long minimumHealth ( int [ ] damage , int armor ) { final long sum = Arrays . stream ( damage ) . asLongStream ( ) . sum ( ) ; final int maxDamage = Arrays . stream ( damage ) . max ( ) . getAsInt ( ) ; return 1 + sum - Math . min ( maxDamage , armor ) ; } }
class Solution { public List < List < Integer > > findDifference ( int [ ] nums1 , int [ ] nums2 ) { Set < Integer > set1 = Arrays . stream ( nums1 ) . boxed ( ) . collect ( Collectors . toSet ( ) ) ; Set < Integer > set2 = Arrays . stream ( nums2 ) . boxed ( ) . collect ( Collectors . toSet ( ) ) ; Arrays . stream ( nums1 ) . forEach ( set2 :: remove ) ; Arrays . stream ( nums2 ) . forEach ( set1 :: remove ) ; return Arrays . asList ( new ArrayList < > ( set1 ) , new ArrayList < > ( set2 ) ) ; } }
class Solution { public int minDeletion ( int [ ] nums ) { int ans = 0 ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) if ( nums [ i ] == nums [ i + 1 ] && ( i - ans ) % 2 == 0 ) ++ ans ; return ans + ( ( ( nums . length - ans ) & 1 ) == 1 ? 1 : 0 ) ; } }
class Solution { public long [ ] kthPalindrome ( int [ ] queries , int intLength ) { final int start = ( int ) Math . pow ( 10 , ( intLength + 1 ) / 2 - 1 ) ; final int end = ( int ) Math . pow ( 10 , ( intLength + 1 ) / 2 ) ; final int mul = ( int ) Math . pow ( 10 , intLength / 2 ) ; long [ ] ans = new long [ queries . length ] ; for ( int i = 0 ; i < queries . length ; ++ i ) if ( start + queries [ i ] > end ) ans [ i ] = - 1 ; else ans [ i ] = getKthPalindrome ( queries [ i ] , start , mul , intLength ) ; return ans ; } private long getKthPalindrome ( int q , int start , int mul , int intLength ) { final long prefix = start + q - 1 ; return prefix * mul + reverse ( intLength % 2 == 1 ? prefix / 10 : prefix ) ; } long reverse ( long num ) { long res = 0 ; while ( num > 0 ) { res = res * 10 + num % 10 ; num /= 10 ; } return res ; } }
class Solution { public int maxValueOfCoins ( List < List < Integer > > piles , int k ) { dp = new Integer [ piles . size ( ) ] [ k + 1 ] ; return maxValueOfCoins ( piles , 0 , k ) ; } private Integer [ ] [ ] dp ; private int maxValueOfCoins ( List < List < Integer > > piles , int i , int k ) { if ( i == piles . size ( ) || k == 0 ) return 0 ; if ( dp [ i ] [ k ] != null ) return dp [ i ] [ k ] ; int ans = maxValueOfCoins ( piles , i + 1 , k ) ; int val = 0 ; for ( int j = 0 ; j < Math . min ( piles . get ( i ) . size ( ) , k ) ; ++ j ) { val += piles . get ( i ) . get ( j ) ; ans = Math . max ( ans , val + maxValueOfCoins ( piles , i + 1 , k - j - 1 ) ) ; } return dp [ i ] [ k ] = ans ; } }
class Solution { public long maximumSumScore ( int [ ] nums ) { long ans = Long . MIN_VALUE ; long prefix = 0 ; long sum = Arrays . stream ( nums ) . asLongStream ( ) . sum ( ) ; for ( final int num : nums ) { prefix += num ; ans = Math . max ( ans , Math . max ( prefix , sum - prefix + num ) ) ; } return ans ; } }
class Solution { public int countNodes ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + countNodes ( root . left ) + countNodes ( root . right ) ; } }
class Solution { public int minBitFlips ( int start , int goal ) { return Integer . bitCount ( start ^ goal ) ; } }
class Solution { public int triangularSum ( int [ ] nums ) { for ( int sz = nums . length ; sz > 0 ; -- sz ) for ( int i = 0 ; i + 1 < sz ; ++ i ) nums [ i ] = ( nums [ i ] + nums [ i + 1 ] ) % 10 ; return nums [ 0 ] ; } }
class Solution { public long numberOfWays ( String s ) { long ans = 0 ; int [ ] before = new int [ 2 ] ; int [ ] after = new int [ 2 ] ; after [ 0 ] = ( int ) s . chars ( ) . filter ( c -> c == '0' ) . count ( ) ; after [ 1 ] = s . length ( ) - after [ 0 ] ; for ( final char c : s . toCharArray ( ) ) { final int num = c - '0' ; -- after [ num ] ; if ( num == 0 ) ans += before [ 1 ] * after [ 1 ] ; else ans += before [ 0 ] * after [ 0 ] ; ++ before [ num ] ; } return ans ; } }
class Solution { public long sumScores ( String s ) { final int n = s . length ( ) ; int [ ] z = new int [ n ] ; int l = 0 ; int r = 0 ; for ( int i = 1 ; i < n ; ++ i ) { if ( i <= r ) z [ i ] = Math . min ( r - i + 1 , z [ i - l ] ) ; while ( i + z [ i ] < n && s . charAt ( z [ i ] ) == s . charAt ( i + z [ i ] ) ) ++ z [ i ] ; if ( i + z [ i ] - 1 > r ) { l = i ; r = i + z [ i ] - 1 ; } } return Arrays . stream ( z ) . sum ( ) . getAsInt ( ) + n ; } }
class Solution { public int convertTime ( String current , String correct ) { final int [ ] ops = { 60 , 15 , 5 , 1 } ; int diff = getMinutes ( correct ) - getMinutes ( current ) ; int ans = 0 ; for ( final int op : ops ) { ans += diff / op ; diff %= op ; } return ans ; } private int getMinutes ( final String s ) { return Integer . parseInt ( s . substring ( 0 , 2 ) ) * 60 + Integer . parseInt ( s . substring ( 3 ) ) ; } }
class Solution { public List < List < Integer > > findWinners ( int [ ] [ ] matches ) { List < List < Integer > > ans = Arrays . asList ( new ArrayList < > ( ) , new ArrayList < > ( ) ) ; Map < Integer , Integer > lossesCount = new TreeMap < > ( ) ; for ( int [ ] m : matches ) { final int winner = m [ 0 ] ; final int loser = m [ 1 ] ; if ( ! lossesCount . containsKey ( winner ) ) lossesCount . put ( winner , 0 ) ; lossesCount . merge ( loser , 1 , Integer :: sum ) ; } for ( final int player : lossesCount . keySet ( ) ) { final int nLosses = lossesCount . get ( player ) ; if ( nLosses < 2 ) ans . get ( nLosses ) . add ( player ) ; } return ans ; } }
class Solution { public int maximumCandies ( int [ ] candies , long k ) { int l = 1 ; int r = ( int ) ( Arrays . stream ( candies ) . asLongStream ( ) . sum ( ) / k ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( numChildren ( candies , m ) < k ) r = m ; else l = m + 1 ; } return numChildren ( candies , l ) >= k ? l : l - 1 ; } private long numChildren ( int [ ] candies , int m ) { return Arrays . stream ( candies ) . asLongStream ( ) . reduce ( 0L , ( subtotal , c ) -> subtotal + c / m ) ; } }
class TrieNode { public TrieNode [ ] children = new TrieNode [ 26 ] ; public boolean isWord = false ; } class Encrypter { public Encrypter ( char [ ] keys , String [ ] values , String [ ] dictionary ) { for ( int i = 0 ; i < keys . length ; ++ i ) { final char key = keys [ i ] ; final String value = values [ i ] ; keyToValue . put ( key , value ) ; valueToKeys . putIfAbsent ( value , new ArrayList < > ( ) ) ; valueToKeys . get ( value ) . add ( key ) ; } for ( final String word : dictionary ) insert ( word ) ; } public String encrypt ( String word1 ) { StringBuilder sb = new StringBuilder ( ) ; for ( final char c : word1 . toCharArray ( ) ) sb . append ( keyToValue . get ( c ) ) ; return sb . toString ( ) ; } public int decrypt ( String word2 ) { return find ( word2 , 0 , root ) ; } private Map < Character , String > keyToValue = new HashMap < > ( ) ; private Map < String , List < Character > > valueToKeys = new HashMap < > ( ) ; private TrieNode root = new TrieNode ( ) ; void insert ( final String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ( ) ) { final int i = c - ' a ' ; if ( node . children [ i ] == null ) node . children [ i ] = new TrieNode ( ) ; node = node . children [ i ] ; } node . isWord = true ; } int find ( final String word , int i , TrieNode node ) { final String value = word . substring ( i , i + 2 ) ; if ( ! valueToKeys . containsKey ( value ) ) return 0 ; int ans = 0 ; if ( i + 2 == word . length ( ) ) { for ( final char key : valueToKeys . get ( value ) ) { TrieNode child = node . children [ key - ' a ' ] ; if ( child != null && child . isWord ) ++ ans ; } return ans ; } for ( final char key : valueToKeys . get ( value ) ) { if ( node . children [ key - ' a ' ] == null ) continue ; ans += find ( word , i + 2 , node . children [ key - ' a ' ] ) ; } return ans ; } }
class Solution { public boolean isConsecutive ( int [ ] nums ) { final int n = nums . length ; final int max = Arrays . stream ( nums ) . max ( ) . getAsInt ( ) ; final int min = Arrays . stream ( nums ) . min ( ) . getAsInt ( ) ; return max - min + 1 == n && Arrays . stream ( nums ) . boxed ( ) . collect ( Collectors . toSet ( ) ) . size ( ) == n ; } }
class Solution { public int computeArea ( long A , long B , long C , long D , long E , long F , long G , long H ) { final long x = Math . max ( A , E ) < Math . min ( C , G ) ? ( Math . min ( C , G ) - Math . max ( A , E ) ) : 0 ; final long y = Math . max ( B , F ) < Math . min ( D , H ) ? ( Math . min ( D , H ) - Math . max ( B , F ) ) : 0 ; return ( int ) ( ( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y ) ; } }
class Solution { public int largestInteger ( int num ) { final String s = String . valueOf ( num ) ; int ans = 0 ; Queue < Integer > [ ] maxHeap = new Queue [ 2 ] ; for ( int i = 0 ; i < 2 ; ++ i ) maxHeap [ i ] = new PriorityQueue < > ( Comparator . reverseOrder ( ) ) ; for ( final char c : s . toCharArray ( ) ) { final int digit = c - '0' ; maxHeap [ digit & 1 ] . offer ( digit ) ; } for ( final char c : s . toCharArray ( ) ) { final int i = c - '0' & 1 ; ans = ( ans * 10 + maxHeap [ i ] . poll ( ) ) ; } return ans ; } }
class Solution { public String minimizeResult ( String expression ) { final int plusIndex = expression . indexOf ( ' + ' ) ; final String left = expression . substring ( 0 , plusIndex ) ; final String right = expression . substring ( plusIndex + 1 ) ; String ans = " " ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < left . length ( ) ; ++ i ) for ( int j = 0 ; j < right . length ( ) ; ++ j ) { final int a = i == 0 ? 1 : Integer . parseInt ( left . substring ( 0 , i ) ) ; final int b = Integer . parseInt ( left . substring ( i ) ) ; final int c = Integer . parseInt ( right . substring ( 0 , j + 1 ) ) ; final int d = j == right . length ( ) - 1 ? 1 : Integer . parseInt ( right . substring ( j + 1 ) ) ; final int val = a * ( b + c ) * d ; if ( val < min ) { min = val ; ans = ( i == 0 ? " " : String . valueOf ( a ) ) + ' ( ' + String . valueOf ( b ) + ' + ' + String . valueOf ( c ) + ' ) ' + ( j == right . length ( ) - 1 ? " " : String . valueOf ( d ) ) ; } } return ans ; } }
class Solution { public int maximumProduct ( int [ ] nums , int k ) { final int kMod = 1_000_000_007 ; long ans = 1 ; Queue < Integer > minHeap = new PriorityQueue < > ( ) ; for ( final int num : nums ) minHeap . offer ( num ) ; for ( int i = 0 ; i < k ; ++ i ) { final int minNum = minHeap . poll ( ) ; minHeap . offer ( minNum + 1 ) ; } while ( ! minHeap . isEmpty ( ) ) { ans *= minHeap . poll ( ) ; ans %= kMod ; } return ( int ) ans ; } }
class Solution { public long maximumBeauty ( int [ ] flowers , long newFlowers , int target , int full , int partial ) { final long n = flowers . length ; for ( int i = 0 ; i < n ; ++ i ) flowers [ i ] = Math . min ( flowers [ i ] , target ) ; Arrays . sort ( flowers ) ; if ( flowers [ 0 ] == target ) return ( long ) n * full ; if ( newFlowers >= n * target - Arrays . stream ( flowers ) . asLongStream ( ) . sum ( ) ) return Math . max ( n * full , ( n - 1 ) * full + ( long ) ( target - 1 ) * partial ) ; long ans = 0 ; long leftFlowers = newFlowers ; long [ ] cost = new long [ flowers . length ] ; for ( int i = 1 ; i < flowers . length ; ++ i ) cost [ i ] = cost [ i - 1 ] + i * ( flowers [ i ] - flowers [ i - 1 ] ) ; int i = flowers . length - 1 ; while ( flowers [ i ] == target ) -- i ; for ( ; leftFlowers >= 0 ; -- i ) { final int j = firstGreater ( cost , i , leftFlowers ) ; final long minIncomplete = flowers [ j - 1 ] + ( leftFlowers - cost [ j - 1 ] ) / j ; ans = Math . max ( ans , ( long ) ( n - 1 - i ) * full + ( long ) minIncomplete * partial ) ; leftFlowers -= Math . max ( 0 , target - flowers [ i ] ) ; } return ans ; } private int firstGreater ( long [ ] A , int maxIndex , long target ) { final int i = Arrays . binarySearch ( A , 0 , maxIndex + 1 , target + 1 ) ; return i < 0 ? - i - 1 : i ; } }
class Solution { public int sum ( int num1 , int num2 ) { return num1 + num2 ; } }
class Solution { public boolean checkTree ( TreeNode root ) { return root . val == root . left . val + root . right . val ; } }
class Solution { public int meetRequirement ( int n , int [ ] [ ] lights , int [ ] requirement ) { int ans = 0 ; int currBrightness = 0 ; int [ ] change = new int [ n + 1 ] ; for ( int [ ] light : lights ) { final int position = light [ 0 ] ; final int range = light [ 1 ] ; ++ change [ Math . max ( 0 , position - range ) ] ; -- change [ Math . min ( n , position + range + 1 ) ] ; } for ( int i = 0 ; i < n ; ++ i ) { currBrightness += change [ i ] ; if ( currBrightness >= requirement [ i ] ) ++ ans ; } return ans ; } }
class Solution { public int findClosestNumber ( int [ ] nums ) { int ans = 0 ; int min = Integer . MAX_VALUE ; for ( final int num : nums ) if ( Math . abs ( num ) < min ) { min = Math . abs ( num ) ; ans = num ; } else if ( Math . abs ( num ) == min && num > ans ) { ans = num ; } return ans ; } }
class Solution { public int calculate ( String s ) { int ans = 0 ; int num = 0 ; int sign = 1 ; Deque < Integer > stack = new ArrayDeque < > ( ) ; stack . push ( sign ) ; for ( final char c : s . toCharArray ( ) ) if ( Character . isDigit ( c ) ) num = num * 10 + ( c - '0' ) ; else if ( c == ' ( ' ) stack . push ( sign ) ; else if ( c == ' ) ' ) stack . pop ( ) ; else if ( c == ' + ' || c == ' - ' ) { ans += sign * num ; sign = ( c == ' + ' ? 1 : - 1 ) * stack . peek ( ) ; num = 0 ; } return ans + sign * num ; } }
class Solution { public long waysToBuyPensPencils ( int total , int cost1 , int cost2 ) { long ans = 0 ; final int maxPen = total / cost1 ; for ( int i = 0 ; i <= maxPen ; ++ i ) ans += ( total - i * cost1 ) / cost2 + 1 ; return ans ; } }
class ATM { public void deposit ( int [ ] banknotesCount ) { for ( int i = 0 ; i < 5 ; ++ i ) bank [ i ] += banknotesCount [ i ] ; } public int [ ] withdraw ( int amount ) { int [ ] withdrew = new int [ 5 ] ; for ( int i = 4 ; i >= 0 ; -- i ) { withdrew [ i ] = ( int ) Math . min ( bank [ i ] , ( long ) amount / banknotes [ i ] ) ; amount -= withdrew [ i ] * banknotes [ i ] ; } if ( amount > 0 ) return new int [ ] { - 1 } ; for ( int i = 0 ; i < 5 ; ++ i ) bank [ i ] -= withdrew [ i ] ; return withdrew ; } private int [ ] banknotes = { 20 , 50 , 100 , 200 , 500 } ; private long [ ] bank = new long [ 5 ] ; }
class Solution { public int maximumScore ( int [ ] scores , int [ ] [ ] edges ) { final int n = scores . length ; int ans = - 1 ; Queue < Integer > [ ] graph = new Queue [ n ] ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new PriorityQueue < > ( ( a , b ) -> scores [ a ] - scores [ b ] ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; graph [ u ] . offer ( v ) ; graph [ v ] . offer ( u ) ; if ( graph [ u ] . size ( ) > 3 ) graph [ u ] . poll ( ) ; if ( graph [ v ] . size ( ) > 3 ) graph [ v ] . poll ( ) ; } for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; for ( final int a : graph [ u ] ) for ( final int b : graph [ v ] ) if ( a != b && a != v && b != u ) ans = Math . max ( ans , scores [ a ] + scores [ u ] + scores [ v ] + scores [ b ] ) ; } return ans ; } }
class Solution { public String digitSum ( String s , int k ) { while ( s . length ( ) > k ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < s . length ( ) ; i += k ) { int sum = 0 ; for ( int j = i ; j < Math . min ( s . length ( ) , i + k ) ; ++ j ) sum += s . charAt ( j ) - '0' ; sb . append ( sum ) ; } s = sb . toString ( ) ; } return s ; } }
class Solution { public int minimumRounds ( int [ ] tasks ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( final int task : tasks ) count . merge ( task , 1 , Integer :: sum ) ; for ( final int freq : count . values ( ) ) if ( freq == 1 ) return - 1 ; else ans += ( freq + 2 ) / 3 ; return ans ; } }
class Solution { public int maxTrailingZeros ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int [ ] [ ] leftPrefix2 = new int [ m ] [ n ] ; int [ ] [ ] leftPrefix5 = new int [ m ] [ n ] ; int [ ] [ ] topPrefix2 = new int [ m ] [ n ] ; int [ ] [ ] topPrefix5 = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { leftPrefix2 [ i ] [ j ] = getCount ( grid [ i ] [ j ] , 2 ) ; leftPrefix5 [ i ] [ j ] = getCount ( grid [ i ] [ j ] , 5 ) ; if ( j > 0 ) { leftPrefix2 [ i ] [ j ] += leftPrefix2 [ i ] [ j - 1 ] ; leftPrefix5 [ i ] [ j ] += leftPrefix5 [ i ] [ j - 1 ] ; } } for ( int j = 0 ; j < n ; ++ j ) for ( int i = 0 ; i < m ; ++ i ) { topPrefix2 [ i ] [ j ] = getCount ( grid [ i ] [ j ] , 2 ) ; topPrefix5 [ i ] [ j ] = getCount ( grid [ i ] [ j ] , 5 ) ; if ( i > 0 ) { topPrefix2 [ i ] [ j ] += topPrefix2 [ i - 1 ] [ j ] ; topPrefix5 [ i ] [ j ] += topPrefix5 [ i - 1 ] [ j ] ; } } int ans = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { final int curr2 = getCount ( grid [ i ] [ j ] , 2 ) ; final int curr5 = getCount ( grid [ i ] [ j ] , 5 ) ; final int l2 = leftPrefix2 [ i ] [ j ] ; final int l5 = leftPrefix5 [ i ] [ j ] ; final int r2 = leftPrefix2 [ i ] [ n - 1 ] - ( j > 0 ? leftPrefix2 [ i ] [ j - 1 ] : 0 ) ; final int r5 = leftPrefix5 [ i ] [ n - 1 ] - ( j > 0 ? leftPrefix5 [ i ] [ j - 1 ] : 0 ) ; final int t2 = topPrefix2 [ i ] [ j ] ; final int t5 = topPrefix5 [ i ] [ j ] ; final int d2 = topPrefix2 [ m - 1 ] [ j ] - ( i > 0 ? topPrefix2 [ i - 1 ] [ j ] : 0 ) ; final int d5 = topPrefix5 [ m - 1 ] [ j ] - ( i > 0 ? topPrefix5 [ i - 1 ] [ j ] : 0 ) ; ans = Math . max ( ans , Math . max ( Math . max ( Math . min ( l2 + t2 - curr2 , l5 + t5 - curr5 ) , Math . min ( r2 + t2 - curr2 , r5 + t5 - curr5 ) ) , Math . max ( Math . min ( l2 + d2 - curr2 , l5 + d5 - curr5 ) , Math . min ( r2 + d2 - curr2 , r5 + d5 - curr5 ) ) ) ) ; } return ans ; } private int getCount ( int num , int factor ) { int count = 0 ; while ( num % factor == 0 ) { num /= factor ; ++ count ; } return count ; } }
class Solution { public int longestPath ( int [ ] parent , String s ) { final int n = parent . length ; List < Integer > [ ] graph = new List [ n ] ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int i = 1 ; i < n ; ++ i ) graph [ parent [ i ] ] . add ( i ) ; longestPathDownFrom ( graph , 0 , s ) ; return ans ; } private int ans = 0 ; private int longestPathDownFrom ( List < Integer > [ ] graph , int u , final String s ) { int max1 = 0 ; int max2 = 0 ; for ( final int v : graph [ u ] ) { final int res = longestPathDownFrom ( graph , v , s ) ; if ( s . charAt ( u ) == s . charAt ( v ) ) continue ; if ( res > max1 ) { max2 = max1 ; max1 = res ; } else if ( res > max2 ) { max2 = res ; } } ans = Math . max ( ans , 1 + max1 + max2 ) ; return 1 + max1 ; } }
class Solution { public int maximumCost ( int n , int [ ] [ ] highways , int k ) { if ( k + 1 > n ) return - 1 ; int ans = - 1 ; dp = new Integer [ n ] [ 1 << n ] ; List < Pair < Integer , Integer > > [ ] graph = new List [ n ] ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] h : highways ) { final int u = h [ 0 ] ; final int v = h [ 1 ] ; final int w = h [ 2 ] ; graph [ u ] . add ( new Pair < > ( v , w ) ) ; graph [ v ] . add ( new Pair < > ( u , w ) ) ; } for ( int i = 0 ; i < n ; ++ i ) ans = Math . max ( ans , maximumCost ( graph , i , 1 << i , k ) ) ; return ans ; } private Integer [ ] [ ] dp ; private int maximumCost ( List < Pair < Integer , Integer > > [ ] graph , int u , int mask , int k ) { if ( Integer . bitCount ( mask ) == k + 1 ) return 0 ; if ( dp [ u ] [ mask ] != null ) return dp [ u ] [ mask ] ; int ans = - 1 ; for ( Pair < Integer , Integer > node : graph [ u ] ) { final int v = node . getKey ( ) ; final int w = node . getValue ( ) ; if ( ( mask >> v & 1 ) == 1 ) continue ; final int res = maximumCost ( graph , v , mask | 1 << v , k ) ; if ( res != - 1 ) ans = Math . max ( ans , w + res ) ; } return dp [ u ] [ mask ] = ans ; } }
class Solution { public List < Integer > intersection ( int [ ] [ ] nums ) { List < Integer > ans = new ArrayList < > ( ) ; int [ ] count = new int [ 1001 ] ; for ( int [ ] A : nums ) for ( final int a : A ) ++ count [ a ] ; for ( int i = 1 ; i < 1001 ; ++ i ) if ( count [ i ] == nums . length ) ans . add ( i ) ; return ans ; } }
class Solution { public int countLatticePoints ( int [ ] [ ] circles ) { int ans = 0 ; for ( int x = 0 ; x < 201 ; ++ x ) for ( int y = 0 ; y < 201 ; ++ y ) for ( int [ ] c : circles ) if ( ( c [ 0 ] - x ) * ( c [ 0 ] - x ) + ( c [ 1 ] - y ) * ( c [ 1 ] - y ) <= c [ 2 ] * c [ 2 ] ) { ++ ans ; break ; } return ans ; } }
class MyStack { public void push ( int x ) { q . offer ( x ) ; for ( int i = 0 ; i < q . size ( ) - 1 ; ++ i ) q . offer ( q . poll ( ) ) ; } public int pop ( ) { return q . poll ( ) ; } public int top ( ) { return q . peek ( ) ; } public boolean empty ( ) { return q . isEmpty ( ) ; } private Queue < Integer > q = new ArrayDeque < > ( ) ; }
class Solution { public int [ ] countRectangles ( int [ ] [ ] rectangles , int [ ] [ ] points ) { int [ ] ans = new int [ points . length ] ; List < Integer > [ ] yToXs = new List [ 101 ] ; for ( int i = 0 ; i < 101 ; ++ i ) yToXs [ i ] = new ArrayList < > ( ) ; for ( int [ ] r : rectangles ) yToXs [ r [ 1 ] ] . add ( r [ 0 ] ) ; for ( List < Integer > xs : yToXs ) Collections . sort ( xs ) ; for ( int i = 0 ; i < points . length ; ++ i ) { int count = 0 ; for ( int y = points [ i ] [ 1 ] ; y < 101 ; ++ y ) { List < Integer > xs = yToXs [ y ] ; count += xs . size ( ) - firstGreaterEqual ( xs , points [ i ] [ 0 ] ) ; } ans [ i ] = count ; } return ans ; } private int firstGreaterEqual ( List < Integer > A , int target ) { int l = 0 ; int r = A . size ( ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A . get ( m ) >= target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public int [ ] fullBloomFlowers ( int [ ] [ ] flowers , int [ ] persons ) { int [ ] ans = new int [ persons . length ] ; List < Integer > starts = new ArrayList < > ( ) ; List < Integer > ends = new ArrayList < > ( ) ; for ( int [ ] f : flowers ) { starts . add ( f [ 0 ] ) ; ends . add ( f [ 1 ] ) ; } Collections . sort ( starts ) ; Collections . sort ( ends ) ; for ( int i = 0 ; i < persons . length ; ++ i ) { final int started = firstGreater ( starts , persons [ i ] ) ; final int ended = firstGreaterEqual ( ends , persons [ i ] ) ; ans [ i ] = started - ended ; } return ans ; } private int firstGreater ( List < Integer > A , int target ) { int l = 0 ; int r = A . size ( ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A . get ( m ) > target ) r = m ; else l = m + 1 ; } return l ; } private int firstGreaterEqual ( List < Integer > A , int target ) { int l = 0 ; int r = A . size ( ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A . get ( m ) >= target ) r = m ; else l = m + 1 ; } return l ; } }
class VideoSharingPlatform { public int upload ( String video ) { final int videoId = getVideoId ( ) ; videoIdToVideo . put ( videoId , video ) ; return videoId ; } public void remove ( int videoId ) { if ( videoIdToVideo . containsKey ( videoId ) ) { usedIds . offer ( videoId ) ; videoIdToVideo . remove ( videoId ) ; videoIdToViews . remove ( videoId ) ; videoIdToLikes . remove ( videoId ) ; videoIdToDislikes . remove ( videoId ) ; } } public String watch ( int videoId , int startMinute , int endMinute ) { if ( ! videoIdToVideo . containsKey ( videoId ) ) return " - 1" ; videoIdToViews . merge ( videoId , 1 , Integer :: sum ) ; final String video = videoIdToVideo . get ( videoId ) ; return video . substring ( startMinute , Math . min ( endMinute + 1 , video . length ( ) ) ) ; } public void like ( int videoId ) { if ( videoIdToVideo . containsKey ( videoId ) ) videoIdToLikes . merge ( videoId , 1 , Integer :: sum ) ; } public void dislike ( int videoId ) { if ( videoIdToVideo . containsKey ( videoId ) ) videoIdToDislikes . merge ( videoId , 1 , Integer :: sum ) ; } public int [ ] getLikesAndDislikes ( int videoId ) { return videoIdToVideo . containsKey ( videoId ) ? new int [ ] { videoIdToLikes . getOrDefault ( videoId , 0 ) , videoIdToDislikes . getOrDefault ( videoId , 0 ) } : new int [ ] { - 1 } ; } public int getViews ( int videoId ) { return videoIdToVideo . containsKey ( videoId ) ? videoIdToViews . getOrDefault ( videoId , 0 ) : - 1 ; } private int currVideoId = 0 ; private Queue < Integer > usedIds = new PriorityQueue < > ( ) ; private Map < Integer , String > videoIdToVideo = new HashMap < > ( ) ; private Map < Integer , Integer > videoIdToViews = new HashMap < > ( ) ; private Map < Integer , Integer > videoIdToLikes = new HashMap < > ( ) ; private Map < Integer , Integer > videoIdToDislikes = new HashMap < > ( ) ; private int getVideoId ( ) { if ( usedIds . isEmpty ( ) ) return currVideoId ++ ; return usedIds . poll ( ) ; } }
class Solution { public int countPrefixes ( String [ ] words , String s ) { return ( int ) Arrays . stream ( words ) . filter ( word -> s . startsWith ( word ) ) . count ( ) ; } }
class Solution { public int minimumAverageDifference ( int [ ] nums ) { final int n = nums . length ; int ans = 0 ; int minDiff = Integer . MAX_VALUE ; long prefix = 0 ; long suffix = Arrays . stream ( nums ) . asLongStream ( ) . sum ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { prefix += nums [ i ] ; suffix -= nums [ i ] ; final int prefixAvg = ( int ) ( prefix / ( i + 1 ) ) ; final int suffixAvg = ( i == n - 1 ) ? 0 : ( int ) ( suffix / ( n - i - 1 ) ) ; final int diff = Math . abs ( prefixAvg - suffixAvg ) ; if ( diff < minDiff ) { ans = i ; minDiff = diff ; } } return ans ; } }
class Solution { public int countUnguarded ( int m , int n , int [ ] [ ] guards , int [ ] [ ] walls ) { int ans = 0 ; char [ ] [ ] grid = new char [ m ] [ n ] ; char [ ] [ ] left = new char [ m ] [ n ] ; char [ ] [ ] right = new char [ m ] [ n ] ; char [ ] [ ] up = new char [ m ] [ n ] ; char [ ] [ ] down = new char [ m ] [ n ] ; for ( int [ ] guard : guards ) grid [ guard [ 0 ] ] [ guard [ 1 ] ] = ' G ' ; for ( int [ ] wall : walls ) grid [ wall [ 0 ] ] [ wall [ 1 ] ] = ' W ' ; for ( int i = 0 ; i < m ; ++ i ) { char lastCell = 0 ; for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ] [ j ] == ' G ' || grid [ i ] [ j ] == ' W ' ) lastCell = grid [ i ] [ j ] ; else left [ i ] [ j ] = lastCell ; lastCell = 0 ; for ( int j = n - 1 ; j >= 0 ; -- j ) if ( grid [ i ] [ j ] == ' G ' || grid [ i ] [ j ] == ' W ' ) lastCell = grid [ i ] [ j ] ; else right [ i ] [ j ] = lastCell ; } for ( int j = 0 ; j < n ; ++ j ) { char lastCell = 0 ; for ( int i = 0 ; i < m ; ++ i ) if ( grid [ i ] [ j ] == ' G ' || grid [ i ] [ j ] == ' W ' ) lastCell = grid [ i ] [ j ] ; else up [ i ] [ j ] = lastCell ; lastCell = 0 ; for ( int i = m - 1 ; i >= 0 ; -- i ) if ( grid [ i ] [ j ] == ' G ' || grid [ i ] [ j ] == ' W ' ) lastCell = grid [ i ] [ j ] ; else down [ i ] [ j ] = lastCell ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ] [ j ] == 0 && left [ i ] [ j ] != ' G ' && right [ i ] [ j ] != ' G ' && up [ i ] [ j ] != ' G ' && down [ i ] [ j ] != ' G ' ) ++ ans ; return ans ; } }
class Solution { public int maximumMinutes ( int [ ] [ ] grid ) { final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; final int kMax = grid . length * grid [ 0 ] . length ; int [ ] [ ] fireMinute = new int [ grid . length ] [ grid [ 0 ] . length ] ; Arrays . stream ( fireMinute ) . forEach ( A -> Arrays . fill ( A , - 1 ) ) ; buildFireGrid ( grid , fireMinute , dirs ) ; int ans = - 1 ; int l = 0 ; int r = kMax ; while ( l <= r ) { final int m = ( l + r ) / 2 ; if ( canStayFor ( grid , fireMinute , m , dirs ) ) { ans = m ; l = m + 1 ; } else { r = m - 1 ; } } return ans == kMax ? ( int ) 1e9 : ans ; } private void buildFireGrid ( int [ ] [ ] grid , int [ ] [ ] fireMinute , final int [ ] dirs ) { int minuteFromFire = 0 ; Queue < Pair < Integer , Integer > > q = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) if ( grid [ i ] [ j ] == 1 ) { q . offer ( new Pair < > ( i , j ) ) ; fireMinute [ i ] [ j ] = 0 ; } while ( ! q . isEmpty ( ) ) { ++ minuteFromFire ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int i = q . peek ( ) . getKey ( ) ; final int j = q . poll ( ) . getValue ( ) ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == grid . length || y < 0 || y == grid [ 0 ] . length ) continue ; if ( grid [ x ] [ y ] == 2 ) continue ; if ( fireMinute [ x ] [ y ] != - 1 ) continue ; fireMinute [ x ] [ y ] = minuteFromFire ; q . offer ( new Pair < > ( x , y ) ) ; } } } } boolean canStayFor ( int [ ] [ ] grid , int [ ] [ ] fireMinute , int minute , final int [ ] dirs ) { Queue < Pair < Integer , Integer > > q = new ArrayDeque < > ( Arrays . asList ( new Pair < > ( 0 , 0 ) ) ) ; boolean [ ] [ ] seen = new boolean [ grid . length ] [ grid [ 0 ] . length ] ; seen [ 0 ] [ 0 ] = true ; while ( ! q . isEmpty ( ) ) { ++ minute ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int i = q . peek ( ) . getKey ( ) ; final int j = q . poll ( ) . getValue ( ) ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == grid . length || y < 0 || y == grid [ 0 ] . length ) continue ; if ( grid [ x ] [ y ] == 2 ) continue ; if ( x == grid . length - 1 && y == grid [ 0 ] . length - 1 ) { if ( fireMinute [ x ] [ y ] != - 1 && fireMinute [ x ] [ y ] < minute ) continue ; return true ; } if ( fireMinute [ x ] [ y ] != - 1 && fireMinute [ x ] [ y ] <= minute ) continue ; if ( seen [ x ] [ y ] ) continue ; q . offer ( new Pair < > ( x , y ) ) ; seen [ x ] [ y ] = true ; } } } return false ; } }
class Solution { public String removeDigit ( String number , char digit ) { for ( int i = 0 ; i + 1 < number . length ( ) ; ++ i ) if ( number . charAt ( i ) == digit && digit < number . charAt ( i + 1 ) ) return new StringBuilder ( number ) . deleteCharAt ( i ) . toString ( ) ; return new StringBuilder ( number ) . deleteCharAt ( number . lastIndexOf ( digit ) ) . toString ( ) ; } }
class Solution { public TreeNode invertTree ( TreeNode root ) { if ( root == null ) return null ; TreeNode left = root . left ; TreeNode right = root . right ; root . left = invertTree ( right ) ; root . right = invertTree ( left ) ; return root ; } }
class Solution { public int minimumCardPickup ( int [ ] cards ) { int ans = Integer . MAX_VALUE ; Map < Integer , Integer > lastOccurrence = new HashMap < > ( ) ; for ( int i = 0 ; i < cards . length ; ++ i ) { if ( lastOccurrence . containsKey ( cards [ i ] ) ) ans = Math . min ( ans , i - lastOccurrence . get ( cards [ i ] ) + 1 ) ; lastOccurrence . put ( cards [ i ] , i ) ; } return ans == Integer . MAX_VALUE ? - 1 : ans ; } }
class TrieNode { public Map < Integer , TrieNode > children = new HashMap < > ( ) ; public int count = 0 ; } class Solution { public int countDistinct ( int [ ] nums , int k , int p ) { for ( int i = 0 ; i < nums . length ; ++ i ) insert ( root , nums , i , k , p ) ; return ans ; } private int ans = 0 ; private TrieNode root = new TrieNode ( ) ; private void insert ( TrieNode node , int [ ] nums , int i , int k , int p ) { if ( i == nums . length || k - ( nums [ i ] % p == 0 ? 1 : 0 ) < 0 ) return ; if ( ! node . children . containsKey ( nums [ i ] ) ) { node . children . put ( nums [ i ] , new TrieNode ( ) ) ; ++ ans ; } insert ( node . children . get ( nums [ i ] ) , nums , i + 1 , k - ( nums [ i ] % p == 0 ? 1 : 0 ) , p ) ; } }
class Solution { public long appealSum ( String s ) { long ans = 0 ; int dp = 0 ; int [ ] lastOccurrence = new int [ 26 ] ; Arrays . fill ( lastOccurrence , - 1 ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { dp += i - lastOccurrence [ s . charAt ( i ) - ' a ' ] ; ans += dp ; lastOccurrence [ s . charAt ( i ) - ' a ' ] = i ; } return ans ; } }
class Solution { public int convertArray ( int [ ] nums ) { return Math . min ( cost ( nums ) , cost ( negative ( nums ) ) ) ; } private int cost ( int [ ] nums ) { int ans = 0 ; Queue < Integer > maxHeap = new PriorityQueue < > ( Comparator . reverseOrder ( ) ) ; for ( final int num : nums ) { if ( ! maxHeap . isEmpty ( ) && maxHeap . peek ( ) > num ) { ans += maxHeap . poll ( ) - num ; maxHeap . offer ( num ) ; } maxHeap . offer ( num ) ; } return ans ; } private int [ ] negative ( int [ ] nums ) { int [ ] A = nums . clone ( ) ; for ( int i = 0 ; i < A . length ; ++ i ) A [ i ] *= - 1 ; return A ; } }
class Solution { public String largestGoodInteger ( String num ) { String ans = " " ; for ( int i = 2 ; i < num . length ( ) ; ++ i ) if ( num . charAt ( i - 2 ) == num . charAt ( i - 1 ) && num . charAt ( i - 1 ) == num . charAt ( i ) && num . substring ( i - 2 , i + 1 ) . compareTo ( ans ) > 0 ) ans = num . substring ( i - 2 , i + 1 ) ; return ans ; } }
class Solution { public int averageOfSubtree ( TreeNode root ) { dfs ( root ) ; return ans ; } private int ans = 0 ; private Pair < Integer , Integer > dfs ( TreeNode root ) { if ( root == null ) return new Pair < > ( 0 , 0 ) ; Pair < Integer , Integer > left = dfs ( root . left ) ; Pair < Integer , Integer > right = dfs ( root . right ) ; final int sum = root . val + left . getKey ( ) + right . getKey ( ) ; final int count = 1 + left . getValue ( ) + right . getValue ( ) ; if ( sum / count == root . val ) ++ ans ; return new Pair < > ( sum , count ) ; } }
class Solution { public int countTexts ( String pressedKeys ) { final int kMod = 1_000_000_007 ; final int n = pressedKeys . length ( ) ; long [ ] dp = new long [ n + 1 ] ; dp [ n ] = 1 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { dp [ i ] = dp [ i + 1 ] ; if ( isSame ( pressedKeys , i , 2 ) ) dp [ i ] += dp [ i + 2 ] ; if ( isSame ( pressedKeys , i , 3 ) ) dp [ i ] += dp [ i + 3 ] ; if ( ( pressedKeys . charAt ( i ) == '7' || pressedKeys . charAt ( i ) == '9' ) && isSame ( pressedKeys , i , 4 ) ) dp [ i ] += dp [ i + 4 ] ; dp [ i ] %= kMod ; } return ( int ) dp [ 0 ] ; } private boolean isSame ( final String s , int i , int k ) { if ( i + k > s . length ( ) ) return false ; for ( int j = i + 1 ; j < i + k ; ++ j ) if ( s . charAt ( j ) != s . charAt ( i ) ) return false ; return true ; } }
class Solution { public boolean hasValidPath ( char [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; dp = new Integer [ m ] [ n ] [ m + n ] ; return hasValidPath ( grid , 0 , 0 , 0 ) == 1 ? true : false ; } private Integer [ ] [ ] [ ] dp ; private int hasValidPath ( char [ ] [ ] grid , int i , int j , int k ) { if ( i == grid . length || j == grid [ 0 ] . length ) return 0 ; k += grid [ i ] [ j ] == ' ( ' ? 1 : - 1 ; if ( k < 0 ) return 0 ; if ( i == grid . length - 1 && j == grid [ 0 ] . length - 1 ) return k == 0 ? 1 : 0 ; if ( dp [ i ] [ j ] [ k ] != null ) return dp [ i ] [ j ] [ k ] ; return dp [ i ] [ j ] [ k ] = hasValidPath ( grid , i + 1 , j , k ) | hasValidPath ( grid , i , j + 1 , k ) ; } }
class Solution { public int minimumKeypresses ( String s ) { int ans = 0 ; Integer [ ] count = new Integer [ 26 ] ; Arrays . fill ( count , 0 ) ; for ( final char c : s . toCharArray ( ) ) ++ count [ c - ' a ' ] ; Arrays . sort ( count , ( a , b ) -> b - a ) ; for ( int i = 0 ; i < 26 ; ++ i ) ans += count [ i ] * ( i / 9 + 1 ) ; return ans ; } }
class Solution { public int divisorSubstrings ( int num , int k ) { final String s = String . valueOf ( num ) ; int ans = 0 ; for ( int i = 0 ; i + k <= s . length ( ) ; ++ i ) { final int x = Integer . parseInt ( s . substring ( i , i + k ) ) ; if ( x != 0 && num % x == 0 ) ++ ans ; } return ans ; } }
class Solution { public int calculate ( String s ) { Deque < Integer > nums = new ArrayDeque < > ( ) ; Deque < Character > ops = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { final char c = s . charAt ( i ) ; if ( Character . isDigit ( c ) ) { int num = c - '0' ; while ( i + 1 < s . length ( ) && Character . isDigit ( s . charAt ( i + 1 ) ) ) { num = num * 10 + ( s . charAt ( i + 1 ) - '0' ) ; ++ i ; } nums . push ( num ) ; } else if ( c == ' + ' || c == ' - ' || c == ' * ' || c == ' / ' ) { while ( ! ops . isEmpty ( ) && compare ( ops . peek ( ) , c ) ) nums . push ( calculate ( ops . pop ( ) , nums . pop ( ) , nums . pop ( ) ) ) ; ops . push ( c ) ; } } while ( ! ops . isEmpty ( ) ) nums . push ( calculate ( ops . pop ( ) , nums . pop ( ) , nums . pop ( ) ) ) ; return nums . peek ( ) ; } private int calculate ( char op , int b , int a ) { switch ( op ) { case ' + ' : return a + b ; case ' - ' : return a - b ; case ' * ' : return a * b ; case ' / ' : return a / b ; } throw new IllegalArgumentException ( ) ; } private boolean compare ( char op1 , char op2 ) { return op1 == ' * ' || op1 == ' / ' || op2 == ' + ' || op2 == ' - ' ; } }
class Solution { public int waysToSplitArray ( int [ ] nums ) { int ans = 0 ; long prefix = 0 ; long suffix = Arrays . stream ( nums ) . asLongStream ( ) . sum ( ) ; for ( int i = 0 ; i < nums . length - 1 ; ++ i ) { prefix += nums [ i ] ; suffix -= nums [ i ] ; if ( prefix >= suffix ) ++ ans ; } return ans ; } }
class Solution { public int maximumWhiteTiles ( int [ ] [ ] tiles , int carpetLen ) { if ( Arrays . stream ( tiles ) . anyMatch ( tile -> tile [ 1 ] - tile [ 0 ] + 1 >= carpetLen ) ) return carpetLen ; int ans = 0 ; List < Integer > starts = new ArrayList < > ( ) ; int [ ] prefix = new int [ tiles . length + 1 ] ; Arrays . sort ( tiles , ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; for ( int [ ] tile : tiles ) starts . add ( tile [ 0 ] ) ; for ( int i = 0 ; i < tiles . length ; ++ i ) { final int length = tiles [ i ] [ 1 ] - tiles [ i ] [ 0 ] + 1 ; prefix [ i + 1 ] = prefix [ i ] + length ; } for ( int i = 0 ; i < tiles . length ; ++ i ) { final int s = tiles [ i ] [ 0 ] ; final int carpetEnd = s + carpetLen - 1 ; final int endIndex = firstGreater ( starts , carpetEnd ) - 1 ; final int notCover = Math . max ( 0 , tiles [ endIndex ] [ 1 ] - carpetEnd ) ; ans = Math . max ( ans , prefix [ endIndex + 1 ] - prefix [ i ] - notCover ) ; } return ans ; } private int firstGreater ( List < Integer > A , int target ) { int l = 0 ; int r = A . size ( ) ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A . get ( m ) > target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public int largestVariance ( String s ) { int ans = 0 ; for ( char c1 = ' a ' ; c1 <= ' z ' ; ++ c1 ) for ( char c2 = ' a ' ; c2 <= ' z ' ; ++ c2 ) if ( c1 != c2 ) ans = Math . max ( ans , kadane ( s , c1 , c2 ) ) ; return ans ; } private int kadane ( final String s , char a , char b ) { int ans = 0 ; int countA = 0 ; int countB = 0 ; boolean canExtendPrevB = false ; for ( final char c : s . toCharArray ( ) ) { if ( c != a && c != b ) continue ; if ( c == a ) ++ countA ; else ++ countB ; if ( countB > 0 ) { ans = Math . max ( ans , countA - countB ) ; } else if ( countB == 0 && canExtendPrevB ) { ans = Math . max ( ans , countA - 1 ) ; } if ( countB > countA ) { countA = 0 ; countB = 0 ; canExtendPrevB = true ; } } return ans ; } }
class Solution { public List < String > removeAnagrams ( String [ ] words ) { List < String > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i < words . length ; ) { int j = i + 1 ; while ( j < words . length && isAnagram ( words [ i ] , words [ j ] ) ) ++ j ; ans . add ( words [ i ] ) ; i = j ; } return ans ; } private boolean isAnagram ( final String a , final String b ) { if ( a . length ( ) != b . length ( ) ) return false ; int [ ] count = new int [ 26 ] ; for ( final char c : a . toCharArray ( ) ) ++ count [ c - ' a ' ] ; for ( final char c : b . toCharArray ( ) ) -- count [ c - ' a ' ] ; return Arrays . stream ( count ) . allMatch ( c -> c == 0 ) ; } }
class Solution { public int maxConsecutive ( int bottom , int top , int [ ] special ) { int ans = 0 ; Arrays . sort ( special ) ; for ( int i = 1 ; i < special . length ; ++ i ) ans = Math . max ( ans , special [ i ] - special [ i - 1 ] - 1 ) ; return Math . max ( ans , Math . max ( special [ 0 ] - bottom , top - special [ special . length - 1 ] ) ) ; } }
class Solution { public int largestCombination ( int [ ] candidates ) { final int kMaxBit = 24 ; int ans = 0 ; for ( int i = 0 ; i < kMaxBit ; ++ i ) { int count = 0 ; for ( final int candidate : candidates ) if ( ( candidate >> i & 1 ) == 1 ) ++ count ; ans = Math . max ( ans , count ) ; } return ans ; } }
class CountIntervals { public void add ( int left , int right ) { while ( isOverlapped ( left , right ) ) { final int l = intervals . floorKey ( right ) ; final int r = intervals . get ( l ) ; left = Math . min ( left , l ) ; right = Math . max ( right , r ) ; intervals . remove ( l ) ; count -= r - l + 1 ; } intervals . put ( left , right ) ; count += right - left + 1 ; } public int count ( ) { return count ; } private TreeMap < Integer , Integer > intervals = new TreeMap < > ( ) ; private int count = 0 ; private boolean isOverlapped ( int left , int right ) { Integer l = intervals . floorKey ( right ) ; return l != null && intervals . get ( l ) >= left ; } }
class Solution { public int [ ] closestNode ( int n , int [ ] [ ] edges , int [ ] [ ] query ) { int [ ] ans = new int [ query . length ] ; List < Integer > [ ] graph = new List [ n ] ; int [ ] [ ] dist = new int [ n ] [ n ] ; Arrays . stream ( dist ) . forEach ( A -> Arrays . fill ( A , - 1 ) ) ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } for ( int i = 0 ; i < n ; ++ i ) fillDist ( graph , i , i , 0 , dist ) ; for ( int i = 0 ; i < query . length ; ++ i ) { final int start = query [ i ] [ 0 ] ; final int end = query [ i ] [ 1 ] ; final int node = query [ i ] [ 2 ] ; ans [ i ] = findClosest ( graph , dist , start , end , node , start ) ; } return ans ; } private void fillDist ( List < Integer > [ ] graph , int start , int u , int d , int [ ] [ ] dist ) { dist [ start ] [ u ] = d ; for ( final int v : graph [ u ] ) if ( dist [ start ] [ v ] == - 1 ) fillDist ( graph , start , v , d + 1 , dist ) ; } private int findClosest ( List < Integer > [ ] graph , int [ ] [ ] dist , int u , int end , int node , int ans ) { for ( final int v : graph [ u ] ) if ( dist [ v ] [ end ] < dist [ u ] [ end ] ) return findClosest ( graph , dist , v , end , node , dist [ ans ] [ node ] < dist [ v ] [ node ] ? ans : v ) ; return ans ; } }
class Solution { public int percentageLetter ( String s , char letter ) { return 100 * ( int ) s . chars ( ) . filter ( c -> c == letter ) . count ( ) / s . length ( ) ; } }
class Solution { public int maximumBags ( int [ ] capacity , int [ ] rocks , int additionalRocks ) { final int n = capacity . length ; int [ ] diff = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) diff [ i ] = capacity [ i ] - rocks [ i ] ; Arrays . sort ( diff ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( diff [ i ] > additionalRocks ) return i ; additionalRocks -= diff [ i ] ; } return n ; } }
class Solution { public List < String > summaryRanges ( int [ ] nums ) { List < String > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { final int begin = nums [ i ] ; while ( i + 1 < nums . length && nums [ i ] == nums [ i + 1 ] - 1 ) ++ i ; final int end = nums [ i ] ; if ( begin == end ) ans . add ( " " + begin ) ; else ans . add ( " " + begin + " - > " + end ) ; } return ans ; } }
class Solution { public int minimumLines ( int [ ] [ ] stockPrices ) { int ans = 0 ; Arrays . sort ( stockPrices , ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; for ( int i = 2 ; i < stockPrices . length ; ++ i ) { Pair < Integer , Integer > a = getSlope ( stockPrices [ i - 2 ] , stockPrices [ i - 1 ] ) ; Pair < Integer , Integer > b = getSlope ( stockPrices [ i - 1 ] , stockPrices [ i ] ) ; if ( a . getKey ( ) != b . getKey ( ) || a . getValue ( ) != b . getValue ( ) ) ++ ans ; } return ans + ( stockPrices . length > 1 ? 1 : 0 ) ; } private Pair < Integer , Integer > getSlope ( int [ ] p , int [ ] q ) { final int dx = p [ 0 ] - q [ 0 ] ; final int dy = p [ 1 ] - q [ 1 ] ; if ( dx == 0 ) return new Pair < > ( 0 , p [ 0 ] ) ; if ( dy == 0 ) return new Pair < > ( p [ 1 ] , 0 ) ; final int d = gcd ( dx , dy ) ; return new Pair < > ( dx / d , dy / d ) ; } private int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } }
class Solution { public int totalStrength ( int [ ] strength ) { final int kMod = 1_000_000_007 ; final int n = strength . length ; long [ ] prefix = new long [ n ] ; long [ ] prefixOfPrefix = new long [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) prefix [ i ] = i == 0 ? strength [ 0 ] : ( strength [ i ] + prefix [ i - 1 ] ) % kMod ; for ( int i = 0 ; i < n ; ++ i ) prefixOfPrefix [ i + 1 ] = ( prefixOfPrefix [ i ] + prefix [ i ] ) % kMod ; int [ ] left = new int [ n ] ; Arrays . fill ( left , - 1 ) ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { while ( ! stack . isEmpty ( ) && strength [ stack . peek ( ) ] >= strength [ i ] ) left [ stack . pop ( ) ] = i ; stack . push ( i ) ; } int [ ] right = new int [ n ] ; Arrays . fill ( right , n ) ; stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! stack . isEmpty ( ) && strength [ stack . peek ( ) ] > strength [ i ] ) right [ stack . pop ( ) ] = i ; stack . push ( i ) ; } long ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { final int l = left [ i ] ; final int r = right [ i ] ; final long leftSum = prefixOfPrefix [ i ] - prefixOfPrefix [ Math . max ( 0 , l ) ] ; final long rightSum = prefixOfPrefix [ r ] - prefixOfPrefix [ i ] ; final int leftLen = i - l ; final int rightLen = r - i ; ans += strength [ i ] * ( rightSum * leftLen % kMod - leftSum * rightLen % kMod + kMod ) % kMod ; ans %= kMod ; } return ( int ) ans ; } }
class Solution { public int [ ] [ ] seePeople ( int [ ] [ ] heights ) { final int m = heights . length ; final int n = heights [ 0 ] . length ; int [ ] [ ] ans = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; ++ i ) { Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int j = 0 ; j < n ; ++ j ) { boolean hasEqualHeight = false ; while ( ! stack . isEmpty ( ) && heights [ i ] [ stack . peek ( ) ] <= heights [ i ] [ j ] ) { if ( heights [ i ] [ stack . peek ( ) ] == heights [ i ] [ j ] ) hasEqualHeight = true ; ++ ans [ i ] [ stack . pop ( ) ] ; } if ( ! stack . isEmpty ( ) && ! hasEqualHeight ) ++ ans [ i ] [ stack . peek ( ) ] ; stack . push ( j ) ; } } for ( int j = 0 ; j < n ; ++ j ) { Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < m ; ++ i ) { boolean hasEqualHeight = false ; while ( ! stack . isEmpty ( ) && heights [ stack . peek ( ) ] [ j ] <= heights [ i ] [ j ] ) { if ( heights [ stack . peek ( ) ] [ j ] == heights [ i ] [ j ] ) hasEqualHeight = true ; ++ ans [ stack . pop ( ) ] [ j ] ; } if ( ! stack . isEmpty ( ) && ! hasEqualHeight ) ++ ans [ stack . peek ( ) ] [ j ] ; stack . push ( i ) ; } } return ans ; } }
class Solution { public boolean digitCount ( String num ) { int [ ] count = new int [ 10 ] ; for ( final char c : num . toCharArray ( ) ) ++ count [ c - '0' ] ; for ( int i = 0 ; i < num . length ( ) ; ++ i ) if ( count [ i ] != num . charAt ( i ) - '0' ) return false ; return true ; } }
class Solution { public String largestWordCount ( String [ ] messages , String [ ] senders ) { final int n = messages . length ; String ans = " " ; int maxWordsSent = 0 ; Map < String , Integer > count = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { final String message = messages [ i ] ; final String sender = senders [ i ] ; final int wordsCount = ( int ) message . chars ( ) . filter ( c -> c == ' ▁ ' ) . count ( ) + 1 ; count . merge ( sender , wordsCount , Integer :: sum ) ; final int numWordsSent = count . get ( sender ) ; if ( numWordsSent > maxWordsSent ) { ans = sender ; maxWordsSent = numWordsSent ; } else if ( numWordsSent == maxWordsSent && sender . compareTo ( ans ) > 0 ) { ans = sender ; } } return ans ; } }
class Solution { public long maximumImportance ( int n , int [ ] [ ] roads ) { long ans = 0 ; long [ ] count = new long [ n ] ; for ( int [ ] r : roads ) { ++ count [ r [ 0 ] ] ; ++ count [ r [ 1 ] ] ; } Arrays . sort ( count ) ; for ( int i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * count [ i ] ; return ans ; } }
class Solution { public int rearrangeCharacters ( String s , String target ) { int ans = s . length ( ) ; int [ ] countS = new int [ 128 ] ; int [ ] countT = new int [ 128 ] ; for ( final char c : s . toCharArray ( ) ) ++ countS [ c ] ; for ( final char c : target . toCharArray ( ) ) ++ countT [ c ] ; for ( final char c : target . toCharArray ( ) ) ans = Math . min ( ans , countS [ c ] / countT [ c ] ) ; return ans ; } }
class Solution { public String discountPrices ( String sentence , int discount ) { final int kPrecision = 2 ; StringBuilder sb = new StringBuilder ( ) ; for ( final String word : sentence . split ( " ▁ " ) ) if ( word . charAt ( 0 ) == ' $ ' && word . length ( ) > 1 ) { final String digits = word . substring ( 1 ) ; if ( digits . chars ( ) . allMatch ( c -> Character . isDigit ( c ) ) ) { final double val = Double . parseDouble ( digits ) * ( 100 - discount ) / 100 ; final String s = String . format ( " % .2f " , val ) ; final String trimmed = s . substring ( 0 , s . indexOf ( " . " ) + kPrecision + 1 ) ; sb . append ( " $ " ) . append ( trimmed ) . append ( " ▁ " ) ; } else { sb . append ( word ) . append ( " ▁ " ) ; } } else { sb . append ( word ) . append ( " ▁ " ) ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; return sb . toString ( ) ; } }
class Solution { public int totalSteps ( int [ ] nums ) { int [ ] dp = new int [ nums . length ] ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { int step = 1 ; while ( ! stack . isEmpty ( ) && nums [ stack . peek ( ) ] <= nums [ i ] ) step = Math . max ( step , dp [ stack . pop ( ) ] + 1 ) ; if ( ! stack . isEmpty ( ) ) dp [ i ] = step ; stack . push ( i ) ; } return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; } }
class Solution { public List < Integer > majorityElement ( int [ ] nums ) { List < Integer > ans = new ArrayList < > ( ) ; int candidate1 = 0 ; int candidate2 = 1 ; int countSoFar1 = 0 ; int countSoFar2 = 0 ; for ( final int num : nums ) if ( num == candidate1 ) { ++ countSoFar1 ; } else if ( num == candidate2 ) { ++ countSoFar2 ; } else if ( countSoFar1 == 0 ) { candidate1 = num ; ++ countSoFar1 ; } else if ( countSoFar2 == 0 ) { candidate2 = num ; ++ countSoFar2 ; } else { -- countSoFar1 ; -- countSoFar2 ; } int count1 = 0 ; int count2 = 0 ; for ( final int num : nums ) if ( num == candidate1 ) ++ count1 ; else if ( num == candidate2 ) ++ count2 ; if ( count1 > nums . length / 3 ) ans . add ( candidate1 ) ; if ( count2 > nums . length / 3 ) ans . add ( candidate2 ) ; return ans ; } }
class Solution { public int minimumObstacles ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; Queue < int [ ] > minHeap = new PriorityQueue < > ( ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; int [ ] [ ] dist = new int [ m ] [ n ] ; Arrays . stream ( dist ) . forEach ( A -> Arrays . fill ( A , Integer . MAX_VALUE ) ) ; minHeap . offer ( new int [ ] { grid [ 0 ] [ 0 ] , 0 , 0 } ) ; dist [ 0 ] [ 0 ] = grid [ 0 ] [ 0 ] ; while ( ! minHeap . isEmpty ( ) ) { final int d = minHeap . peek ( ) [ 0 ] ; final int i = minHeap . peek ( ) [ 1 ] ; final int j = minHeap . poll ( ) [ 2 ] ; if ( i == m - 1 && j == n - 1 ) return d ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; final int newDist = d + grid [ i ] [ j ] ; if ( newDist < dist [ x ] [ y ] ) { dist [ x ] [ y ] = newDist ; minHeap . offer ( new int [ ] { newDist , x , y } ) ; } } } return dist [ m - 1 ] [ n - 1 ] ; } }
class Solution { public int maximumProfit ( int [ ] present , int [ ] future , int budget ) { final int n = present . length ; int [ ] [ ] dp = new int [ n + 1 ] [ budget + 1 ] ; for ( int i = 1 ; i <= n ; ++ i ) { final int profit = future [ i - 1 ] - present [ i - 1 ] ; for ( int j = 0 ; j <= budget ; ++ j ) if ( j < present [ i - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , profit + dp [ i - 1 ] [ j - present [ i - 1 ] ] ) ; } return dp [ n ] [ budget ] ; } }
class Solution { public int minMaxGame ( int [ ] nums ) { if ( nums . length == 1 ) return nums [ 0 ] ; int [ ] nextNums = new int [ nums . length / 2 ] ; for ( int i = 0 ; i < nextNums . length ; ++ i ) nextNums [ i ] = ( i & 1 ) == 1 ? Math . max ( nums [ 2 * i ] , nums [ 2 * i + 1 ] ) : Math . min ( nums [ 2 * i ] , nums [ 2 * i + 1 ] ) ; return minMaxGame ( nextNums ) ; } }
class Solution { public int partitionArray ( int [ ] nums , int k ) { Arrays . sort ( nums ) ; int ans = 1 ; int min = nums [ 0 ] ; for ( int i = 1 ; i < nums . length ; ++ i ) if ( min + k < nums [ i ] ) { ++ ans ; min = nums [ i ] ; } return ans ; } }
class Solution { public int [ ] arrayChange ( int [ ] nums , int [ ] [ ] operations ) { Map < Integer , Integer > numToIndex = new HashMap < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) numToIndex . put ( nums [ i ] , i ) ; for ( int [ ] o : operations ) { final int original = o [ 0 ] ; final int replaced = o [ 1 ] ; final int index = numToIndex . get ( original ) ; nums [ index ] = replaced ; numToIndex . remove ( original ) ; numToIndex . put ( replaced , index ) ; } return nums ; } }
class TextEditor { public void addText ( String text ) { sb . append ( text ) ; } public int deleteText ( int k ) { final int numDeleted = Math . min ( k , sb . length ( ) ) ; for ( int i = 0 ; i < numDeleted ; ++ i ) sb . deleteCharAt ( sb . length ( ) - 1 ) ; return numDeleted ; } public String cursorLeft ( int k ) { while ( ! sb . isEmpty ( ) && k -- > 0 ) { stack . push ( sb . charAt ( sb . length ( ) - 1 ) ) ; sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return getString ( ) ; } public String cursorRight ( int k ) { while ( ! stack . isEmpty ( ) && k -- > 0 ) sb . append ( stack . pop ( ) ) ; return getString ( ) ; } private String getString ( ) { if ( sb . length ( ) < 10 ) return sb . toString ( ) ; return sb . substring ( sb . length ( ) - 10 ) . toString ( ) ; } private StringBuilder sb = new StringBuilder ( ) ; private Deque < Character > stack = new ArrayDeque < > ( ) ; }
class Solution { public long minCost ( int [ ] nums , int [ ] costs ) { final int n = nums . length ; long [ ] dp = new long [ n ] ; Deque < Integer > maxStack = new ArrayDeque < > ( ) ; Deque < Integer > minStack = new ArrayDeque < > ( ) ; Arrays . fill ( dp , Long . MAX_VALUE ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! maxStack . isEmpty ( ) && nums [ i ] >= nums [ maxStack . peek ( ) ] ) dp [ i ] = Math . min ( dp [ i ] , dp [ maxStack . pop ( ) ] + costs [ i ] ) ; while ( ! minStack . isEmpty ( ) && nums [ i ] < nums [ minStack . peek ( ) ] ) dp [ i ] = Math . min ( dp [ i ] , dp [ minStack . pop ( ) ] + costs [ i ] ) ; maxStack . push ( i ) ; minStack . push ( i ) ; } return dp [ n - 1 ] ; } }
class Solution { public boolean strongPasswordCheckerII ( String password ) { if ( password . length ( ) < 8 ) return false ; final boolean hasLowerCase = password . chars ( ) . anyMatch ( c -> Character . isLowerCase ( c ) ) ; if ( ! hasLowerCase ) return false ; final boolean hasUpperCase = password . chars ( ) . anyMatch ( c -> Character . isUpperCase ( c ) ) ; if ( ! hasUpperCase ) return false ; final boolean hasDigit = password . chars ( ) . anyMatch ( c -> Character . isDigit ( c ) ) ; if ( ! hasDigit ) return false ; final boolean hasSpecial = password . chars ( ) . anyMatch ( c -> " ! @ # $ % ^ & * ( ) - + " . indexOf ( c ) != - 1 ) ; if ( ! hasSpecial ) return false ; for ( int i = 1 ; i < password . length ( ) ; ++ i ) if ( password . charAt ( i ) == password . charAt ( i - 1 ) ) return false ; return true ; } }
class Solution { public ListNode mergeKLists ( ListNode [ ] lists ) { ListNode dummy = new ListNode ( 0 ) ; ListNode curr = dummy ; Queue < ListNode > minHeap = new PriorityQueue < > ( ( a , b ) -> a . val - b . val ) ; for ( final ListNode list : lists ) if ( list != null ) minHeap . offer ( list ) ; while ( ! minHeap . isEmpty ( ) ) { ListNode minNode = minHeap . poll ( ) ; if ( minNode . next != null ) minHeap . offer ( minNode . next ) ; curr . next = minNode ; curr = curr . next ; } return dummy . next ; } }
class Solution { public int kthSmallest ( TreeNode root , int k ) { final int leftCount = countNodes ( root . left ) ; if ( leftCount == k - 1 ) return root . val ; if ( leftCount >= k ) return kthSmallest ( root . left , k ) ; return kthSmallest ( root . right , k - 1 - leftCount ) ; } private int countNodes ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + countNodes ( root . left ) + countNodes ( root . right ) ; } }
class Solution { public int [ ] successfulPairs ( int [ ] spells , int [ ] potions , long success ) { int [ ] ans = new int [ spells . length ] ; Arrays . sort ( potions ) ; for ( int i = 0 ; i < spells . length ; ++ i ) ans [ i ] = potions . length - firstIndexSuccess ( spells [ i ] , potions , success ) ; return ans ; } private int firstIndexSuccess ( int spell , int [ ] potions , long success ) { int l = 0 ; int r = potions . length ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( ( long ) spell * potions [ m ] >= success ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public boolean matchReplacement ( String s , String sub , char [ ] [ ] mappings ) { boolean [ ] [ ] isMapped = new boolean [ 128 ] [ 128 ] ; for ( char [ ] m : mappings ) isMapped [ m [ 0 ] ] [ m [ 1 ] ] = true ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( canTransform ( s , i , sub , isMapped ) ) return true ; return false ; } private boolean canTransform ( final String s , int start , final String sub , boolean [ ] [ ] isMapped ) { if ( start + sub . length ( ) > s . length ( ) ) return false ; for ( int i = 0 ; i < sub . length ( ) ; ++ i ) { final char a = sub . charAt ( i ) ; final char b = s . charAt ( start + i ) ; if ( a != b && ! isMapped [ a ] [ b ] ) return false ; } return true ; } }
class Solution { public long countSubarrays ( int [ ] nums , long k ) { long ans = 0 ; long sum = 0 ; for ( int l = 0 , r = 0 ; r < nums . length ; ++ r ) { sum += nums [ r ] ; while ( sum * ( r - l + 1 ) >= k ) sum -= nums [ l ++ ] ; ans += r - l + 1 ; } return ans ; } }
class Solution { public double calculateTax ( int [ ] [ ] brackets , int income ) { double ans = 0 ; int prev = 0 ; for ( int [ ] b : brackets ) { final int upper = b [ 0 ] ; final int percent = b [ 1 ] ; if ( income < upper ) return ans + ( income - prev ) * percent / 100.0 ; ans += ( upper - prev ) * percent / 100.0 ; prev = upper ; } return ans ; } }
class Solution { public int minPathCost ( int [ ] [ ] grid , int [ ] [ ] moveCost ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int [ ] [ ] dp = new int [ m ] [ n ] ; Arrays . stream ( dp ) . forEach ( A -> Arrays . fill ( A , Integer . MAX_VALUE ) ) ; dp [ 0 ] = grid [ 0 ] ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) for ( int k = 0 ; k < n ; ++ k ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + moveCost [ grid [ i - 1 ] [ k ] ] [ j ] + grid [ i ] [ j ] ) ; return Arrays . stream ( dp [ m - 1 ] ) . min ( ) . getAsInt ( ) ; } }
class Solution { public int distributeCookies ( int [ ] cookies , int k ) { dfs ( cookies , 0 , k , new int [ k ] ) ; return ans ; } private int ans = Integer . MAX_VALUE ; private void dfs ( int [ ] cookies , int s , int k , int [ ] children ) { if ( s == cookies . length ) { ans = Math . min ( ans , Arrays . stream ( children ) . max ( ) . getAsInt ( ) ) ; return ; } for ( int i = 0 ; i < k ; ++ i ) { children [ i ] += cookies [ s ] ; dfs ( cookies , s + 1 , k , children ) ; children [ i ] -= cookies [ s ] ; } } }
class Solution { public long distinctNames ( String [ ] ideas ) { long ans = 0 ; Set < String > [ ] suffixes = new Set [ 26 ] ; for ( int i = 0 ; i < 26 ; ++ i ) suffixes [ i ] = new HashSet < > ( ) ; for ( final String idea : ideas ) suffixes [ idea . charAt ( 0 ) - ' a ' ] . add ( idea . substring ( 1 ) ) ; for ( int i = 0 ; i < 25 ; ++ i ) for ( int j = i + 1 ; j < 26 ; ++ j ) { int count = 0 ; for ( final String suffix : suffixes [ i ] ) if ( suffixes [ j ] . contains ( suffix ) ) ++ count ; ans += 2 * ( suffixes [ i ] . size ( ) - count ) * ( suffixes [ j ] . size ( ) - count ) ; } return ans ; } }
class Solution { public boolean checkContradictions ( List < List < String > > equations , double [ ] values ) { Map < String , Integer > strToInt = new HashMap < > ( ) ; for ( List < String > e : equations ) { strToInt . putIfAbsent ( e . get ( 0 ) , strToInt . size ( ) ) ; strToInt . putIfAbsent ( e . get ( 1 ) , strToInt . size ( ) ) ; } List < Pair < Integer , Double > > [ ] graph = new List [ strToInt . size ( ) ] ; double [ ] seen = new double [ graph . length ] ; for ( int i = 0 ; i < graph . length ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < equations . size ( ) ; ++ i ) { final int u = strToInt . get ( equations . get ( i ) . get ( 0 ) ) ; final int v = strToInt . get ( equations . get ( i ) . get ( 1 ) ) ; graph [ u ] . add ( new Pair < > ( v , values [ i ] ) ) ; graph [ v ] . add ( new Pair < > ( u , 1 / values [ i ] ) ) ; } for ( int i = 0 ; i < graph . length ; ++ i ) if ( seen [ i ] != 0.0 && dfs ( graph , i , seen , 1.0 ) ) return true ; return false ; } private boolean dfs ( List < Pair < Integer , Double > > [ ] graph , int u , double [ ] seen , double val ) { if ( seen [ u ] != 0.0 ) return Math . abs ( val / seen [ u ] - 1 ) > 1e-5 ; seen [ u ] = val ; for ( Pair < Integer , Integer > node : graph [ u ] ) { final int v = node . getKey ( ) ; final double w = node . getValue ( ) ; if ( dfs ( graph , v , seen , val / w ) ) return true ; } return false ; } }
class Solution { public String greatestLetter ( String s ) { boolean [ ] seen = new boolean [ 128 ] ; for ( final char c : s . toCharArray ( ) ) seen [ c ] = true ; for ( int i = 25 ; i >= 0 ; -- i ) if ( seen [ ' a ' + i ] && seen [ ' A ' + i ] ) return String . valueOf ( ( char ) ( ' A ' + i ) ) ; return " " ; } }
class Solution { public boolean isPowerOfTwo ( int n ) { return n < 0 ? false : Integer . bitCount ( n ) == 1 ; } }
class Solution { public int minimumNumbers ( int num , int k ) { if ( num == 0 ) return 0 ; for ( int i = 1 ; i <= 10 && i * k <= num ; ++ i ) if ( i * k % 10 == num % 10 ) return i ; return - 1 ; } }
class Solution { public int longestSubsequence ( String s , int k ) { int oneCount = 0 ; int num = 0 ; int pow = 1 ; for ( int i = s . length ( ) - 1 ; i >= 0 && num + pow <= k ; -- i ) { if ( s . charAt ( i ) == '1' ) { ++ oneCount ; num += pow ; } pow *= 2 ; } return ( int ) s . chars ( ) . filter ( c -> c == '0' ) . count ( ) + oneCount ; } }
class Solution { public long sellingWood ( int m , int n , int [ ] [ ] prices ) { long [ ] [ ] dp = new long [ m + 1 ] [ n + 1 ] ; for ( int [ ] p : prices ) dp [ p [ 0 ] ] [ p [ 1 ] ] = p [ 2 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) { for ( int h = 1 ; h <= i / 2 ; ++ h ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ h ] [ j ] + dp [ i - h ] [ j ] ) ; for ( int w = 1 ; w <= j / 2 ; ++ w ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ w ] + dp [ i ] [ j - w ] ) ; } return dp [ m ] [ n ] ; } }
class Solution { public int countAsterisks ( String s ) { int ans = 0 ; int bars = 0 ; for ( final char c : s . toCharArray ( ) ) { if ( c == ' | ' ) ++ bars ; else if ( c == ' * ' && bars % 2 == 0 ) ++ ans ; } return ans ; } }
class Solution { public long countPairs ( int n , int [ ] [ ] edges ) { long ans = 0 ; List < Integer > [ ] graph = new List [ n ] ; boolean [ ] seen = new boolean [ n ] ; int unreached = n ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } for ( int i = 0 ; i < n ; ++ i ) { final int reached = dfs ( graph , i , seen ) ; unreached -= reached ; ans += ( long ) unreached * reached ; } return ans ; } private int dfs ( List < Integer > [ ] graph , int u , boolean [ ] seen ) { if ( seen [ u ] ) return 0 ; seen [ u ] = true ; int ans = 1 ; for ( final int v : graph [ u ] ) ans += dfs ( graph , v , seen ) ; return ans ; } }
class Solution { public int maximumXOR ( int [ ] nums ) { int ans = 0 ; for ( final int num : nums ) ans |= num ; return ans ; } }
class Solution { public int distinctSequences ( int n ) { dp = new int [ n + 1 ] [ 7 ] [ 7 ] ; return distinctSequences ( n , 0 , 0 ) ; } private static final int kMod = 1_000_000_007 ; private int [ ] [ ] [ ] dp ; private int distinctSequences ( int n , int prev , int prevPrev ) { if ( n == 0 ) return 1 ; if ( dp [ n ] [ prev ] [ prevPrev ] > 0 ) return dp [ n ] [ prev ] [ prevPrev ] ; for ( int dice = 1 ; dice <= 6 ; ++ dice ) if ( dice != prev && dice != prevPrev && ( prev == 0 || gcd ( dice , prev ) == 1 ) ) { dp [ n ] [ prev ] [ prevPrev ] += distinctSequences ( n - 1 , dice , prev ) ; dp [ n ] [ prev ] [ prevPrev ] %= kMod ; } return dp [ n ] [ prev ] [ prevPrev ] ; } private int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } }
class Solution { public boolean checkXMatrix ( int [ ] [ ] grid ) { final int n = grid . length ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( i == j || i + j == n - 1 ) { if ( grid [ i ] [ j ] == 0 ) return false ; } else if ( grid [ i ] [ j ] > 0 ) { return false ; } return true ; } }
class MyQueue { public void push ( int x ) { input . push ( x ) ; } public int pop ( ) { peek ( ) ; return output . pop ( ) ; } public int peek ( ) { if ( output . isEmpty ( ) ) while ( ! input . isEmpty ( ) ) output . push ( input . pop ( ) ) ; return output . peek ( ) ; } public boolean empty ( ) { return input . isEmpty ( ) && output . isEmpty ( ) ; } private Deque < Integer > input = new ArrayDeque < > ( ) ; private Deque < Integer > output = new ArrayDeque < > ( ) ; }
class Solution { public int countHousePlacements ( int n ) { final int kMod = 1_000_000_007 ; int house = 1 ; int space = 1 ; int total = house + space ; for ( int i = 2 ; i <= n ; ++ i ) { house = space ; space = total ; total = ( house + space ) % kMod ; } return ( int ) ( ( long ) total * total % kMod ) ; } }
class Solution { public int maximumsSplicedArray ( int [ ] nums1 , int [ ] nums2 ) { return Math . max ( kadane ( nums1 , nums2 ) , kadane ( nums2 , nums1 ) ) ; } private int kadane ( int [ ] nums1 , int [ ] nums2 ) { int gain = 0 ; int maxGain = 0 ; for ( int i = 0 ; i < nums1 . length ; ++ i ) { gain = Math . max ( 0 , gain + nums2 [ i ] - nums1 [ i ] ) ; maxGain = Math . max ( maxGain , gain ) ; } return maxGain + Arrays . stream ( nums1 ) . sum ( ) ; } }
class Solution { public int minimumScore ( int [ ] nums , int [ ] [ ] edges ) { final int n = nums . length ; final int xors = getXors ( nums ) ; int [ ] subXors = nums . clone ( ) ; List < Integer > [ ] graph = new List [ n ] ; Set < Integer > [ ] children = new Set [ n ] ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) children [ i ] = new HashSet < > ( Arrays . asList ( i ) ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } dfs ( graph , 0 , - 1 , subXors , children ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < edges . length ; ++ i ) { int a = edges [ i ] [ 0 ] ; int b = edges [ i ] [ 1 ] ; if ( children [ a ] . contains ( b ) ) { final int temp = a ; a = b ; b = a ; } for ( int j = 0 ; j < i ; ++ j ) { int c = edges [ j ] [ 0 ] ; int d = edges [ j ] [ 1 ] ; if ( children [ c ] . contains ( d ) ) { final int temp = c ; c = d ; d = temp ; } int [ ] cands ; if ( a != c && children [ a ] . contains ( c ) ) cands = new int [ ] { subXors [ c ] , subXors [ a ] ^ subXors [ c ] , xors ^ subXors [ a ] } ; else if ( a != c && children [ c ] . contains ( a ) ) cands = new int [ ] { subXors [ a ] , subXors [ c ] ^ subXors [ a ] , xors ^ subXors [ c ] } ; else cands = new int [ ] { subXors [ a ] , subXors [ c ] , xors ^ subXors [ a ] ^ subXors [ c ] } ; ans = Math . min ( ans , Arrays . stream ( cands ) . max ( ) . getAsInt ( ) - Arrays . stream ( cands ) . min ( ) . getAsInt ( ) ) ; } } return ans ; } private Pair < Integer , Set < Integer > > dfs ( List < Integer > [ ] graph , int u , int parent , int [ ] subXors , Set < Integer > [ ] children ) { for ( final int v : graph [ u ] ) { if ( v == parent ) continue ; final Pair < Integer , Set < Integer > > pair = dfs ( graph , v , u , subXors , children ) ; final int vXor = pair . getKey ( ) ; final Set < Integer > vChildren = pair . getValue ( ) ; subXors [ u ] ^= vXor ; for ( final int child : vChildren ) children [ u ] . add ( child ) ; } return new Pair < > ( subXors [ u ] , children [ u ] ) ; } private int getXors ( int [ ] nums ) { int xors = 0 ; for ( final int num : nums ) xors ^= num ; return xors ; } }
class Solution { public int minimumTime ( int [ ] jobs , int [ ] workers ) { int ans = 0 ; Arrays . sort ( jobs ) ; Arrays . sort ( workers ) ; for ( int i = 0 ; i < jobs . length ; ++ i ) ans = Math . max ( ans , ( jobs [ i ] - 1 ) / workers [ i ] + 1 ) ; return ans ; } }
class Solution { public String decodeMessage ( String key , String message ) { StringBuilder sb = new StringBuilder ( ) ; char [ ] keyToActual = new char [ 128 ] ; keyToActual [ ' ▁ ' ] = ' ▁ ' ; char currChar = ' a ' ; for ( final char c : key . toCharArray ( ) ) if ( keyToActual [ c ] == 0 ) keyToActual [ c ] = currChar ++ ; for ( final char c : message . toCharArray ( ) ) sb . append ( keyToActual [ c ] ) ; return sb . toString ( ) ; } }
class Solution { public int [ ] [ ] spiralMatrix ( int m , int n , ListNode head ) { final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; int [ ] [ ] ans = new int [ m ] [ n ] ; Arrays . stream ( ans ) . forEach ( A -> Arrays . fill ( A , - 1 ) ) ; int x = 0 ; int y = 0 ; int d = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) { ans [ x ] [ y ] = curr . val ; if ( x + dirs [ d ] < 0 || x + dirs [ d ] == m || y + dirs [ d + 1 ] < 0 || y + dirs [ d + 1 ] == n || ans [ x + dirs [ d ] ] [ y + dirs [ d + 1 ] ] != - 1 ) d = ( d + 1 ) % 4 ; x += dirs [ d ] ; y += dirs [ d + 1 ] ; } return ans ; } }
class Solution { public int peopleAwareOfSecret ( int n , int delay , int forget ) { final int kMod = 1_000_000_007 ; long share = 0 ; int [ ] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) { if ( i - delay >= 0 ) share += dp [ i - delay ] ; if ( i - forget >= 0 ) share -= dp [ i - forget ] ; share += kMod ; share %= kMod ; dp [ i ] = ( int ) share ; } int ans = 0 ; for ( int i = n - forget ; i < n ; ++ i ) ans = ( ans + dp [ i ] ) % kMod ; return ans ; } }
class Solution { public int countPaths ( int [ ] [ ] grid ) { m = grid . length ; n = grid [ 0 ] . length ; int ans = 0 ; dp = new int [ m ] [ n ] ; Arrays . stream ( dp ) . forEach ( A -> Arrays . fill ( A , - 1 ) ) ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { ans += dfs ( grid , i , j ) ; ans %= kMod ; } return ans ; } private static final int kMod = 1_000_000_007 ; private final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; private int m ; private int n ; private int [ ] [ ] dp ; private int dfs ( int [ ] [ ] grid , int i , int j ) { if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; dp [ i ] [ j ] = 1 ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( grid [ x ] [ y ] <= grid [ i ] [ j ] ) continue ; dp [ i ] [ j ] += dfs ( grid , x , y ) ; dp [ i ] [ j ] %= kMod ; } return dp [ i ] [ j ] ; } }
class Solution { public int countDigitOne ( int n ) { int ans = 0 ; for ( long pow10 = 1 ; pow10 <= n ; pow10 *= 10 ) { final long divisor = pow10 * 10 ; final int quotient = ( int ) ( n / divisor ) ; final int remainder = ( int ) ( n % divisor ) ; if ( quotient > 0 ) ans += quotient * pow10 ; if ( remainder >= pow10 ) ans += Math . min ( remainder - pow10 + 1 , pow10 ) ; } return ans ; } }
class Solution { public boolean makePalindrome ( String s ) { int change = 0 ; int l = 0 ; int r = s . length ( ) - 1 ; while ( l < r ) { if ( s . charAt ( l ) != s . charAt ( r ) && ++ change > 2 ) return false ; ++ l ; -- r ; } return true ; } }
class Solution { public boolean evaluateTree ( TreeNode root ) { if ( root . val < 2 ) return root . val == 1 ; if ( root . val == 2 ) return evaluateTree ( root . left ) || evaluateTree ( root . right ) ; return evaluateTree ( root . left ) && evaluateTree ( root . right ) ; } }
class Solution { public int latestTimeCatchTheBus ( int [ ] buses , int [ ] passengers , int capacity ) { Arrays . sort ( buses ) ; Arrays . sort ( passengers ) ; if ( passengers [ 0 ] > buses [ buses . length - 1 ] ) return buses [ buses . length - 1 ] ; int ans = passengers [ 0 ] - 1 ; int i = 0 ; int j = 0 ; while ( i < buses . length ) { int arrived = 0 ; while ( arrived < capacity && j < passengers . length && passengers [ j ] <= buses [ i ] ) { if ( j > 0 && passengers [ j ] != passengers [ j - 1 ] + 1 ) ans = passengers [ j ] - 1 ; ++ j ; ++ arrived ; } if ( arrived < capacity && j > 0 && passengers [ j - 1 ] != buses [ i ] ) ans = buses [ i ] ; ++ i ; } return ans ; } }
class Solution { public int validSubarraySize ( int [ ] nums , int threshold ) { final int n = nums . length ; long ans = 0 ; int [ ] prev = new int [ n ] ; int [ ] next = new int [ n ] ; Deque < Integer > stack = new ArrayDeque < > ( ) ; Arrays . fill ( prev , - 1 ) ; Arrays . fill ( next , n ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { while ( ! stack . isEmpty ( ) && nums [ stack . peek ( ) ] > nums [ i ] ) { final int index = stack . pop ( ) ; next [ index ] = i ; } if ( ! stack . isEmpty ( ) ) prev [ i ] = stack . peek ( ) ; stack . push ( i ) ; } for ( int i = 0 ; i < n ; ++ i ) { final int k = ( i - prev [ i ] ) + ( next [ i ] - i ) - 1 ; if ( nums [ i ] > threshold / ( double ) k ) return k ; } return - 1 ; } }
class Solution { public int fillCups ( int [ ] amount ) { final int max = Arrays . stream ( amount ) . max ( ) . getAsInt ( ) ; final int sum = Arrays . stream ( amount ) . sum ( ) ; return Math . max ( max , ( sum + 1 ) / 2 ) ; } }
class Solution { public boolean canChange ( String start , String target ) { final int n = start . length ( ) ; int i = 0 ; int j = 0 ; while ( i <= n && j <= n ) { while ( i < n && start . charAt ( i ) == ' _ ' ) ++ i ; while ( j < n && target . charAt ( j ) == ' _ ' ) ++ j ; if ( i == n || j == n ) return i == n && j == n ; if ( start . charAt ( i ) != target . charAt ( j ) ) return false ; if ( start . charAt ( i ) == ' R ' && i > j ) return false ; if ( start . charAt ( i ) == ' L ' && i < j ) return false ; ++ i ; ++ j ; } return true ; } }
class Solution { public boolean isPalindrome ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } if ( fast != null ) slow = slow . next ; slow = reverseList ( slow ) ; while ( slow != null ) { if ( slow . val != head . val ) return false ; slow = slow . next ; head = head . next ; } return true ; } private ListNode reverseList ( ListNode head ) { ListNode prev = null ; while ( head != null ) { ListNode next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } }
class Solution { public int minimumSwaps ( int [ ] nums ) { final int minIndex = getLeftmostMinIndex ( nums ) ; final int maxIndex = getRightmostMaxIndex ( nums ) ; final int swaps = minIndex + ( nums . length - 1 - maxIndex ) ; return minIndex <= maxIndex ? swaps : swaps - 1 ; } private int getLeftmostMinIndex ( int [ ] nums ) { int min = nums [ 0 ] ; int minIndex = 0 ; for ( int i = 1 ; i < nums . length ; ++ i ) if ( nums [ i ] < min ) { min = nums [ i ] ; minIndex = i ; } return minIndex ; } int getRightmostMaxIndex ( int [ ] nums ) { int max = nums [ nums . length - 1 ] ; int maxIndex = nums . length - 1 ; for ( int i = nums . length - 2 ; i >= 0 ; -- i ) if ( nums [ i ] > max ) { max = nums [ i ] ; maxIndex = i ; } return maxIndex ; } }
class Solution { public int [ ] numberOfPairs ( int [ ] nums ) { final int kMax = 100 ; int [ ] ans = new int [ 2 ] ; int [ ] count = new int [ kMax + 1 ] ; for ( final int num : nums ) ++ count [ num ] ; for ( int i = 0 ; i <= kMax ; ++ i ) { ans [ 0 ] += count [ i ] / 2 ; if ( count [ i ] % 2 == 1 ) ++ ans [ 1 ] ; } return ans ; } }
class Solution { public int maximumSum ( int [ ] nums ) { final int kMax = 9 * 9 ; int ans = - 1 ; List < Integer > [ ] count = new List [ kMax + 1 ] ; for ( int i = 0 ; i <= kMax ; ++ i ) count [ i ] = new ArrayList < > ( ) ; for ( final int num : nums ) count [ getSum ( num ) ] . add ( num ) ; for ( List < Integer > groupNums : count ) { if ( groupNums . size ( ) < 2 ) continue ; Collections . sort ( groupNums , Collections . reverseOrder ( ) ) ; ans = Math . max ( ans , groupNums . get ( 0 ) + groupNums . get ( 1 ) ) ; } return ans ; } private int getSum ( int num ) { int sum = 0 ; while ( num > 0 ) { sum += num % 10 ; num /= 10 ; } return sum ; } }
class Solution { public int minOperations ( int [ ] nums , int [ ] numsDivide ) { final int gcd = getGCD ( numsDivide ) ; Arrays . sort ( nums ) ; for ( int i = 0 ; i < nums . length ; ++ i ) if ( gcd % nums [ i ] == 0 ) return i ; return - 1 ; } private int getGCD ( int [ ] nums ) { int g = nums [ 0 ] ; for ( final int num : nums ) g = gcd ( g , num ) ; return g ; } int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } }
class Solution { public int visibleMountains ( int [ ] [ ] peaks ) { List < Pair < Integer , Integer > > A = deDuplicates ( peaks ) ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < A . size ( ) ; ++ i ) { while ( ! stack . isEmpty ( ) && isHidden ( A . get ( stack . peek ( ) ) , A . get ( i ) ) ) stack . pop ( ) ; if ( ! stack . isEmpty ( ) && isHidden ( A . get ( i ) , A . get ( stack . peek ( ) ) ) ) continue ; stack . push ( i ) ; } return stack . size ( ) ; } private List < Pair < Integer , Integer > > deDuplicates ( int [ ] [ ] peaks ) { List < Pair < Integer , Integer > > A = new ArrayList < > ( ) ; Map < Pair < Integer , Integer > , Integer > count = new HashMap < > ( ) ; for ( int [ ] peak : peaks ) count . merge ( new Pair < > ( peak [ 0 ] , peak [ 1 ] ) , 1 , Integer :: sum ) ; for ( Map . Entry < Pair < Integer , Integer > , Integer > entry : count . entrySet ( ) ) if ( entry . getValue ( ) == 1 ) A . add ( entry . getKey ( ) ) ; Collections . sort ( A , Comparator . comparing ( Pair :: getKey ) ) ; return A ; } boolean isHidden ( Pair < Integer , Integer > peak1 , Pair < Integer , Integer > peak2 ) { final int x1 = peak1 . getKey ( ) ; final int y1 = peak1 . getValue ( ) ; final int x2 = peak2 . getKey ( ) ; final int y2 = peak2 . getValue ( ) ; return x1 - y1 >= x2 - y2 && x1 + y1 <= x2 + y2 ; } }
class Solution { public String bestHand ( int [ ] ranks , char [ ] suits ) { if ( new String ( suits ) . chars ( ) . allMatch ( s -> s == suits [ 0 ] ) ) return " Flush " ; final int kMax = 13 ; int [ ] count = new int [ kMax + 1 ] ; for ( final int rank : ranks ) ++ count [ rank ] ; final int max = Arrays . stream ( count ) . max ( ) . getAsInt ( ) ; if ( max > 2 ) return " Three ▁ of ▁ a ▁ Kind " ; if ( max == 2 ) return " Pair " ; return " High ▁ Card " ; } }
class Solution { public long zeroFilledSubarray ( int [ ] nums ) { long ans = 0 ; int indexBeforeZero = - 1 ; for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] == 0 ) ans += i - indexBeforeZero ; else indexBeforeZero = i ; return ans ; } }
class NumberContainers { public void change ( int index , int number ) { if ( indexToNumbers . containsKey ( index ) ) { final int originalNumber = indexToNumbers . get ( index ) ; numberToIndices . get ( originalNumber ) . remove ( index ) ; if ( numberToIndices . get ( originalNumber ) . isEmpty ( ) ) numberToIndices . remove ( originalNumber ) ; } indexToNumbers . put ( index , number ) ; numberToIndices . putIfAbsent ( number , new TreeSet < > ( ) ) ; numberToIndices . get ( number ) . add ( index ) ; } public int find ( int number ) { if ( numberToIndices . containsKey ( number ) ) return numberToIndices . get ( number ) . first ( ) ; return - 1 ; } private Map < Integer , TreeSet < Integer > > numberToIndices = new HashMap < > ( ) ; private Map < Integer , Integer > indexToNumbers = new HashMap < > ( ) ; }
class Solution { public TreeNode lowestCommonAncestor ( TreeNode root , TreeNode p , TreeNode q ) { if ( root . val > Math . max ( p . val , q . val ) ) return lowestCommonAncestor ( root . left , p , q ) ; if ( root . val < Math . min ( p . val , q . val ) ) return lowestCommonAncestor ( root . right , p , q ) ; return root ; } }
class Solution { public int shortestSequence ( int [ ] rolls , int k ) { int ans = 1 ; Set < Integer > seen = new HashSet < > ( ) ; for ( final int roll : rolls ) { seen . add ( roll ) ; if ( seen . size ( ) == k ) { ++ ans ; seen . clear ( ) ; } } return ans ; } }
class Solution { public char repeatedCharacter ( String s ) { boolean [ ] seen = new boolean [ 26 ] ; for ( final char c : s . toCharArray ( ) ) { if ( seen [ c - ' a ' ] ) return c ; seen [ c - ' a ' ] = true ; } throw new IllegalArgumentException ( ) ; } }
class Solution { public int equalPairs ( int [ ] [ ] grid ) { final int n = grid . length ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int k = 0 ; for ( ; k < n ; ++ k ) if ( grid [ i ] [ k ] != grid [ k ] [ j ] ) break ; if ( k == n ) ++ ans ; } return ans ; } }
class FoodRatings { public FoodRatings ( String [ ] foods , String [ ] cuisines , int [ ] ratings ) { for ( int i = 0 ; i < foods . length ; ++ i ) { cuisineToRatingAndFoods . putIfAbsent ( cuisines [ i ] , new TreeSet < > ( ( a , b ) -> a . getKey ( ) . equals ( b . getKey ( ) ) ? a . getValue ( ) . compareTo ( b . getValue ( ) ) : b . getKey ( ) - a . getKey ( ) ) ) ; cuisineToRatingAndFoods . get ( cuisines [ i ] ) . add ( new Pair < > ( ratings [ i ] , foods [ i ] ) ) ; foodToCuisine . put ( foods [ i ] , cuisines [ i ] ) ; foodToRating . put ( foods [ i ] , ratings [ i ] ) ; } } public void changeRating ( String food , int newRating ) { final String cuisine = foodToCuisine . get ( food ) ; final int oldRating = foodToRating . get ( food ) ; TreeSet < Pair < Integer , String > > ratingAndFoods = cuisineToRatingAndFoods . get ( cuisine ) ; ratingAndFoods . remove ( new Pair < > ( oldRating , food ) ) ; ratingAndFoods . add ( new Pair < > ( newRating , food ) ) ; foodToRating . put ( food , newRating ) ; } public String highestRated ( String cuisine ) { return cuisineToRatingAndFoods . get ( cuisine ) . first ( ) . getValue ( ) ; } Map < String , TreeSet < Pair < Integer , String > > > cuisineToRatingAndFoods = new HashMap < > ( ) ; Map < String , String > foodToCuisine = new HashMap < > ( ) ; Map < String , Integer > foodToRating = new HashMap < > ( ) ; }
class Solution { public long countExcellentPairs ( int [ ] nums , int k ) { final int kMaxDigit = 30 ; long ans = 0 ; long [ ] count = new long [ kMaxDigit ] ; for ( final int num : Arrays . stream ( nums ) . boxed ( ) . collect ( Collectors . toSet ( ) ) ) ++ count [ Integer . bitCount ( num ) ] ; for ( int i = 0 ; i < kMaxDigit ; ++ i ) for ( int j = 0 ; j < kMaxDigit ; ++ j ) if ( i + j >= k ) ans += count [ i ] * count [ j ] ; return ans ; } }
class Solution { public long maximumBooks ( int [ ] books ) { long [ ] dp = new long [ books . length ] ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < books . length ; ++ i ) { while ( ! stack . isEmpty ( ) && books [ stack . peek ( ) ] >= books [ i ] - ( i - stack . peek ( ) ) ) stack . pop ( ) ; final int j = stack . isEmpty ( ) ? - 1 : stack . peek ( ) ; final int lastTook = books [ i ] - ( i - j ) + 1 ; if ( lastTook > 1 ) dp [ i ] = ( long ) ( books [ i ] + lastTook ) * ( i - j ) / 2 ; else dp [ i ] = ( long ) ( books [ i ] ) * ( books [ i ] + 1 ) / 2 ; if ( j >= 0 ) dp [ i ] += dp [ j ] ; stack . push ( i ) ; } return Arrays . stream ( dp ) . max ( ) . getAsLong ( ) ; } }
class Solution { public int minimumOperations ( int [ ] nums ) { Set < Integer > seen = Arrays . stream ( nums ) . boxed ( ) . collect ( Collectors . toSet ( ) ) ; return seen . size ( ) - ( seen . contains ( 0 ) ? 1 : 0 ) ; } }
class Solution { public int maximumGroups ( int [ ] grades ) { return ( int ) ( Math . sqrt ( grades . length * 2 + 0.25 ) - 0.5 ) ; } }
class Solution { public int closestMeetingNode ( int [ ] edges , int node1 , int node2 ) { final int kMax = 10000 ; final int [ ] dist1 = getDist ( edges , node1 ) ; final int [ ] dist2 = getDist ( edges , node2 ) ; int minDist = kMax ; int ans = - 1 ; for ( int i = 0 ; i < edges . length ; ++ i ) if ( Math . min ( dist1 [ i ] , dist2 [ i ] ) >= 0 ) { final int maxDist = Math . max ( dist1 [ i ] , dist2 [ i ] ) ; if ( maxDist < minDist ) { minDist = maxDist ; ans = i ; } } return ans ; } private int [ ] getDist ( int [ ] edges , int u ) { int [ ] dist = new int [ edges . length ] ; Arrays . fill ( dist , - 1 ) ; int d = 0 ; while ( u != - 1 && dist [ u ] == - 1 ) { dist [ u ] = d ++ ; u = edges [ u ] ; } return dist ; } }
class Solution { public TreeNode lowestCommonAncestor ( TreeNode root , TreeNode p , TreeNode q ) { if ( root == null || root == p || root == q ) return root ; TreeNode l = lowestCommonAncestor ( root . left , p , q ) ; TreeNode r = lowestCommonAncestor ( root . right , p , q ) ; if ( l != null && r != null ) return root ; return l == null ? r : l ; } }
class Solution { public int longestCycle ( int [ ] edges ) { int ans = - 1 ; int time = 1 ; int [ ] timeVisited = new int [ edges . length ] ; for ( int i = 0 ; i < edges . length ; ++ i ) { if ( timeVisited [ i ] > 0 ) continue ; final int startTime = time ; int u = i ; while ( u != - 1 && timeVisited [ u ] == 0 ) { timeVisited [ u ] = time ++ ; u = edges [ u ] ; } if ( u != - 1 && timeVisited [ u ] >= startTime ) ans = Math . max ( ans , time - timeVisited [ u ] ) ; } return ans ; } }
class Solution { public long [ ] minimumCosts ( int [ ] regular , int [ ] express , int expressCost ) { final int n = regular . length ; long [ ] ans = new long [ n ] ; long dpReg = 0 ; long dpExp = expressCost ; for ( int i = 0 ; i < n ; ++ i ) { final long prevReg = dpReg ; final long prevExp = dpExp ; dpReg = Math . min ( prevReg + regular [ i ] , prevExp + 0 + regular [ i ] ) ; dpExp = Math . min ( prevReg + expressCost + express [ i ] , prevExp + express [ i ] ) ; ans [ i ] = Math . min ( dpReg , dpExp ) ; } return ans ; } }
class Solution { public List < List < Integer > > mergeSimilarItems ( int [ ] [ ] items1 , int [ ] [ ] items2 ) { final int kMax = 1000 ; List < List < Integer > > ans = new ArrayList < > ( ) ; int [ ] count = new int [ kMax + 1 ] ; for ( int [ ] item : items1 ) count [ item [ 0 ] ] += item [ 1 ] ; for ( int [ ] item : items2 ) count [ item [ 0 ] ] += item [ 1 ] ; for ( int i = 1 ; i <= kMax ; ++ i ) if ( count [ i ] > 0 ) ans . add ( Arrays . asList ( i , count [ i ] ) ) ; return ans ; } }
class Solution { public long countBadPairs ( int [ ] nums ) { long ans = 0 ; Map < Integer , Long > count = new HashMap < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { ans += i - count . getOrDefault ( nums [ i ] - i , 0L ) ; count . merge ( nums [ i ] - i , 1L , Long :: sum ) ; } return ans ; } }
class Solution { public long taskSchedulerII ( int [ ] tasks , int space ) { Map < Integer , Long > taskToNextAvailable = new HashMap < > ( ) ; long ans = 0 ; for ( final int task : tasks ) { ans = Math . max ( ans + 1 , taskToNextAvailable . getOrDefault ( task , 0L ) ) ; taskToNextAvailable . put ( task , ans + space + 1 ) ; } return ans ; } }
class Solution { public long minimumReplacement ( int [ ] nums ) { long ans = 0 ; int max = nums [ nums . length - 1 ] ; for ( int i = nums . length - 2 ; i >= 0 ; -- i ) { final int ops = ( nums [ i ] - 1 ) / max ; ans += ops ; max = nums [ i ] / ( ops + 1 ) ; } return ans ; } }
class Solution { public int arithmeticTriplets ( int [ ] nums , int diff ) { final int kMax = 200 ; int ans = 0 ; boolean [ ] count = new boolean [ kMax + 1 ] ; for ( final int num : nums ) { if ( num >= 2 * diff && count [ num - diff ] && count [ num - 2 * diff ] ) ++ ans ; count [ num ] = true ; } return ans ; } }
class Solution { public int reachableNodes ( int n , int [ ] [ ] edges , int [ ] restricted ) { List < Integer > [ ] graph = new List [ n ] ; boolean [ ] seen = new boolean [ n ] ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } for ( final int r : restricted ) seen [ r ] = true ; return dfs ( graph , 0 , seen ) ; } private int dfs ( List < Integer > [ ] graph , int u , boolean [ ] seen ) { if ( seen [ u ] ) return 0 ; seen [ u ] = true ; int ans = 1 ; for ( final int v : graph [ u ] ) ans += dfs ( graph , v , seen ) ; return ans ; } }
class Solution { public boolean validPartition ( int [ ] nums ) { final int n = nums . length ; boolean [ ] dp = new boolean [ n + 1 ] ; dp [ 0 ] = true ; dp [ 2 ] = nums [ 0 ] == nums [ 1 ] ; for ( int i = 3 ; i <= n ; ++ i ) dp [ i ] = ( dp [ i - 2 ] && nums [ i - 2 ] == nums [ i - 1 ] ) || ( dp [ i - 3 ] && ( ( nums [ i - 3 ] == nums [ i - 2 ] && nums [ i - 2 ] == nums [ i - 1 ] ) || ( nums [ i - 3 ] + 1 == nums [ i - 2 ] && nums [ i - 2 ] + 1 == nums [ i - 1 ] ) ) ) ; return dp [ n ] ; } }
class Solution { public void deleteNode ( ListNode node ) { node . val = node . next . val ; node . next = node . next . next ; } }
class Solution { public int longestIdealString ( String s , int k ) { int [ ] dp = new int [ 26 ] ; for ( final char c : s . toCharArray ( ) ) { final int i = c - ' a ' ; dp [ i ] = 1 + getMaxReachable ( dp , i , k ) ; } return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; } private int getMaxReachable ( int [ ] dp , int i , int k ) { final int first = Math . max ( 0 , i - k ) ; final int last = Math . min ( 25 , i + k ) ; int maxReachable = 0 ; for ( int j = first ; j <= last ; ++ j ) maxReachable = Math . max ( maxReachable , dp [ j ] ) ; return maxReachable ; } }
class Solution { public int [ ] [ ] minScore ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int [ ] [ ] ans = new int [ m ] [ n ] ; List < int [ ] > valAndIndices = new ArrayList < > ( ) ; int [ ] rows = new int [ m ] ; int [ ] cols = new int [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) valAndIndices . add ( new int [ ] { grid [ i ] [ j ] , i , j } ) ; Collections . sort ( valAndIndices , new Comparator < int [ ] > ( ) { @ Override public int compare ( int [ ] a , int [ ] b ) { return Integer . compare ( a [ 0 ] , b [ 0 ] ) ; } } ) ; for ( int [ ] valAndIndex : valAndIndices ) { final int i = valAndIndex [ 1 ] ; final int j = valAndIndex [ 2 ] ; final int nextAvailable = Math . max ( rows [ i ] , cols [ j ] ) + 1 ; ans [ i ] [ j ] = nextAvailable ; rows [ i ] = nextAvailable ; cols [ j ] = nextAvailable ; } return ans ; } }
class Solution { public int [ ] [ ] largestLocal ( int [ ] [ ] grid ) { final int n = grid . length ; int [ ] [ ] ans = new int [ n - 2 ] [ n - 2 ] ; for ( int i = 0 ; i < n - 2 ; ++ i ) for ( int j = 0 ; j < n - 2 ; ++ j ) for ( int x = i ; x < i + 3 ; ++ x ) for ( int y = j ; y < j + 3 ; ++ y ) ans [ i ] [ j ] = Math . max ( ans [ i ] [ j ] , grid [ x ] [ y ] ) ; return ans ; } }
class Solution { public int edgeScore ( int [ ] edges ) { int ans = 0 ; long [ ] scores = new long [ edges . length ] ; for ( int i = 0 ; i < edges . length ; ++ i ) scores [ edges [ i ] ] += i ; for ( int i = 1 ; i < scores . length ; ++ i ) if ( scores [ i ] > scores [ ans ] ) ans = i ; return ans ; } }
class Solution { public String smallestNumber ( String pattern ) { StringBuilder sb = new StringBuilder ( ) ; Deque < Character > stack = new ArrayDeque < > ( Arrays . asList ( '1' ) ) ; for ( final char c : pattern . toCharArray ( ) ) { char maxSorFar = stack . peek ( ) ; if ( c == ' I ' ) while ( ! stack . isEmpty ( ) ) { maxSorFar = ( char ) Math . max ( maxSorFar , stack . peek ( ) ) ; sb . append ( stack . poll ( ) ) ; } stack . push ( ( char ) ( maxSorFar + 1 ) ) ; } while ( ! stack . isEmpty ( ) ) sb . append ( stack . poll ( ) ) ; return sb . toString ( ) ; } }
class Solution { public int countSpecialNumbers ( int n ) { final int digitSize = ( int ) Math . log10 ( n ) + 1 ; dp = new Integer [ digitSize + 1 ] [ 1 << 10 ] [ 2 ] ; return count ( String . valueOf ( n ) , digitSize , 0 , true ) - 1 ; } private Integer [ ] [ ] [ ] dp ; private int count ( final String s , int digitSize , int usedMask , boolean isTight ) { if ( digitSize == 0 ) return 1 ; if ( dp [ digitSize ] [ usedMask ] [ isTight ? 1 : 0 ] != null ) return dp [ digitSize ] [ usedMask ] [ isTight ? 1 : 0 ] ; int ans = 0 ; final int maxDigit = isTight ? s . charAt ( s . length ( ) - digitSize ) - '0' : 9 ; for ( int digit = 0 ; digit <= maxDigit ; ++ digit ) { if ( ( usedMask >> digit & 1 ) == 1 ) continue ; final boolean nextIsTight = isTight && ( digit == maxDigit ) ; if ( usedMask == 0 && digit == 0 ) ans += count ( s , digitSize - 1 , usedMask , nextIsTight ) ; else ans += count ( s , digitSize - 1 , usedMask | 1 << digit , nextIsTight ) ; } return dp [ digitSize ] [ usedMask ] [ isTight ? 1 : 0 ] = ans ; } }
class Solution { public long maxScore ( int [ ] [ ] edges ) { final int n = edges . length ; List < Pair < Integer , Integer > > [ ] graph = new List [ n ] ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { final int parent = edges [ i ] [ 0 ] ; final int weight = edges [ i ] [ 1 ] ; if ( parent != - 1 ) graph [ parent ] . add ( new Pair < > ( i , weight ) ) ; } Pair < Long , Long > pair = dfs ( graph , 0 ) ; final long takeRoot = pair . getKey ( ) ; final long notTakeRoot = pair . getValue ( ) ; return Math . max ( takeRoot , notTakeRoot ) ; } private Pair < Long , Long > dfs ( List < Pair < Integer , Integer > > [ ] graph , int u ) { long bestEdge = 0 ; long notTakeU = 0 ; for ( Pair < Integer , Integer > node : graph [ u ] ) { final int v = node . getKey ( ) ; final int w = node . getValue ( ) ; Pair < Long , Long > pair = dfs ( graph , v ) ; final long takeV = pair . getKey ( ) ; final long notTakeV = pair . getValue ( ) ; bestEdge = Math . max ( bestEdge , w + notTakeV - takeV ) ; notTakeU += takeV ; } return new Pair < > ( bestEdge + notTakeU , notTakeU ) ; } }
class Solution { public int minimumRecolors ( String blocks , int k ) { int countB = 0 ; int maxCountB = 0 ; for ( int i = 0 ; i < blocks . length ( ) ; ++ i ) { if ( blocks . charAt ( i ) == ' B ' ) ++ countB ; if ( i >= k && blocks . charAt ( i - k ) == ' B ' ) -- countB ; maxCountB = Math . max ( maxCountB , countB ) ; } return k - maxCountB ; } }
class Solution { public int [ ] productExceptSelf ( int [ ] nums ) { final int n = nums . length ; int [ ] ans = new int [ n ] ; int [ ] prefix = new int [ n ] ; int [ ] suffix = new int [ n ] ; prefix [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) prefix [ i ] = prefix [ i - 1 ] * nums [ i - 1 ] ; suffix [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) suffix [ i ] = suffix [ i + 1 ] * nums [ i + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = prefix [ i ] * suffix [ i ] ; return ans ; } }
class Solution { public int secondsToRemoveOccurrences ( String s ) { int ans = 0 ; int zeros = 0 ; for ( final char c : s . toCharArray ( ) ) if ( c == '0' ) ++ zeros ; else if ( zeros > 0 ) ans = Math . max ( ans + 1 , zeros ) ; return ans ; } }
class Solution { public String shiftingLetters ( String s , int [ ] [ ] shifts ) { StringBuilder sb = new StringBuilder ( ) ; int currShift = 0 ; int [ ] timeline = new int [ s . length ( ) + 1 ] ; for ( int [ ] shift : shifts ) { final int start = shift [ 0 ] ; final int end = shift [ 1 ] ; final int direction = shift [ 2 ] ; final int diff = direction == 1 ? 1 : - 1 ; timeline [ start ] += diff ; timeline [ end + 1 ] -= diff ; } for ( int i = 0 ; i < s . length ( ) ; ++ i ) { currShift = ( currShift + timeline [ i ] ) % 26 ; final int num = ( s . charAt ( i ) - ' a ' + currShift + 26 ) % 26 ; sb . append ( ( char ) ( ' a ' + num ) ) ; } return sb . toString ( ) ; } }
class Solution { public long [ ] maximumSegmentSum ( int [ ] nums , int [ ] removeQueries ) { final int n = nums . length ; long maxSum = 0 ; long [ ] ans = new long [ n ] ; long [ ] sum = new long [ n ] ; int [ ] count = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; -- i ) { ans [ i ] = maxSum ; final int j = removeQueries [ i ] ; final long leftSum = j > 0 ? sum [ j - 1 ] : 0 ; final long rightSum = j + 1 < n ? sum [ j + 1 ] : 0 ; final long segmentSum = nums [ j ] + leftSum + rightSum ; final int leftCount = j > 0 ? count [ j - 1 ] : 0 ; final int rightCount = j + 1 < n ? count [ j + 1 ] : 0 ; final int segmentCount = 1 + leftCount + rightCount ; final int l = j - leftCount ; final int r = j + rightCount ; sum [ l ] = segmentSum ; sum [ r ] = segmentSum ; count [ l ] = segmentCount ; count [ r ] = segmentCount ; maxSum = Math . max ( maxSum , segmentSum ) ; } return ans ; } }
class Solution { public int minNumberOfHours ( int initialEnergy , int initialExperience , int [ ] energy , int [ ] experience ) { return getRequiredEnergy ( initialEnergy , energy ) + getRequiredExperience ( initialExperience , experience ) ; } private int getRequiredEnergy ( int initialEnergy , int [ ] energy ) { return Math . max ( 0 , Arrays . stream ( energy ) . sum ( ) + 1 - initialEnergy ) ; } private int getRequiredExperience ( int currentExperience , int [ ] experience ) { int requiredExperience = 0 ; for ( final int e : experience ) { if ( e >= currentExperience ) { requiredExperience += e + 1 - currentExperience ; currentExperience += e + 1 - currentExperience ; } currentExperience += e ; } return requiredExperience ; } }
import java . util . Map ; class Solution { public String largestPalindromic ( String num ) { Map < Character , Integer > count = new HashMap < > ( ) ; for ( final char c : num . toCharArray ( ) ) count . merge ( c , 1 , Integer :: sum ) ; final String firstHalf = getFirstHalf ( count ) ; final String mid = getMid ( count ) ; final String ans = firstHalf + mid + reversed ( firstHalf ) ; return ans . isEmpty ( ) ? "0" : ans ; } private String getFirstHalf ( Map < Character , Integer > count ) { StringBuilder sb = new StringBuilder ( ) ; for ( char c = '9' ; c >= '0' ; -- c ) { final int freq = count . getOrDefault ( c , 0 ) ; sb . append ( String . valueOf ( c ) . repeat ( freq / 2 ) ) ; } final int index = firstNotZeroIndex ( sb ) ; return index == - 1 ? " " : sb . substring ( index ) ; } private int firstNotZeroIndex ( StringBuilder sb ) { for ( int i = 0 ; i < sb . length ( ) ; ++ i ) if ( sb . charAt ( i ) != '0' ) return i ; return - 1 ; } private String getMid ( Map < Character , Integer > count ) { StringBuilder sb = new StringBuilder ( ) ; for ( char c = '9' ; c >= '0' ; -- c ) { final int freq = count . getOrDefault ( c , 0 ) ; if ( freq % 2 == 1 ) return String . valueOf ( c ) ; } return " " ; } private String reversed ( final String s ) { return new StringBuilder ( s ) . reverse ( ) . toString ( ) ; } }
class Solution { public int amountOfTime ( TreeNode root , int start ) { int ans = - 1 ; Map < Integer , List < Integer > > graph = getGraph ( root ) ; Queue < Integer > q = new ArrayDeque < > ( Arrays . asList ( start ) ) ; Set < Integer > seen = new HashSet < > ( Arrays . asList ( start ) ) ; for ( ; ! q . isEmpty ( ) ; ++ ans ) { for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int u = q . poll ( ) ; if ( ! graph . containsKey ( u ) ) continue ; for ( final int v : graph . get ( u ) ) { if ( seen . contains ( v ) ) continue ; q . offer ( v ) ; seen . add ( v ) ; } } } return ans ; } private Map < Integer , List < Integer > > getGraph ( TreeNode root ) { Map < Integer , List < Integer > > graph = new HashMap < > ( ) ; Queue < Pair < TreeNode , Integer > > q = new ArrayDeque < > ( Arrays . asList ( new Pair < > ( root , - 1 ) ) ) ; while ( ! q . isEmpty ( ) ) { Pair < TreeNode , Integer > pair = q . poll ( ) ; TreeNode node = pair . getKey ( ) ; final int parent = pair . getValue ( ) ; if ( parent != - 1 ) { graph . putIfAbsent ( parent , new ArrayList < > ( ) ) ; graph . putIfAbsent ( node . val , new ArrayList < > ( ) ) ; graph . get ( parent ) . add ( node . val ) ; graph . get ( node . val ) . add ( parent ) ; } if ( node . left != null ) q . add ( new Pair < > ( node . left , node . val ) ) ; if ( node . right != null ) q . add ( new Pair < > ( node . right , node . val ) ) ; } return graph ; } }
class Solution { public long kSum ( int [ ] nums , int k ) { final long maxSum = getMaxSum ( nums ) ; final int [ ] absNums = getAbsNums ( nums ) ; long ans = maxSum ; Queue < Pair < Long , Integer > > maxHeap = new PriorityQueue < > ( ( a , b ) -> Long . compare ( b . getKey ( ) , a . getKey ( ) ) ) ; maxHeap . offer ( new Pair < > ( maxSum - absNums [ 0 ] , 0 ) ) ; for ( int j = 0 ; j < k - 1 ; ++ j ) { Pair < Long , Integer > pair = maxHeap . poll ( ) ; final long nextMaxSum = pair . getKey ( ) ; final int i = pair . getValue ( ) ; ans = nextMaxSum ; if ( i + 1 < absNums . length ) { maxHeap . offer ( new Pair < > ( nextMaxSum - absNums [ i + 1 ] , i + 1 ) ) ; maxHeap . offer ( new Pair < > ( nextMaxSum - absNums [ i + 1 ] + absNums [ i ] , i + 1 ) ) ; } } return ans ; } private long getMaxSum ( int [ ] nums ) { long maxSum = 0 ; for ( final int num : nums ) if ( num > 0 ) maxSum += num ; return maxSum ; } private int [ ] getAbsNums ( int [ ] nums ) { for ( int i = 0 ; i < nums . length ; ++ i ) nums [ i ] = Math . abs ( nums [ i ] ) ; Arrays . sort ( nums ) ; return nums ; } }
class Solution { public int matrixMedian ( int [ ] [ ] grid ) { final int noGreaterThanMedianCount = grid . length * grid [ 0 ] . length / 2 + 1 ; int l = 1 ; int r = ( int ) 1e6 ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( numsNoGreaterThan ( grid , m ) >= noGreaterThanMedianCount ) r = m ; else l = m + 1 ; } return l ; } private int numsNoGreaterThan ( int [ ] [ ] grid , int m ) { int count = 0 ; for ( int [ ] row : grid ) count += firstGreater ( row , m ) ; return count ; } private int firstGreater ( int [ ] row , int target ) { int l = 0 ; int r = row . length ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( row [ m ] > target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public int [ ] answerQueries ( int [ ] nums , int [ ] queries ) { int [ ] ans = new int [ queries . length ] ; Arrays . sort ( nums ) ; for ( int i = 0 ; i < queries . length ; ++ i ) ans [ i ] = numOfElementsLessThan ( nums , queries [ i ] ) ; return ans ; } private int numOfElementsLessThan ( int [ ] nums , int q ) { int sum = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { sum += nums [ i ] ; if ( sum > q ) return i ; } return nums . length ; } }
class Solution { public int [ ] maxSlidingWindow ( int [ ] nums , int k ) { int [ ] ans = new int [ nums . length - k + 1 ] ; Deque < Integer > q = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { while ( ! q . isEmpty ( ) && q . peekLast ( ) < nums [ i ] ) q . pollLast ( ) ; q . offerLast ( nums [ i ] ) ; if ( i >= k && nums [ i - k ] == q . peekFirst ( ) ) q . pollFirst ( ) ; if ( i >= k - 1 ) ans [ i - k + 1 ] = q . peekFirst ( ) ; } return ans ; } }
class Solution { public String removeStars ( String s ) { StringBuilder sb = new StringBuilder ( ) ; for ( final char c : s . toCharArray ( ) ) if ( c == ' * ' ) sb . deleteCharAt ( sb . length ( ) - 1 ) ; else sb . append ( c ) ; return sb . toString ( ) ; } }
class Solution { public int garbageCollection ( String [ ] garbage , int [ ] travel ) { int [ ] prefix = new int [ travel . length ] ; prefix [ 0 ] = travel [ 0 ] ; for ( int i = 1 ; i < prefix . length ; ++ i ) prefix [ i ] += prefix [ i - 1 ] + travel [ i ] ; final int timeM = getTime ( garbage , prefix , ' M ' ) ; final int timeP = getTime ( garbage , prefix , ' P ' ) ; final int timeG = getTime ( garbage , prefix , ' G ' ) ; return timeM + timeP + timeG ; } private int getTime ( String [ ] garbage , int [ ] prefix , char c ) { int characterCount = 0 ; int lastIndex = - 1 ; for ( int i = 0 ; i < garbage . length ; ++ i ) { final String s = garbage [ i ] ; if ( s . chars ( ) . anyMatch ( g -> g == c ) ) lastIndex = i ; characterCount += ( int ) s . chars ( ) . filter ( g -> g == c ) . count ( ) ; } return characterCount + ( lastIndex <= 0 ? 0 : prefix [ lastIndex - 1 ] ) ; } }
class Solution { public int [ ] [ ] buildMatrix ( int k , int [ ] [ ] rowConditions , int [ ] [ ] colConditions ) { List < Integer > rowOrder = topologicalSort ( rowConditions , k ) ; if ( rowOrder . isEmpty ( ) ) return new int [ ] [ ] { } ; List < Integer > colOrder = topologicalSort ( colConditions , k ) ; if ( colOrder . isEmpty ( ) ) return new int [ ] [ ] { } ; int [ ] [ ] ans = new int [ k ] [ k ] ; int [ ] nodeToRowIndex = new int [ k + 1 ] ; for ( int i = 0 ; i < k ; ++ i ) nodeToRowIndex [ rowOrder . get ( i ) ] = i ; for ( int j = 0 ; j < k ; ++ j ) { final int node = colOrder [ j ] ; final int i = nodeToRowIndex [ node ] ; ans [ i ] [ j ] = node ; } return ans ; } private List < Integer > topologicalSort ( int [ ] [ ] conditions , int n ) { List < Integer > order = new ArrayList < > ( ) ; List < Integer > [ ] graph = new List [ n + 1 ] ; int [ ] inDegree = new int [ n + 1 ] ; Queue < Integer > q = new ArrayDeque < > ( ) ; for ( int i = 1 ; i <= n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] condition : conditions ) { final int u = condition [ 0 ] ; final int v = condition [ 1 ] ; graph [ u ] . add ( v ) ; ++ inDegree [ v ] ; } for ( int i = 1 ; i <= n ; ++ i ) if ( inDegree [ i ] == 0 ) q . offer ( i ) ; while ( ! q . isEmpty ( ) ) { final int u = q . poll ( ) ; order . add ( u ) ; for ( final int v : graph [ u ] ) if ( -- inDegree [ v ] == 0 ) q . offer ( v ) ; } return order . size ( ) == n ? order : new ArrayList < > ( ) ; } }
class Solution { public long countSubarrays ( int [ ] nums ) { long ans = 0 ; for ( int i = 0 , j = - 1 ; i < nums . length ; ++ i ) { if ( i > 0 && nums [ i ] <= nums [ i - 1 ] ) j = i - 1 ; ans += i - j ; } return ans ; } }
class Solution { public boolean findSubarrays ( int [ ] nums ) { Set < Integer > seen = new HashSet < > ( ) ; for ( int i = 1 ; i < nums . length ; ++ i ) { final int sum = nums [ i - 1 ] + nums [ i ] ; if ( seen . contains ( sum ) ) return true ; seen . add ( sum ) ; } return false ; } }
class Solution { public boolean isStrictlyPalindromic ( int n ) { return false ; } }
class Solution { public int maximumRows ( int [ ] [ ] matrix , int numSelect ) { dfs ( matrix , 0 , numSelect , 0 ) ; return ans ; } private int ans = 0 ; private void dfs ( int [ ] [ ] matrix , int colIndex , int leftColsCount , int mask ) { if ( leftColsCount == 0 ) { ans = Math . max ( ans , getAllZerosRowCount ( matrix , mask ) ) ; return ; } if ( colIndex == matrix [ 0 ] . length ) return ; dfs ( matrix , colIndex + 1 , leftColsCount - 1 , mask | 1 << colIndex ) ; dfs ( matrix , colIndex + 1 , leftColsCount , mask ) ; } int getAllZerosRowCount ( int [ ] [ ] matrix , int mask ) { int count = 0 ; for ( int [ ] row : matrix ) { boolean isAllZeros = true ; for ( int i = 0 ; i < row . length ; ++ i ) { if ( row [ i ] == 1 && ( mask >> i & 1 ) == 0 ) { isAllZeros = false ; break ; } } if ( isAllZeros ) ++ count ; } return count ; } }
class Solution { public int maximumRobots ( int [ ] chargeTimes , int [ ] runningCosts , long budget ) { long cost = 0 ; Deque < Integer > q = new ArrayDeque < > ( ) ; int j = 0 ; for ( int i = 0 ; i < chargeTimes . length ; ++ i ) { cost += runningCosts [ i ] ; while ( ! q . isEmpty ( ) && q . peekLast ( ) < chargeTimes [ i ] ) q . pollLast ( ) ; q . offerLast ( chargeTimes [ i ] ) ; if ( q . peekFirst ( ) + ( i - j + 1 ) * cost > budget ) { if ( q . peekFirst ( ) == chargeTimes [ j ] ) q . pollFirst ( ) ; cost -= runningCosts [ j ++ ] ; } } return chargeTimes . length - j ; } }
class Solution { public boolean checkDistances ( String s , int [ ] distance ) { int [ ] firstSeenIndex = new int [ 26 ] ; Arrays . fill ( firstSeenIndex , - 1 ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { final int j = s . charAt ( i ) - ' a ' ; final int prevIndex = firstSeenIndex [ j ] ; if ( prevIndex != - 1 && i - prevIndex - 1 != distance [ j ] ) return false ; firstSeenIndex [ j ] = i ; } return true ; } }
class Solution { public ListNode swapPairs ( ListNode head ) { final int length = getLength ( head ) ; ListNode dummy = new ListNode ( 0 , head ) ; ListNode prev = dummy ; ListNode curr = head ; for ( int i = 0 ; i < length / 2 ; ++ i ) { ListNode next = curr . next ; curr . next = next . next ; next . next = curr ; prev . next = next ; prev = curr ; curr = curr . next ; } return dummy . next ; } private int getLength ( ListNode head ) { int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; return length ; } }
class Solution { public boolean searchMatrix ( int [ ] [ ] matrix , int target ) { int r = 0 ; int c = matrix [ 0 ] . length - 1 ; while ( r <= matrix . length && c >= 0 ) { if ( matrix [ r ] [ c ] == target ) return true ; if ( matrix [ r ] [ c ] > target ) -- c ; else ++ r ; } return false ; } }
class Solution { public int numberOfWays ( int startPos , int endPos , int k ) { final int val = k + endPos - startPos ; if ( val < 0 || val % 2 == 1 ) return 0 ; final int rightStep = val / 2 ; final int leftStep = k - rightStep ; if ( leftStep < 0 ) return 0 ; return nChooseK ( leftStep + rightStep , Math . min ( leftStep , rightStep ) ) ; } private int nChooseK ( int n , int k ) { final int kMod = 1_000_000_007 ; int [ ] dp = new int [ k + 1 ] ; dp [ 0 ] = 1 ; while ( n -- > 0 ) for ( int j = k ; j > 0 ; -- j ) { dp [ j ] += dp [ j - 1 ] ; dp [ j ] %= kMod ; } return dp [ k ] ; } }
class Solution { public int longestNiceSubarray ( int [ ] nums ) { int ans = 0 ; int usedBits = 0 ; for ( int l = 0 , r = 0 ; r < nums . length ; ++ r ) { while ( ( usedBits & nums [ r ] ) > 0 ) usedBits ^= nums [ l ++ ] ; usedBits |= nums [ r ] ; ans = Math . max ( ans , r - l + 1 ) ; } return ans ; } }
class T { public long endTime ; public int roomId ; public T ( long endTime , int roomId ) { this . endTime = endTime ; this . roomId = roomId ; } } class Solution { public int mostBooked ( int n , int [ ] [ ] meetings ) { int [ ] count = new int [ n ] ; Arrays . sort ( meetings , ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; Queue < T > occupied = new PriorityQueue < > ( ( a , b ) -> a . endTime == b . endTime ? Integer . compare ( a . roomId , b . roomId ) : Long . compare ( a . endTime , b . endTime ) ) ; Queue < Integer > availableRoomIds = new PriorityQueue < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) availableRoomIds . offer ( i ) ; for ( int [ ] meeting : meetings ) { final int start = meeting [ 0 ] ; final int end = meeting [ 1 ] ; while ( ! occupied . isEmpty ( ) && occupied . peek ( ) . endTime <= start ) availableRoomIds . offer ( occupied . poll ( ) . roomId ) ; if ( availableRoomIds . isEmpty ( ) ) { T t = occupied . poll ( ) ; ++ count [ t . roomId ] ; occupied . offer ( new T ( t . endTime + ( end - start ) , t . roomId ) ) ; } else { final int roomId = availableRoomIds . poll ( ) ; ++ count [ roomId ] ; occupied . offer ( new T ( end , roomId ) ) ; } } int maxIndex = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( count [ i ] > count [ maxIndex ] ) maxIndex = i ; return maxIndex ; } }
class Solution { public long minimumTime ( int [ ] power ) { final int n = power . length ; final int maxMask = 1 << n ; long [ ] dp = new long [ maxMask ] ; Arrays . fill ( dp , Long . MAX_VALUE ) ; dp [ 0 ] = 0 ; for ( int mask = 1 ; mask < maxMask ; ++ mask ) { final int currentGain = Integer . bitCount ( mask ) ; for ( int i = 0 ; i < n ; ++ i ) if ( ( mask >> i & 1 ) == 1 ) dp [ mask ] = Math . min ( dp [ mask ] , dp [ mask & ~ ( 1 << i ) ] + ( int ) ( Math . ceil ( power [ i ] * 1.0 / currentGain ) ) ) ; } return dp [ maxMask - 1 ] ; } }
class Solution { public int mostFrequentEven ( int [ ] nums ) { int ans = - 1 ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( final int num : nums ) { if ( num % 2 == 1 ) continue ; count . merge ( num , 1 , Integer :: sum ) ; final int newCount = count . get ( num ) ; final int maxCount = count . getOrDefault ( ans , 0 ) ; if ( newCount > maxCount || newCount == maxCount && num < ans ) ans = num ; } return ans ; } }
class Solution { public int partitionString ( String s ) { int ans = 1 ; int usedMask = 0 ; for ( final char c : s . toCharArray ( ) ) { final int i = c - ' a ' ; if ( ( usedMask >> i & 1 ) == 1 ) { usedMask = 1 << i ; ++ ans ; } else { usedMask |= 1 << i ; } } return ans ; } }
class Solution { public int minGroups ( int [ ] [ ] intervals ) { Queue < Integer > minHeap = new PriorityQueue < > ( ( a , b ) -> a - b ) ; Arrays . sort ( intervals , ( a , b ) -> ( a [ 0 ] - b [ 0 ] ) ) ; for ( int [ ] interval : intervals ) { if ( ! minHeap . isEmpty ( ) && interval [ 0 ] > minHeap . peek ( ) ) minHeap . poll ( ) ; minHeap . offer ( interval [ 1 ] ) ; } return minHeap . size ( ) ; } }
class Solution { public int countDaysTogether ( String arriveAlice , String leaveAlice , String arriveBob , String leaveBob ) { final int arriveA = toDays ( arriveAlice ) ; final int leaveA = toDays ( leaveAlice ) ; final int arriveB = toDays ( arriveBob ) ; final int leaveB = toDays ( leaveBob ) ; int ans = 0 ; for ( int day = 1 ; day <= 365 ; ++ day ) if ( arriveA <= day && day <= leaveA && arriveB <= day && day <= leaveB ) ++ ans ; return ans ; } private final int [ ] days = { 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; private int toDays ( final String s ) { final int month = ( s . charAt ( 0 ) - '0' ) * 10 + ( s . charAt ( 1 ) - '0' ) ; final int day = ( s . charAt ( 3 ) - '0' ) * 10 + ( s . charAt ( 4 ) - '0' ) ; int prevDays = 0 ; for ( int m = 1 ; m < month ; ++ m ) prevDays += days [ m ] ; return prevDays + day ; } }
class Solution { public List < Integer > diffWaysToCompute ( String expression ) { return ways ( expression , new HashMap < > ( ) ) ; } private List < Integer > ways ( final String s , Map < String , List < Integer > > memo ) { if ( memo . containsKey ( s ) ) return memo . get ( s ) ; List < Integer > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( ! Character . isDigit ( s . charAt ( i ) ) ) for ( final int a : ways ( s . substring ( 0 , i ) , memo ) ) for ( final int b : ways ( s . substring ( i + 1 ) , memo ) ) if ( s . charAt ( i ) == ' + ' ) ans . add ( a + b ) ; else if ( s . charAt ( i ) == ' - ' ) ans . add ( a - b ) ; else ans . add ( a * b ) ; if ( ans . isEmpty ( ) ) { memo . put ( s , Arrays . asList ( Integer . parseInt ( s ) ) ) ; return memo . get ( s ) ; } memo . put ( s , ans ) ; return ans ; } }
class Solution { public int matchPlayersAndTrainers ( int [ ] players , int [ ] trainers ) { int ans = 0 ; Arrays . sort ( players ) ; Arrays . sort ( trainers ) ; for ( int i = 0 ; i < trainers . length ; ++ i ) if ( players [ ans ] <= trainers [ i ] && ++ ans == players . length ) return ans ; return ans ; } }
class Solution { public int [ ] smallestSubarrays ( int [ ] nums ) { final int kMaxDigit = 30 ; int [ ] ans = new int [ nums . length ] ; int [ ] closest = new int [ kMaxDigit ] ; Arrays . fill ( ans , 1 ) ; for ( int i = nums . length - 1 ; i >= 0 ; -- i ) for ( int j = 0 ; j < kMaxDigit ; ++ j ) { if ( ( nums [ i ] >> j & 1 ) == 1 ) closest [ j ] = i ; ans [ i ] = Math . max ( ans [ i ] , closest [ j ] - i + 1 ) ; } return ans ; } }
class Solution { public long minimumMoney ( int [ ] [ ] transactions ) { long ans = 0 ; long losses = 0 ; for ( int [ ] t : transactions ) { final int cost = t [ 0 ] ; final int cashback = t [ 1 ] ; losses += Math . max ( 0 , cost - cashback ) ; } for ( int [ ] t : transactions ) { final int cost = t [ 0 ] ; final int cashback = t [ 1 ] ; if ( cost > cashback ) ans = Math . max ( ans , losses + cashback ) ; else ans = Math . max ( ans , losses + cost ) ; } return ans ; } }
class Solution { public int smallestEvenMultiple ( int n ) { return n * ( n % 2 + 1 ) ; } }
class Solution { public int longestContinuousSubstring ( String s ) { int ans = 1 ; int runningLen = 1 ; for ( int i = 1 ; i < s . length ( ) ; ++ i ) if ( s . charAt ( i ) == s . charAt ( i - 1 ) + 1 ) ans = Math . max ( ans , ++ runningLen ) ; else runningLen = 1 ; return ans ; } }
class Solution { public TreeNode reverseOddLevels ( TreeNode root ) { dfs ( root . left , root . right , true ) ; return root ; } private void dfs ( TreeNode left , TreeNode right , boolean isOddLevel ) { if ( left == null ) return ; if ( isOddLevel ) { final int val = left . val ; left . val = right . val ; right . val = val ; } dfs ( left . left , right . right , ! isOddLevel ) ; dfs ( left . right , right . left , ! isOddLevel ) ; } }
class TrieNode { public TrieNode [ ] children = new TrieNode [ 26 ] ; public int count = 0 ; } class Solution { public int [ ] sumPrefixScores ( String [ ] words ) { int [ ] ans = new int [ words . length ] ; for ( final String word : words ) insert ( word ) ; for ( int i = 0 ; i < words . length ; ++ i ) ans [ i ] = getScore ( words [ i ] ) ; return ans ; } private TrieNode root = new TrieNode ( ) ; private void insert ( String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ( ) ) { final int i = c - ' a ' ; if ( node . children [ i ] == null ) node . children [ i ] = new TrieNode ( ) ; node = node . children [ i ] ; ++ node . count ; } } private int getScore ( String word ) { TrieNode node = root ; int score = 0 ; for ( final char c : word . toCharArray ( ) ) { node = node . children [ c - ' a ' ] ; score += node . count ; } return score ; } }
class Solution { public int closestFair ( int n ) { final int digitsCount = String . valueOf ( n ) . length ( ) ; return ( digitsCount % 2 == 1 ) ? ( int ) getOddDigits ( digitsCount ) : getEvenDigits ( n ) ; } private long getOddDigits ( int digitsCount ) { final int zerosCount = ( digitsCount + 1 ) / 2 ; final int onesCount = ( digitsCount - 1 ) / 2 ; return Integer . valueOf ( '1' + "0" . repeat ( zerosCount ) + "1" . repeat ( onesCount ) ) ; } private int getEvenDigits ( int n ) { final int digitsCount = String . valueOf ( n ) . length ( ) ; final long maxNum = Long . valueOf ( '1' + "0" . repeat ( digitsCount ) ) ; for ( long num = n ; num < maxNum ; ++ num ) if ( isValidNum ( num ) ) return ( int ) num ; return ( int ) getOddDigits ( digitsCount + 1 ) ; } private boolean isValidNum ( long num ) { int count = 0 ; for ( final char c : String . valueOf ( num ) . toCharArray ( ) ) count += ( ( c - '0' ) % 2 == 1 ) ? - 1 : 1 ; return count == 0 ; } }
class Solution { public String [ ] sortPeople ( String [ ] names , int [ ] heights ) { List < Pair < Integer , String > > heightAndNames = new ArrayList < > ( ) ; for ( int i = 0 ; i < names . length ; ++ i ) heightAndNames . add ( new Pair < > ( heights [ i ] , names [ i ] ) ) ; Collections . sort ( heightAndNames , ( a , b ) -> b . getKey ( ) - a . getKey ( ) ) ; for ( int i = 0 ; i < heightAndNames . size ( ) ; ++ i ) names [ i ] = heightAndNames . get ( i ) . getValue ( ) ; return names ; } }
class Solution { public int longestSubarray ( int [ ] nums ) { int ans = 0 ; int maxIndex = 0 ; int sameNumLength = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] == nums [ maxIndex ] ) { ans = Math . max ( ans , ++ sameNumLength ) ; } else if ( nums [ i ] > nums [ maxIndex ] ) { maxIndex = i ; sameNumLength = 1 ; ans = 1 ; } else { sameNumLength = 0 ; } return ans ; } }
class Solution { public boolean isAnagram ( String s , String t ) { if ( s . length ( ) != t . length ( ) ) return false ; int [ ] count = new int [ 128 ] ; for ( final char c : s . toCharArray ( ) ) ++ count [ c ] ; for ( final char c : t . toCharArray ( ) ) if ( -- count [ c ] < 0 ) return false ; return true ; } }
class Solution { public List < Integer > goodIndices ( int [ ] nums , int k ) { final int n = nums . length ; List < Integer > ans = new ArrayList < > ( ) ; int [ ] dec = new int [ n ] ; int [ ] inc = new int [ n ] ; Arrays . fill ( dec , 1 ) ; Arrays . fill ( inc , 1 ) ; for ( int i = 1 ; i < n ; ++ i ) if ( nums [ i - 1 ] >= nums [ i ] ) dec [ i ] = dec [ i - 1 ] + 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) if ( nums [ i ] <= nums [ i + 1 ] ) inc [ i ] = inc [ i + 1 ] + 1 ; for ( int i = k ; i < n - k ; ++ i ) if ( dec [ i - 1 ] >= k && inc [ i + 1 ] >= k ) ans . add ( i ) ; return ans ; } }
class Solution { public int minimumOperations ( int [ ] nums ) { int ans = 0 ; int l = 0 ; int r = nums . length - 1 ; long leftSum = nums [ l ] ; long rightSum = nums [ r ] ; while ( l < r ) if ( leftSum < rightSum ) { leftSum += nums [ ++ l ] ; ++ ans ; } else if ( leftSum > rightSum ) { rightSum += nums [ -- r ] ; ++ ans ; } else { leftSum = nums [ ++ l ] ; rightSum = nums [ -- r ] ; } return ans ; } }
class Solution { public boolean equalFrequency ( String word ) { int [ ] count = new int [ 26 ] ; for ( final char c : word . toCharArray ( ) ) ++ count [ c - ' a ' ] ; for ( final char c : word . toCharArray ( ) ) { -- count [ c - ' a ' ] ; if ( equalCount ( count ) ) return true ; ++ count [ c - ' a ' ] ; } return false ; } private boolean equalCount ( int [ ] count ) { int freq = - 1 ; for ( final int c : count ) { if ( c == 0 || c == freq ) continue ; if ( freq == - 1 ) freq = c ; else return false ; } return true ; } }
class LUPrefix { public LUPrefix ( int n ) { } public void upload ( int video ) { seen . add ( video ) ; while ( seen . contains ( longestPrefix + 1 ) ) ++ longestPrefix ; } public int longest ( ) { return longestPrefix ; } private Set < Integer > seen = new HashSet < > ( ) ; private int longestPrefix = 0 ; }
class Solution { public int xorAllNums ( int [ ] nums1 , int [ ] nums2 ) { final int xors1 = Arrays . stream ( nums1 ) . reduce ( ( a , b ) -> a ^ b ) . getAsInt ( ) ; final int xors2 = Arrays . stream ( nums2 ) . reduce ( ( a , b ) -> a ^ b ) . getAsInt ( ) ; return ( nums1 . length % 2 * xors2 ) ^ ( nums2 . length % 2 * xors1 ) ; } }
class Solution { public int commonFactors ( int a , int b ) { int ans = 1 ; final int gcd = gcd ( a , b ) ; for ( int i = 2 ; i <= gcd ; ++ i ) if ( a % i == 0 && b % i == 0 ) ++ ans ; return ans ; } private int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } }
public class Solution { public int maxSum ( int [ ] [ ] grid ) { int ans = 0 ; for ( int i = 1 ; i + 1 < grid . length ; ++ i ) for ( int j = 1 ; j + 1 < grid [ 0 ] . length ; ++ j ) ans = Math . max ( ans , grid [ i - 1 ] [ j - 1 ] + grid [ i - 1 ] [ j ] + grid [ i - 1 ] [ j + 1 ] + grid [ i ] [ j ] + grid [ i + 1 ] [ j - 1 ] + grid [ i + 1 ] [ j ] + grid [ i + 1 ] [ j + 1 ] ) ; return ans ; } }
class Solution { public int minimizeXor ( int num1 , int num2 ) { final int kMaxDigit = 30 ; int bits = Integer . bitCount ( num2 ) ; if ( Integer . bitCount ( num1 ) == bits ) return num1 ; int ans = 0 ; for ( int i = kMaxDigit - 1 ; i >= 0 ; -- i ) if ( ( num1 >> i & 1 ) == 1 ) { ans |= 1 << i ; if ( -- bits == 0 ) return ans ; } for ( int i = 0 ; i < kMaxDigit ; ++ i ) if ( ( num1 >> i & 1 ) == 0 ) { ans |= 1 << i ; if ( -- bits == 0 ) return ans ; } return ans ; } }
class Solution { public int shortestDistance ( String [ ] wordsDict , String word1 , String word2 ) { int ans = wordsDict . length ; int index1 = - 1 ; int index2 = - 1 ; for ( int i = 0 ; i < wordsDict . length ; ++ i ) { if ( wordsDict [ i ] . equals ( word1 ) ) { index1 = i ; if ( index2 != - 1 ) ans = Math . min ( ans , index1 - index2 ) ; } if ( wordsDict [ i ] . equals ( word2 ) ) { index2 = i ; if ( index1 != - 1 ) ans = Math . min ( ans , index2 - index1 ) ; } } return ans ; } }
class Solution { public int deleteString ( String s ) { final int n = s . length ( ) ; int [ ] [ ] lcs = new int [ n + 1 ] [ n + 1 ] ; int [ ] dp = new int [ n ] ; Arrays . fill ( dp , 1 ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) for ( int j = i + 1 ; j < n ; ++ j ) { if ( s . charAt ( i ) == s . charAt ( j ) ) lcs [ i ] [ j ] = lcs [ i + 1 ] [ j + 1 ] + 1 ; if ( lcs [ i ] [ j ] >= j - i ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } return dp [ 0 ] ; } }
class Solution { public int maxTastiness ( int [ ] price , int [ ] tastiness , int maxAmount , int maxCoupons ) { final int n = price . length ; int [ ] [ ] [ ] dp = new int [ price . length + 1 ] [ maxAmount + 1 ] [ maxCoupons + 1 ] ; for ( int i = 1 ; i <= n ; ++ i ) { final int currPrice = price [ i - 1 ] ; final int currTastiness = tastiness [ i - 1 ] ; for ( int amount = 0 ; amount <= maxAmount ; ++ amount ) { for ( int coupon = 0 ; coupon <= maxCoupons ; ++ coupon ) { dp [ i ] [ amount ] [ coupon ] = dp [ i - 1 ] [ amount ] [ coupon ] ; if ( amount >= currPrice ) dp [ i ] [ amount ] [ coupon ] = Math . max ( dp [ i ] [ amount ] [ coupon ] , dp [ i - 1 ] [ amount - currPrice ] [ coupon ] + currTastiness ) ; if ( coupon > 0 && amount >= currPrice / 2 ) dp [ i ] [ amount ] [ coupon ] = Math . max ( dp [ i ] [ amount ] [ coupon ] , dp [ i - 1 ] [ amount - currPrice / 2 ] [ coupon - 1 ] + currTastiness ) ; } } } return dp [ n ] [ maxAmount ] [ maxCoupons ] ; } }
class Solution { public int hardestWorker ( int n , int [ ] [ ] logs ) { int ans = logs [ 0 ] [ 0 ] ; int maxWorkingTime = logs [ 0 ] [ 1 ] ; for ( int i = 1 ; i < logs . length ; ++ i ) { final int id = logs [ i ] [ 0 ] ; final int workingTime = logs [ i ] [ 1 ] - logs [ i - 1 ] [ 1 ] ; if ( workingTime > maxWorkingTime ) { ans = id ; maxWorkingTime = workingTime ; } else if ( workingTime == maxWorkingTime ) { ans = Math . min ( ans , id ) ; } } return ans ; } }
class Solution { public int [ ] findArray ( int [ ] pref ) { int [ ] ans = new int [ pref . length ] ; ans [ 0 ] = pref [ 0 ] ; for ( int i = 1 ; i < ans . length ; ++ i ) ans [ i ] = pref [ i ] ^ pref [ i - 1 ] ; return ans ; } }
class Solution { public String robotWithString ( String s ) { StringBuilder sb = new StringBuilder ( ) ; int [ ] count = new int [ 26 ] ; Deque < Character > stack = new ArrayDeque < > ( ) ; for ( final char c : s . toCharArray ( ) ) ++ count [ c - ' a ' ] ; for ( final char c : s . toCharArray ( ) ) { stack . push ( c ) ; -- count [ c - ' a ' ] ; final char minChar = getMinChar ( count ) ; while ( ! stack . isEmpty ( ) && stack . peek ( ) <= minChar ) sb . append ( stack . poll ( ) ) ; } while ( ! stack . isEmpty ( ) ) sb . append ( stack . poll ( ) ) ; return sb . toString ( ) ; } private char getMinChar ( int [ ] count ) { for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] > 0 ) return ( char ) ( ' a ' + i ) ; return ' a ' ; } }
class Solution { public int numberOfPaths ( int [ ] [ ] grid , int k ) { m = grid . length ; n = grid [ 0 ] . length ; dp = new Integer [ m ] [ n ] [ k ] ; return numberOfPaths ( grid , 0 , 0 , 0 , k ) ; } private static final int kMod = 1_000_000_007 ; private int m ; private int n ; private Integer [ ] [ ] [ ] dp ; private int numberOfPaths ( int [ ] [ ] grid , int i , int j , int sum , int k ) { if ( i == m || j == n ) return 0 ; if ( i == m - 1 && j == n - 1 ) return ( sum + grid [ i ] [ j ] ) % k == 0 ? 1 : 0 ; if ( dp [ i ] [ j ] [ sum ] != null ) return dp [ i ] [ j ] [ sum ] ; final int newSum = ( sum + grid [ i ] [ j ] ) % k ; return dp [ i ] [ j ] [ sum ] = ( numberOfPaths ( grid , i + 1 , j , newSum , k ) + numberOfPaths ( grid , i , j + 1 , newSum , k ) ) % kMod ; } }
class Solution { public int minimumSplits ( int [ ] nums ) { int ans = 1 ; int gcd = nums [ 0 ] ; for ( final int num : nums ) { final int newGcd = gcd ( gcd , num ) ; if ( newGcd > 1 ) { gcd = newGcd ; } else { gcd = num ; ++ ans ; } } return ans ; } private int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } }
class Solution { public int countTime ( String time ) { int ans = 1 ; if ( time . charAt ( 3 ) == ' ? ' ) ans *= 6 ; if ( time . charAt ( 4 ) == ' ? ' ) ans *= 10 ; if ( time . charAt ( 0 ) == ' ? ' && time . charAt ( 1 ) == ' ? ' ) return ans * 24 ; if ( time . charAt ( 0 ) == ' ? ' ) return time . charAt ( 1 ) < '4' ? ans * 3 : ans * 2 ; if ( time . charAt ( 1 ) == ' ? ' ) return time . charAt ( 0 ) == '2' ? ans * 4 : ans * 10 ; return ans ; } }
class Solution { public int [ ] productQueries ( int n , int [ ] [ ] queries ) { final int kMod = 1_000_000_007 ; final int kMaxDigit = 30 ; int [ ] ans = new int [ queries . length ] ; List < Integer > powers = new ArrayList < > ( ) ; for ( int i = 0 ; i < kMaxDigit ; ++ i ) if ( ( n >> i & 1 ) == 1 ) powers . add ( 1 << i ) ; for ( int i = 0 ; i < queries . length ; ++ i ) { final int left = queries [ i ] [ 0 ] ; final int right = queries [ i ] [ 1 ] ; long prod = 1 ; for ( int j = left ; j <= right ; ++ j ) { prod *= powers . get ( j ) ; prod %= kMod ; } ans [ i ] = ( int ) prod ; } return ans ; } }
class Solution { public int minimizeArrayValue ( int [ ] nums ) { long ans = 0 ; long prefix = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { prefix += nums [ i ] ; final long prefixAvg = ( long ) Math . ceil ( prefix / ( double ) ( i + 1 ) ) ; ans = Math . max ( ans , prefixAvg ) ; } return ( int ) ans ; } }
class WordDistance { public WordDistance ( String [ ] words ) { for ( int i = 0 ; i < words . length ; ++ i ) { wordToIndices . putIfAbsent ( words [ i ] , new ArrayList < > ( ) ) ; wordToIndices . get ( words [ i ] ) . add ( i ) ; } } public int shortest ( String word1 , String word2 ) { List < Integer > indices1 = wordToIndices . get ( word1 ) ; List < Integer > indices2 = wordToIndices . get ( word2 ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 , j = 0 ; i < indices1 . size ( ) && j < indices2 . size ( ) ; ) { ans = Math . min ( ans , Math . abs ( indices1 . get ( i ) - indices2 . get ( j ) ) ) ; if ( indices1 . get ( i ) < indices2 . get ( j ) ) ++ i ; else ++ j ; } return ans ; } private Map < String , List < Integer > > wordToIndices = new HashMap < > ( ) ; }
class Solution { public int componentValue ( int [ ] nums , int [ ] [ ] edges ) { final int n = nums . length ; final int sum = Arrays . stream ( nums ) . sum ( ) ; List < Integer > [ ] graph = new List [ n ] ; for ( int i = 0 ; i < graph . length ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } for ( int i = n ; i > 1 ; -- i ) if ( sum % i == 0 && dfs ( nums , graph , 0 , sum / i , new boolean [ n ] ) == 0 ) return i - 1 ; return 0 ; } private static final int kMax = 1_000_000_000 ; private int dfs ( int [ ] nums , List < Integer > [ ] graph , int u , int target , boolean [ ] seen ) { int sum = nums [ u ] ; seen [ u ] = true ; for ( final int v : graph [ u ] ) { if ( seen [ v ] ) continue ; sum += dfs ( nums , graph , v , target , seen ) ; if ( sum > target ) return kMax ; } if ( sum == target ) return 0 ; return sum ; } }
public class Solution { public int findMaxK ( int [ ] nums ) { int ans = - 1 ; Set < Integer > seen = new HashSet < > ( ) ; for ( final int num : nums ) if ( seen . contains ( - num ) ) ans = Math . max ( ans , Math . abs ( num ) ) ; else seen . add ( num ) ; return ans ; } }
class Solution { public long countSubarrays ( int [ ] nums , int minK , int maxK ) { long ans = 0 ; int j = - 1 ; int prevMinKIndex = - 1 ; int prevMaxKIndex = - 1 ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] < minK || nums [ i ] > maxK ) j = i ; if ( nums [ i ] == minK ) prevMinKIndex = i ; if ( nums [ i ] == maxK ) prevMaxKIndex = i ; ans += Math . max ( 0 , Math . min ( prevMinKIndex , prevMaxKIndex ) - j ) ; } return ans ; } }
class Solution { public int shortestWordDistance ( String [ ] words , String word1 , String word2 ) { final boolean isSame = word1 . equals ( word2 ) ; int ans = Integer . MAX_VALUE ; int index1 = words . length ; int index2 = - words . length ; for ( int i = 0 ; i < words . length ; ++ i ) { if ( words [ i ] . equals ( word1 ) ) { if ( isSame ) index2 = index1 ; index1 = i ; } else if ( words [ i ] . equals ( word2 ) ) { index2 = i ; } ans = Math . min ( ans , Math . abs ( index1 - index2 ) ) ; } return ans ; } }
class Solution { public boolean isStrobogrammatic ( String num ) { final char [ ] rotated = { '0' , '1' , ' n ' , ' n ' , ' n ' , ' n ' , '9' , ' n ' , '8' , '6' } ; int l = 0 ; int r = num . length ( ) - 1 ; while ( l <= r ) if ( num . charAt ( l ++ ) != rotated [ num . charAt ( r -- ) - '0' ] ) return false ; return true ; } }
class Solution { public List < String > findStrobogrammatic ( int n ) { return helper ( n , n ) ; } private List < String > helper ( int n , int k ) { if ( n == 0 ) return new ArrayList < > ( Arrays . asList ( " " ) ) ; if ( n == 1 ) return new ArrayList < > ( Arrays . asList ( "0" , "1" , "8" ) ) ; List < String > ans = new ArrayList < > ( ) ; for ( final String inner : helper ( n - 2 , k ) ) { if ( n < k ) ans . add ( "0" + inner + "0" ) ; ans . add ( "1" + inner + "1" ) ; ans . add ( "6" + inner + "9" ) ; ans . add ( "8" + inner + "8" ) ; ans . add ( "9" + inner + "6" ) ; } return ans ; } }
class Solution { public int strobogrammaticInRange ( String low , String high ) { for ( int n = low . length ( ) ; n <= high . length ( ) ; ++ n ) { char [ ] c = new char [ n ] ; dfs ( low , high , c , 0 , n - 1 ) ; } return ans ; } private int ans = 0 ; private static final char [ ] [ ] pairs = { { '0' , '0' } , { '1' , '1' } , { '6' , '9' } , { '8' , '8' } , { '9' , '6' } } ; private void dfs ( final String low , final String high , char [ ] c , int l , int r ) { if ( l > r ) { final String s = new String ( c ) ; if ( s . length ( ) == low . length ( ) && s . compareTo ( low ) < 0 ) return ; if ( s . length ( ) == high . length ( ) && s . compareTo ( high ) > 0 ) return ; ++ ans ; return ; } for ( char [ ] pair : pairs ) { if ( l == r && pair [ 0 ] != pair [ 1 ] ) continue ; c [ l ] = pair [ 0 ] ; c [ r ] = pair [ 1 ] ; if ( c . length > 1 && c [ 0 ] == '0' ) continue ; dfs ( low , high , c , l + 1 , r - 1 ) ; } } }
class Solution { public List < List < String > > groupStrings ( String [ ] strings ) { Map < String , List < String > > keyToStrings = new HashMap < > ( ) ; for ( final String s : strings ) keyToStrings . computeIfAbsent ( getKey ( s ) , k -> new ArrayList < > ( ) ) . add ( s ) ; return new ArrayList < > ( keyToStrings . values ( ) ) ; } private String getKey ( final String s ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 1 ; i < s . length ( ) ; ++ i ) { final int diff = ( s . charAt ( i ) - s . charAt ( i - 1 ) + 26 ) % 26 ; sb . append ( diff ) . append ( " , " ) ; } return sb . toString ( ) ; } }
class Solution { public ListNode reverseKGroup ( ListNode head , int k ) { if ( head == null ) return null ; ListNode tail = head ; for ( int i = 0 ; i < k ; ++ i ) { if ( tail == null ) return head ; tail = tail . next ; } ListNode newHead = reverse ( head , tail ) ; head . next = reverseKGroup ( tail , k ) ; return newHead ; } private ListNode reverse ( ListNode head , ListNode tail ) { ListNode prev = null ; ListNode curr = head ; while ( curr != tail ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } }
class Solution { public int countUnivalSubtrees ( TreeNode root ) { isUnival ( root , Integer . MAX_VALUE ) ; return ans ; } private int ans = 0 ; private boolean isUnival ( TreeNode root , int val ) { if ( root == null ) return true ; if ( isUnival ( root . left , root . val ) & isUnival ( root . right , root . val ) ) { ++ ans ; return root . val == val ; } return false ; } }
class Vector2D { public Vector2D ( int [ ] [ ] vec ) { for ( int [ ] A : vec ) for ( final int a : A ) this . vec . add ( a ) ; } public int next ( ) { return vec . get ( i ++ ) ; } public boolean hasNext ( ) { return i < vec . size ( ) ; } private List < Integer > vec = new ArrayList < > ( ) ; private int i = 0 ; }
class Solution { public boolean canAttendMeetings ( int [ ] [ ] intervals ) { Arrays . sort ( intervals , ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; for ( int i = 1 ; i < intervals . length ; ++ i ) if ( intervals [ i - 1 ] [ 1 ] > intervals [ i ] [ 0 ] ) return false ; return true ; } }
class Solution { public int minMeetingRooms ( int [ ] [ ] intervals ) { Queue < Integer > minHeap = new PriorityQueue < > ( ( a , b ) -> a - b ) ; Arrays . sort ( intervals , ( a , b ) -> ( a [ 0 ] - b [ 0 ] ) ) ; for ( int [ ] interval : intervals ) { if ( ! minHeap . isEmpty ( ) && interval [ 0 ] >= minHeap . peek ( ) ) minHeap . poll ( ) ; minHeap . offer ( interval [ 1 ] ) ; } return minHeap . size ( ) ; } }
class Solution { public List < List < Integer > > getFactors ( int n ) { List < List < Integer > > ans = new ArrayList < > ( ) ; dfs ( n , 2 , new ArrayList < > ( ) , ans ) ; return ans ; } private void dfs ( int n , int s , List < Integer > path , List < List < Integer > > ans ) { if ( n == 1 ) { if ( path . size ( ) > 1 ) ans . add ( new ArrayList < > ( path ) ) ; return ; } for ( int i = s ; i <= n ; ++ i ) if ( n % i == 0 ) { path . add ( i ) ; dfs ( n / i , i , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; } } }
class Solution { public boolean verifyPreorder ( int [ ] preorder ) { dfs ( preorder , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; return i == preorder . length ; } private int i = 0 ; private void dfs ( int [ ] preorder , int min , int max ) { if ( i == preorder . length ) return ; if ( preorder [ i ] < min || preorder [ i ] > max ) return ; final int val = preorder [ i ++ ] ; dfs ( preorder , min , val ) ; dfs ( preorder , val , max ) ; } }
class Solution { public int minCost ( int [ ] [ ] costs ) { final int n = costs . length ; for ( int i = 1 ; i < n ; ++ i ) { costs [ i ] [ 0 ] += Math . min ( costs [ i - 1 ] [ 1 ] , costs [ i - 1 ] [ 2 ] ) ; costs [ i ] [ 1 ] += Math . min ( costs [ i - 1 ] [ 0 ] , costs [ i - 1 ] [ 2 ] ) ; costs [ i ] [ 2 ] += Math . min ( costs [ i - 1 ] [ 0 ] , costs [ i - 1 ] [ 1 ] ) ; } return Math . min ( costs [ n - 1 ] [ 0 ] , Math . min ( costs [ n - 1 ] [ 1 ] , costs [ n - 1 ] [ 2 ] ) ) ; } }
class Solution { public List < String > binaryTreePaths ( TreeNode root ) { List < String > ans = new ArrayList < > ( ) ; dfs ( root , new StringBuilder ( ) , ans ) ; return ans ; } private void dfs ( TreeNode root , StringBuilder sb , List < String > ans ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { ans . add ( sb . append ( root . val ) . toString ( ) ) ; return ; } final int length = sb . length ( ) ; dfs ( root . left , sb . append ( root . val ) . append ( " - > " ) , ans ) ; sb . setLength ( length ) ; dfs ( root . right , sb . append ( root . val ) . append ( " - > " ) , ans ) ; sb . setLength ( length ) ; } }
class Solution { public int addDigits ( int num ) { return 1 + ( num - 1 ) % 9 ; } }
class Solution { public int threeSumSmaller ( int [ ] nums , int target ) { if ( nums . length < 3 ) return 0 ; int ans = 0 ; Arrays . sort ( nums ) ; for ( int i = 0 ; i + 2 < nums . length ; ++ i ) { int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) if ( nums [ i ] + nums [ l ] + nums [ r ] < target ) { ans += r - l ; ++ l ; } else { -- r ; } } return ans ; } }
class Solution { public int removeDuplicates ( int [ ] nums ) { int i = 0 ; for ( final int num : nums ) if ( i < 1 || num > nums [ i - 1 ] ) nums [ i ++ ] = num ; return i ; } }
class Solution { public int [ ] singleNumber ( int [ ] nums ) { final int xors = Arrays . stream ( nums ) . reduce ( ( a , b ) -> a ^ b ) . getAsInt ( ) ; final int lowbit = xors & - xors ; int [ ] ans = new int [ 2 ] ; for ( final int num : nums ) if ( ( num & lowbit ) > 0 ) ans [ 0 ] ^= num ; else ans [ 1 ] ^= num ; return ans ; } }
class Solution { public boolean validTree ( int n , int [ ] [ ] edges ) { if ( n == 0 || edges . length != n - 1 ) return false ; List < Integer > [ ] graph = new List [ n ] ; Queue < Integer > q = new ArrayDeque < > ( Arrays . asList ( 0 ) ) ; Set < Integer > seen = new HashSet < > ( Arrays . asList ( 0 ) ) ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } while ( ! q . isEmpty ( ) ) { final int u = q . poll ( ) ; for ( final int v : graph [ u ] ) if ( ! seen . contains ( v ) ) { q . offer ( v ) ; seen . add ( v ) ; } } return seen . size ( ) == n ; } }
class Solution { public boolean isUgly ( int n ) { if ( n == 0 ) return false ; for ( final int prime : new int [ ] { 2 , 3 , 5 } ) while ( n % prime == 0 ) n /= prime ; return n == 1 ; } }
class Solution { public int nthUglyNumber ( int n ) { List < Integer > uglyNums = new ArrayList < > ( ) ; uglyNums . add ( 1 ) ; int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( uglyNums . size ( ) < n ) { final int next2 = uglyNums . get ( i2 ) * 2 ; final int next3 = uglyNums . get ( i3 ) * 3 ; final int next5 = uglyNums . get ( i5 ) * 5 ; final int next = Math . min ( next2 , Math . min ( next3 , next5 ) ) ; if ( next == next2 ) ++ i2 ; if ( next == next3 ) ++ i3 ; if ( next == next5 ) ++ i5 ; uglyNums . add ( next ) ; } return uglyNums . get ( uglyNums . size ( ) - 1 ) ; } }
class Solution { public int minCostII ( int [ ] [ ] costs ) { int prevIndex = - 1 ; int prevMin1 = 0 ; int prevMin2 = 0 ; for ( int [ ] cost : costs ) { int index = - 1 ; int min1 = Integer . MAX_VALUE ; int min2 = Integer . MAX_VALUE ; for ( int i = 0 ; i < cost . length ; ++ i ) { final int theCost = cost [ i ] + ( i == prevIndex ? prevMin2 : prevMin1 ) ; if ( theCost < min1 ) { index = i ; min2 = min1 ; min1 = theCost ; } else if ( theCost < min2 ) { min2 = theCost ; } } prevIndex = index ; prevMin1 = min1 ; prevMin2 = min2 ; } return prevMin1 ; } }
class Solution { public boolean canPermutePalindrome ( String s ) { Set < Character > seen = new HashSet < > ( ) ; for ( final char c : s . toCharArray ( ) ) if ( ! seen . add ( c ) ) seen . remove ( c ) ; return seen . size ( ) <= 1 ; } }
class Solution { public List < String > generatePalindromes ( String s ) { int odd = 0 ; Map < Character , Integer > count = new HashMap < > ( ) ; for ( final char c : s . toCharArray ( ) ) count . put ( c , count . getOrDefault ( c , 0 ) + 1 ) ; for ( Map . Entry < Character , Integer > entry : count . entrySet ( ) ) if ( entry . getValue ( ) % 2 == 1 ) ++ odd ; if ( odd > 1 ) return new ArrayList < > ( ) ; List < String > ans = new ArrayList < > ( ) ; List < Character > candidates = new ArrayList < > ( ) ; StringBuilder mid = new StringBuilder ( ) ; for ( Map . Entry < Character , Integer > entry : count . entrySet ( ) ) { final char key = entry . getKey ( ) ; final int value = entry . getValue ( ) ; if ( value % 2 == 1 ) mid . append ( key ) ; for ( int i = 0 ; i < value / 2 ; ++ i ) candidates . add ( key ) ; } dfs ( candidates , mid , new boolean [ candidates . size ( ) ] , new StringBuilder ( ) , ans ) ; return ans ; } private void dfs ( List < Character > candidates , StringBuilder mid , boolean [ ] used , StringBuilder sb , List < String > ans ) { if ( sb . length ( ) == candidates . size ( ) ) { ans . add ( sb . toString ( ) + mid + sb . reverse ( ) . toString ( ) ) ; sb . reverse ( ) ; return ; } for ( int i = 0 ; i < candidates . size ( ) ; ++ i ) { if ( used [ i ] ) continue ; if ( i > 0 && candidates . get ( i ) == candidates . get ( i - 1 ) && ! used [ i - 1 ] ) continue ; used [ i ] = true ; sb . append ( candidates . get ( i ) ) ; dfs ( candidates , mid , used , sb , ans ) ; sb . deleteCharAt ( sb . length ( ) - 1 ) ; used [ i ] = false ; } } }
class Solution { public int missingNumber ( int [ ] nums ) { int ans = nums . length ; for ( int i = 0 ; i < nums . length ; ++ i ) ans ^= i ^ nums [ i ] ; return ans ; } }
class Solution { public String alienOrder ( String [ ] words ) { Map < Character , Set < Character > > graph = new HashMap < > ( ) ; int [ ] inDegree = new int [ 26 ] ; buildGraph ( graph , words , inDegree ) ; return topology ( graph , inDegree ) ; } private void buildGraph ( Map < Character , Set < Character > > graph , String [ ] words , int [ ] inDegree ) { for ( final String word : words ) for ( final char c : word . toCharArray ( ) ) graph . putIfAbsent ( c , new HashSet < > ( ) ) ; for ( int i = 1 ; i < words . length ; ++ i ) { final String first = words [ i - 1 ] ; final String second = words [ i ] ; final int length = Math . min ( first . length ( ) , second . length ( ) ) ; for ( int j = 0 ; j < length ; ++ j ) { final char u = first . charAt ( j ) ; final char v = second . charAt ( j ) ; if ( u != v ) { if ( ! graph . get ( u ) . contains ( v ) ) { graph . get ( u ) . add ( v ) ; ++ inDegree [ v - ' a ' ] ; } break ; } if ( j == length - 1 && first . length ( ) > second . length ( ) ) { graph . clear ( ) ; return ; } } } } private String topology ( Map < Character , Set < Character > > graph , int [ ] inDegree ) { StringBuilder sb = new StringBuilder ( ) ; Queue < Character > q = graph . keySet ( ) . stream ( ) . filter ( c -> inDegree [ c - ' a ' ] == 0 ) . collect ( Collectors . toCollection ( ArrayDeque :: new ) ) ; while ( ! q . isEmpty ( ) ) { final char u = q . poll ( ) ; sb . append ( u ) ; for ( final char v : graph . get ( u ) ) if ( -- inDegree [ v - ' a ' ] == 0 ) q . offer ( v ) ; } return sb . length ( ) == graph . size ( ) ? sb . toString ( ) : " " ; } }
class Solution { public int removeElement ( int [ ] nums , int val ) { int i = 0 ; for ( final int num : nums ) if ( num != val ) nums [ i ++ ] = num ; return i ; } }
class Solution { public int closestValue ( TreeNode root , double target ) { if ( target < root . val && root . left != null ) { final int left = closestValue ( root . left , target ) ; if ( Math . abs ( left - target ) < Math . abs ( root . val - target ) ) return left ; } if ( target > root . val && root . right != null ) { final int right = closestValue ( root . right , target ) ; if ( Math . abs ( right - target ) < Math . abs ( root . val - target ) ) return right ; } return root . val ; } }
public class Codec { public String encode ( List < String > strs ) { StringBuilder encoded = new StringBuilder ( ) ; for ( final String s : strs ) encoded . append ( s . length ( ) ) . append ( ' / ' ) . append ( s ) ; return encoded . toString ( ) ; } public List < String > decode ( String s ) { List < String > decoded = new ArrayList < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; ) { final int slash = s . indexOf ( ' / ' , i ) ; final int length = Integer . parseInt ( s . substring ( i , slash ) ) ; i = slash + length + 1 ; decoded . add ( s . substring ( slash + 1 , i ) ) ; } return decoded ; } }
class Solution { public List < Integer > closestKValues ( TreeNode root , double target , int k ) { Deque < Integer > q = new ArrayDeque < > ( ) ; inorder ( root , q ) ; while ( q . size ( ) > k ) if ( Math . abs ( q . peekFirst ( ) - target ) > Math . abs ( q . peekLast ( ) - target ) ) q . pollFirst ( ) ; else q . pollLast ( ) ; return new ArrayList < > ( q ) ; } private void inorder ( TreeNode root , Deque < Integer > q ) { if ( root == null ) return ; inorder ( root . left , q ) ; q . addLast ( root . val ) ; inorder ( root . right , q ) ; } }
class Solution { public String numberToWords ( int num ) { return num == 0 ? " Zero " : helper ( num ) ; } private final String [ ] belowTwenty = { " " , " One " , " Two " , " Three " , " Four " , " Five " , " Six " , " Seven " , " Eight " , " Nine " , " Ten " , " Eleven " , " Twelve " , " Thirteen " , " Fourteen " , " Fifteen " , " Sixteen " , " Seventeen " , " Eighteen " , " Nineteen " } ; private final String [ ] tens = { " " , " " , " Twenty " , " Thirty " , " Forty " , " Fifty " , " Sixty " , " Seventy " , " Eighty " , " Ninety " } ; private String helper ( int num ) { StringBuilder s = new StringBuilder ( ) ; if ( num < 20 ) s . append ( belowTwenty [ num ] ) ; else if ( num < 100 ) s . append ( tens [ num / 10 ] ) . append ( " ▁ " ) . append ( belowTwenty [ num % 10 ] ) ; else if ( num < 1000 ) s . append ( helper ( num / 100 ) ) . append ( " ▁ Hundred ▁ " ) . append ( helper ( num % 100 ) ) ; else if ( num < 1000000 ) s . append ( helper ( num / 1000 ) ) . append ( " ▁ Thousand ▁ " ) . append ( helper ( num % 1000 ) ) ; else if ( num < 1000000000 ) s . append ( helper ( num / 1000000 ) ) . append ( " ▁ Million ▁ " ) . append ( helper ( num % 1000000 ) ) ; else s . append ( helper ( num / 1000000000 ) ) . append ( " ▁ Billion ▁ " ) . append ( helper ( num % 1000000000 ) ) ; return s . toString ( ) . trim ( ) ; } }
class Solution { public int hIndex ( int [ ] citations ) { final int n = citations . length ; int accumulate = 0 ; int [ ] count = new int [ n + 1 ] ; for ( final int citation : citations ) ++ count [ Math . min ( citation , n ) ] ; for ( int i = n ; i >= 0 ; -- i ) { accumulate += count [ i ] ; if ( accumulate >= i ) return i ; } throw new IllegalArgumentException ( ) ; } }
class Solution { public int hIndex ( int [ ] citations ) { int l = 0 ; int r = citations . length ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( citations [ m ] >= citations . length - m ) r = m ; else l = m + 1 ; } return citations . length - l ; } }
class Solution { public int numWays ( int n , int k ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return k ; if ( n == 2 ) return k * k ; int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = k ; dp [ 2 ] = k * k ; for ( int i = 3 ; i <= n ; ++ i ) dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) * ( k - 1 ) ; return dp [ n ] ; } }
public class Solution extends Relation { public int findCelebrity ( int n ) { int candidate = 0 ; for ( int i = 1 ; i < n ; ++ i ) if ( knows ( candidate , i ) ) candidate = i ; for ( int i = 0 ; i < n ; ++ i ) { if ( i < candidate && knows ( candidate , i ) || ! knows ( i , candidate ) ) return - 1 ; if ( i > candidate && ! knows ( i , candidate ) ) return - 1 ; } return candidate ; } }
public class Solution extends VersionControl { public int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m ) ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public int numSquares ( int n ) { int [ ] dp = new int [ n + 1 ] ; Arrays . fill ( dp , n ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 1 ; j * j <= i ; ++ j ) dp [ i ] = Math . min ( dp [ i ] , dp [ i - j * j ] + 1 ) ; return dp [ n ] ; } }
class Solution { public int strStr ( String haystack , String needle ) { final int m = haystack . length ( ) ; final int n = needle . length ( ) ; for ( int i = 0 ; i < m - n + 1 ; ++ i ) if ( haystack . substring ( i , i + n ) . equals ( needle ) ) return i ; return - 1 ; } }
class Solution { public void wiggleSort ( int [ ] nums ) { for ( int i = 1 ; i < nums . length ; ++ i ) if ( ( i % 2 == 0 && nums [ i ] > nums [ i - 1 ] ) || ( i % 2 == 1 && nums [ i ] < nums [ i - 1 ] ) ) swap ( nums , i , i - 1 ) ; } private void swap ( int [ ] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } }
public class ZigzagIterator { public ZigzagIterator ( List < Integer > v1 , List < Integer > v2 ) { if ( ! v1 . isEmpty ( ) ) q . offer ( v1 . iterator ( ) ) ; if ( ! v2 . isEmpty ( ) ) q . offer ( v2 . iterator ( ) ) ; } public int next ( ) { final Iterator it = q . poll ( ) ; final int next = ( int ) it . next ( ) ; if ( it . hasNext ( ) ) q . offer ( it ) ; return next ; } public boolean hasNext ( ) { return ! q . isEmpty ( ) ; } private Queue < Iterator > q = new ArrayDeque < > ( ) ; }
class Solution { public List < String > addOperators ( String num , int target ) { List < String > ans = new ArrayList < > ( ) ; dfs ( num , target , 0 , 0 , 0 , new StringBuilder ( ) , ans ) ; return ans ; } private void dfs ( String num , int target , int s , long prev , long eval , StringBuilder sb , List < String > ans ) { if ( s == num . length ( ) ) { if ( eval == target ) ans . add ( sb . toString ( ) ) ; return ; } for ( int i = s ; i < num . length ( ) ; ++ i ) { if ( i > s && num . charAt ( s ) == '0' ) return ; final long curr = Long . parseLong ( num . substring ( s , i + 1 ) ) ; final int length = sb . length ( ) ; if ( s == 0 ) { dfs ( num , target , i + 1 , curr , curr , sb . append ( curr ) , ans ) ; sb . setLength ( length ) ; } else { dfs ( num , target , i + 1 , curr , eval + curr , sb . append ( " + " ) . append ( curr ) , ans ) ; sb . setLength ( length ) ; dfs ( num , target , i + 1 , - curr , eval - curr , sb . append ( " - " ) . append ( curr ) , ans ) ; sb . setLength ( length ) ; dfs ( num , target , i + 1 , prev * curr , eval - prev + prev * curr , sb . append ( " * " ) . append ( curr ) , ans ) ; sb . setLength ( length ) ; } } } }
class Solution { public void moveZeroes ( int [ ] nums ) { int i = 0 ; for ( final int num : nums ) if ( num != 0 ) nums [ i ++ ] = num ; while ( i < nums . length ) nums [ i ++ ] = 0 ; } }
class PeekingIterator implements Iterator < Integer > { public PeekingIterator ( Iterator < Integer > iterator ) { this . iterator = iterator ; buffer = iterator . hasNext ( ) ? iterator . next ( ) : null ; } public Integer peek ( ) { return buffer ; } @ Override public Integer next ( ) { Integer next = buffer ; buffer = iterator . hasNext ( ) ? iterator . next ( ) : null ; return next ; } @ Override public boolean hasNext ( ) { return buffer != null ; } private Iterator < Integer > iterator ; private Integer buffer ; }
class Solution { public TreeNode inorderSuccessor ( TreeNode root , TreeNode p ) { if ( root == null ) return null ; if ( root . val <= p . val ) return inorderSuccessor ( root . right , p ) ; TreeNode left = inorderSuccessor ( root . left , p ) ; return left == null ? root : left ; } }
class Solution { public void wallsAndGates ( int [ ] [ ] rooms ) { final int m = rooms . length ; final int n = rooms [ 0 ] . length ; final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; Queue < int [ ] > q = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( rooms [ i ] [ j ] == 0 ) q . offer ( new int [ ] { i , j } ) ; while ( ! q . isEmpty ( ) ) { int [ ] p = q . poll ( ) ; final int i = p [ 0 ] ; final int j = p [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( rooms [ x ] [ y ] != Integer . MAX_VALUE ) continue ; rooms [ x ] [ y ] = rooms [ i ] [ j ] + 1 ; q . offer ( new int [ ] { x , y } ) ; } } } }
class Solution { public int findDuplicate ( int [ ] nums ) { int slow = nums [ nums [ 0 ] ] ; int fast = nums [ nums [ nums [ 0 ] ] ] ; while ( slow != fast ) { slow = nums [ slow ] ; fast = nums [ nums [ fast ] ] ; } slow = nums [ 0 ] ; while ( slow != fast ) { slow = nums [ slow ] ; fast = nums [ fast ] ; } return slow ; } }
class ValidWordAbbr { public ValidWordAbbr ( String [ ] dictionary ) { dict = new HashSet < > ( Arrays . asList ( dictionary ) ) ; for ( final String word : dict ) { final String abbr = getAbbr ( word ) ; abbrUnique . put ( abbr , ! abbrUnique . containsKey ( abbr ) ) ; } } public boolean isUnique ( String word ) { final String abbr = getAbbr ( word ) ; final Boolean hasAbbr = abbrUnique . get ( abbr ) ; return hasAbbr == null || hasAbbr && dict . contains ( word ) ; } private Set < String > dict ; private Map < String , Boolean > abbrUnique = new HashMap < > ( ) ; private String getAbbr ( final String s ) { final int n = s . length ( ) ; if ( n <= 2 ) return s ; return s . charAt ( 0 ) + Integer . toString ( n - 2 ) + s . charAt ( n - 1 ) ; } }
class Solution { public void gameOfLife ( int [ ] [ ] board ) { final int m = board . length ; final int n = board [ 0 ] . length ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; for ( int x = Math . max ( 0 , i - 1 ) ; x < Math . min ( m , i + 2 ) ; ++ x ) for ( int y = Math . max ( 0 , j - 1 ) ; y < Math . min ( n , j + 2 ) ; ++ y ) ones += board [ x ] [ y ] & 1 ; if ( board [ i ] [ j ] == 1 && ( ones == 3 || ones == 4 ) ) board [ i ] [ j ] |= 0b10 ; if ( board [ i ] [ j ] == 0 && ones == 3 ) board [ i ] [ j ] |= 0b10 ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ] [ j ] >>= 1 ; } }
class Solution { public int divide ( long dividend , long divisor ) { if ( dividend == Integer . MIN_VALUE && divisor == - 1 ) return Integer . MAX_VALUE ; final int sign = dividend > 0 ^ divisor > 0 ? - 1 : 1 ; long ans = 0 ; long dvd = Math . abs ( dividend ) ; long dvs = Math . abs ( divisor ) ; while ( dvd >= dvs ) { long k = 1 ; while ( k * 2 * dvs <= dvd ) k *= 2 ; dvd -= k * dvs ; ans += k ; } return sign * ( int ) ans ; } }
class Solution { public boolean wordPattern ( String pattern , String str ) { String [ ] words = str . split ( " ▁ " ) ; if ( words . length != pattern . length ( ) ) return false ; Map < Character , Integer > charToIndex = new HashMap < > ( ) ; Map < String , Integer > stringToIndex = new HashMap < > ( ) ; for ( Integer i = 0 ; i < pattern . length ( ) ; ++ i ) if ( charToIndex . put ( pattern . charAt ( i ) , i ) != stringToIndex . put ( words [ i ] , i ) ) return false ; return true ; } }
class Solution { public boolean wordPatternMatch ( String pattern , String s ) { return isMatch ( pattern , 0 , s , 0 , new HashMap < > ( ) , new HashSet < > ( ) ) ; } private boolean isMatch ( final String pattern , int i , final String s , int j , Map < Character , String > charToString , Set < String > seen ) { if ( i == pattern . length ( ) && j == s . length ( ) ) return true ; if ( i == pattern . length ( ) || j == s . length ( ) ) return false ; final char c = pattern . charAt ( i ) ; if ( charToString . containsKey ( c ) ) { final String t = charToString . get ( c ) ; if ( ! s . startsWith ( t , j ) ) return false ; return isMatch ( pattern , i + 1 , s , j + t . length ( ) , charToString , seen ) ; } for ( int k = j ; k < s . length ( ) ; ++ k ) { final String t = s . substring ( j , k + 1 ) ; if ( seen . contains ( t ) ) continue ; charToString . put ( c , t ) ; seen . add ( t ) ; if ( isMatch ( pattern , i + 1 , s , k + 1 , charToString , seen ) ) return true ; charToString . remove ( c ) ; seen . remove ( t ) ; } return false ; } }
class Solution { public boolean canWinNim ( int n ) { return n % 4 != 0 ; } }
class Solution { public List < String > generatePossibleNextMoves ( String currentState ) { List < String > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i + 1 < currentState . length ( ) ; ++ i ) if ( currentState . charAt ( i ) == ' + ' && currentState . charAt ( i + 1 ) == ' + ' ) { StringBuilder sb = new StringBuilder ( currentState ) ; sb . setCharAt ( i , ' - ' ) ; sb . setCharAt ( i + 1 , ' - ' ) ; ans . add ( sb . toString ( ) ) ; } return ans ; } }
class Solution { public boolean canWin ( String currentState ) { if ( memo . containsKey ( currentState ) ) memo . get ( currentState ) ; for ( int i = 0 ; i + 1 < currentState . length ( ) ; ++ i ) if ( currentState . charAt ( i ) == ' + ' && currentState . charAt ( i + 1 ) == ' + ' && ! canWin ( currentState . substring ( 0 , i ) + " - " + currentState . substring ( i + 2 ) ) ) { memo . put ( currentState , true ) ; return true ; } memo . put ( currentState , false ) ; return false ; } private Map < String , Boolean > memo = new HashMap < > ( ) ; }
class MedianFinder { public void addNum ( int num ) { if ( maxHeap . isEmpty ( ) || num <= maxHeap . peek ( ) ) maxHeap . offer ( num ) ; else minHeap . offer ( num ) ; if ( maxHeap . size ( ) < minHeap . size ( ) ) maxHeap . offer ( minHeap . poll ( ) ) ; else if ( maxHeap . size ( ) - minHeap . size ( ) > 1 ) minHeap . offer ( maxHeap . poll ( ) ) ; } public double findMedian ( ) { if ( maxHeap . size ( ) == minHeap . size ( ) ) return ( double ) ( maxHeap . peek ( ) + minHeap . peek ( ) ) / 2.0 ; return ( double ) maxHeap . peek ( ) ; } private Queue < Integer > maxHeap = new PriorityQueue < > ( Collections . reverseOrder ( ) ) ; private Queue < Integer > minHeap = new PriorityQueue < > ( ) ; }
class Solution { public int minTotalDistance ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; List < Integer > I = new ArrayList < > ( ) ; List < Integer > J = new ArrayList < > ( ) ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ] [ j ] == 1 ) I . add ( i ) ; for ( int j = 0 ; j < n ; ++ j ) for ( int i = 0 ; i < m ; ++ i ) if ( grid [ i ] [ j ] == 1 ) J . add ( j ) ; return minTotalDistance ( I ) + minTotalDistance ( J ) ; } private int minTotalDistance ( List < Integer > grid ) { int sum = 0 ; int i = 0 ; int j = grid . size ( ) - 1 ; while ( i < j ) sum += grid . get ( j -- ) - grid . get ( i ++ ) ; return sum ; } }
public class Codec { public String serialize ( TreeNode root ) { if ( root == null ) return " " ; StringBuilder sb = new StringBuilder ( ) ; Queue < TreeNode > q = new LinkedList < > ( Arrays . asList ( root ) ) ; while ( ! q . isEmpty ( ) ) { TreeNode node = q . poll ( ) ; if ( node == null ) { sb . append ( " n ▁ " ) ; } else { sb . append ( node . val ) . append ( " ▁ " ) ; q . offer ( node . left ) ; q . offer ( node . right ) ; } } return sb . toString ( ) ; } public TreeNode deserialize ( String data ) { if ( data . equals ( " " ) ) return null ; final String [ ] vals = data . split ( " ▁ " ) ; TreeNode root = new TreeNode ( Integer . parseInt ( vals [ 0 ] ) ) ; Queue < TreeNode > q = new LinkedList < > ( Arrays . asList ( root ) ) ; for ( int i = 1 ; i < vals . length ; i += 2 ) { TreeNode node = q . poll ( ) ; if ( ! vals [ i ] . equals ( " n " ) ) { node . left = new TreeNode ( Integer . parseInt ( vals [ i ] ) ) ; q . offer ( node . left ) ; } if ( ! vals [ i + 1 ] . equals ( " n " ) ) { node . right = new TreeNode ( Integer . parseInt ( vals [ i + 1 ] ) ) ; q . offer ( node . right ) ; } } return root ; } }
class Solution { public int longestConsecutive ( TreeNode root ) { if ( root == null ) return 0 ; return dfs ( root , - 1 , 0 , 1 ) ; } private int dfs ( TreeNode root , int target , int length , int max ) { if ( root == null ) return max ; if ( root . val == target ) max = Math . max ( max , ++ length ) ; else length = 1 ; return Math . max ( dfs ( root . left , root . val + 1 , length , max ) , dfs ( root . right , root . val + 1 , length , max ) ) ; } }
class Solution { public String getHint ( String secret , String guess ) { int A = 0 ; int B = 0 ; int [ ] count1 = new int [ 10 ] ; int [ ] count2 = new int [ 10 ] ; for ( int i = 0 ; i < secret . length ( ) ; ++ i ) if ( secret . charAt ( i ) == guess . charAt ( i ) ) ++ A ; else { ++ count1 [ secret . charAt ( i ) - '0' ] ; ++ count2 [ guess . charAt ( i ) - '0' ] ; } for ( int i = 0 ; i < 10 ; ++ i ) B += Math . min ( count1 [ i ] , count2 [ i ] ) ; return String . valueOf ( A ) + " A " + String . valueOf ( B ) + " B " ; } }
class Solution { public int lengthOfLongestSubstring ( String s ) { int ans = 0 ; int [ ] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length ( ) ; ++ r ) { ++ count [ s . charAt ( r ) ] ; while ( count [ s . charAt ( r ) ] > 1 ) -- count [ s . charAt ( l ++ ) ] ; ans = Math . max ( ans , r - l + 1 ) ; } return ans ; } }
class Solution { public List < Integer > findSubstring ( String s , String [ ] words ) { if ( s . isEmpty ( ) || words . length == 0 ) return new ArrayList < > ( ) ; final int k = words . length ; final int n = words [ 0 ] . length ( ) ; List < Integer > ans = new ArrayList < > ( ) ; Map < String , Integer > count = new HashMap < > ( ) ; for ( final String word : words ) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ) ; for ( int i = 0 ; i <= s . length ( ) - k * n ; ++ i ) { Map < String , Integer > seen = new HashMap < > ( ) ; int j = 0 ; for ( ; j < k ; ++ j ) { final String word = s . substring ( i + j * n , i + j * n + n ) ; seen . put ( word , seen . getOrDefault ( word , 0 ) + 1 ) ; if ( seen . get ( word ) > count . getOrDefault ( word , 0 ) ) break ; } if ( j == k ) ans . add ( i ) ; } return ans ; } }
class Solution { public int lengthOfLIS ( int [ ] nums ) { if ( nums . length == 0 ) return 0 ; int [ ] dp = new int [ nums . length ] ; Arrays . fill ( dp , 1 ) ; for ( int i = 1 ; i < nums . length ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( nums [ j ] < nums [ i ] ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; } }
class Solution { public List < String > removeInvalidParentheses ( String s ) { List < String > ans = new ArrayList < > ( ) ; final int [ ] counts = getLeftAndRightCounts ( s ) ; dfs ( s , 0 , counts [ 0 ] , counts [ 1 ] , ans ) ; return ans ; } private int [ ] getLeftAndRightCounts ( final String s ) { int l = 0 ; int r = 0 ; for ( final char c : s . toCharArray ( ) ) if ( c == ' ( ' ) ++ l ; else if ( c == ' ) ' ) { if ( l == 0 ) ++ r ; else -- l ; } return new int [ ] { l , r } ; } private void dfs ( final String s , int start , int l , int r , List < String > ans ) { if ( l == 0 && r == 0 && isValid ( s ) ) { ans . add ( s ) ; return ; } for ( int i = start ; i < s . length ( ) ; ++ i ) { if ( i > start && s . charAt ( i ) == s . charAt ( i - 1 ) ) continue ; if ( l > 0 && s . charAt ( i ) == ' ( ' ) dfs ( s . substring ( 0 , i ) + s . substring ( i + 1 ) , i , l - 1 , r , ans ) ; else if ( r > 0 && s . charAt ( i ) == ' ) ' ) dfs ( s . substring ( 0 , i ) + s . substring ( i + 1 ) , i , l , r - 1 , ans ) ; } } private boolean isValid ( final String s ) { int count = 0 ; for ( final char c : s . toCharArray ( ) ) { if ( c == ' ( ' ) ++ count ; else if ( c == ' ) ' ) -- count ; if ( count < 0 ) return false ; } return true ; } }
class Solution { public int minArea ( char [ ] [ ] image , int x , int y ) { final int m = image . length ; final int n = image [ 0 ] . length ; final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; int [ ] topLeft = { x , y } ; int [ ] bottomRight = { x , y } ; Queue < int [ ] > q = new ArrayDeque < > ( Arrays . asList ( new int [ ] { x , y } ) ) ; image [ x ] [ y ] = '2' ; while ( ! q . isEmpty ( ) ) { final int i = q . peek ( ) [ 0 ] ; final int j = q . poll ( ) [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int r = i + dirs [ k ] ; final int c = j + dirs [ k + 1 ] ; if ( r < 0 || r == m || c < 0 || c == n ) continue ; if ( image [ r ] [ c ] != '1' ) continue ; topLeft [ 0 ] = Math . min ( topLeft [ 0 ] , r ) ; topLeft [ 1 ] = Math . min ( topLeft [ 1 ] , c ) ; bottomRight [ 0 ] = Math . max ( bottomRight [ 0 ] , r ) ; bottomRight [ 1 ] = Math . max ( bottomRight [ 1 ] , c ) ; q . offer ( new int [ ] { r , c } ) ; image [ r ] [ c ] = '2' ; } } final int width = bottomRight [ 1 ] - topLeft [ 1 ] + 1 ; final int height = bottomRight [ 0 ] - topLeft [ 0 ] + 1 ; return width * height ; } }
class NumArray { public NumArray ( int [ ] nums ) { prefix = new int [ nums . length + 1 ] ; for ( int i = 0 ; i < nums . length ; ++ i ) prefix [ i + 1 ] = nums [ i ] + prefix [ i ] ; } public int sumRange ( int left , int right ) { return prefix [ right + 1 ] - prefix [ left ] ; } private int [ ] prefix ; }
class NumMatrix { public NumMatrix ( int [ ] [ ] matrix ) { if ( matrix . length == 0 ) return ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; prefix = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) prefix [ i + 1 ] [ j + 1 ] = matrix [ i ] [ j ] + prefix [ i ] [ j + 1 ] + prefix [ i + 1 ] [ j ] - prefix [ i ] [ j ] ; } public int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { return prefix [ row2 + 1 ] [ col2 + 1 ] - prefix [ row1 ] [ col2 + 1 ] - prefix [ row2 + 1 ] [ col1 ] + prefix [ row1 ] [ col1 ] ; } private int [ ] [ ] prefix ; }
class UnionFind { public int [ ] id ; public UnionFind ( int n ) { id = new int [ n ] ; Arrays . fill ( id , - 1 ) ; } public void union ( int u , int v ) { id [ u ] = v ; } public int find ( int u ) { return id [ u ] == u ? u : ( id [ u ] = find ( id [ u ] ) ) ; } } class Solution { public List < Integer > numIslands2 ( int m , int n , int [ ] [ ] positions ) { final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; List < Integer > ans = new ArrayList < > ( ) ; boolean [ ] [ ] seen = new boolean [ m ] [ n ] ; UnionFind uf = new UnionFind ( m * n ) ; int count = 0 ; for ( int [ ] p : positions ) { final int i = p [ 0 ] ; final int j = p [ 1 ] ; if ( seen [ i ] [ j ] ) { ans . add ( count ) ; continue ; } seen [ i ] [ j ] = true ; final int id = getId ( i , j , n ) ; uf . id [ id ] = id ; ++ count ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; final int neighborId = getId ( x , y , n ) ; if ( uf . id [ neighborId ] == - 1 ) continue ; final int currentParent = uf . find ( id ) ; final int neighborParent = uf . find ( neighborId ) ; if ( currentParent != neighborParent ) { uf . union ( currentParent , neighborParent ) ; -- count ; } } ans . add ( count ) ; } return ans ; } private int getId ( int i , int j , int n ) { return i * n + j ; } }
class Solution { public boolean isAdditiveNumber ( String num ) { final int n = num . length ( ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( i > 0 && num . charAt ( 0 ) == '0' ) return false ; final long firstNum = Long . parseLong ( num . substring ( 0 , i + 1 ) ) ; for ( int j = i + 1 ; Math . max ( i , j - i ) < n - j ; ++ j ) { if ( j > i + 1 && num . charAt ( i + 1 ) == '0' ) break ; final long secondNum = Long . parseLong ( num . substring ( i + 1 , j + 1 ) ) ; if ( dfs ( num , firstNum , secondNum , j + 1 ) ) return true ; } } return false ; } private boolean dfs ( final String num , long firstNum , long secondNum , long s ) { if ( s == num . length ( ) ) return true ; final long thirdNum = firstNum + secondNum ; final String thirdNumStr = String . valueOf ( thirdNum ) ; return num . indexOf ( thirdNumStr , ( int ) s ) == s && dfs ( num , secondNum , thirdNum , s + thirdNumStr . length ( ) ) ; } }
class FenwickTree { public FenwickTree ( int n ) { sums = new int [ n + 1 ] ; } public void update ( int i , int delta ) { while ( i < sums . length ) { sums [ i ] += delta ; i += lowbit ( i ) ; } } public int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ] ; i -= lowbit ( i ) ; } return sum ; } private int [ ] sums ; private static int lowbit ( int i ) { return i & - i ; } } class NumArray { public NumArray ( int [ ] nums ) { this . nums = nums ; tree = new FenwickTree ( nums . length ) ; for ( int i = 0 ; i < nums . length ; ++ i ) tree . update ( i + 1 , nums [ i ] ) ; } public void update ( int index , int val ) { tree . update ( index + 1 , val - nums [ index ] ) ; nums [ index ] = val ; } public int sumRange ( int left , int right ) { return tree . get ( right + 1 ) - tree . get ( left ) ; } private int [ ] nums ; private FenwickTree tree ; }
class FenwickTree { public FenwickTree ( int m , int n ) { sums = new int [ m + 1 ] [ n + 1 ] ; } public void update ( int row , int col , int delta ) { for ( int i = row ; i < sums . length ; i += i & - i ) for ( int j = col ; j < sums [ 0 ] . length ; j += j & - j ) sums [ i ] [ j ] += delta ; } public int get ( int row , int col ) { int sum = 0 ; for ( int i = row ; i > 0 ; i -= i & - i ) for ( int j = col ; j > 0 ; j -= j & - j ) sum += sums [ i ] [ j ] ; return sum ; } private int [ ] [ ] sums ; } class NumMatrix { public NumMatrix ( int [ ] [ ] matrix ) { this . matrix = matrix ; tree = new FenwickTree ( matrix . length , matrix [ 0 ] . length ) ; for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) tree . update ( i + 1 , j + 1 , matrix [ i ] [ j ] ) ; } public void update ( int row , int col , int val ) { tree . update ( row + 1 , col + 1 , val - matrix [ row ] [ col ] ) ; matrix [ row ] [ col ] = val ; } public int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { return tree . get ( row2 + 1 , col2 + 1 ) - tree . get ( row1 , col2 + 1 ) - tree . get ( row2 + 1 , col1 ) + tree . get ( row1 , col1 ) ; } private int [ ] [ ] matrix ; private FenwickTree tree ; }
class Solution { public int maxProfit ( int [ ] prices ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; int prev = 0 ; for ( final int price : prices ) { final int cache = sell ; sell = Math . max ( sell , hold + price ) ; hold = Math . max ( hold , prev - price ) ; prev = cache ; } return sell ; } }
class Solution { public void nextPermutation ( int [ ] nums ) { final int n = nums . length ; int i ; for ( i = n - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ] ) break ; if ( i >= 0 ) for ( int j = n - 1 ; j > i ; -- j ) if ( nums [ j ] > nums [ i ] ) { swap ( nums , i , j ) ; break ; } reverse ( nums , i + 1 , n - 1 ) ; } private void reverse ( int [ ] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++ , r -- ) ; } private void swap ( int [ ] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } }
class Solution { public List < Integer > findMinHeightTrees ( int n , int [ ] [ ] edges ) { if ( n == 0 || edges . length == 0 ) return new ArrayList < > ( Arrays . asList ( 0 ) ) ; List < Integer > ans = new ArrayList < > ( ) ; Map < Integer , Set < Integer > > graph = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) graph . put ( i , new HashSet < > ( ) ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 0 ] ; graph . get ( u ) . add ( v ) ; graph . get ( v ) . add ( u ) ; } for ( Map . Entry < Integer , Set < Integer > > entry : graph . entrySet ( ) ) { final int label = entry . getKey ( ) ; Set < Integer > children = entry . getValue ( ) ; if ( children . size ( ) == 1 ) ans . add ( label ) ; } while ( n > 2 ) { n -= ans . size ( ) ; List < Integer > nextLeaves = new ArrayList < > ( ) ; for ( final int leaf : ans ) { final int u = ( int ) graph . get ( leaf ) . iterator ( ) . next ( ) ; graph . get ( u ) . remove ( leaf ) ; if ( graph . get ( u ) . size ( ) == 1 ) nextLeaves . add ( u ) ; } ans = nextLeaves ; } return ans ; } }
class Solution { public int [ ] [ ] multiply ( int [ ] [ ] mat1 , int [ ] [ ] mat2 ) { final int m = mat1 . length ; final int n = mat2 . length ; final int l = mat2 [ 0 ] . length ; int [ ] [ ] ans = new int [ m ] [ l ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < l ; ++ j ) for ( int k = 0 ; k < n ; ++ k ) ans [ i ] [ j ] += mat1 [ i ] [ k ] * mat2 [ k ] [ j ] ; return ans ; } }
class Solution { public int maxCoins ( int [ ] nums ) { final int n = nums . length ; A = new int [ n + 2 ] ; System . arraycopy ( nums , 0 , A , 1 , n ) ; A [ 0 ] = 1 ; A [ n + 1 ] = 1 ; dp = new int [ n + 2 ] [ n + 2 ] ; return maxCoins ( 1 , n ) ; } private int [ ] [ ] dp ; private int [ ] A ; private int maxCoins ( int i , int j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] > 0 ) return dp [ i ] [ j ] ; for ( int k = i ; k <= j ; ++ k ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , maxCoins ( i , k - 1 ) + maxCoins ( k + 1 , j ) + A [ i - 1 ] * A [ k ] * A [ j + 1 ] ) ; return dp [ i ] [ j ] ; } }
class Solution { public int nthSuperUglyNumber ( int n , int [ ] primes ) { final int k = primes . length ; int [ ] indices = new int [ k ] ; int [ ] uglyNums = new int [ n ] ; uglyNums [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) { int [ ] nexts = new int [ k ] ; for ( int j = 0 ; j < k ; ++ j ) nexts [ j ] = uglyNums [ indices [ j ] ] * primes [ j ] ; final int next = Arrays . stream ( nexts ) . min ( ) . getAsInt ( ) ; for ( int j = 0 ; j < k ; ++ j ) if ( next == nexts [ j ] ) ++ indices [ j ] ; uglyNums [ i ] = next ; } return uglyNums [ n - 1 ] ; } }
class Solution { public List < List < Integer > > verticalOrder ( TreeNode root ) { if ( root == null ) return new ArrayList < > ( ) ; List < List < Integer > > ans = new ArrayList < > ( ) ; Queue < Pair < TreeNode , Integer > > q = new ArrayDeque < > ( ) ; int [ ] range = new int [ 2 ] ; getRange ( root , range , 0 ) ; for ( int i = range [ 0 ] ; i <= range [ 1 ] ; ++ i ) ans . add ( new ArrayList < > ( ) ) ; q . offer ( new Pair < > ( root , - range [ 0 ] ) ) ; while ( ! q . isEmpty ( ) ) { final TreeNode node = q . peek ( ) . getKey ( ) ; final int x = q . poll ( ) . getValue ( ) ; ans . get ( x ) . add ( node . val ) ; if ( node . left != null ) q . offer ( new Pair < > ( node . left , x - 1 ) ) ; if ( node . right != null ) q . offer ( new Pair < > ( node . right , x + 1 ) ) ; } return ans ; } private void getRange ( TreeNode root , int [ ] range , int x ) { if ( root == null ) return ; range [ 0 ] = Math . min ( range [ 0 ] , x ) ; range [ 1 ] = Math . max ( range [ 1 ] , x ) ; getRange ( root . left , range , x - 1 ) ; getRange ( root . right , range , x + 1 ) ; } }
class FenwickTree { public FenwickTree ( int n ) { sums = new int [ n + 1 ] ; } public void update ( int i , int delta ) { while ( i < sums . length ) { sums [ i ] += delta ; i += lowbit ( i ) ; } } public int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ] ; i -= lowbit ( i ) ; } return sum ; } private int [ ] sums ; private static int lowbit ( int i ) { return i & - i ; } } class Solution { public List < Integer > countSmaller ( int [ ] nums ) { List < Integer > ans = new ArrayList < > ( ) ; Map < Integer , Integer > ranks = new HashMap < > ( ) ; getRanks ( nums , ranks ) ; FenwickTree tree = new FenwickTree ( ranks . size ( ) ) ; for ( int i = nums . length - 1 ; i >= 0 ; -- i ) { final int num = nums [ i ] ; ans . add ( tree . get ( ranks . get ( num ) - 1 ) ) ; tree . update ( ranks . get ( num ) , 1 ) ; } Collections . reverse ( ans ) ; return ans ; } private void getRanks ( int [ ] nums , Map < Integer , Integer > ranks ) { SortedSet < Integer > sorted = new TreeSet < > ( ) ; for ( final int num : nums ) sorted . add ( num ) ; int rank = 0 ; for ( Iterator < Integer > it = sorted . iterator ( ) ; it . hasNext ( ) ; ) ranks . put ( it . next ( ) , ++ rank ) ; } }
class Solution { public String removeDuplicateLetters ( String s ) { StringBuilder sb = new StringBuilder ( ) ; int [ ] count = new int [ 128 ] ; boolean [ ] used = new boolean [ 128 ] ; for ( final char c : s . toCharArray ( ) ) ++ count [ c ] ; for ( final char c : s . toCharArray ( ) ) { -- count [ c ] ; if ( used [ c ] ) continue ; while ( sb . length ( ) > 0 && last ( sb ) > c && count [ last ( sb ) ] > 0 ) { used [ last ( sb ) ] = false ; sb . setLength ( sb . length ( ) - 1 ) ; } used [ c ] = true ; sb . append ( c ) ; } return sb . toString ( ) ; } private char last ( StringBuilder sb ) { return sb . charAt ( sb . length ( ) - 1 ) ; } }
class Solution { public int shortestDistance ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; final int nBuildings = getBuildingCount ( grid ) ; int ans = Integer . MAX_VALUE ; int [ ] [ ] dist = new int [ m ] [ n ] ; int [ ] [ ] reachCount = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ] [ j ] == 1 ) if ( ! bfs ( grid , i , j , dist , reachCount , nBuildings ) ) return - 1 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( reachCount [ i ] [ j ] == nBuildings ) ans = Math . min ( ans , dist [ i ] [ j ] ) ; return ans == Integer . MAX_VALUE ? - 1 : ans ; } private static final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; private boolean bfs ( int [ ] [ ] grid , int row , int col , int [ ] [ ] dist , int [ ] [ ] reachCount , int nBuildings ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; Queue < int [ ] > q = new ArrayDeque < > ( Arrays . asList ( new int [ ] { row , col } ) ) ; boolean [ ] [ ] seen = new boolean [ m ] [ n ] ; seen [ row ] [ col ] = true ; int depth = 0 ; int seenBuildings = 1 ; while ( ! q . isEmpty ( ) ) { ++ depth ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final int i = q . peek ( ) [ 0 ] ; final int j = q . poll ( ) [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seen [ x ] [ y ] ) continue ; seen [ x ] [ y ] = true ; if ( grid [ x ] [ y ] == 0 ) { dist [ x ] [ y ] += depth ; ++ reachCount [ x ] [ y ] ; q . offer ( new int [ ] { x , y } ) ; } else if ( grid [ x ] [ y ] == 1 ) { ++ seenBuildings ; } } } } return seenBuildings == nBuildings ; } private int getBuildingCount ( int [ ] [ ] grid ) { int buildingCount = 0 ; for ( int [ ] row : grid ) for ( final int cell : row ) if ( cell == 1 ) ++ buildingCount ; return buildingCount ; } }
class Solution { public int maxProduct ( String [ ] words ) { int ans = 0 ; int [ ] masks = new int [ words . length ] ; for ( int i = 0 ; i < words . length ; ++ i ) masks [ i ] = getMask ( words [ i ] ) ; for ( int i = 0 ; i < masks . length ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( ( masks [ i ] & masks [ j ] ) == 0 ) ans = Math . max ( ans , words [ i ] . length ( ) * words [ j ] . length ( ) ) ; return ans ; } private int getMask ( final String word ) { int mask = 0 ; for ( final char c : word . toCharArray ( ) ) mask |= 1 << c - ' a ' ; return mask ; } }
class Solution { public int bulbSwitch ( int n ) { return ( int ) Math . sqrt ( n ) ; } }
class Solution { public int longestValidParentheses ( String s ) { final String s2 = " ) " + s ; int dp [ ] = new int [ s2 . length ( ) ] ; for ( int i = 1 ; i < s2 . length ( ) ; ++ i ) if ( s2 . charAt ( i ) == ' ) ' && s2 . charAt ( i - dp [ i - 1 ] - 1 ) == ' ( ' ) dp [ i ] = dp [ i - 1 ] + dp [ i - dp [ i - 1 ] - 2 ] + 2 ; return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; } }
class Solution { public List < String > generateAbbreviations ( String word ) { List < String > ans = new ArrayList < > ( ) ; dfs ( word , 0 , 0 , new StringBuilder ( ) , ans ) ; return ans ; } private void dfs ( final String word , int i , int count , StringBuilder sb , List < String > ans ) { if ( i == word . length ( ) ) { final int length = sb . length ( ) ; ans . add ( sb . append ( getCountString ( count ) ) . toString ( ) ) ; sb . setLength ( length ) ; return ; } dfs ( word , i + 1 , count + 1 , sb , ans ) ; final int length = sb . length ( ) ; dfs ( word , i + 1 , 0 , sb . append ( getCountString ( count ) ) . append ( word . charAt ( i ) ) , ans ) ; sb . setLength ( length ) ; } private String getCountString ( int count ) { return count > 0 ? String . valueOf ( count ) : " " ; } }
class Solution { public int coinChange ( int [ ] coins , int amount ) { int [ ] dp = new int [ amount + 1 ] ; Arrays . fill ( dp , 1 , dp . length , amount + 1 ) ; for ( final int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] = Math . min ( dp [ i ] , dp [ i - coin ] + 1 ) ; return dp [ amount ] == amount + 1 ? - 1 : dp [ amount ] ; } }
class Solution { public int countComponents ( int n , int [ ] [ ] edges ) { int ans = 0 ; List < Integer > [ ] graph = new List [ n ] ; Set < Integer > seen = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( int [ ] e : edges ) { final int u = e [ 0 ] ; final int v = e [ 1 ] ; graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } for ( int i = 0 ; i < n ; ++ i ) if ( ! seen . contains ( i ) ) { bfs ( graph , i , seen ) ; ++ ans ; } return ans ; } private void bfs ( List < Integer > [ ] graph , int node , Set < Integer > seen ) { Queue < Integer > q = new ArrayDeque < > ( Arrays . asList ( node ) ) ; seen . add ( node ) ; while ( ! q . isEmpty ( ) ) { final int u = q . poll ( ) ; for ( final int v : graph [ u ] ) if ( ! seen . contains ( v ) ) { q . offer ( v ) ; seen . add ( v ) ; } } } }
class Solution { public int maxSubArrayLen ( int [ ] nums , int k ) { int ans = 0 ; int prefix = 0 ; Map < Integer , Integer > prefixToIndex = new HashMap < > ( ) ; prefixToIndex . put ( 0 , - 1 ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { prefix += nums [ i ] ; final int target = prefix - k ; if ( prefixToIndex . containsKey ( target ) ) ans = Math . max ( ans , i - prefixToIndex . get ( target ) ) ; prefixToIndex . putIfAbsent ( prefix , i ) ; } return ans ; } }
class Solution { public boolean isPowerOfThree ( int n ) { return n > 0 && Math . pow ( 3 , 19 ) % n == 0 ; } }
class Solution { public int countRangeSum ( int [ ] nums , int lower , int upper ) { final int n = nums . length ; long [ ] prefix = new long [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) prefix [ i + 1 ] = ( long ) nums [ i ] + prefix [ i ] ; mergeSort ( prefix , 0 , n , lower , upper ) ; return ans ; } private int ans = 0 ; private void mergeSort ( long [ ] prefix , int l , int r , int lower , int upper ) { if ( l >= r ) return ; final int m = ( l + r ) / 2 ; mergeSort ( prefix , l , m , lower , upper ) ; mergeSort ( prefix , m + 1 , r , lower , upper ) ; merge ( prefix , l , m , r , lower , upper ) ; } private void merge ( long [ ] prefix , int l , int m , int r , int lower , int upper ) { int lo = m + 1 ; int hi = m + 1 ; for ( int i = l ; i <= m ; ++ i ) { while ( lo <= r && prefix [ lo ] - prefix [ i ] < lower ) ++ lo ; while ( hi <= r && prefix [ hi ] - prefix [ i ] <= upper ) ++ hi ; ans += hi - lo ; } long [ ] sorted = new long [ r - l + 1 ] ; int k = 0 ; int i = l ; int j = m + 1 ; while ( i <= m && j <= r ) if ( prefix [ i ] < prefix [ j ] ) sorted [ k ++ ] = prefix [ i ++ ] ; else sorted [ k ++ ] = prefix [ j ++ ] ; while ( i <= m ) sorted [ k ++ ] = prefix [ i ++ ] ; while ( j <= r ) sorted [ k ++ ] = prefix [ j ++ ] ; System . arraycopy ( sorted , 0 , prefix , l , sorted . length ) ; } }
class Solution { public ListNode oddEvenList ( ListNode head ) { ListNode oddHead = new ListNode ( 0 ) ; ListNode evenHead = new ListNode ( 0 ) ; ListNode odd = oddHead ; ListNode even = evenHead ; for ( boolean isOdd = true ; head != null ; head = head . next , isOdd = ! isOdd ) if ( isOdd ) { odd . next = head ; odd = odd . next ; } else { even . next = head ; even = even . next ; } odd . next = evenHead . next ; even . next = null ; return oddHead . next ; } }
class Solution { public int longestIncreasingPath ( int [ ] [ ] matrix ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int ans = 0 ; int [ ] [ ] memo = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = Math . max ( ans , dfs ( matrix , i , j , Integer . MIN_VALUE , memo ) ) ; return ans ; } private int dfs ( int [ ] [ ] matrix , int i , int j , int prev , int [ ] [ ] memo ) { if ( i < 0 || i == matrix . length || j < 0 || j == matrix [ 0 ] . length ) return 0 ; if ( matrix [ i ] [ j ] <= prev ) return 0 ; if ( memo [ i ] [ j ] > 0 ) return memo [ i ] [ j ] ; final int curr = matrix [ i ] [ j ] ; final int a = dfs ( matrix , i + 1 , j , curr , memo ) ; final int b = dfs ( matrix , i - 1 , j , curr , memo ) ; final int c = dfs ( matrix , i , j + 1 , curr , memo ) ; final int d = dfs ( matrix , i , j - 1 , curr , memo ) ; return memo [ i ] [ j ] = 1 + Math . max ( Math . max ( a , b ) , Math . max ( c , d ) ) ; } }
class Solution { public int search ( int [ ] nums , int target ) { int l = 0 ; int r = nums . length - 1 ; while ( l <= r ) { final int m = ( l + r ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ] ) { if ( nums [ l ] <= target && target < nums [ m ] ) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ] ) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } }
class Solution { public int minPatches ( int [ ] nums , int n ) { int ans = 0 ; int i = 0 ; long miss = 1 ; while ( miss <= n ) if ( i < nums . length && nums [ i ] <= miss ) { miss += nums [ i ++ ] ; } else { miss += miss ; ++ ans ; } return ans ; } }
class Solution { public boolean isValidSerialization ( String preorder ) { int degree = 1 ; for ( final String node : preorder . split ( " , " ) ) { if ( -- degree < 0 ) return false ; if ( ! node . equals ( " # " ) ) degree += 2 ; } return degree == 0 ; } }
class Solution { public List < String > findItinerary ( List < List < String > > tickets ) { LinkedList < String > ans = new LinkedList < > ( ) ; Map < String , Queue < String > > graph = new HashMap < > ( ) ; for ( final List < String > ticket : tickets ) { graph . putIfAbsent ( ticket . get ( 0 ) , new PriorityQueue < > ( ) ) ; graph . get ( ticket . get ( 0 ) ) . offer ( ticket . get ( 1 ) ) ; } dfs ( graph , " JFK " , ans ) ; return ans ; } private void dfs ( Map < String , Queue < String > > graph , final String u , LinkedList < String > ans ) { final Queue < String > arrivals = graph . get ( u ) ; while ( arrivals != null && ! arrivals . isEmpty ( ) ) dfs ( graph , arrivals . poll ( ) , ans ) ; ans . addFirst ( u ) ; } }
class Solution { public boolean increasingTriplet ( int [ ] nums ) { int first = Integer . MAX_VALUE ; int second = Integer . MAX_VALUE ; for ( final int num : nums ) if ( num <= first ) first = num ; else if ( num <= second ) second = num ; else return true ; return false ; } }
class Solution { public boolean isSelfCrossing ( int [ ] x ) { if ( x . length <= 3 ) return false ; for ( int i = 3 ; i < x . length ; ++ i ) { if ( x [ i - 2 ] <= x [ i ] && x [ i - 1 ] <= x [ i - 3 ] ) return true ; if ( i >= 4 && x [ i - 1 ] == x [ i - 3 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ] ) return true ; if ( i >= 5 && x [ i - 4 ] <= x [ i - 2 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ] && x [ i - 1 ] <= x [ i - 3 ] && x [ i - 3 ] <= x [ i - 1 ] + x [ i - 5 ] ) return true ; } return false ; } }
class Solution { public List < List < Integer > > palindromePairs ( String [ ] words ) { List < List < Integer > > ans = new ArrayList < > ( ) ; Map < String , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < words . length ; ++ i ) map . put ( new StringBuilder ( words [ i ] ) . reverse ( ) . toString ( ) , i ) ; for ( int i = 0 ; i < words . length ; ++ i ) { final String word = words [ i ] ; if ( map . containsKey ( " " ) && map . get ( " " ) != i && isPalindrome ( word ) ) ans . add ( Arrays . asList ( i , map . get ( " " ) ) ) ; for ( int j = 1 ; j <= word . length ( ) ; ++ j ) { final String l = word . substring ( 0 , j ) ; final String r = word . substring ( j ) ; if ( map . containsKey ( l ) && map . get ( l ) != i && isPalindrome ( r ) ) ans . add ( Arrays . asList ( i , map . get ( l ) ) ) ; if ( map . containsKey ( r ) && map . get ( r ) != i && isPalindrome ( l ) ) ans . add ( Arrays . asList ( map . get ( r ) , i ) ) ; } } return ans ; } private boolean isPalindrome ( final String word ) { int l = 0 ; int r = word . length ( ) - 1 ; while ( l < r ) if ( word . charAt ( l ++ ) != word . charAt ( r -- ) ) return false ; return true ; } }
class T { public int robRoot ; public int notRobRoot ; public T ( int robRoot , int notRobRoot ) { this . robRoot = robRoot ; this . notRobRoot = notRobRoot ; } } class Solution { public int rob ( TreeNode root ) { T t = robOrNotRob ( root ) ; return Math . max ( t . robRoot , t . notRobRoot ) ; } private T robOrNotRob ( TreeNode root ) { if ( root == null ) return new T ( 0 , 0 ) ; T l = robOrNotRob ( root . left ) ; T r = robOrNotRob ( root . right ) ; return new T ( root . val + l . notRobRoot + r . notRobRoot , Math . max ( l . robRoot , l . notRobRoot ) + Math . max ( r . robRoot , r . notRobRoot ) ) ; } }
class Solution { public int [ ] countBits ( int n ) { int [ ] ans = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; ++ i ) ans [ i ] = ans [ i / 2 ] + ( i % 2 == 0 ? 0 : 1 ) ; return ans ; } }
class Solution { public int depthSum ( List < NestedInteger > nestedList ) { int ans = 0 ; int depth = 0 ; Queue < NestedInteger > q = new ArrayDeque < > ( ) ; addIntegers ( q , nestedList ) ; while ( ! q . isEmpty ( ) ) { ++ depth ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { final NestedInteger ni = q . poll ( ) ; if ( ni . isInteger ( ) ) ans += ni . getInteger ( ) * depth ; else addIntegers ( q , ni . getList ( ) ) ; } } return ans ; } private void addIntegers ( Queue < NestedInteger > q , List < NestedInteger > nestedList ) { for ( final NestedInteger ni : nestedList ) q . offer ( ni ) ; } }
class Solution { public int [ ] searchRange ( int [ ] nums , int target ) { final int l = firstGreaterEqual ( nums , target ) ; if ( l == nums . length || nums [ l ] != target ) return new int [ ] { - 1 , - 1 } ; final int r = firstGreaterEqual ( nums , target + 1 ) - 1 ; return new int [ ] { l , r } ; } private int firstGreaterEqual ( int [ ] A , int target ) { int l = 0 ; int r = A . length ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( A [ m ] >= target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public int lengthOfLongestSubstringKDistinct ( String s , int k ) { int ans = 0 ; int distinct = 0 ; int [ ] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length ( ) ; ++ r ) { if ( ++ count [ s . charAt ( r ) ] == 1 ) ++ distinct ; while ( distinct == k + 1 ) if ( -- count [ s . charAt ( l ++ ) ] == 0 ) -- distinct ; ans = Math . max ( ans , r - l + 1 ) ; } return ans ; } }
public class NestedIterator implements Iterator < Integer > { public NestedIterator ( List < NestedInteger > nestedList ) { addInteger ( nestedList ) ; } @ Override public Integer next ( ) { return q . poll ( ) ; } @ Override public boolean hasNext ( ) { return ! q . isEmpty ( ) ; } private Queue < Integer > q = new ArrayDeque < > ( ) ; private void addInteger ( final List < NestedInteger > nestedList ) { for ( final NestedInteger ni : nestedList ) if ( ni . isInteger ( ) ) q . offer ( ni . getInteger ( ) ) ; else addInteger ( ni . getList ( ) ) ; } }
class Solution { public boolean isPowerOfFour ( int n ) { return n > 0 && Integer . bitCount ( n ) == 1 && ( n - 1 ) % 3 == 0 ; } }
class Solution { public int integerBreak ( int n ) { if ( n == 2 ) return 1 ; if ( n == 3 ) return 2 ; int ans = 1 ; while ( n > 4 ) { n -= 3 ; ans *= 3 ; } ans *= n ; return ans ; } }
class Solution { public void reverseString ( char [ ] s ) { int l = 0 ; int r = s . length - 1 ; while ( l < r ) { char temp = s [ l ] ; s [ l ++ ] = s [ r ] ; s [ r -- ] = temp ; } } }
class Solution { public String reverseVowels ( String s ) { final String vowels = " aeiouAEIOU " ; StringBuilder sb = new StringBuilder ( s ) ; int l = 0 ; int r = s . length ( ) - 1 ; while ( l < r ) { while ( l < r && ! vowels . contains ( " " + sb . charAt ( l ) ) ) ++ l ; while ( l < r && ! vowels . contains ( " " + sb . charAt ( r ) ) ) -- r ; sb . setCharAt ( l , s . charAt ( r ) ) ; sb . setCharAt ( r , s . charAt ( l ) ) ; ++ l ; -- r ; } return sb . toString ( ) ; } }
class MovingAverage { public MovingAverage ( int size ) { this . size = size ; } public double next ( int val ) { if ( q . size ( ) == size ) sum -= q . poll ( ) ; sum += val ; q . offer ( val ) ; return sum / q . size ( ) ; } private int size = 0 ; private double sum = 0 ; private Queue < Integer > q = new ArrayDeque < > ( ) ; }
class TicTacToe { public TicTacToe ( int n ) { this . n = n ; rows = new int [ n ] ; cols = new int [ n ] ; } public int move ( int row , int col , int player ) { final int toAdd = player == 1 ? 1 : - 1 ; final int target = player == 1 ? n : - n ; if ( row == col ) { diag += toAdd ; if ( diag == target ) return player ; } if ( row + col == n - 1 ) { antiDiag += toAdd ; if ( antiDiag == target ) return player ; } rows [ row ] += toAdd ; if ( rows [ row ] == target ) return player ; cols [ col ] += toAdd ; if ( cols [ col ] == target ) return player ; return 0 ; } private final int n ; private int [ ] rows ; private int [ ] cols ; private int diag = 0 ; private int antiDiag = 0 ; }
class Solution { public int [ ] intersection ( int [ ] nums1 , int [ ] nums2 ) { List < Integer > ans = new ArrayList < > ( ) ; Set < Integer > set = Arrays . stream ( nums1 ) . boxed ( ) . collect ( Collectors . toSet ( ) ) ; for ( final int num : nums2 ) if ( set . remove ( num ) ) ans . add ( num ) ; return ans . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; } }
class Solution { public int searchInsert ( int [ ] nums , int target ) { int l = 0 ; int r = nums . length ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } }
class Solution { public int [ ] intersect ( int [ ] nums1 , int [ ] nums2 ) { if ( nums1 . length > nums2 . length ) return intersect ( nums2 , nums1 ) ; List < Integer > ans = new ArrayList < > ( ) ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( final int num : nums1 ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ) ; for ( final int num : nums2 ) if ( count . containsKey ( num ) && count . get ( num ) > 0 ) { ans . add ( num ) ; count . put ( num , count . get ( num ) - 1 ) ; } return ans . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; } }
class Solution { public int numberOfPatterns ( int m , int n ) { int ans = 0 ; int [ ] [ ] across = new int [ 10 ] [ 10 ] ; boolean [ ] seen = new boolean [ 10 ] ; across [ 1 ] [ 3 ] = across [ 3 ] [ 1 ] = 2 ; across [ 1 ] [ 7 ] = across [ 7 ] [ 1 ] = 4 ; across [ 3 ] [ 9 ] = across [ 9 ] [ 3 ] = 6 ; across [ 7 ] [ 9 ] = across [ 9 ] [ 7 ] = 8 ; across [ 1 ] [ 9 ] = across [ 9 ] [ 1 ] = across [ 2 ] [ 8 ] = across [ 8 ] [ 2 ] = across [ 3 ] [ 7 ] = across [ 7 ] [ 3 ] = across [ 4 ] [ 6 ] = across [ 6 ] [ 4 ] = 5 ; ans += dfs ( m , n , 1 , 1 , seen , across ) * 4 ; ans += dfs ( m , n , 2 , 1 , seen , across ) * 4 ; ans += dfs ( m , n , 5 , 1 , seen , across ) ; return ans ; } private int dfs ( int m , int n , int u , int level , boolean [ ] seen , int [ ] [ ] across ) { if ( level > n ) return 0 ; seen [ u ] = true ; int ans = level >= m ; for ( int v = 1 ; v <= 9 ; ++ v ) { if ( v == u || seen [ v ] ) continue ; final int acrossed = across [ u ] [ v ] ; if ( acrossed == 0 || seen [ acrossed ] ) ans += dfs ( m , n , v , level + 1 , seen , across ) ; } seen [ u ] = false ; return ans ; } }
class SnakeGame { public SnakeGame ( int width , int height , int [ ] [ ] food ) { this . width = width ; this . height = height ; this . food = food ; lookup . add ( getId ( 0 , 0 ) ) ; body . offerLast ( getId ( 0 , 0 ) ) ; } public int move ( String direction ) { int i = body . peekFirst ( ) / width ; int j = body . peekFirst ( ) % width ; if ( direction . equals ( " U " ) && -- i < 0 ) return - 1 ; if ( direction . equals ( " L " ) && -- j < 0 ) return - 1 ; if ( direction . equals ( " R " ) && ++ j == width ) return - 1 ; if ( direction . equals ( " D " ) && ++ i == height ) return - 1 ; final int newHead = getId ( i , j ) ; if ( k < food . length && i == food [ k ] [ 0 ] && j == food [ k ] [ 1 ] ) { lookup . add ( newHead ) ; body . offerFirst ( newHead ) ; ++ k ; return ++ score ; } if ( newHead != body . peekLast ( ) && lookup . contains ( newHead ) ) return - 1 ; lookup . remove ( body . peekLast ( ) ) ; lookup . add ( newHead ) ; body . pollLast ( ) ; body . offerFirst ( newHead ) ; return score ; } private int width ; private int height ; private int score = 0 ; private int k = 0 ; private int [ ] [ ] food ; private Set < Integer > lookup = new HashSet < > ( ) ; private Deque < Integer > body = new ArrayDeque < > ( ) ; private int getId ( int i , int j ) { return i * width + j ; } }
class Solution { public int maxEnvelopes ( int [ ] [ ] envelopes ) { Arrays . sort ( envelopes , ( a , b ) -> a [ 0 ] == b [ 0 ] ? b [ 1 ] - a [ 1 ] : a [ 0 ] - b [ 0 ] ) ; int ans = 0 ; int [ ] dp = new int [ envelopes . length ] ; for ( int [ ] e : envelopes ) { int i = Arrays . binarySearch ( dp , 0 , ans , e [ 1 ] ) ; if ( i < 0 ) i = - ( i + 1 ) ; dp [ i ] = e [ 1 ] ; if ( i == ans ) ++ ans ; } return ans ; } }
class Tweet { public int id ; public int time ; public Tweet next = null ; public Tweet ( int id , int time ) { this . id = id ; this . time = time ; } } class User { private int id ; public Set < Integer > followeeIds = new HashSet < > ( ) ; public Tweet tweetHead = null ; public User ( int id ) { this . id = id ; follow ( id ) ; } public void follow ( int followeeId ) { followeeIds . add ( followeeId ) ; } public void unfollow ( int followeeId ) { followeeIds . remove ( followeeId ) ; } public void post ( int tweetId , int time ) { final Tweet oldTweetHead = tweetHead ; tweetHead = new Tweet ( tweetId , time ) ; tweetHead . next = oldTweetHead ; } } class Twitter { public void postTweet ( int userId , int tweetId ) { users . putIfAbsent ( userId , new User ( userId ) ) ; users . get ( userId ) . post ( tweetId , time ++ ) ; } public List < Integer > getNewsFeed ( int userId ) { if ( ! users . containsKey ( userId ) ) return new ArrayList < > ( ) ; List < Integer > newsFeed = new ArrayList < > ( ) ; Queue < Tweet > maxHeap = new PriorityQueue < > ( ( a , b ) -> b . time - a . time ) ; for ( final int followeeId : users . get ( userId ) . followeeIds ) { Tweet tweetHead = users . get ( followeeId ) . tweetHead ; if ( tweetHead != null ) maxHeap . offer ( tweetHead ) ; } int count = 0 ; while ( ! maxHeap . isEmpty ( ) && count ++ < 10 ) { Tweet tweet = maxHeap . poll ( ) ; newsFeed . add ( tweet . id ) ; if ( tweet . next != null ) maxHeap . offer ( tweet . next ) ; } return newsFeed ; } public void follow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; users . putIfAbsent ( followerId , new User ( followerId ) ) ; users . putIfAbsent ( followeeId , new User ( followeeId ) ) ; users . get ( followerId ) . follow ( followeeId ) ; } public void unfollow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; if ( users . containsKey ( followerId ) && users . containsKey ( followeeId ) ) users . get ( followerId ) . unfollow ( followeeId ) ; } private int time = 0 ; private Map < Integer , User > users = new HashMap < > ( ) ; }
class Solution { public boolean isReflected ( int [ ] [ ] points ) { int minX = Integer . MAX_VALUE ; int maxX = Integer . MIN_VALUE ; Set < String > seen = new HashSet < > ( ) ; for ( int [ ] p : points ) { final int x = p [ 0 ] ; final int y = p [ 1 ] ; minX = Math . min ( minX , x ) ; maxX = Math . max ( maxX , x ) ; seen . add ( x + " , " + y ) ; } final int sum = minX + maxX ; for ( int [ ] p : points ) if ( ! seen . contains ( sum - p [ 0 ] + " , " + p [ 1 ] ) ) return false ; return true ; } }
class Solution { public int countNumbersWithUniqueDigits ( int n ) { if ( n == 0 ) return 1 ; int ans = 10 ; int uniqueDigits = 9 ; for ( int availableNum = 9 ; n > 1 && availableNum > 0 ; -- n , -- availableNum ) { uniqueDigits *= availableNum ; ans += uniqueDigits ; } return ans ; } }
class Solution { public String rearrangeString ( String s , int k ) { final int n = s . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; int [ ] count = new int [ 128 ] ; int [ ] valid = new int [ 128 ] ; for ( final char c : s . toCharArray ( ) ) ++ count [ c ] ; for ( int i = 0 ; i < n ; ++ i ) { final char c = getBestLetter ( count , valid , i ) ; if ( c == ' * ' ) return " " ; sb . append ( c ) ; -- count [ c ] ; valid [ c ] = i + k ; } return sb . toString ( ) ; } private char getBestLetter ( int [ ] count , int [ ] valid , int index ) { int maxCount = - 1 ; char bestLetter = ' * ' ; for ( char c = ' a ' ; c <= ' z ' ; ++ c ) if ( count [ c ] > 0 && count [ c ] > maxCount && index >= valid [ c ] ) { bestLetter = c ; maxCount = count [ c ] ; } return bestLetter ; } }
class Logger { public boolean shouldPrintMessage ( int timestamp , String message ) { while ( ! messageQueue . isEmpty ( ) ) { Pair < Integer , String > head = messageQueue . peekFirst ( ) ; if ( timestamp - head . getKey ( ) < 10 ) break ; messageQueue . pollFirst ( ) ; messageSet . remove ( head . getValue ( ) ) ; } if ( messageSet . contains ( message ) ) return false ; messageQueue . offerLast ( new Pair < > ( timestamp , message ) ) ; messageSet . add ( message ) ; return true ; } private Deque < Pair < Integer , String > > messageQueue = new ArrayDeque < > ( ) ; private Set < String > messageSet = new HashSet < > ( ) ; }
class Solution { public boolean isValidSudoku ( char [ ] [ ] board ) { Set < String > seen = new HashSet < > ( ) ; for ( int i = 0 ; i < 9 ; ++ i ) for ( int j = 0 ; j < 9 ; ++ j ) { if ( board [ i ] [ j ] == ' . ' ) continue ; final char c = board [ i ] [ j ] ; if ( ! seen . add ( c + " @ row " + i ) || ! seen . add ( c + " @ col " + j ) || ! seen . add ( c + " @ box " + i / 3 + j / 3 ) ) return false ; } return true ; } }
class Solution { public int [ ] sortTransformedArray ( int [ ] nums , int a , int b , int c ) { final int n = nums . length ; final boolean upward = a > 0 ; int [ ] ans = new int [ n ] ; int [ ] quad = new int [ n ] ; for ( int i = 0 ; i < nums . length ; ++ i ) quad [ i ] = f ( nums [ i ] , a , b , c ) ; int i = upward ? n - 1 : 0 ; for ( int l = 0 , r = n - 1 ; l <= r ; ) if ( upward ) ans [ i -- ] = quad [ l ] > quad [ r ] ? quad [ l ++ ] : quad [ r -- ] ; else ans [ i ++ ] = quad [ l ] < quad [ r ] ? quad [ l ++ ] : quad [ r -- ] ; return ans ; } private int f ( int x , int a , int b , int c ) { return ( a * x + b ) * x + c ; } }
class Solution { public int maxKilledEnemies ( char [ ] [ ] grid ) { if ( grid . length == 0 || grid [ 0 ] . length == 0 ) return 0 ; final int m = grid . length ; final int n = grid [ 0 ] . length ; int ans = 0 ; int [ ] [ ] dp = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; ++ i ) { enemyCount = 0 ; for ( int j = 0 ; j < n ; ++ j ) update ( grid , i , j , dp ) ; enemyCount = 0 ; for ( int j = n - 1 ; j >= 0 ; -- j ) update ( grid , i , j , dp ) ; } for ( int j = 0 ; j < n ; ++ j ) { enemyCount = 0 ; for ( int i = 0 ; i < m ; ++ i ) update ( grid , i , j , dp ) ; enemyCount = 0 ; for ( int i = m - 1 ; i >= 0 ; -- i ) update ( grid , i , j , dp ) ; } for ( int [ ] row : dp ) ans = Math . max ( ans , Arrays . stream ( row ) . max ( ) . getAsInt ( ) ) ; return ans ; } private int enemyCount = 0 ; private void update ( char [ ] [ ] grid , int i , int j , int [ ] [ ] dp ) { if ( grid [ i ] [ j ] == '0' ) dp [ i ] [ j ] += enemyCount ; else if ( grid [ i ] [ j ] == ' E ' ) ++ enemyCount ; else enemyCount = 0 ; } }
class HitCounter { public void hit ( int timestamp ) { final int i = timestamp % 300 ; if ( timestamps [ i ] == timestamp ) { ++ hits [ i ] ; } else { timestamps [ i ] = timestamp ; hits [ i ] = 1 ; } } public int getHits ( int timestamp ) { int countHits = 0 ; for ( int i = 0 ; i < 300 ; ++ i ) if ( timestamp - timestamps [ i ] < 300 ) countHits += hits [ i ] ; return countHits ; } private int [ ] timestamps = new int [ 300 ] ; private int [ ] hits = new int [ 300 ] ; }
class Solution { public boolean canMeasureWater ( int jug1Capacity , int jug2Capacity , int targetCapacity ) { return targetCapacity == 0 || jug1Capacity + jug2Capacity >= targetCapacity && targetCapacity % gcd ( jug1Capacity , jug2Capacity ) == 0 ; } private int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } }
class Solution { public boolean isPerfectSquare ( int num ) { long l = 1 ; long r = num ; while ( l < r ) { final long m = ( l + r ) / 2 ; if ( m >= num / m ) r = m ; else l = m + 1 ; } return l * l == num ; } }
class Solution { public List < Integer > largestDivisibleSubset ( int [ ] nums ) { final int n = nums . length ; List < Integer > ans = new ArrayList < > ( ) ; int [ ] sizeEndsAt = new int [ n ] ; int [ ] prevIndex = new int [ n ] ; int maxSize = 0 ; int index = - 1 ; Arrays . fill ( sizeEndsAt , 1 ) ; Arrays . fill ( prevIndex , - 1 ) ; Arrays . sort ( nums ) ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i - 1 ; j >= 0 ; -- j ) if ( nums [ i ] % nums [ j ] == 0 && sizeEndsAt [ i ] < sizeEndsAt [ j ] + 1 ) { sizeEndsAt [ i ] = sizeEndsAt [ j ] + 1 ; prevIndex [ i ] = j ; } if ( maxSize < sizeEndsAt [ i ] ) { maxSize = sizeEndsAt [ i ] ; index = i ; } } while ( index != - 1 ) { ans . add ( nums [ index ] ) ; index = prevIndex [ index ] ; } return ans ; } }
class Solution { public void solveSudoku ( char [ ] [ ] board ) { dfs ( board , 0 ) ; } private boolean dfs ( char [ ] [ ] board , int s ) { if ( s == 81 ) return true ; final int i = s / 9 ; final int j = s % 9 ; if ( board [ i ] [ j ] != ' . ' ) return dfs ( board , s + 1 ) ; for ( char c = '1' ; c <= '9' ; ++ c ) if ( isValid ( board , i , j , c ) ) { board [ i ] [ j ] = c ; if ( dfs ( board , s + 1 ) ) return true ; board [ i ] [ j ] = ' . ' ; } return false ; } private boolean isValid ( char [ ] [ ] board , int row , int col , char c ) { for ( int i = 0 ; i < 9 ; ++ i ) if ( board [ i ] [ col ] == c || board [ row ] [ i ] == c || board [ 3 * ( row / 3 ) + i / 3 ] [ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; return true ; } }
class Solution { public int getSum ( int a , int b ) { while ( b != 0 ) { final int carry = a & b ; a ^= b ; b = carry << 1 ; } return a ; } }
class Solution { public int superPow ( int a , int [ ] b ) { int ans = 1 ; a %= k ; for ( final int i : b ) ans = powMod ( ans , 10 ) * powMod ( a , i ) % k ; return ans ; } private final int k = 1337 ; private int powMod ( int x , int y ) { int pow = 1 ; while ( y -- > 0 ) pow = ( pow * x ) % k ; return pow ; } }
class Solution { public int getMoneyAmount ( int n ) { dp = new int [ n + 1 ] [ n + 1 ] ; Arrays . stream ( dp ) . forEach ( A -> Arrays . fill ( A , Integer . MAX_VALUE ) ) ; return getMoneyAmount ( 1 , n ) ; } private int [ ] [ ] dp ; private int getMoneyAmount ( int i , int j ) { if ( i >= j ) return 0 ; if ( dp [ i ] [ j ] != Integer . MAX_VALUE ) return dp [ i ] [ j ] ; for ( int k = i ; k <= j ; ++ k ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , Math . max ( getMoneyAmount ( i , k - 1 ) , getMoneyAmount ( k + 1 , j ) ) + k ) ; return dp [ i ] [ j ] ; } }
class Solution { public int combinationSum4 ( int [ ] nums , int target ) { int [ ] dp = new int [ target + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i <= target ; ++ i ) for ( final int num : nums ) if ( i >= num ) dp [ i ] += dp [ i - num ] ; return dp [ target ] ; } }
class T { public int i ; public int j ; public int num ; public T ( int i , int j , int num ) { this . i = i ; this . j = j ; this . num = num ; } } class Solution { public int kthSmallest ( int [ ] [ ] matrix , int k ) { Queue < T > minHeap = new PriorityQueue < > ( ( a , b ) -> a . num - b . num ) ; for ( int i = 0 ; i < k && i < matrix . length ; ++ i ) minHeap . offer ( new T ( i , 0 , matrix [ i ] [ 0 ] ) ) ; while ( k -- > 1 ) { final int i = minHeap . peek ( ) . i ; final int j = minHeap . poll ( ) . j ; if ( j + 1 < matrix [ 0 ] . length ) minHeap . offer ( new T ( i , j + 1 , matrix [ i ] [ j + 1 ] ) ) ; } return minHeap . peek ( ) . num ; } }
class Solution { public String countAndSay ( int n ) { StringBuilder sb = new StringBuilder ( "1" ) ; while ( -- n > 0 ) { StringBuilder next = new StringBuilder ( ) ; for ( int i = 0 ; i < sb . length ( ) ; ++ i ) { int count = 1 ; while ( i + 1 < sb . length ( ) && sb . charAt ( i ) == sb . charAt ( i + 1 ) ) { ++ count ; ++ i ; } next . append ( count ) . append ( sb . charAt ( i ) ) ; } sb = next ; } return sb . toString ( ) ; } }
class RandomizedSet { public boolean insert ( int val ) { if ( valToIndex . containsKey ( val ) ) return false ; valToIndex . put ( val , vals . size ( ) ) ; vals . add ( val ) ; return true ; } public boolean remove ( int val ) { if ( ! valToIndex . containsKey ( val ) ) return false ; final int index = valToIndex . get ( val ) ; valToIndex . put ( last ( vals ) , index ) ; valToIndex . remove ( val ) ; vals . set ( index , last ( vals ) ) ; vals . remove ( vals . size ( ) - 1 ) ; return true ; } public int getRandom ( ) { final int index = rand . nextInt ( vals . size ( ) ) ; return vals . get ( index ) ; } private Map < Integer , Integer > valToIndex = new HashMap < > ( ) ; private List < Integer > vals = new ArrayList < > ( ) ; private Random rand = new Random ( ) ; private int last ( List < Integer > vals ) { return vals . get ( vals . size ( ) - 1 ) ; } }
class Item { public int val ; public int indexInMap ; public Item ( int val , int indexInMap ) { this . val = val ; this . indexInMap = indexInMap ; } } class RandomizedCollection { public boolean insert ( int val ) { valToIndices . putIfAbsent ( val , new ArrayList < > ( ) ) ; valToIndices . get ( val ) . add ( items . size ( ) ) ; items . add ( new Item ( val , valToIndices . get ( val ) . size ( ) - 1 ) ) ; return valToIndices . get ( val ) . size ( ) == 1 ; } public boolean remove ( int val ) { if ( ! valToIndices . containsKey ( val ) ) return false ; final int index = lastIndex ( valToIndices . get ( val ) ) ; valToIndices . get ( last ( items ) . val ) . set ( last ( items ) . indexInMap , index ) ; final int indicesSize = valToIndices . get ( val ) . size ( ) ; valToIndices . get ( val ) . remove ( indicesSize - 1 ) ; if ( valToIndices . get ( val ) . isEmpty ( ) ) valToIndices . remove ( val ) ; items . set ( index , last ( items ) ) ; items . remove ( items . size ( ) - 1 ) ; return true ; } public int getRandom ( ) { final int index = rand . nextInt ( items . size ( ) ) ; return items . get ( index ) . val ; } private Map < Integer , List < Integer > > valToIndices = new HashMap < > ( ) ; private List < Item > items = new ArrayList < > ( ) ; private Random rand = new Random ( ) ; private int lastIndex ( List < Integer > indices ) { return indices . get ( indices . size ( ) - 1 ) ; } private Item last ( List < Item > items ) { return items . get ( items . size ( ) - 1 ) ; } }
class Solution { public boolean canConstruct ( String ransomNote , String magazine ) { int [ ] count = new int [ 128 ] ; for ( final char c : magazine . toCharArray ( ) ) ++ count [ c ] ; for ( final char c : ransomNote . toCharArray ( ) ) if ( -- count [ c ] < 0 ) return false ; return true ; } }
class Solution { public Solution ( int [ ] nums ) { this . nums = nums ; } public int [ ] reset ( ) { return nums ; } public int [ ] shuffle ( ) { int [ ] A = nums . clone ( ) ; for ( int i = A . length - 1 ; i > 0 ; -- i ) { final int j = rand . nextInt ( i + 1 ) ; swap ( A , i , j ) ; } return A ; } private int [ ] nums ; private Random rand = new Random ( ) ; private void swap ( int [ ] A , int i , int j ) { final int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } }
class Solution { public NestedInteger deserialize ( String s ) { if ( s . charAt ( 0 ) != ' [ ' ) return new NestedInteger ( Integer . parseInt ( s ) ) ; Deque < NestedInteger > stack = new ArrayDeque < > ( ) ; int start = 1 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) switch ( s . charAt ( i ) ) { case ' [ ' : stack . push ( new NestedInteger ( ) ) ; start = i + 1 ; break ; case ' , ' : if ( i > start ) { final int num = Integer . parseInt ( s . substring ( start , i ) ) ; stack . peek ( ) . add ( new NestedInteger ( num ) ) ; } start = i + 1 ; break ; case ' ] ' : NestedInteger popped = stack . pop ( ) ; if ( i > start ) { final int num = Integer . parseInt ( s . substring ( start , i ) ) ; popped . add ( new NestedInteger ( num ) ) ; } if ( ! stack . isEmpty ( ) ) stack . peek ( ) . add ( popped ) ; else return popped ; start = i + 1 ; break ; } throw new IllegalArgumentException ( ) ; } }
class Solution { public int firstUniqChar ( String s ) { int [ ] count = new int [ 128 ] ; for ( final char c : s . toCharArray ( ) ) ++ count [ c ] ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( count [ s . charAt ( i ) ] == 1 ) return i ; return - 1 ; } }
class Solution { public char findTheDifference ( String s , String t ) { char ans = 0 ; for ( final char c : s . toCharArray ( ) ) ans ^= c ; for ( final char c : t . toCharArray ( ) ) ans ^= c ; return ans ; } }
class Solution { public List < List < Integer > > combinationSum ( int [ ] candidates , int target ) { List < List < Integer > > ans = new ArrayList < > ( ) ; Arrays . sort ( candidates ) ; dfs ( 0 , candidates , target , new ArrayList < > ( ) , ans ) ; return ans ; } private void dfs ( int s , int [ ] candidates , int target , List < Integer > path , List < List < Integer > > ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . add ( new ArrayList < > ( path ) ) ; return ; } for ( int i = s ; i < candidates . length ; ++ i ) { path . add ( candidates [ i ] ) ; dfs ( i , candidates , target - candidates [ i ] , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; } } }
class Solution { public String decodeString ( String s ) { Stack < Pair < StringBuilder , Integer > > stack = new Stack < > ( ) ; StringBuilder currStr = new StringBuilder ( ) ; int currNum = 0 ; for ( final char c : s . toCharArray ( ) ) if ( Character . isDigit ( c ) ) { currNum = currNum * 10 + ( c - '0' ) ; } else { if ( c == ' [ ' ) { stack . push ( new Pair < > ( currStr , currNum ) ) ; currStr = new StringBuilder ( ) ; currNum = 0 ; } else if ( c == ' ] ' ) { final Pair < StringBuilder , Integer > pair = stack . pop ( ) ; final StringBuilder prevStr = pair . getKey ( ) ; final int n = pair . getValue ( ) ; currStr = prevStr . append ( getRepeatedStr ( currStr , n ) ) ; } else { currStr . append ( c ) ; } } return currStr . toString ( ) ; } private StringBuilder getRepeatedStr ( StringBuilder s , int n ) { StringBuilder sb = new StringBuilder ( ) ; while ( n -- > 0 ) sb . append ( s ) ; return sb ; } }
class Solution { public int maxRotateFunction ( int [ ] nums ) { final int sum = Arrays . stream ( nums ) . sum ( ) ; int f = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) f += i * nums [ i ] ; int ans = f ; for ( int i = nums . length - 1 ; i >= 0 ; -- i ) { f += sum - nums . length * nums [ i ] ; ans = Math . max ( ans , f ) ; } return ans ; } }
class Solution { public int integerReplacement ( long n ) { int ans = 0 ; for ( ; n > 1 ; ++ ans ) if ( ( n & 1 ) == 0 ) n >>= 1 ; else if ( n == 3 || ( ( n >> 1 ) & 1 ) == 0 ) -- n ; else ++ n ; return ans ; } }
class Solution { public double [ ] calcEquation ( List < List < String > > equations , double [ ] values , List < List < String > > queries ) { double [ ] ans = new double [ queries . size ( ) ] ; Map < String , Map < String , Double > > graph = new HashMap < > ( ) ; for ( int i = 0 ; i < equations . size ( ) ; ++ i ) { final String A = equations . get ( i ) . get ( 0 ) ; final String B = equations . get ( i ) . get ( 1 ) ; graph . putIfAbsent ( A , new HashMap < > ( ) ) ; graph . putIfAbsent ( B , new HashMap < > ( ) ) ; graph . get ( A ) . put ( B , values [ i ] ) ; graph . get ( B ) . put ( A , 1.0 / values [ i ] ) ; } for ( int i = 0 ; i < queries . size ( ) ; ++ i ) { final String A = queries . get ( i ) . get ( 0 ) ; final String C = queries . get ( i ) . get ( 1 ) ; if ( ! graph . containsKey ( A ) || ! graph . containsKey ( C ) ) ans [ i ] = - 1.0 ; else ans [ i ] = divide ( graph , A , C , new HashSet < > ( ) ) ; } return ans ; } private double divide ( Map < String , Map < String , Double > > graph , final String A , final String C , Set < String > seen ) { if ( A . equals ( C ) ) return 1.0 ; seen . add ( A ) ; for ( final String B : graph . get ( A ) . keySet ( ) ) { if ( seen . contains ( B ) ) continue ; final double res = divide ( graph , B , C , seen ) ; if ( res > 0 ) return graph . get ( A ) . get ( B ) * res ; } return - 1.0 ; } }
class Solution { public double findMedianSortedArrays ( int [ ] nums1 , int [ ] nums2 ) { final int n1 = nums1 . length ; final int n2 = nums2 . length ; if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ) ; int l = 0 ; int r = n1 ; while ( l <= r ) { final int partition1 = ( l + r ) / 2 ; final int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; final int maxLeft1 = partition1 == 0 ? Integer . MIN_VALUE : nums1 [ partition1 - 1 ] ; final int maxLeft2 = partition2 == 0 ? Integer . MIN_VALUE : nums2 [ partition2 - 1 ] ; final int minRight1 = partition1 == n1 ? Integer . MAX_VALUE : nums1 [ partition1 ] ; final int minRight2 = partition2 == n2 ? Integer . MAX_VALUE : nums2 [ partition2 ] ; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( Math . max ( maxLeft1 , maxLeft2 ) + Math . min ( minRight1 , minRight2 ) ) * 0.5 : Math . max ( maxLeft1 , maxLeft2 ) ; else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw new IllegalArgumentException ( ) ; } }
class Solution { public List < List < Integer > > combinationSum2 ( int [ ] candidates , int target ) { List < List < Integer > > ans = new ArrayList < > ( ) ; Arrays . sort ( candidates ) ; dfs ( 0 , candidates , target , new ArrayList < > ( ) , ans ) ; return ans ; } private void dfs ( int s , int [ ] candidates , int target , List < Integer > path , List < List < Integer > > ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . add ( new ArrayList < > ( path ) ) ; return ; } for ( int i = s ; i < candidates . length ; ++ i ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ] ) continue ; path . add ( candidates [ i ] ) ; dfs ( i + 1 , candidates , target - candidates [ i ] , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; } } }
class Solution { public int findNthDigit ( int n ) { int digitSize = 1 ; int startNum = 1 ; long count = 9 ; while ( digitSize * count < n ) { n -= digitSize * count ; ++ digitSize ; startNum *= 10 ; count *= 10 ; } final int targetNum = startNum + ( n - 1 ) / digitSize ; final int index = ( n - 1 ) % digitSize ; return String . valueOf ( targetNum ) . charAt ( index ) - '0' ; } }
class Solution { public boolean canCross ( int [ ] stones ) { final int n = stones . length ; int [ ] [ ] dp = new int [ n ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { final int k = stones [ i ] - stones [ j ] ; if ( k > n ) continue ; for ( final int x : new int [ ] { k - 1 , k , k + 1 } ) if ( 0 <= x && x <= n ) dp [ i ] [ k ] |= dp [ j ] [ x ] ; } return Arrays . stream ( dp [ n - 1 ] ) . anyMatch ( a -> a == 1 ) ; } }
class Solution { public int longestPalindrome ( String s ) { int ans = 0 ; int [ ] count = new int [ 128 ] ; for ( final char c : s . toCharArray ( ) ) ++ count [ c ] ; for ( final int c : count ) ans += c % 2 == 0 ? c : c - 1 ; final boolean hasOddCount = Arrays . stream ( count ) . anyMatch ( c -> c % 2 == 1 ) ; return ans + ( hasOddCount ? 1 : 0 ) ; } }
class Solution { public int firstMissingPositive ( int [ ] nums ) { final int n = nums . length ; for ( int i = 0 ; i < n ; ++ i ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ] ) swap ( nums , i , nums [ i ] - 1 ) ; for ( int i = 0 ; i < n ; ++ i ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } private void swap ( int [ ] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } }
class Solution { public int splitArray ( int [ ] nums , int m ) { final int n = nums . length ; dp = new int [ n + 1 ] [ m + 1 ] ; prefix = new int [ n + 1 ] ; Arrays . stream ( dp ) . forEach ( A -> Arrays . fill ( A , Integer . MAX_VALUE ) ) ; for ( int i = 0 ; i < n ; ++ i ) prefix [ i + 1 ] = nums [ i ] + prefix [ i ] ; return splitArray ( nums , n , m ) ; } private int [ ] [ ] dp ; private int [ ] prefix ; private int splitArray ( int [ ] nums , int i , int k ) { if ( k == 1 ) return prefix [ i ] ; if ( dp [ i ] [ k ] < Integer . MAX_VALUE ) return dp [ i ] [ k ] ; for ( int j = k - 1 ; j < i ; ++ j ) dp [ i ] [ k ] = Math . min ( dp [ i ] [ k ] , Math . max ( splitArray ( nums , j , k - 1 ) , prefix [ i ] - prefix [ j ] ) ) ; return dp [ i ] [ k ] ; } }
class Solution { public String minAbbreviation ( String target , String [ ] dictionary ) { final int m = target . length ( ) ; List < Integer > masks = new ArrayList < > ( ) ; for ( final String word : dictionary ) { if ( word . length ( ) != m ) continue ; masks . add ( getMask ( target , word ) ) ; } if ( masks . isEmpty ( ) ) return String . valueOf ( m ) ; List < String > abbrs = new ArrayList < > ( ) ; final int maxCand = ( int ) Math . pow ( 2 , m ) ; for ( int i = 0 ; i < maxCand ; ++ i ) { final int cand = i ; if ( masks . stream ( ) . allMatch ( mask -> ( cand & mask ) > 0 ) ) abbrs . add ( getAbbr ( target , cand ) ) ; } String ans = target ; for ( final String abbr : abbrs ) if ( getAbbrLen ( abbr ) < getAbbrLen ( ans ) ) ans = abbr ; return ans ; } private int getMask ( final String target , final String word ) { final int m = target . length ( ) ; int mask = 0 ; for ( int i = 0 ; i < m ; ++ i ) if ( word . charAt ( i ) != target . charAt ( i ) ) mask |= 1 << m - 1 - i ; return mask ; } String getAbbr ( final String target , int cand ) { final int m = target . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; int replacedCount = 0 ; for ( int i = 0 ; i < m ; ++ i ) if ( ( cand >> m - 1 - i & 1 ) == 1 ) { if ( replacedCount > 0 ) sb . append ( replacedCount ) ; sb . append ( target . charAt ( i ) ) ; replacedCount = 0 ; } else { ++ replacedCount ; } if ( replacedCount > 0 ) sb . append ( replacedCount ) ; return sb . toString ( ) ; } int getAbbrLen ( final String abbr ) { int abbrLen = 0 ; int i = 0 ; int j = 0 ; while ( i < abbr . length ( ) ) { if ( Character . isAlphabetic ( abbr . charAt ( j ) ) ) ++ j ; else while ( j < abbr . length ( ) && Character . isDigit ( abbr . charAt ( j ) ) ) ++ j ; ++ abbrLen ; i = j ; } return abbrLen ; } }
class Solution { public List < String > fizzBuzz ( int n ) { List < String > ans = new ArrayList < > ( ) ; for ( int i = 1 ; i <= n ; ++ i ) { StringBuilder sb = new StringBuilder ( ) ; if ( i % 3 == 0 ) sb . append ( " Fizz " ) ; if ( i % 5 == 0 ) sb . append ( " Buzz " ) ; ans . add ( sb . length ( ) == 0 ? String . valueOf ( i ) : sb . toString ( ) ) ; } return ans ; } }
class Solution { public String addStrings ( String num1 , String num2 ) { StringBuilder sb = new StringBuilder ( ) ; int carry = 0 ; int i = num1 . length ( ) - 1 ; int j = num2 . length ( ) - 1 ; while ( i >= 0 || j >= 0 || carry > 0 ) { if ( i >= 0 ) carry += num1 . charAt ( i -- ) - '0' ; if ( j >= 0 ) carry += num2 . charAt ( j -- ) - '0' ; sb . append ( carry % 10 ) ; carry /= 10 ; } return sb . reverse ( ) . toString ( ) ; } }
class Solution { public boolean canPartition ( int [ ] nums ) { final int sum = Arrays . stream ( nums ) . sum ( ) ; if ( sum % 2 == 1 ) return false ; return knapsack ( nums , sum / 2 ) ; } private boolean knapsack ( int [ ] nums , int subsetSum ) { final int n = nums . length ; boolean [ ] [ ] dp = new boolean [ n + 1 ] [ subsetSum + 1 ] ; dp [ 0 ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; ++ i ) { final int num = nums [ i - 1 ] ; for ( int j = 0 ; j <= subsetSum ; ++ j ) if ( j < num ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] || dp [ i - 1 ] [ j - num ] ; } return dp [ n ] [ subsetSum ] ; } }
class Solution { public List < List < Integer > > pacificAtlantic ( int [ ] [ ] heights ) { final int m = heights . length ; final int n = heights [ 0 ] . length ; List < List < Integer > > ans = new ArrayList < > ( ) ; Queue < int [ ] > qP = new ArrayDeque < > ( ) ; Queue < int [ ] > qA = new ArrayDeque < > ( ) ; boolean [ ] [ ] seenP = new boolean [ m ] [ n ] ; boolean [ ] [ ] seenA = new boolean [ m ] [ n ] ; for ( int i = 0 ; i < m ; ++ i ) { qP . offer ( new int [ ] { i , 0 } ) ; qA . offer ( new int [ ] { i , n - 1 } ) ; seenP [ i ] [ 0 ] = true ; seenA [ i ] [ n - 1 ] = true ; } for ( int j = 0 ; j < n ; ++ j ) { qP . offer ( new int [ ] { 0 , j } ) ; qA . offer ( new int [ ] { m - 1 , j } ) ; seenP [ 0 ] [ j ] = true ; seenA [ m - 1 ] [ j ] = true ; } bfs ( heights , qP , seenP ) ; bfs ( heights , qA , seenA ) ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( seenP [ i ] [ j ] && seenA [ i ] [ j ] ) ans . add ( new ArrayList < > ( Arrays . asList ( i , j ) ) ) ; return ans ; } private static final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; private void bfs ( int [ ] [ ] heights , Queue < int [ ] > q , boolean [ ] [ ] seen ) { while ( ! q . isEmpty ( ) ) { final int i = q . peek ( ) [ 0 ] ; final int j = q . poll ( ) [ 1 ] ; final int h = heights [ i ] [ j ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == heights . length || y < 0 || y == heights [ 0 ] . length ) continue ; if ( seen [ x ] [ y ] || heights [ x ] [ y ] < h ) continue ; q . offer ( new int [ ] { x , y } ) ; seen [ x ] [ y ] = true ; } } } }
class Solution { public int wordsTyping ( String [ ] sentence , int rows , int cols ) { final String combined = String . join ( " ▁ " , sentence ) + " ▁ " ; final int n = combined . length ( ) ; int i = 0 ; while ( rows -- > 0 ) { i += cols ; if ( combined . charAt ( i % n ) == ' ▁ ' ) { ++ i ; } else { while ( i > 0 && combined . charAt ( ( i - 1 ) % n ) != ' ▁ ' ) -- i ; } } return i / n ; } }
class Solution { public int trap ( int [ ] height ) { final int n = height . length ; int ans = 0 ; int [ ] l = new int [ n ] ; int [ ] r = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) l [ i ] = i == 0 ? height [ i ] : Math . max ( height [ i ] , l [ i - 1 ] ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) r [ i ] = i == n - 1 ? height [ i ] : Math . max ( height [ i ] , r [ i + 1 ] ) ; for ( int i = 0 ; i < n ; ++ i ) ans += Math . min ( l [ i ] , r [ i ] ) - height [ i ] ; return ans ; } }
class Solution { public String originalDigits ( String s ) { StringBuilder sb = new StringBuilder ( ) ; int [ ] count = new int [ 10 ] ; for ( final char c : s . toCharArray ( ) ) { if ( c == ' z ' ) ++ count [ 0 ] ; if ( c == ' o ' ) ++ count [ 1 ] ; if ( c == ' w ' ) ++ count [ 2 ] ; if ( c == ' h ' ) ++ count [ 3 ] ; if ( c == ' u ' ) ++ count [ 4 ] ; if ( c == ' f ' ) ++ count [ 5 ] ; if ( c == ' x ' ) ++ count [ 6 ] ; if ( c == ' s ' ) ++ count [ 7 ] ; if ( c == ' g ' ) ++ count [ 8 ] ; if ( c == ' i ' ) ++ count [ 9 ] ; } count [ 1 ] -= count [ 0 ] + count [ 2 ] + count [ 4 ] ; count [ 3 ] -= count [ 8 ] ; count [ 5 ] -= count [ 4 ] ; count [ 7 ] -= count [ 6 ] ; count [ 9 ] -= count [ 5 ] + count [ 6 ] + count [ 8 ] ; for ( int i = 0 ; i < 10 ; ++ i ) for ( int j = 0 ; j < count [ i ] ; ++ j ) sb . append ( i ) ; return sb . toString ( ) ; } }
class Solution { public int characterReplacement ( String s , int k ) { int ans = 0 ; int maxCount = 0 ; int [ ] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length ( ) ; ++ r ) { maxCount = Math . max ( maxCount , ++ count [ s . charAt ( r ) ] ) ; while ( maxCount + k < r - l + 1 ) -- count [ s . charAt ( l ++ ) ] ; ans = Math . max ( ans , r - l + 1 ) ; } return ans ; } }
class Solution { public String multiply ( String num1 , String num2 ) { final int m = num1 . length ( ) ; final int n = num2 . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; int [ ] pos = new int [ m + n ] ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { final int multiply = ( num1 . charAt ( i ) - '0' ) * ( num2 . charAt ( j ) - '0' ) ; final int sum = multiply + pos [ i + j + 1 ] ; pos [ i + j ] += sum / 10 ; pos [ i + j + 1 ] = sum % 10 ; } for ( final int p : pos ) if ( p > 0 || sb . length ( ) > 0 ) sb . append ( p ) ; return sb . length ( ) == 0 ? "0" : sb . toString ( ) ; } }
class Solution { public Node flatten ( Node head ) { return flatten ( head , null ) ; } private Node flatten ( Node head , Node rest ) { if ( head == null ) return rest ; head . next = flatten ( head . child , flatten ( head . next , rest ) ) ; if ( head . next != null ) head . next . prev = head ; head . child = null ; return head ; } }
class Codec { public TreeNode encode ( Node root ) { if ( root == null ) return null ; TreeNode rootTreeNode = new TreeNode ( root . val ) ; Queue < Pair < Node , TreeNode > > q = new ArrayDeque < > ( Arrays . asList ( new Pair < > ( root , rootTreeNode ) ) ) ; while ( ! q . isEmpty ( ) ) { Node parentNode = q . peek ( ) . getKey ( ) ; TreeNode parentTreeNode = q . poll ( ) . getValue ( ) ; TreeNode prevTreeNode = null ; TreeNode headTreeNode = null ; for ( Node child : parentNode . children ) { TreeNode currTreeNode = new TreeNode ( child . val ) ; if ( prevTreeNode == null ) headTreeNode = currTreeNode ; else prevTreeNode . right = currTreeNode ; prevTreeNode = currTreeNode ; q . offer ( new Pair < > ( child , currTreeNode ) ) ; } parentTreeNode . left = headTreeNode ; } return rootTreeNode ; } public Node decode ( TreeNode root ) { if ( root == null ) return null ; Node rootNode = new Node ( root . val , new ArrayList < > ( ) ) ; Queue < Pair < Node , TreeNode > > q = new ArrayDeque < > ( Arrays . asList ( new Pair < > ( rootNode , root ) ) ) ; while ( ! q . isEmpty ( ) ) { Node parentNode = q . peek ( ) . getKey ( ) ; TreeNode parentTreeNode = q . poll ( ) . getValue ( ) ; TreeNode sibling = parentTreeNode . left ; while ( sibling != null ) { Node currNode = new Node ( sibling . val , new ArrayList < > ( ) ) ; parentNode . children . add ( currNode ) ; q . offer ( new Pair < > ( currNode , sibling ) ) ; sibling = sibling . right ; } } return rootNode ; } }
class Solution { public int countSegments ( String s ) { int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( s . charAt ( i ) != ' ▁ ' && ( i == 0 || s . charAt ( i - 1 ) == ' ▁ ' ) ) ++ ans ; return ans ; } }
class Solution { public int eraseOverlapIntervals ( int [ ] [ ] intervals ) { if ( intervals . length == 0 ) return 0 ; Arrays . sort ( intervals , ( a , b ) -> a [ 1 ] - b [ 1 ] ) ; int ans = 0 ; int currentEnd = intervals [ 0 ] [ 1 ] ; for ( int i = 1 ; i < intervals . length ; ++ i ) if ( intervals [ i ] [ 0 ] >= currentEnd ) currentEnd = intervals [ i ] [ 1 ] ; else ++ ans ; return ans ; } }
class Solution { public int pathSum ( TreeNode root , int sum ) { if ( root == null ) return 0 ; return dfs ( root , sum ) + pathSum ( root . left , sum ) + pathSum ( root . right , sum ) ; } private int dfs ( TreeNode root , int sum ) { if ( root == null ) return 0 ; return ( sum == root . val ? 1 : 0 ) + dfs ( root . left , sum - root . val ) + dfs ( root . right , sum - root . val ) ; } }
class Solution { public List < Integer > findAnagrams ( String s , String p ) { List < Integer > ans = new ArrayList < > ( ) ; int [ ] count = new int [ 128 ] ; int required = p . length ( ) ; for ( final char c : p . toCharArray ( ) ) ++ count [ c ] ; for ( int l = 0 , r = 0 ; r < s . length ( ) ; ++ r ) { if ( -- count [ s . charAt ( r ) ] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 == p . length ( ) ) ans . add ( l ) ; if ( ++ count [ s . charAt ( l ++ ) ] > 0 ) ++ required ; } } return ans ; } }
class Solution { public String parseTernary ( String expression ) { final char c = expression . charAt ( i ) ; if ( i + 1 == expression . length ( ) || expression . charAt ( i + 1 ) == ' : ' ) { i += 2 ; return String . valueOf ( c ) ; } i += 2 ; final String first = parseTernary ( expression ) ; final String second = parseTernary ( expression ) ; return c == ' T ' ? first : second ; } private int i = 0 ; }
class Solution { public boolean isMatch ( String s , String p ) { final int m = s . length ( ) ; final int n = p . length ( ) ; boolean [ ] [ ] dp = new boolean [ m + 1 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = true ; for ( int j = 0 ; j < p . length ( ) ; ++ j ) if ( p . charAt ( j ) == ' * ' ) dp [ 0 ] [ j + 1 ] = dp [ 0 ] [ j ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( p . charAt ( j ) == ' * ' ) { final boolean matchEmpty = dp [ i + 1 ] [ j ] ; final boolean matchSome = dp [ i ] [ j + 1 ] ; dp [ i + 1 ] [ j + 1 ] = matchEmpty || matchSome ; } else if ( isMatch ( s , i , p , j ) ) { dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] ; } return dp [ m ] [ n ] ; } private boolean isMatch ( final String s , int i , final String p , int j ) { return j >= 0 && p . charAt ( j ) == ' ? ' || s . charAt ( i ) == p . charAt ( j ) ; } }
class Solution { public int arrangeCoins ( long n ) { return ( int ) ( - 1 + Math . sqrt ( 8 * n + 1 ) ) / 2 ; } }
class Solution { public List < Integer > findDuplicates ( int [ ] nums ) { List < Integer > ans = new ArrayList < > ( ) ; for ( final int num : nums ) { nums [ Math . abs ( num ) - 1 ] *= - 1 ; if ( nums [ Math . abs ( num ) - 1 ] > 0 ) ans . add ( Math . abs ( num ) ) ; } return ans ; } }
class Solution { public int compress ( char [ ] chars ) { int ans = 0 ; for ( int i = 0 ; i < chars . length ; ) { final char letter = chars [ i ] ; int count = 0 ; while ( i < chars . length && chars [ i ] == letter ) { ++ count ; ++ i ; } chars [ ans ++ ] = letter ; if ( count > 1 ) for ( final char c : String . valueOf ( count ) . toCharArray ( ) ) chars [ ans ++ ] = c ; } return ans ; } }
class Solution { public boolean sequenceReconstruction ( int [ ] org , List < List < Integer > > seqs ) { if ( seqs . isEmpty ( ) ) return false ; final int n = org . length ; List < Integer > [ ] graph = new List [ n ] ; int [ ] inDegree = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList < > ( ) ; for ( List < Integer > seq : seqs ) { if ( seq . size ( ) == 1 && seq . get ( 0 ) < 1 || seq . get ( 0 ) > n ) { return false ; } else { for ( int i = 0 ; i + 1 < seq . size ( ) ; ++ i ) { final int u = seq . get ( i ) ; final int v = seq . get ( i + 1 ) ; if ( u < 1 || u > n || v < 1 || v > n ) return false ; graph [ u - 1 ] . add ( v - 1 ) ; ++ inDegree [ v - 1 ] ; } } } Queue < Integer > q = IntStream . range ( 0 , n ) . filter ( i -> inDegree [ i ] == 0 ) . boxed ( ) . collect ( Collectors . toCollection ( ArrayDeque :: new ) ) ; int i = 0 ; while ( ! q . isEmpty ( ) ) { if ( q . size ( ) > 1 ) return false ; final int u = q . poll ( ) ; if ( u != org [ i ] - 1 ) return false ; ++ i ; for ( final int v : graph [ u ] ) if ( -- inDegree [ v ] == 0 ) q . offer ( v ) ; } return i == n ; } }
class Solution { public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { Deque < ListNode > stack1 = new ArrayDeque < > ( ) ; Deque < ListNode > stack2 = new ArrayDeque < > ( ) ; while ( l1 != null ) { stack1 . push ( l1 ) ; l1 = l1 . next ; } while ( l2 != null ) { stack2 . push ( l2 ) ; l2 = l2 . next ; } ListNode head = null ; int carry = 0 ; while ( carry > 0 || ! stack1 . isEmpty ( ) || ! stack2 . isEmpty ( ) ) { if ( ! stack1 . isEmpty ( ) ) carry += stack1 . pop ( ) . val ; if ( ! stack2 . isEmpty ( ) ) carry += stack2 . pop ( ) . val ; ListNode node = new ListNode ( carry % 10 ) ; node . next = head ; head = node ; carry /= 10 ; } return head ; } }
class Solution { public int numberOfBoomerangs ( int [ ] [ ] points ) { int ans = 0 ; for ( int [ ] p : points ) { Map < Integer , Integer > distCount = new HashMap < > ( ) ; for ( int [ ] q : points ) { final int dist = ( int ) getDist ( p , q ) ; distCount . put ( dist , distCount . getOrDefault ( dist , 0 ) + 1 ) ; } for ( final int freq : distCount . values ( ) ) ans += freq * ( freq - 1 ) ; } return ans ; } private double getDist ( int [ ] p , int [ ] q ) { return Math . pow ( p [ 0 ] - q [ 0 ] , 2 ) + Math . pow ( p [ 1 ] - q [ 1 ] , 2 ) ; } }
class Solution { public List < Integer > findDisappearedNumbers ( int [ ] nums ) { List < Integer > ans = new ArrayList < > ( ) ; for ( final int num : nums ) { final int index = Math . abs ( num ) - 1 ; nums [ index ] = - Math . abs ( nums [ index ] ) ; } for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] > 0 ) ans . add ( i + 1 ) ; return ans ; } }
class Solution { public int jump ( int [ ] nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i < nums . length - 1 ; ++ i ) { farthest = Math . max ( farthest , i + nums [ i ] ) ; if ( farthest >= nums . length - 1 ) { ++ ans ; break ; } if ( i == end ) { ++ ans ; end = farthest ; } } return ans ; } }
class Solution { public TreeNode deleteNode ( TreeNode root , int key ) { if ( root == null ) return null ; if ( root . val == key ) { if ( root . left == null ) return root . right ; if ( root . right == null ) return root . left ; TreeNode minNode = getMin ( root . right ) ; root . right = deleteNode ( root . right , minNode . val ) ; minNode . left = root . left ; minNode . right = root . right ; root = minNode ; } else if ( root . val < key ) { root . right = deleteNode ( root . right , key ) ; } else { root . val > key root . left = deleteNode ( root . left , key ) ; } return root ; } private TreeNode getMin ( TreeNode node ) { while ( node . left != null ) node = node . left ; return node ; } }
class Solution { public String frequencySort ( String s ) { final int n = s . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; int [ ] count = new int [ 128 ] ; List < Character > [ ] bucket = new List [ n + 1 ] ; for ( final char c : s . toCharArray ( ) ) ++ count [ c ] ; for ( int i = 0 ; i < 128 ; ++ i ) { final int freq = count [ i ] ; if ( freq > 0 ) { if ( bucket [ freq ] == null ) bucket [ freq ] = new ArrayList < > ( ) ; bucket [ freq ] . add ( ( char ) i ) ; } } for ( int freq = n ; freq > 0 ; -- freq ) if ( bucket [ freq ] != null ) for ( final char c : bucket [ freq ] ) for ( int i = 0 ; i < freq ; ++ i ) sb . append ( c ) ; return sb . toString ( ) ; } }
class Solution { public int findMinArrowShots ( int [ ] [ ] points ) { Arrays . sort ( points , ( a , b ) -> a [ 1 ] - b [ 1 ] ) ; int ans = 1 ; int arrowX = points [ 0 ] [ 1 ] ; for ( int i = 1 ; i < points . length ; ++ i ) if ( points [ i ] [ 0 ] > arrowX ) { arrowX = points [ i ] [ 1 ] ; ++ ans ; } return ans ; } }
class Solution { public int minMoves ( int [ ] nums ) { final int sum = Arrays . stream ( nums ) . sum ( ) ; final int min = Arrays . stream ( nums ) . min ( ) . getAsInt ( ) ; return sum - min * nums . length ; } }
class Solution { public int fourSumCount ( int [ ] A , int [ ] B , int [ ] C , int [ ] D ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( final int a : A ) for ( final int b : B ) count . put ( a + b , count . getOrDefault ( a + b , 0 ) + 1 ) ; for ( final int c : C ) for ( final int d : D ) if ( count . containsKey ( - c - d ) ) ans += count . get ( - c - d ) ; return ans ; } }
class Solution { public boolean circularArrayLoop ( int [ ] nums ) { if ( nums . length < 2 ) return false ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( nums , slow ) ; while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast ) ] > 0 ) { if ( slow == fast ) { if ( slow == advance ( nums , slow ) ) break ; return true ; } slow = advance ( nums , slow ) ; fast = advance ( nums , advance ( nums , fast ) ) ; } slow = i ; final int sign = nums [ i ] ; while ( sign * nums [ slow ] > 0 ) { final int next = advance ( nums , slow ) ; nums [ slow ] = 0 ; slow = next ; } } return false ; } private int advance ( int [ ] nums , int i ) { final int n = nums . length ; final int val = ( i + nums [ i ] ) % n ; return i + nums [ i ] >= 0 ? val : n + val ; } }
class Solution { public int poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { return ( int ) Math . ceil ( Math . log ( buckets ) / Math . log ( minutesToTest / minutesToDie + 1 ) ) ; } }
class Solution { public boolean repeatedSubstringPattern ( String s ) { final String ss = s + s ; return ss . substring ( 1 , ss . length ( ) - 1 ) . contains ( s ) ; } }
class Solution { public List < List < Integer > > permute ( int [ ] nums ) { List < List < Integer > > ans = new ArrayList < > ( ) ; dfs ( nums , new boolean [ nums . length ] , new ArrayList < > ( ) , ans ) ; return ans ; } private void dfs ( int [ ] nums , boolean [ ] used , List < Integer > path , List < List < Integer > > ans ) { if ( path . size ( ) == nums . length ) { ans . add ( new ArrayList < > ( path ) ) ; return ; } for ( int i = 0 ; i < nums . length ; ++ i ) { if ( used [ i ] ) continue ; used [ i ] = true ; path . add ( nums [ i ] ) ; dfs ( nums , used , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; used [ i ] = false ; } } }
class Solution { public int minMoves2 ( int [ ] nums ) { final int n = nums . length ; final int median = quickSelect ( nums , 0 , n - 1 , ( n + 1 ) / 2 ) ; int ans = 0 ; for ( final int num : nums ) ans += Math . abs ( num - median ) ; return ans ; } private int quickSelect ( int [ ] nums , int l , int r , int k ) { final int randIndex = new Random ( ) . nextInt ( r - l + 1 ) + l ; swap ( nums , randIndex , r ) ; final int pivot = nums [ r ] ; int nextSwapped = l ; for ( int i = l ; i < r ; ++ i ) if ( nums [ i ] <= pivot ) swap ( nums , nextSwapped ++ , i ) ; swap ( nums , nextSwapped , r ) ; final int count = nextSwapped - l + 1 ; if ( count == k ) return nums [ nextSwapped ] ; if ( count > k ) return quickSelect ( nums , l , nextSwapped - 1 , k ) ; return quickSelect ( nums , nextSwapped + 1 , r , k - count ) ; } private void swap ( int [ ] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } }
class Solution { public int islandPerimeter ( int [ ] [ ] grid ) { int islands = 0 ; int neighbors = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) if ( grid [ i ] [ j ] == 1 ) { ++ islands ; if ( i - 1 >= 0 && grid [ i - 1 ] [ j ] == 1 ) ++ neighbors ; if ( j - 1 >= 0 && grid [ i ] [ j - 1 ] == 1 ) ++ neighbors ; } return islands * 4 - neighbors * 2 ; } }
class Solution { public int minTransfers ( int [ ] [ ] transactions ) { int [ ] balance = new int [ 21 ] ; List < Integer > debt = new ArrayList < > ( ) ; for ( int [ ] t : transactions ) { final int from = t [ 0 ] ; final int to = t [ 1 ] ; final int amount = t [ 2 ] ; balance [ from ] -= amount ; balance [ to ] += amount ; } for ( final int b : balance ) if ( b != 0 ) debt . add ( b ) ; return dfs ( debt , 0 ) ; } private int dfs ( List < Integer > debt , int s ) { while ( s < debt . size ( ) && debt . get ( s ) == 0 ) ++ s ; if ( s == debt . size ( ) ) return 0 ; int ans = Integer . MAX_VALUE ; for ( int i = s + 1 ; i < debt . size ( ) ; ++ i ) if ( debt . get ( i ) * debt . get ( s ) < 0 ) { debt . set ( i , debt . get ( i ) + debt . get ( s ) ) ; ans = Math . min ( ans , 1 + dfs ( debt , s + 1 ) ) ; debt . set ( i , debt . get ( i ) - debt . get ( s ) ) ; } return ans ; } }
class Solution { public boolean isConvex ( List < List < Integer > > points ) { final int n = points . size ( ) ; long sign = 0 ; for ( int i = 0 ; i < n ; ++ i ) { final int cross = getCross ( points . get ( i ) , points . get ( ( i + 1 ) % n ) , points . get ( ( i + 2 ) % n ) ) ; if ( cross == 0 ) continue ; if ( sign == 0 ) sign = cross ; else if ( cross * sign < 0 ) return false ; } return true ; } private int getCross ( List < Integer > p , List < Integer > q , List < Integer > r ) { return ( q . get ( 0 ) - p . get ( 0 ) ) * ( r . get ( 1 ) - p . get ( 1 ) ) - ( q . get ( 1 ) - p . get ( 1 ) ) * ( r . get ( 0 ) - p . get ( 0 ) ) ; } }
class Solution { public List < List < Integer > > permuteUnique ( int [ ] nums ) { List < List < Integer > > ans = new ArrayList < > ( ) ; Arrays . sort ( nums ) ; dfs ( nums , new boolean [ nums . length ] , new ArrayList < > ( ) , ans ) ; return ans ; } private void dfs ( int [ ] nums , boolean [ ] used , List < Integer > path , List < List < Integer > > ans ) { if ( path . size ( ) == nums . length ) { ans . add ( new ArrayList < > ( path ) ) ; return ; } for ( int i = 0 ; i < nums . length ; ++ i ) { if ( used [ i ] ) continue ; if ( i > 0 && nums [ i ] == nums [ i - 1 ] && ! used [ i - 1 ] ) continue ; used [ i ] = true ; path . add ( nums [ i ] ) ; dfs ( nums , used , path , ans ) ; path . remove ( path . size ( ) - 1 ) ; used [ i ] = false ; } } }
class Solution { public List < String > findAllConcatenatedWordsInADict ( String [ ] words ) { List < String > ans = new ArrayList < > ( ) ; Set < String > wordSet = new HashSet < > ( Arrays . asList ( words ) ) ; Map < String , Boolean > memo = new HashMap < > ( ) ; for ( final String word : words ) if ( wordBreak ( word , wordSet , memo ) ) ans . add ( word ) ; return ans ; } private boolean wordBreak ( final String word , Set < String > wordSet , Map < String , Boolean > memo ) { if ( memo . containsKey ( word ) ) return memo . get ( word ) ; for ( int i = 1 ; i < word . length ( ) ; ++ i ) { final String prefix = word . substring ( 0 , i ) ; final String suffix = word . substring ( i ) ; if ( wordSet . contains ( prefix ) && ( wordSet . contains ( suffix ) || wordBreak ( suffix , wordSet , memo ) ) ) { memo . put ( word , true ) ; return true ; } } memo . put ( word , false ) ; return false ; } }
class Solution { public boolean makesquare ( int [ ] matchsticks ) { if ( matchsticks . length < 4 ) return false ; final int perimeter = Arrays . stream ( matchsticks ) . sum ( ) ; if ( perimeter % 4 != 0 ) return false ; int [ ] edges = new int [ 4 ] ; Arrays . fill ( edges , perimeter / 4 ) ; Arrays . sort ( edges ) ; return dfs ( matchsticks , matchsticks . length - 1 , edges ) ; } private boolean dfs ( int [ ] matchsticks , int selected , int [ ] edges ) { if ( selected == - 1 ) return Arrays . stream ( edges ) . allMatch ( edge -> edge == 0 ) ; for ( int i = 0 ; i < 4 ; ++ i ) { if ( matchsticks [ selected ] > edges [ i ] ) continue ; edges [ i ] -= matchsticks [ selected ] ; if ( dfs ( matchsticks , selected - 1 , edges ) ) return true ; edges [ i ] += matchsticks [ selected ] ; } return false ; } }
class Solution { public int findMaxForm ( String [ ] strs , int m , int n ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( final String s : strs ) { final int count0 = ( int ) s . chars ( ) . filter ( c -> c == '0' ) . count ( ) ; final int count1 = ( int ) s . length ( ) - count0 ; for ( int i = m ; i >= count0 ; -- i ) for ( int j = n ; j >= count1 ; -- j ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - count0 ] [ j - count1 ] + 1 ) ; } return dp [ m ] [ n ] ; } }
class Solution { public Solution ( double radius , double x_center , double y_center ) { this . radius = radius ; this . x_center = x_center ; this . y_center = y_center ; } public double [ ] randPoint ( ) { final double length = Math . sqrt ( Math . random ( ) ) * radius ; final double degree = Math . random ( ) * 2 * Math . PI ; final double x = x_center + length * Math . cos ( degree ) ; final double y = y_center + length * Math . sin ( degree ) ; return new double [ ] { x , y } ; } private double radius ; private double x_center ; private double y_center ; }
class Solution { public int largestPalindrome ( int n ) { if ( n == 1 ) return 9 ; final int kMod = 1337 ; final int upper = ( int ) Math . pow ( 10 , n ) - 1 ; final int lower = ( int ) Math . pow ( 10 , n - 1 ) - 1 ; for ( int i = upper ; i > lower ; -- i ) { final long cand = getPalindromeCandidate ( i ) ; for ( long j = upper ; j * j >= cand ; -- j ) if ( cand % j == 0 ) return ( int ) ( cand % kMod ) ; } throw new IllegalArgumentException ( ) ; } private long getPalindromeCandidate ( int i ) { final String reversed = new StringBuilder ( ) . append ( i ) . reverse ( ) . toString ( ) ; return Long . valueOf ( i + reversed ) ; } }
class Solution { public void rotate ( int [ ] [ ] matrix ) { for ( int i = 0 , j = matrix . length - 1 ; i < j ; ++ i , -- j ) { int [ ] temp = matrix [ i ] ; matrix [ i ] = matrix [ j ] ; matrix [ j ] = temp ; } for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = i + 1 ; j < matrix . length ; ++ j ) { final int temp = matrix [ i ] [ j ] ; matrix [ i ] [ j ] = matrix [ j ] [ i ] ; matrix [ j ] [ i ] = temp ; } } }
class Solution { public String smallestGoodBase ( String n ) { final long num = Long . parseLong ( n ) ; final int log2 = ( int ) ( Math . log ( num ) / Math . log ( 2 ) ) ; for ( int m = log2 ; m >= 2 ; -- m ) { int k = ( int ) Math . floor ( Math . pow ( num , 1.0 / m ) ) ; long sum = 1 ; long prod = 1 ; for ( int i = 0 ; i < m ; ++ i ) { prod *= k ; sum += prod ; } if ( sum == num ) return String . valueOf ( k ) ; } return String . valueOf ( num - 1 ) ; } }
class Solution { public int [ ] findPermutation ( String s ) { int [ ] ans = new int [ s . length ( ) + 1 ] ; int ansIndex = 0 ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { stack . push ( i + 1 ) ; if ( s . charAt ( i ) == ' I ' ) while ( ! stack . isEmpty ( ) ) ans [ ansIndex ++ ] = stack . pop ( ) ; } stack . push ( s . length ( ) + 1 ) ; while ( ! stack . isEmpty ( ) ) ans [ ansIndex ++ ] = stack . pop ( ) ; return ans ; } }
class Solution { public int findMaxConsecutiveOnes ( int [ ] nums ) { int ans = 0 ; int sum = 0 ; for ( final int num : nums ) if ( num == 1 ) ans = Math . max ( ans , ++ sum ) ; else sum = 0 ; return ans ; } }
class Solution { public int findMaxConsecutiveOnes ( int [ ] nums ) { int ans = 0 ; int zeros = 0 ; for ( int l = 0 , r = 0 ; r < nums . length ; ++ r ) { if ( nums [ r ] == 0 ) ++ zeros ; while ( zeros == 2 ) if ( nums [ l ++ ] == 0 ) -- zeros ; ans = Math . max ( ans , r - l + 1 ) ; } return ans ; } }
class Solution { public int findMinStep ( String board , String hand ) { Map < String , Integer > memo = new HashMap < > ( ) ; final int ans = dfs ( board + ' # ' , hand , memo ) ; return ans == Integer . MAX_VALUE ? - 1 : ans ; } private int dfs ( String board , final String hand , Map < String , Integer > memo ) { final String hashKey = board + ' # ' + hand ; if ( memo . containsKey ( hashKey ) ) return memo . get ( hashKey ) ; board = deDup ( board ) ; if ( board . equals ( " # " ) ) return 0 ; Set < Character > boardSet = new HashSet < > ( ) ; for ( final char c : board . toCharArray ( ) ) boardSet . add ( c ) ; StringBuilder sb = new StringBuilder ( ) ; for ( final char h : hand . toCharArray ( ) ) if ( boardSet . contains ( h ) ) sb . append ( h ) ; final String hs = sb . toString ( ) ; if ( sb . length ( ) == 0 ) return Integer . MAX_VALUE ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < board . length ( ) ; ++ i ) for ( int j = 0 ; j < hs . length ( ) ; ++ j ) { final String newHand = hs . substring ( 0 , j ) + hs . substring ( j + 1 ) ; String newBoard = board . substring ( 0 , i ) + hs . charAt ( j ) + board . substring ( i ) ; final int res = dfs ( newBoard , newHand , memo ) ; if ( res < Integer . MAX_VALUE ) ans = Math . min ( ans , 1 + res ) ; } memo . put ( hashKey , ans ) ; return ans ; } private String deDup ( String board ) { int start = 0 ; for ( int i = 0 ; i < board . length ( ) ; ++ i ) if ( board . charAt ( i ) != board . charAt ( start ) ) { if ( i - start >= 3 ) return deDup ( board . substring ( 0 , start ) + board . substring ( i ) ) ; start = i ; } return board ; } }
class Solution { public List < List < String > > groupAnagrams ( String [ ] strs ) { Map < String , List < String > > keyToAnagrams = new HashMap < > ( ) ; for ( final String str : strs ) { char [ ] chars = str . toCharArray ( ) ; Arrays . sort ( chars ) ; String key = String . valueOf ( chars ) ; keyToAnagrams . computeIfAbsent ( key , k -> new ArrayList < > ( ) ) . add ( str ) ; } return new ArrayList < > ( keyToAnagrams . values ( ) ) ; } }
class Solution { public boolean hasPath ( int [ ] [ ] maze , int [ ] start , int [ ] destination ) { final int m = maze . length ; final int n = maze [ 0 ] . length ; final int [ ] dirs = { 0 , 1 , 0 , - 1 , 0 } ; Queue < int [ ] > q = new ArrayDeque < > ( Arrays . asList ( new int [ ] { start [ 0 ] , start [ 1 ] } ) ) ; boolean [ ] [ ] seen = new boolean [ m ] [ n ] ; seen [ start [ 0 ] ] [ start [ 1 ] ] = true ; while ( ! q . isEmpty ( ) ) { final int i = q . peek ( ) [ 0 ] ; final int j = q . poll ( ) [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { int x = i ; int y = j ; while ( isValid ( maze , x + dirs [ k ] , y + dirs [ k + 1 ] ) ) { x += dirs [ k ] ; y += dirs [ k + 1 ] ; } if ( x == destination [ 0 ] && y == destination [ 1 ] ) return true ; if ( seen [ x ] [ y ] ) continue ; q . offer ( new int [ ] { x , y } ) ; seen [ x ] [ y ] = true ; } } return false ; } private boolean isValid ( int [ ] [ ] maze , int x , int y ) { return 0 <= x && x < maze . length && 0 <= y && y < maze [ 0 ] . length && maze [ x ] [ y ] == 0 ; } }
class Solution { public List < List < Integer > > findSubsequences ( int [ ] nums ) { List < List < Integer > > ans = new LinkedList < > ( ) ; dfs ( nums , 0 , new LinkedList < > ( ) , ans ) ; return ans ; } private void dfs ( int [ ] nums , int s , LinkedList < Integer > path , List < List < Integer > > ans ) { if ( path . size ( ) > 1 ) ans . add ( new LinkedList < > ( path ) ) ; Set < Integer > used = new HashSet < > ( ) ; for ( int i = s ; i < nums . length ; ++ i ) { if ( used . contains ( nums [ i ] ) ) continue ; if ( path . isEmpty ( ) || nums [ i ] >= path . getLast ( ) ) { used . add ( nums [ i ] ) ; path . addLast ( nums [ i ] ) ; dfs ( nums , i + 1 , path , ans ) ; path . removeLast ( ) ; } } } }
class Solution { public int findTargetSumWays ( int [ ] nums , int target ) { final int sum = Arrays . stream ( nums ) . sum ( ) ; if ( sum < Math . abs ( target ) || ( sum + target ) % 2 == 1 ) return 0 ; return knapsack ( nums , ( sum + target ) / 2 ) ; } private int knapsack ( int [ ] nums , int target ) { final int n = nums . length ; int [ ] [ ] dp = new int [ n + 1 ] [ target + 1 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { final int num = nums [ i - 1 ] ; for ( int j = 0 ; j <= target ; ++ j ) if ( j < num ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - num ] ; } return dp [ n ] [ target ] ; } }
class Solution { public int findPoisonedDuration ( int [ ] timeSeries , int duration ) { if ( duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . length ; ++ i ) ans += Math . min ( timeSeries [ i + 1 ] - timeSeries [ i ] , duration ) ; return ans + duration ; } }
class Solution { public int [ ] nextGreaterElement ( int [ ] nums1 , int [ ] nums2 ) { List < Integer > ans = new ArrayList < > ( ) ; Map < Integer , Integer > numToNextGreater = new HashMap < > ( ) ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( final int num : nums2 ) { while ( ! stack . isEmpty ( ) && stack . peek ( ) < num ) numToNextGreater . put ( stack . pop ( ) , num ) ; stack . push ( num ) ; } for ( final int num : nums1 ) if ( numToNextGreater . containsKey ( num ) ) ans . add ( numToNextGreater . get ( num ) ) ; else ans . add ( - 1 ) ; return ans . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; } }
class Solution { public Solution ( int [ ] [ ] rects ) { this . rects = rects ; areas = new int [ rects . length ] ; for ( int i = 0 ; i < rects . length ; ++ i ) areas [ i ] = getArea ( rects [ i ] ) + ( i > 0 ? areas [ i - 1 ] : 0 ) ; } public int [ ] pick ( ) { final int target = rand . nextInt ( areas [ areas . length - 1 ] ) ; final int index = firstGreater ( areas , target ) ; final int [ ] r = rects [ index ] ; return new int [ ] { rand . nextInt ( r [ 2 ] - r [ 0 ] + 1 ) + r [ 0 ] , rand . nextInt ( r [ 3 ] - r [ 1 ] + 1 ) + r [ 1 ] , } ; } private int [ ] [ ] rects ; private int [ ] areas ; private Random rand = new Random ( ) ; private int getArea ( int [ ] r ) { return ( r [ 2 ] - r [ 0 ] + 1 ) * ( r [ 3 ] - r [ 1 ] + 1 ) ; } private int firstGreater ( int [ ] areas , int target ) { int l = 0 ; int r = areas . length ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( areas [ m ] > target ) r = m ; else l = m + 1 ; } return l ; } }
class Solution { public String findShortestWay ( int [ ] [ ] maze , int [ ] ball , int [ ] hole ) { dfs ( maze , ball [ 0 ] , ball [ 1 ] , hole , 0 , 0 , 0 , " " ) ; return ans ; } private String ans = " impossible " ; private int minSteps = Integer . MAX_VALUE ; private void dfs ( int [ ] [ ] maze , int i , int j , int [ ] hole , int dx , int dy , int steps , final String path ) { if ( steps >= minSteps ) return ; if ( dx != 0 || dy != 0 ) { while ( i + dx >= 0 && i + dx < maze . length && j + dy >= 0 && j + dy < maze [ 0 ] . length && maze [ i + dx ] [ j + dy ] != 1 ) { i += dx ; j += dy ; ++ steps ; if ( i == hole [ 0 ] && j == hole [ 1 ] && steps < minSteps ) { minSteps = steps ; ans = path ; } } } if ( maze [ i ] [ j ] == 0 || steps + 2 < maze [ i ] [ j ] ) { maze [ i ] [ j ] = steps + 2 ; if ( dx == 0 ) dfs ( maze , i , j , hole , 1 , 0 , steps , path + " d " ) ; if ( dy == 0 ) dfs ( maze , i , j , hole , 0 , - 1 , steps , path + " l " ) ; if ( dy == 0 ) dfs ( maze , i , j , hole , 0 , 1 , steps , path + " r " ) ; if ( dx == 0 ) dfs ( maze , i , j , hole , - 1 , 0 , steps , path + " u " ) ; } } }
class Solution { public String longestPalindrome ( String s ) { if ( s . isEmpty ( ) ) return " " ; int [ ] indices = { 0 , 0 } ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { int [ ] indices1 = extend ( s , i , i ) ; if ( indices1 [ 1 ] - indices1 [ 0 ] > indices [ 1 ] - indices [ 0 ] ) indices = indices1 ; if ( i + 1 < s . length ( ) && s . charAt ( i ) == s . charAt ( i + 1 ) ) { int [ ] indices2 = extend ( s , i , i + 1 ) ; if ( indices2 [ 1 ] - indices2 [ 0 ] > indices [ 1 ] - indices [ 0 ] ) indices = indices2 ; } } return s . substring ( indices [ 0 ] , indices [ 1 ] + 1 ) ; } private int [ ] extend ( final String s , int i , int j ) { for ( ; i >= 0 && j < s . length ( ) ; -- i , ++ j ) if ( s . charAt ( i ) != s . charAt ( j ) ) break ; return new int [ ] { i + 1 , j - 1 } ; } }
class Solution { public double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ) ; if ( n % 2 == 1 ) return x * myPow ( x , n - 1 ) ; return myPow ( x * x , n / 2 ) ; } }
class Solution { public String [ ] findWords ( String [ ] words ) { List < String > ans = new ArrayList < > ( ) ; final int [ ] rows = { 2 , 3 , 3 , 2 , 1 , 2 , 2 , 2 , 1 , 2 , 2 , 2 , 3 , 3 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 3 , 1 , 3 , 1 , 3 } ; for ( final String word : words ) { final String lowerWord = word . toLowerCase ( ) ; final int row = rows [ lowerWord . charAt ( 0 ) - ' a ' ] ; final boolean isValid = lowerWord . chars ( ) . allMatch ( c -> rows [ c - ' a ' ] == row ) ; if ( isValid ) ans . add ( word ) ; } return ans . toArray ( new String [ 0 ] ) ; } }
class Solution { public int [ ] findMode ( TreeNode root ) { List < Integer > ans = new ArrayList < > ( ) ; int [ ] count = new int [ 2 ] ; inorder ( root , count , ans ) ; return ans . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; } private TreeNode pred = null ; private void inorder ( TreeNode root , int [ ] count , List < Integer > ans ) { if ( root == null ) return ; inorder ( root . left , count , ans ) ; updateCount ( root , count , ans ) ; inorder ( root . right , count , ans ) ; } private void updateCount ( TreeNode root , int [ ] count , List < Integer > ans ) { if ( pred != null && pred . val == root . val ) ++ count [ 0 ] ; else count [ 0 ] = 1 ; if ( count [ 0 ] > count [ 1 ] ) { count [ 1 ] = count [ 0 ] ; ans . clear ( ) ; ans . add ( root . val ) ; } else if ( count [ 0 ] == count [ 1 ] ) { ans . add ( root . val ) ; } pred = root ; } }
class Solution { public int [ ] nextGreaterElements ( int [ ] nums ) { final int n = nums . length ; int [ ] ans = new int [ n ] ; Arrays . fill ( ans , - 1 ) ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < n * 2 ; ++ i ) { final int num = nums [ i % n ] ; while ( ! stack . isEmpty ( ) && nums [ stack . peek ( ) ] < num ) ans [ stack . pop ( ) ] = num ; if ( i < n ) stack . push ( i ) ; } return ans ; } }
class Solution { public boolean checkPerfectNumber ( int num ) { if ( num == 1 ) return false ; int sum = 1 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; ++ i ) if ( num % i == 0 ) sum += i + num / i ; return sum == num ; } }
class Solution { public int [ ] findFrequentTreeSum ( TreeNode root ) { List < Integer > ans = new ArrayList < > ( ) ; Map < Integer , Integer > count = new HashMap < > ( ) ; int maxCount = 0 ; sumDownFrom ( root , count ) ; for ( final int freq : count . values ( ) ) maxCount = Math . max ( maxCount , freq ) ; for ( final int sum : count . keySet ( ) ) if ( count . get ( sum ) == maxCount ) ans . add ( sum ) ; return ans . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; } private int sumDownFrom ( TreeNode root , Map < Integer , Integer > count ) { if ( root == null ) return 0 ; final int sum = root . val + sumDownFrom ( root . left , count ) + sumDownFrom ( root . right , count ) ; count . merge ( sum , 1 , Integer :: sum ) ; return sum ; } }
class Solution { public int fib ( int N ) { if ( N < 2 ) return N ; int [ ] dp = { 0 , 0 , 1 } ; for ( int i = 2 ; i <= N ; ++ i ) { dp [ 0 ] = dp [ 1 ] ; dp [ 1 ] = dp [ 2 ] ; dp [ 2 ] = dp [ 0 ] + dp [ 1 ] ; } return dp [ 2 ] ; } }
class Solution { public List < List < String > > solveNQueens ( int n ) { List < List < String > > ans = new ArrayList < > ( ) ; char [ ] [ ] board = new char [ n ] [ n ] ; for ( int i = 0 ; i < n ; ++ i ) Arrays . fill ( board [ i ] , ' . ' ) ; dfs ( n , 0 , new boolean [ n ] , new boolean [ 2 * n - 1 ] , new boolean [ 2 * n - 1 ] , board , ans ) ; return ans ; } private void dfs ( int n , int i , boolean [ ] cols , boolean [ ] diag1 , boolean [ ] diag2 , char [ ] [ ] board , List < List < String > > ans ) { if ( i == n ) { ans . add ( construct ( board ) ) ; return ; } for ( int j = 0 ; j < cols . length ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + n - 1 ] ) continue ; board [ i ] [ j ] = ' Q ' ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = true ; dfs ( n , i + 1 , cols , diag1 , diag2 , board , ans ) ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = false ; board [ i ] [ j ] = ' . ' ; } } private List < String > construct ( char [ ] [ ] board ) { List < String > listBoard = new ArrayList < > ( ) ; for ( int i = 0 ; i < board . length ; ++ i ) listBoard . add ( String . valueOf ( board [ i ] ) ) ; return listBoard ; } }
class Solution { public int findBottomLeftValue ( TreeNode root ) { Queue < TreeNode > q = new ArrayDeque < > ( Arrays . asList ( root ) ) ; TreeNode node = null ; while ( ! q . isEmpty ( ) ) { node = q . poll ( ) ; if ( node . right != null ) q . offer ( node . right ) ; if ( node . left != null ) q . offer ( node . left ) ; } return node . val ; } }
class Solution { public int findRotateSteps ( String ring , String key ) { Map < String , Integer > memo = new HashMap < > ( ) ; return dfs ( ring , key , 0 , memo ) + key . length ( ) ; } private int dfs ( final String ring , final String key , int index , Map < String , Integer > memo ) { if ( index == key . length ( ) ) return 0 ; final String hashKey = ring + index ; if ( memo . containsKey ( hashKey ) ) return memo . get ( hashKey ) ; int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < ring . length ( ) ; ++ i ) if ( ring . charAt ( i ) == key . charAt ( index ) ) { final int minRotates = Math . min ( i , ring . length ( ) - i ) ; final String newRing = ring . substring ( i ) + ring . substring ( 0 , i ) ; final int remainingRotates = dfs ( newRing , key , index + 1 , memo ) ; ans = Math . min ( ans , minRotates + remainingRotates ) ; } memo . put ( hashKey , ans ) ; return ans ; } }
class Solution { public List < Integer > largestValues ( TreeNode root ) { if ( root == null ) return new ArrayList < > ( ) ; List < Integer > ans = new ArrayList < > ( ) ; Queue < TreeNode > q = new ArrayDeque < > ( Arrays . asList ( root ) ) ; while ( ! q . isEmpty ( ) ) { int max = Integer . MIN_VALUE ; for ( int sz = q . size ( ) ; sz > 0 ; -- sz ) { TreeNode node = q . poll ( ) ; max = Math . max ( max , node . val ) ; if ( node . left != null ) q . offer ( node . left ) ; if ( node . right != null ) q . offer ( node . right ) ; } ans . add ( max ) ; } return ans ; } }
class Solution { public int longestPalindromeSubseq ( String s ) { final int n = s . length ( ) ; dp = new int [ n ] [ n ] ; return lps ( s , 0 , n - 1 ) ; } private int [ ] [ ] dp ; private int lps ( final String s , int i , int j ) { if ( i > j ) return 0 ; if ( i == j ) return 1 ; if ( dp [ i ] [ j ] > 0 ) return dp [ i ] [ j ] ; if ( s . charAt ( i ) == s . charAt ( j ) ) dp [ i ] [ j ] = 2 + lps ( s , i + 1 , j - 1 ) ; else dp [ i ] [ j ] = Math . max ( lps ( s , i + 1 , j ) , lps ( s , i , j - 1 ) ) ; return dp [ i ] [ j ] ; } }
class Solution { public int findMinMoves ( int [ ] machines ) { int dresses = Arrays . stream ( machines ) . sum ( ) ; if ( dresses % machines . length != 0 ) return - 1 ; int ans = 0 ; int inout = 0 ; final int average = dresses / machines . length ; for ( final int dress : machines ) { inout += dress - average ; ans = Math . max ( ans , Math . max ( Math . abs ( inout ) , dress - average ) ) ; } return ans ; } }
class Solution { public int change ( int amount , int [ ] coins ) { int [ ] dp = new int [ amount + 1 ] ; dp [ 0 ] = 1 ; for ( final int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] += dp [ i - coin ] ; return dp [ amount ] ; } }
class Solution { public int totalNQueens ( int n ) { dfs ( n , 0 , new boolean [ n ] , new boolean [ 2 * n - 1 ] , new boolean [ 2 * n - 1 ] ) ; return ans ; } private int ans = 0 ; private void dfs ( int n , int i , boolean [ ] cols , boolean [ ] diag1 , boolean [ ] diag2 ) { if ( i == n ) { ++ ans ; return ; } for ( int j = 0 ; j < cols . length ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + n - 1 ] ) continue ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = true ; dfs ( n , i + 1 , cols , diag1 , diag2 ) ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = false ; } } }
class Solution { public boolean detectCapitalUse ( String word ) { return word . equals ( word . toUpperCase ( ) ) || word . substring ( 1 ) . equals ( word . substring ( 1 ) . toLowerCase ( ) ) ; } }
class Solution { public int findLUSlength ( String a , String b ) { return a . equals ( b ) ? - 1 : Math . max ( a . length ( ) , b . length ( ) ) ; } }
class Solution { public int findLUSlength ( String [ ] strs ) { Set < String > seen = new HashSet < > ( ) ; Set < String > duplicates = new HashSet < > ( ) ; for ( final String str : strs ) if ( seen . contains ( str ) ) duplicates . add ( str ) ; else seen . add ( str ) ; Arrays . sort ( strs , ( a , b ) -> b . length ( ) - a . length ( ) ) ; for ( int i = 0 ; i < strs . length ; ++ i ) { if ( duplicates . contains ( strs [ i ] ) ) continue ; boolean isASubsequence = false ; for ( int j = 0 ; j < i ; ++ j ) isASubsequence |= isSubsequence ( strs [ i ] , strs [ j ] ) ; if ( ! isASubsequence ) return strs [ i ] . length ( ) ; } return - 1 ; } private boolean isSubsequence ( final String a , final String b ) { int i = 0 ; for ( final char c : b . toCharArray ( ) ) if ( i < a . length ( ) && c == a . charAt ( i ) ) ++ i ; return i == a . length ( ) ; } }
class Solution { public boolean checkSubarraySum ( int [ ] nums , int k ) { int prefix = 0 ; Map < Integer , Integer > prefixToIndex = new HashMap < > ( ) ; prefixToIndex . put ( 0 , - 1 ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { prefix += nums [ i ] ; if ( k != 0 ) prefix %= k ; if ( prefixToIndex . containsKey ( prefix ) ) { if ( i - prefixToIndex . get ( prefix ) > 1 ) return true ; } else { prefixToIndex . put ( prefix , i ) ; } } return false ; } }
class Solution { public String findLongestWord ( String s , List < String > d ) { String ans = " " ; for ( final String word : d ) if ( isSubsequence ( word , s ) ) if ( word . length ( ) > ans . length ( ) || word . length ( ) == ans . length ( ) && word . compareTo ( ans ) < 0 ) ans = word ; return ans ; } private boolean isSubsequence ( final String a , final String b ) { int i = 0 ; for ( final char c : b . toCharArray ( ) ) if ( i < a . length ( ) && c == a . charAt ( i ) ) ++ i ; return i == a . length ( ) ; } }
class Solution { public int findMaxLength ( int [ ] nums ) { int ans = 0 ; int prefix = 0 ; Map < Integer , Integer > prefixToIndex = new HashMap < > ( ) ; prefixToIndex . put ( 0 , - 1 ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { prefix += nums [ i ] == 1 ? 1 : - 1 ; if ( prefixToIndex . containsKey ( prefix ) ) ans = Math . max ( ans , i - prefixToIndex . get ( prefix ) ) ; else prefixToIndex . put ( prefix , i ) ; } return ans ; } }
class Solution { public List < String > wordsAbbreviation ( List < String > words ) { final int n = words . size ( ) ; List < String > ans = new ArrayList < > ( ) ; int [ ] prefix = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) ans . add ( getAbbrev ( words . get ( i ) , 0 ) ) ; for ( int i = 0 ; i < n ; ++ i ) while ( true ) { List < Integer > dupeIndices = new ArrayList < > ( ) ; for ( int j = i + 1 ; j < n ; ++ j ) if ( ans . get ( i ) . equals ( ans . get ( j ) ) ) dupeIndices . add ( j ) ; if ( dupeIndices . isEmpty ( ) ) break ; dupeIndices . add ( i ) ; for ( final int dupeIndex : dupeIndices ) ans . set ( dupeIndex , getAbbrev ( words . get ( dupeIndex ) , ++ prefix [ dupeIndex ] ) ) ; } return ans ; } private String getAbbrev ( final String s , int prefixIndex ) { final int n = s . length ( ) ; final int num = n - ( prefixIndex + 1 ) - 1 ; final int numLength = num < 10 ? 1 : num < 100 ? 2 : 3 ; final int abbrevLength = ( prefixIndex + 1 ) + numLength + 1 ; if ( abbrevLength >= n ) return s ; return s . substring ( 0 , prefixIndex + 1 ) + num + s . charAt ( n - 1 ) ; } }
class Solution { public Solution ( int [ ] w ) { prefix = w ; for ( int i = 1 ; i < prefix . length ; ++ i ) prefix [ i ] += prefix [ i - 1 ] ; } public int pickIndex ( ) { final int target = rand . nextInt ( prefix [ prefix . length - 1 ] ) ; int l = 0 ; int r = prefix . length ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( prefix [ m ] > target ) r = m ; else l = m + 1 ; } return l ; } private int [ ] prefix ; private Random rand = new Random ( ) ; }
class Solution { public char [ ] [ ] updateBoard ( char [ ] [ ] board , int [ ] click ) { if ( board [ click [ 0 ] ] [ click [ 1 ] ] == ' M ' ) { board [ click [ 0 ] ] [ click [ 1 ] ] = ' X ' ; return board ; } dfs ( board , click [ 0 ] , click [ 1 ] ) ; return board ; } private static final int [ ] [ ] dirs = { { - 1 , - 1 } , { - 1 , 0 } , { - 1 , 1 } , { 0 , - 1 } , { 0 , 1 } , { 1 , - 1 } , { 1 , 0 } , { 1 , 1 } } ; private void dfs ( char [ ] [ ] board , int i , int j ) { if ( i < 0 || i == board . length || j < 0 || j == board [ 0 ] . length ) return ; if ( board [ i ] [ j ] != ' E ' ) return ; final int minesCount = getMinesCount ( board , i , j ) ; board [ i ] [ j ] = minesCount == 0 ? ' B ' : ( char ) ( '0' + minesCount ) ; if ( minesCount == 0 ) for ( int [ ] dir : dirs ) dfs ( board , i + dir [ 0 ] , j + dir [ 1 ] ) ; } private int getMinesCount ( char [ ] [ ] board , int i , int j ) { int minesCount = 0 ; for ( final int [ ] dir : dirs ) { final int x = i + dir [ 0 ] ; final int y = j + dir [ 1 ] ; if ( x < 0 || x == board . length || y < 0 || y == board [ 0 ] . length ) continue ; if ( board [ x ] [ y ] == ' M ' ) ++ minesCount ; } return minesCount ; } }
class Solution { public int maxSubArray ( int [ ] nums ) { int ans = Integer . MIN_VALUE ; int sum = 0 ; for ( final int num : nums ) { sum += num ; ans = Math . max ( ans , sum ) ; sum = Math . max ( sum , 0 ) ; } return ans ; } }
class Solution { public int findLonelyPixel ( char [ ] [ ] picture ) { final int m = picture . length ; final int n = picture [ 0 ] . length ; int ans = 0 ; int [ ] rows = new int [ m ] ; int [ ] cols = new int [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( picture [ i ] [ j ] == ' B ' ) { ++ rows [ i ] ; ++ cols [ j ] ; } for ( int i = 0 ; i < m ; ++ i ) if ( rows [ i ] == 1 ) for ( int j = 0 ; j < n ; ++ j ) if ( picture [ i ] [ j ] == ' B ' ) { if ( cols [ j ] == 1 ) ++ ans ; break ; } return ans ; } }
class Solution { public int findPairs ( int [ ] nums , int k ) { int ans = 0 ; Map < Integer , Integer > numToIndex = new HashMap < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) numToIndex . put ( nums [ i ] , i ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { final int target = nums [ i ] + k ; if ( numToIndex . containsKey ( target ) && numToIndex . get ( target ) != i ) { ++ ans ; numToIndex . remove ( target ) ; } } return ans ; } }
class Solution { public int findBlackPixel ( char [ ] [ ] picture , int target ) { final int m = picture . length ; final int n = picture [ 0 ] . length ; int ans = 0 ; int [ ] rows = new int [ m ] ; int [ ] cols = new int [ n ] ; String [ ] rowStrings = new String [ m ] ; Map < String , Integer > countRowStrings = new HashMap < > ( ) ; for ( int i = 0 ; i < m ; ++ i ) { StringBuilder sb = new StringBuilder ( ) ; for ( int j = 0 ; j < n ; ++ j ) { if ( picture [ i ] [ j ] == ' B ' ) { ++ rows [ i ] ; ++ cols [ j ] ; } sb . append ( picture [ i ] [ j ] ) ; } rowStrings [ i ] = sb . toString ( ) ; countRowStrings . merge ( rowStrings [ i ] , 1 , Integer :: sum ) ; } for ( int i = 0 ; i < m ; ++ i ) if ( rows [ i ] == target && countRowStrings . get ( rowStrings [ i ] ) == target ) for ( int j = 0 ; j < n ; ++ j ) if ( picture [ i ] [ j ] == ' B ' && cols [ j ] == target ) ++ ans ; return ans ; } }
public class Codec { public String encode ( String longUrl ) { while ( ! urlToCode . containsKey ( longUrl ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < 6 ; ++ i ) { final char nextChar = alphabets . charAt ( rand . nextInt ( alphabets . length ( ) ) ) ; sb . append ( nextChar ) ; } final String code = sb . toString ( ) ; if ( ! codeToUrl . containsKey ( code ) ) { codeToUrl . put ( code , longUrl ) ; urlToCode . put ( longUrl , code ) ; return " http : // tinyurl . com / " + code ; } } throw new IllegalArgumentException ( ) ; } public String decode ( String shortUrl ) { return codeToUrl . get ( shortUrl . substring ( 19 ) ) ; } private static final String alphabets = " abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" ; private Map < String , String > urlToCode = new HashMap < > ( ) ; private Map < String , String > codeToUrl = new HashMap < > ( ) ; private Random rand = new Random ( ) ; }
class Solution { public String complexNumberMultiply ( String a , String b ) { int [ ] A = getRealAndImag ( a ) ; int [ ] B = getRealAndImag ( b ) ; return String . valueOf ( A [ 0 ] * B [ 0 ] - A [ 1 ] * B [ 1 ] ) + " + " + String . valueOf ( A [ 0 ] * B [ 1 ] + A [ 1 ] * B [ 0 ] ) + " i " ; } private int [ ] getRealAndImag ( final String s ) { final String real = s . substring ( 0 , s . indexOf ( ' + ' ) ) ; final String imag = s . substring ( s . indexOf ( ' + ' ) + 1 , s . length ( ) - 1 ) ; return new int [ ] { Integer . valueOf ( real ) , Integer . valueOf ( imag ) } ; } }
class Solution { public TreeNode convertBST ( TreeNode root ) { reversedInorder ( root ) ; return root ; } private int prefix = 0 ; private void reversedInorder ( TreeNode root ) { if ( root == null ) return ; reversedInorder ( root . right ) ; prefix += root . val ; root . val = prefix ; reversedInorder ( root . left ) ; } }
class Solution { public int findMinDifference ( List < String > timePoints ) { int ans = 24 * 60 ; int first = 24 * 60 ; boolean [ ] bucket = new boolean [ 24 * 60 ] ; for ( final String timePoint : timePoints ) { final int num = Integer . valueOf ( timePoint . substring ( 0 , 2 ) ) * 60 + Integer . valueOf ( timePoint . substring ( 3 ) ) ; first = Math . min ( first , num ) ; if ( bucket [ num ] ) return 0 ; bucket [ num ] = true ; } int prev = first ; for ( int i = first + 1 ; i < bucket . length ; ++ i ) if ( bucket [ i ] ) { ans = Math . min ( ans , i - prev ) ; prev = i ; } return Math . min ( ans , 24 * 60 - prev + first ) ; } }
class Solution { public List < Integer > spiralOrder ( int [ ] [ ] matrix ) { if ( matrix . length == 0 ) return new ArrayList < > ( ) ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; List < Integer > ans = new ArrayList < > ( ) ; int r1 = 0 ; int c1 = 0 ; int r2 = m - 1 ; int c2 = n - 1 ; while ( ans . size ( ) < m * n ) { for ( int j = c1 ; j <= c2 && ans . size ( ) < m * n ; ++ j ) ans . add ( matrix [ r1 ] [ j ] ) ; for ( int i = r1 + 1 ; i <= r2 - 1 && ans . size ( ) < m * n ; ++ i ) ans . add ( matrix [ i ] [ c2 ] ) ; for ( int j = c2 ; j >= c1 && ans . size ( ) < m * n ; -- j ) ans . add ( matrix [ r2 ] [ j ] ) ; for ( int i = r2 - 1 ; i >= r1 + 1 && ans . size ( ) < m * n ; -- i ) ans . add ( matrix [ i ] [ c1 ] ) ; ++ r1 ; ++ c1 ; -- r2 ; -- c2 ; } return ans ; } }
class Solution { public int singleNonDuplicate ( int [ ] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = ( l + r ) / 2 ; if ( m % 2 == 1 ) -- m ; if ( nums [ m ] == nums [ m + 1 ] ) l = m + 2 ; else r = m ; } return nums [ l ] ; } }
class Solution { public String reverseStr ( String s , int k ) { StringBuilder sb = new StringBuilder ( s ) ; for ( int i = 0 ; i < sb . length ( ) ; i += 2 * k ) { int l = i ; int r = Math . min ( i + k - 1 , sb . length ( ) - 1 ) ; while ( l < r ) { sb . setCharAt ( l , s . charAt ( r ) ) ; sb . setCharAt ( r , s . charAt ( l ) ) ; ++ l ; -- r ; } } return sb . toString ( ) ; } }
class Solution { public int [ ] [ ] updateMatrix ( int [ ] [ ] mat ) { final int m = mat . length ; final int n = mat [ 0 ] . length ; final int [ ] dirs = new int [ ] { 0 , 1 , 0 , - 1 , 0 } ; Queue < int [ ] > q = new ArrayDeque < > ( ) ; boolean [ ] [ ] seen = new boolean [ m ] [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( mat [ i ] [ j ] == 0 ) { q . offer ( new int [ ] { i , j } ) ; seen [ i ] [ j ] = true ; } while ( ! q . isEmpty ( ) ) { final int i = q . peek ( ) [ 0 ] ; final int j = q . poll ( ) [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seen [ x ] [ y ] ) continue ; mat [ x ] [ y ] = mat [ i ] [ j ] + 1 ; q . offer ( new int [ ] { x , y } ) ; seen [ x ] [ y ] = true ; } } return mat ; } }
class Solution { public int diameterOfBinaryTree ( TreeNode root ) { maxDepth ( root ) ; return ans ; } private int ans = 0 ; int maxDepth ( TreeNode root ) { if ( root == null ) return 0 ; final int l = maxDepth ( root . left ) ; final int r = maxDepth ( root . right ) ; ans = Math . max ( ans , l + r ) ; return 1 + Math . max ( l , r ) ; } }
class Solution { public String findContestMatch ( int n ) { List < String > matches = new ArrayList < > ( ) ; for ( int i = 1 ; i <= n ; ++ i ) matches . add ( String . valueOf ( i ) ) ; return generateMatches ( matches ) ; } private String generateMatches ( List < String > matches ) { if ( matches . size ( ) == 1 ) return matches . get ( 0 ) ; List < String > nextMatches = new ArrayList < > ( ) ; for ( int i = 0 ; i < matches . size ( ) / 2 ; ++ i ) nextMatches . add ( " ( " + matches . get ( i ) + " , " + matches . get ( matches . size ( ) - 1 - i ) + " ) " ) ; return generateMatches ( nextMatches ) ; } }
class Solution { public List < Integer > boundaryOfBinaryTree ( TreeNode root ) { if ( root == null ) return new ArrayList < > ( ) ; List < Integer > ans = new ArrayList < > ( Arrays . asList ( root . val ) ) ; dfs ( root . left , true , false , ans ) ; dfs ( root . right , false , true , ans ) ; return ans ; } private void dfs ( TreeNode root , boolean lb , boolean rb , List < Integer > ans ) { if ( root == null ) return ; if ( lb ) ans . add ( root . val ) ; if ( ! lb && ! rb && root . left == null && root . right == null ) ans . add ( root . val ) ; dfs ( root . left , lb , rb && root . right == null , ans ) ; dfs ( root . right , lb && root . left == null , rb , ans ) ; if ( rb ) ans . add ( root . val ) ; } }
class Solution { public int removeBoxes ( int [ ] boxes ) { final int n = boxes . length ; dp = new int [ n ] [ n ] [ n ] ; return removeBoxes ( boxes , 0 , n - 1 , 0 ) ; } private int [ ] [ ] [ ] dp ; private int removeBoxes ( int [ ] boxes , int i , int j , int k ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] [ k ] > 0 ) return dp [ i ] [ j ] [ k ] ; int r = j ; int sameBoxes = k + 1 ; while ( r > 0 && boxes [ r - 1 ] == boxes [ r ] ) { -- r ; ++ sameBoxes ; } dp [ i ] [ j ] [ k ] = removeBoxes ( boxes , i , r - 1 , 0 ) + sameBoxes * sameBoxes ; for ( int p = i ; p < r ; ++ p ) if ( boxes [ p ] == boxes [ r ] ) dp [ i ] [ j ] [ k ] = Math . max ( dp [ i ] [ j ] [ k ] , removeBoxes ( boxes , i , p , sameBoxes ) + removeBoxes ( boxes , p + 1 , r - 1 , 0 ) ) ; return dp [ i ] [ j ] [ k ] ; } }
class UnionFind { public UnionFind ( int n ) { count = n ; id = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) id [ i ] = i ; } public void union ( int u , int v ) { final int i = find ( u ) ; final int j = find ( v ) ; if ( i == j ) return ; id [ i ] = j ; -- count ; } public int getCount ( ) { return count ; } private int count ; private int [ ] id ; private int find ( int u ) { return id [ u ] == u ? u : ( id [ u ] = find ( id [ u ] ) ) ; } } class Solution { public int findCircleNum ( int [ ] [ ] M ) { final int n = M . length ; UnionFind uf = new UnionFind ( n ) ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) if ( M [ i ] [ j ] == 1 ) uf . union ( i , j ) ; return uf . getCount ( ) ; } }
class Solution { public boolean canJump ( int [ ] nums ) { int i = 0 ; for ( int reach = 0 ; i < nums . length && i <= reach ; ++ i ) reach = Math . max ( reach , i + nums [ i ] ) ; return i == nums . length ; } }
class Solution { public boolean checkRecord ( String s ) { return s . indexOf ( " A " ) == s . lastIndexOf ( " A " ) && ! s . contains ( " LLL " ) ; } }
class Solution { public int checkRecord ( int n ) { final int kMod = 1_000_000_007 ; long [ ] [ ] dp = new long [ 2 ] [ 3 ] ; dp [ 0 ] [ 0 ] = 1 ; while ( n -- > 0 ) { long [ ] [ ] prev = Arrays . stream ( dp ) . map ( ( long [ ] A ) -> A . clone ( ) ) . toArray ( ( int length ) -> new long [ length ] [ ] ) ; dp [ 0 ] [ 0 ] = ( prev [ 0 ] [ 0 ] + prev [ 0 ] [ 1 ] + prev [ 0 ] [ 2 ] ) % kMod ; dp [ 0 ] [ 1 ] = prev [ 0 ] [ 0 ] ; dp [ 0 ] [ 2 ] = prev [ 0 ] [ 1 ] ; dp [ 1 ] [ 0 ] = ( prev [ 0 ] [ 0 ] + prev [ 0 ] [ 1 ] + prev [ 0 ] [ 2 ] + prev [ 1 ] [ 0 ] + prev [ 1 ] [ 1 ] + prev [ 1 ] [ 2 ] ) % kMod ; dp [ 1 ] [ 1 ] = prev [ 1 ] [ 0 ] ; dp [ 1 ] [ 2 ] = prev [ 1 ] [ 1 ] ; } return ( int ) ( ( dp [ 0 ] [ 0 ] + dp [ 0 ] [ 1 ] + dp [ 0 ] [ 2 ] + dp [ 1 ] [ 0 ] + dp [ 1 ] [ 1 ] + dp [ 1 ] [ 2 ] ) % kMod ) ; } }
class Solution { public String optimalDivision ( int [ ] nums ) { StringBuilder sb = new StringBuilder ( String . valueOf ( nums [ 0 ] ) ) ; if ( nums . length == 1 ) return sb . toString ( ) ; if ( nums . length == 2 ) return sb . append ( ' / ' ) . append ( nums [ 1 ] ) . toString ( ) ; sb . append ( " / ( " ) . append ( nums [ 1 ] ) ; for ( int i = 2 ; i < nums . length ; ++ i ) sb . append ( ' / ' ) . append ( nums [ i ] ) ; sb . append ( ' ) ' ) ; return sb . toString ( ) ; } }
class Solution { public int leastBricks ( List < List < Integer > > wall ) { int maxFreq = 0 ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( List < Integer > row : wall ) { int prefix = 0 ; for ( int i = 0 ; i < row . size ( ) - 1 ; ++ i ) { prefix += row . get ( i ) ; count . put ( prefix , count . getOrDefault ( prefix , 0 ) + 1 ) ; maxFreq = Math . max ( maxFreq , count . get ( prefix ) ) ; } } return wall . size ( ) - maxFreq ; } }
class Solution { public String splitLoopedString ( String [ ] strs ) { String ans = " " ; String [ ] sortedStrs = new String [ strs . length ] ; for ( int i = 0 ; i < strs . length ; ++ i ) { final String s = strs [ i ] ; final String r = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; sortedStrs [ i ] = s . compareTo ( r ) > 0 ? s : r ; } for ( int i = 0 ; i < sortedStrs . length ; ++ i ) for ( final String s : new String [ ] { sortedStrs [ i ] , new StringBuilder ( sortedStrs [ i ] ) . reverse ( ) . toString ( ) } ) for ( int j = 0 ; j <= s . length ( ) ; ++ j ) { final String t = s . substring ( j ) + join ( sortedStrs , i ) + s . substring ( 0 , j ) ; if ( t . compareTo ( ans ) > 0 ) ans = t ; } return ans ; } private String join ( String [ ] sortedStrs , int i ) { StringBuilder sb = new StringBuilder ( ) ; for ( int j = i + 1 ; j < sortedStrs . length ; ++ j ) sb . append ( sortedStrs [ j ] ) ; for ( int j = 0 ; j < i ; ++ j ) sb . append ( sortedStrs [ j ] ) ; return sb . toString ( ) ; } }
class Solution { public int nextGreaterElement ( int n ) { final String s = nextPermutation ( String . valueOf ( n ) . toCharArray ( ) ) ; final long ans = Long . parseLong ( s ) ; return ans > Integer . MAX_VALUE || ans <= ( long ) n ? - 1 : ( int ) ans ; } private String nextPermutation ( char [ ] s ) { final int n = s . length ; int i ; for ( i = n - 2 ; i >= 0 ; -- i ) if ( s [ i ] < s [ i + 1 ] ) break ; if ( i >= 0 ) { for ( int j = n - 1 ; j > i ; -- j ) if ( s [ j ] > s [ i ] ) { swap ( s , i , j ) ; break ; } } reverse ( s , i + 1 , n - 1 ) ; return new String ( s ) ; } private void reverse ( char [ ] s , int l , int r ) { while ( l < r ) swap ( s , l ++ , r -- ) ; } private void swap ( char [ ] s , int i , int j ) { final char temp = s [ i ] ; s [ i ] = s [ j ] ; s [ j ] = temp ; } }
class Solution { public int maxDepth ( Node root ) { if ( root == null ) return 0 ; int ans = 0 ; for ( Node child : root . children ) ans = Math . max ( ans , maxDepth ( child ) ) ; return 1 + ans ; } }
class Solution { public int [ ] [ ] merge ( int [ ] [ ] intervals ) { List < int [ ] > ans = new ArrayList < > ( ) ; Arrays . sort ( intervals , ( a , b ) -> ( a [ 0 ] - b [ 0 ] ) ) ; for ( int [ ] interval : intervals ) if ( ans . isEmpty ( ) || ans . get ( ans . size ( ) - 1 ) [ 1 ] < interval [ 0 ] ) ans . add ( interval ) ; else ans . get ( ans . size ( ) - 1 ) [ 1 ] = Math . max ( ans . get ( ans . size ( ) - 1 ) [ 1 ] , interval [ 1 ] ) ; return ans . toArray ( new int [ ans . size ( ) ] [ ] ) ; } }
class Solution { public int subarraySum ( int [ ] nums , int k ) { int ans = 0 ; int prefix = 0 ; Map < Integer , Integer > count = new HashMap < > ( ) ; count . put ( 0 , 1 ) ; for ( final int num : nums ) { prefix += num ; ans += count . getOrDefault ( prefix - k , 0 ) ; count . put ( prefix , count . getOrDefault ( prefix , 0 ) + 1 ) ; } return ans ; } }
class Solution { public int arrayPairSum ( int [ ] nums ) { int ans = 0 ; Arrays . sort ( nums ) ; for ( int i = 0 ; i < nums . length ; i += 2 ) ans += nums [ i ] ; return ans ; } }
class Solution { public int longestLine ( int [ ] [ ] mat ) { final int m = mat . length ; final int n = mat [ 0 ] . length ; int ans = 0 ; int [ ] [ ] [ ] dp = new int [ m ] [ n ] [ 4 ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( mat [ i ] [ j ] == 1 ) { dp [ i ] [ j ] [ 0 ] = j > 0 ? dp [ i ] [ j - 1 ] [ 0 ] + 1 : 1 ; dp [ i ] [ j ] [ 1 ] = i > 0 ? dp [ i - 1 ] [ j ] [ 1 ] + 1 : 1 ; dp [ i ] [ j ] [ 2 ] = ( i > 0 && j > 0 ) ? dp [ i - 1 ] [ j - 1 ] [ 2 ] + 1 : 1 ; dp [ i ] [ j ] [ 3 ] = ( i > 0 && j < n - 1 ) ? dp [ i - 1 ] [ j + 1 ] [ 3 ] + 1 : 1 ; for ( int k = 0 ; k < 4 ; ++ k ) ans = Math . max ( ans , dp [ i ] [ j ] [ k ] ) ; } return ans ; } }
class Solution { public int findTilt ( TreeNode root ) { sum ( root ) ; return ans ; } private int ans = 0 ; private int sum ( TreeNode root ) { if ( root == null ) return 0 ; final int l = sum ( root . left ) ; final int r = sum ( root . right ) ; ans += Math . abs ( l - r ) ; return root . val + l + r ; } }
class Solution { public String nearestPalindromic ( String n ) { final long [ ] palindromes = getPalindromes ( n ) ; return Math . abs ( palindromes [ 0 ] - Long . parseLong ( n ) ) <= Math . abs ( palindromes [ 1 ] - Long . parseLong ( n ) ) ? String . valueOf ( palindromes [ 0 ] ) : String . valueOf ( palindromes [ 1 ] ) ; } private long [ ] getPalindromes ( final String s ) { final long num = Long . parseLong ( s ) ; final int n = s . length ( ) ; long [ ] palindromes = new long [ 2 ] ; final String half = s . substring ( 0 , ( n + 1 ) / 2 ) ; final String reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 ) ) . reverse ( ) . toString ( ) ; final long candidate = Long . parseLong ( half + reversedHalf ) ; if ( candidate < num ) palindromes [ 0 ] = candidate ; else { final String prevHalf = String . valueOf ( Long . parseLong ( half ) - 1 ) ; final String reversedPrevHalf = new StringBuilder ( prevHalf . substring ( 0 , Math . min ( prevHalf . length ( ) , n / 2 ) ) ) . reverse ( ) . toString ( ) ; if ( n % 2 == 0 && Long . parseLong ( prevHalf ) == 0 ) palindromes [ 0 ] = 9 ; else if ( n % 2 == 0 && ( Long . parseLong ( prevHalf ) + 1 ) % 10 == 0 ) palindromes [ 0 ] = Long . parseLong ( prevHalf + '9' + reversedPrevHalf ) ; else palindromes [ 0 ] = Long . parseLong ( prevHalf + reversedPrevHalf ) ; } if ( candidate > num ) palindromes [ 1 ] = candidate ; else { final String nextHalf = String . valueOf ( Long . parseLong ( half ) + 1 ) ; final String reversedNextHalf = new StringBuilder ( nextHalf . substring ( 0 , n / 2 ) ) . reverse ( ) . toString ( ) ; palindromes [ 1 ] = Long . parseLong ( nextHalf + reversedNextHalf ) ; } return palindromes ; } }
class Solution { public int arrayNesting ( int [ ] nums ) { int ans = 0 ; for ( final int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { final int cache = index ; index = nums [ index ] ; nums [ cache ] = - 1 ; ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; } }
class Solution { public int [ ] [ ] matrixReshape ( int [ ] [ ] nums , int r , int c ) { if ( nums . length == 0 || r * c != nums . length * nums [ 0 ] . length ) return nums ; int [ ] [ ] ans = new int [ r ] [ c ] ; int k = 0 ; for ( int [ ] row : nums ) for ( final int num : row ) { ans [ k / c ] [ k % c ] = num ; ++ k ; } return ans ; } }
class Solution { public int [ ] [ ] insert ( int [ ] [ ] intervals , int [ ] newInterval ) { final int n = intervals . length ; List < int [ ] > ans = new ArrayList < > ( ) ; int i = 0 ; while ( i < n && intervals [ i ] [ 1 ] < newInterval [ 0 ] ) ans . add ( intervals [ i ++ ] ) ; while ( i < n && intervals [ i ] [ 0 ] <= newInterval [ 1 ] ) { newInterval [ 0 ] = Math . min ( newInterval [ 0 ] , intervals [ i ] [ 0 ] ) ; newInterval [ 1 ] = Math . max ( newInterval [ 1 ] , intervals [ i ] [ 1 ] ) ; ++ i ; } ans . add ( newInterval ) ; while ( i < n ) ans . add ( intervals [ i ++ ] ) ; return ans . toArray ( new int [ ans . size ( ) ] [ ] ) ; } }
class Solution { public int minDistance ( int height , int width , int [ ] tree , int [ ] squirrel , int [ ] [ ] nuts ) { int totDist = 0 ; int maxSave = Integer . MIN_VALUE ; for ( int [ ] nut : nuts ) { totDist += dist ( nut , tree ) * 2 ; maxSave = Math . max ( maxSave , dist ( nut , tree ) - dist ( nut , squirrel ) ) ; } return totDist - maxSave ; } private int dist ( int [ ] a , int [ ] b ) { return Math . abs ( a [ 0 ] - b [ 0 ] ) + Math . abs ( a [ 1 ] - b [ 1 ] ) ; } }
class Solution { public int distributeCandies ( int [ ] candies ) { BitSet bitset = new BitSet ( 200001 ) ; for ( final int candy : candies ) bitset . set ( candy + 100000 ) ; return Math . min ( candies . length / 2 , bitset . cardinality ( ) ) ; } }
class Solution { public int lengthOfLastWord ( String s ) { int i = s . length ( ) - 1 ; while ( i >= 0 && s . charAt ( i ) == ' ▁ ' ) -- i ; final int lastIndex = i ; while ( i >= 0 && s . charAt ( i ) != ' ▁ ' ) -- i ; return lastIndex - i ; } }
class Solution { public int findUnsortedSubarray ( int [ ] nums ) { final int n = nums . length ; int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; boolean meetDecrease = false ; boolean meetIncrease = false ; for ( int i = 1 ; i < n ; ++ i ) { if ( nums [ i ] < nums [ i - 1 ] ) meetDecrease = true ; if ( meetDecrease ) min = Math . min ( min , nums [ i ] ) ; } for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( nums [ i ] > nums [ i + 1 ] ) meetIncrease = true ; if ( meetIncrease ) max = Math . max ( max , nums [ i ] ) ; } int l = 0 ; for ( l = 0 ; l < n ; ++ l ) if ( nums [ l ] > min ) break ; int r = 0 ; for ( r = n - 1 ; r >= 0 ; -- r ) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } }
class Solution { public List < Integer > killProcess ( List < Integer > pid , List < Integer > ppid , int kill ) { List < Integer > ans = new ArrayList < > ( ) ; Map < Integer , List < Integer > > tree = new HashMap < > ( ) ; for ( int i = 0 ; i < pid . size ( ) ; ++ i ) { if ( ppid . get ( i ) == 0 ) continue ; tree . putIfAbsent ( ppid . get ( i ) , new ArrayList < > ( ) ) ; tree . get ( ppid . get ( i ) ) . add ( pid . get ( i ) ) ; } dfs ( tree , kill , ans ) ; return ans ; } private void dfs ( Map < Integer , List < Integer > > tree , int u , List < Integer > ans ) { ans . add ( u ) ; for ( final int v : tree . getOrDefault ( u , new ArrayList < > ( ) ) ) dfs ( tree , v , ans ) ; } }
class Solution { public int minDistance ( String word1 , String word2 ) { final int k = lcs ( word1 , word2 ) ; return ( word1 . length ( ) - k ) + ( word2 . length ( ) - k ) ; } private int lcs ( final String A , final String B ) { final int m = A . length ( ) ; final int n = B . length ( ) ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; return dp [ m ] [ n ] ; } }
class Solution { public int [ ] [ ] outerTrees ( int [ ] [ ] trees ) { Stack < int [ ] > hull = new Stack < > ( ) ; Arrays . sort ( trees , ( a , b ) -> a [ 0 ] == b [ 0 ] ? a [ 1 ] - b [ 1 ] : a [ 0 ] - b [ 0 ] ) ; for ( int [ ] tree : trees ) { while ( hull . size ( ) > 1 && cross ( hull . peek ( ) , hull . get ( hull . size ( ) - 2 ) , tree ) > 0 ) hull . pop ( ) ; hull . push ( tree ) ; } hull . pop ( ) ; for ( int i = trees . length - 1 ; i >= 0 ; -- i ) { while ( hull . size ( ) > 1 && cross ( hull . peek ( ) , hull . get ( hull . size ( ) - 2 ) , trees [ i ] ) > 0 ) hull . pop ( ) ; hull . push ( trees [ i ] ) ; } HashSet < int [ ] > unique = new HashSet < > ( hull ) ; return unique . toArray ( new int [ unique . size ( ) ] [ ] ) ; } private int cross ( int [ ] p , int [ ] q , int [ ] r ) { return ( q [ 1 ] - p [ 1 ] ) * ( r [ 0 ] - q [ 0 ] ) - ( q [ 0 ] - p [ 0 ] ) * ( r [ 1 ] - q [ 1 ] ) ; } }
class Solution { public int [ ] [ ] generateMatrix ( int n ) { int [ ] [ ] ans = new int [ n ] [ n ] ; int count = 1 ; for ( int min = 0 ; min < n / 2 ; ++ min ) { final int max = n - min - 1 ; for ( int i = min ; i < max ; ++ i ) ans [ min ] [ i ] = count ++ ; for ( int i = min ; i < max ; ++ i ) ans [ i ] [ max ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ max ] [ i ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ i ] [ min ] = count ++ ; } if ( n % 2 == 1 ) ans [ n / 2 ] [ n / 2 ] = count ; return ans ; } }
class Solution { public boolean isValid ( String code ) { if ( code . charAt ( 0 ) != ' < ' || code . charAt ( code . length ( ) - 1 ) != ' > ' ) return false ; Deque < String > stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < code . length ( ) ; ++ i ) { int closeIndex = 0 ; if ( stack . isEmpty ( ) && containsTag ) return false ; if ( code . charAt ( i ) == ' < ' ) { if ( ! stack . isEmpty ( ) && code . charAt ( i + 1 ) == ' ! ' ) { closeIndex = code . indexOf ( " ] ] > " , i + 2 ) ; if ( closeIndex < 0 || ! isValidCdata ( code . substring ( i + 2 , closeIndex ) ) ) return false ; } else if ( code . charAt ( i + 1 ) == ' / ' ) { closeIndex = code . indexOf ( ' > ' , i + 2 ) ; if ( closeIndex < 0 || ! isValidTagName ( stack , code . substring ( i + 2 , closeIndex ) , true ) ) return false ; } else { closeIndex = code . indexOf ( ' > ' , i + 1 ) ; if ( closeIndex < 0 || ! isValidTagName ( stack , code . substring ( i + 1 , closeIndex ) , false ) ) return false ; } i = closeIndex ; } } return stack . isEmpty ( ) && containsTag ; } private boolean containsTag = false ; private boolean isValidCdata ( final String s ) { return s . indexOf ( " [ CDATA [ " ) == 0 ; } private boolean isValidTagName ( Deque < String > stack , String tagName , boolean isEndTag ) { if ( tagName . isEmpty ( ) || tagName . length ( ) > 9 ) return false ; for ( final char c : tagName . toCharArray ( ) ) if ( ! Character . isUpperCase ( c ) ) return false ; if ( isEndTag ) return ! stack . isEmpty ( ) && stack . pop ( ) . equals ( tagName ) ; containsTag = true ; stack . push ( tagName ) ; return true ; } }
class Solution { public String fractionAddition ( String expression ) { Scanner sc = new Scanner ( expression ) . useDelimiter ( " / | ( ? = [ + - ] ) " ) ; int A = 0 ; int B = 1 ; while ( sc . hasNext ( ) ) { final int a = sc . nextInt ( ) ; final int b = sc . nextInt ( ) ; A = A * b + a * B ; B *= b ; final int g = gcd ( A , B ) ; A /= g ; B /= g ; } return A + " / " + B ; } private int gcd ( int a , int b ) { return a == 0 ? Math . abs ( b ) : gcd ( b % a , a ) ; } }
class Solution { public boolean validSquare ( int [ ] p1 , int [ ] p2 , int [ ] p3 , int [ ] p4 ) { Set < Integer > distSet = new HashSet < > ( ) ; int [ ] [ ] points = { p1 , p2 , p3 , p4 } ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = i + 1 ; j < 4 ; ++ j ) distSet . add ( dist ( points [ i ] , points [ j ] ) ) ; return ! distSet . contains ( 0 ) && distSet . size ( ) == 2 ; } private int dist ( int [ ] p1 , int [ ] p2 ) { return ( p1 [ 0 ] - p2 [ 0 ] ) * ( p1 [ 0 ] - p2 [ 0 ] ) + ( p1 [ 1 ] - p2 [ 1 ] ) * ( p1 [ 1 ] - p2 [ 1 ] ) ; } }
class Solution { public int findLHS ( int [ ] nums ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( final int num : nums ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ) ; for ( final int num : count . keySet ( ) ) if ( count . containsKey ( num + 1 ) ) ans = Math . max ( ans , count . get ( num ) + count . get ( num + 1 ) ) ; return ans ; } }
class Solution { public int maxCount ( int m , int n , int [ ] [ ] ops ) { int minY = m ; int minX = n ; for ( int [ ] op : ops ) { minY = Math . min ( minY , op [ 0 ] ) ; minX = Math . min ( minX , op [ 1 ] ) ; } return minX * minY ; } }
class Solution { public String [ ] findRestaurant ( String [ ] list1 , String [ ] list2 ) { List < String > ans = new LinkedList < > ( ) ; Map < String , Integer > restaurantToIndex = new HashMap < > ( ) ; int minSum = Integer . MAX_VALUE ; for ( int i = 0 ; i < list1 . length ; ++ i ) restaurantToIndex . put ( list1 [ i ] , i ) ; for ( int i = 0 ; i < list2 . length ; ++ i ) { final String restaurant = list2 [ i ] ; if ( restaurantToIndex . containsKey ( restaurant ) ) { final int sum = restaurantToIndex . get ( restaurant ) + i ; if ( sum < minSum ) { minSum = sum ; ans . clear ( ) ; ans . add ( restaurant ) ; } else if ( sum == minSum ) { ans . add ( restaurant ) ; } } } return ans . toArray ( new String [ 0 ] ) ; } }
class Solution { public String convert ( String s , int numRows ) { StringBuilder sb = new StringBuilder ( ) ; List < Character > [ ] rows = new List [ numRows ] ; int k = 0 ; int direction = numRows == 1 ? 0 : - 1 ; for ( int i = 0 ; i < numRows ; ++ i ) rows [ i ] = new ArrayList < > ( ) ; for ( final char c : s . toCharArray ( ) ) { rows [ k ] . add ( c ) ; if ( k == 0 || k == numRows - 1 ) direction *= - 1 ; k += direction ; } for ( List < Character > row : rows ) for ( final char c : row ) sb . append ( c ) ; return sb . toString ( ) ; } }
class Solution { public String getPermutation ( int n , int k ) { StringBuilder sb = new StringBuilder ( ) ; List < Integer > nums = new ArrayList < > ( ) ; int [ ] factorial = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; ++ i ) nums . add ( i ) ; Arrays . fill ( factorial , 1 ) ; for ( int i = 2 ; i <= n ; ++ i ) factorial [ i ] = factorial [ i - 1 ] * i ; -- k ; for ( int i = n - 1 ; i >= 0 ; -- i ) { final int j = k / factorial [ i ] ; k %= factorial [ i ] ; sb . append ( nums . get ( j ) ) ; nums . remove ( j ) ; } return sb . toString ( ) ; } }
class StringIterator { public StringIterator ( String compressedString ) { s = compressedString ; } public char next ( ) { if ( ! hasNext ( ) ) return ' ▁ ' ; if ( num == 0 ) { currentChar = s . charAt ( i ++ ) ; while ( i < s . length ( ) && Character . isDigit ( s . charAt ( i ) ) ) num = num * 10 + ( s . charAt ( i ++ ) - '0' ) ; } -- num ; return currentChar ; } public boolean hasNext ( ) { return i < s . length ( ) || num > 0 ; } private final String s ; private int i = 0 ; private int num = 0 ; private char currentChar = ' ▁ ' ; }
class Solution { public boolean canPlaceFlowers ( int [ ] flowerbed , int n ) { if ( n == 0 ) return true ; for ( int i = 0 ; i < flowerbed . length ; ++ i ) if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . length - 1 || flowerbed [ i + 1 ] == 0 ) ) { flowerbed [ i ] = 1 ; if ( -- n == 0 ) return true ; } return false ; } }
class Solution { public String tree2str ( TreeNode t ) { return dfs ( t ) ; } private String dfs ( TreeNode root ) { if ( root == null ) return " " ; if ( root . right != null ) return root . val + " ( " + dfs ( root . left ) + " ) ( " + dfs ( root . right ) + " ) " ; if ( root . left != null ) return root . val + " ( " + dfs ( root . left ) + " ) " ; return root . val + " " ; } }
class Solution { public List < List < String > > findDuplicate ( String [ ] paths ) { List < List < String > > ans = new ArrayList < > ( ) ; Map < String , List < String > > contentToFilePaths = new HashMap < > ( ) ; for ( final String path : paths ) { final String [ ] words = path . split ( " ▁ " ) ; final String rootPath = words [ 0 ] ; for ( int i = 1 ; i < words . length ; ++ i ) { final String fileAndContent = words [ i ] ; final int l = fileAndContent . indexOf ( ' ( ' ) ; final int r = fileAndContent . indexOf ( ' ) ' ) ; final String file = fileAndContent . substring ( 0 , l ) ; final String content = fileAndContent . substring ( l + 1 , r ) ; final String filePath = rootPath + ' / ' + file ; contentToFilePaths . putIfAbsent ( content , new ArrayList < > ( ) ) ; contentToFilePaths . get ( content ) . add ( filePath ) ; } } for ( List < String > filePaths : contentToFilePaths . values ( ) ) if ( filePaths . size ( ) > 1 ) ans . add ( filePaths ) ; return ans ; } }
class Solution { public ListNode rotateRight ( ListNode head , int k ) { if ( head == null || head . next == null || k == 0 ) return head ; int length = 1 ; ListNode tail = head ; for ( ; tail . next != null ; tail = tail . next ) ++ length ; tail . next = head ; final int t = length - k % length ; for ( int i = 0 ; i < t ; ++ i ) tail = tail . next ; ListNode newHead = tail . next ; tail . next = null ; return newHead ; } }
class Solution { public int triangleNumber ( int [ ] nums ) { if ( nums . length < 3 ) return 0 ; int ans = 0 ; Arrays . sort ( nums ) ; for ( int k = nums . length - 1 ; k > 1 ; -- k ) { int i = 0 ; int j = k - 1 ; while ( i < j ) if ( nums [ i ] + nums [ j ] > nums [ k ] ) { ans += j - i ; -- j ; } else { ++ i ; } } return ans ; } }
class Solution { public String addBoldTag ( String s , String [ ] words ) { final int n = s . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; boolean [ ] bold = new boolean [ n ] ; int boldEnd = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { for ( final String word : words ) if ( s . substring ( i ) . startsWith ( word ) ) boldEnd = Math . max ( boldEnd , i + word . length ( ) ) ; bold [ i ] = boldEnd > i ; } int i = 0 ; while ( i < n ) if ( bold [ i ] ) { int j = i ; while ( j < n && bold [ j ] ) ++ j ; sb . append ( " < b > " ) . append ( s . substring ( i , j ) ) . append ( " < / b > " ) ; i = j ; } else { sb . append ( s . charAt ( i ++ ) ) ; } return sb . toString ( ) ; } }
class Solution { public TreeNode mergeTrees ( TreeNode root1 , TreeNode root2 ) { if ( root1 == null && root2 == null ) return null ; final int val = ( root1 == null ? 0 : root1 . val ) + ( root2 == null ? 0 : root2 . val ) ; TreeNode root = new TreeNode ( val ) ; root . left = mergeTrees ( root1 == null ? null : root1 . left , root2 == null ? null : root2 . left ) ; root . right = mergeTrees ( root1 == null ? null : root1 . right , root2 == null ? null : root2 . right ) ; return root ; } }
class Solution { public int uniquePaths ( int m , int n ) { int [ ] [ ] dp = new int [ m ] [ n ] ; Arrays . stream ( dp ) . forEach ( row -> Arrays . fill ( row , 1 ) ) ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ m - 1 ] [ n - 1 ] ; } }
class Solution { public int leastInterval ( char [ ] tasks , int n ) { int [ ] count = new int [ 26 ] ; for ( final char task : tasks ) ++ count [ task - ' A ' ] ; final int maxFreq = Arrays . stream ( count ) . max ( ) . getAsInt ( ) ; final int maxFreqTaskOccupy = ( maxFreq - 1 ) * ( n + 1 ) ; final int nMaxFreq = ( int ) Arrays . stream ( count ) . filter ( c -> c == maxFreq ) . count ( ) ; return Math . max ( maxFreqTaskOccupy + nMaxFreq , tasks . length ) ; } }
class Solution { public int maxDistance ( List < List < Integer > > arrays ) { int ans = 0 ; int min = 10000 ; int max = - 10000 ; for ( List < Integer > A : arrays ) { ans = Math . max ( ans , Math . max ( A . get ( A . size ( ) - 1 ) - min , max - A . get ( 0 ) ) ) ; min = Math . min ( min , A . get ( 0 ) ) ; max = Math . max ( max , A . get ( A . size ( ) - 1 ) ) ; } return ans ; } }
class Solution { public int smallestFactorization ( int num ) { if ( num == 1 ) return 1 ; long ans = 0 ; long base = 1 ; for ( int i = 9 ; i > 1 ; -- i ) while ( num % i == 0 ) { num /= i ; ans = base * i + ans ; base *= 10 ; } return num == 1 && ans <= Integer . MAX_VALUE ? ( int ) ans : 0 ; } }
class Solution { public int maximumProduct ( int [ ] nums ) { final int n = nums . length ; Arrays . sort ( nums ) ; return Math . max ( nums [ n - 1 ] * nums [ 0 ] * nums [ 1 ] , nums [ n - 1 ] * nums [ n - 2 ] * nums [ n - 3 ] ) ; } }
class Solution { public int kInversePairs ( int n , int k ) { final int kMod = 1_000_000_007 ; int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) dp [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= k ; ++ j ) { dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] ) % kMod ; if ( j - i >= 0 ) dp [ i ] [ j ] = ( dp [ i ] [ j ] - dp [ i - 1 ] [ j - i ] + kMod ) % kMod ; } return dp [ n ] [ k ] ; } }
class Solution { public int uniquePathsWithObstacles ( int [ ] [ ] obstacleGrid ) { final int m = obstacleGrid . length ; final int n = obstacleGrid [ 0 ] . length ; long [ ] [ ] dp = new long [ m + 1 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( obstacleGrid [ i - 1 ] [ j - 1 ] == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return ( int ) dp [ m ] [ n ] ; } }
class Solution { public int scheduleCourse ( int [ ] [ ] courses ) { int time = 0 ; Arrays . sort ( courses , ( a , b ) -> ( a [ 1 ] - b [ 1 ] ) ) ; Queue < Integer > maxHeap = new PriorityQueue < > ( ( a , b ) -> b - a ) ; for ( int [ ] c : courses ) { final int duration = c [ 0 ] ; final int lastDay = c [ 1 ] ; maxHeap . offer ( duration ) ; time += c [ 0 ] ; if ( time > lastDay ) time -= maxHeap . poll ( ) ; } return maxHeap . size ( ) ; } }
class Cell { public int val = 0 ; public Map < Integer , Integer > posCount = new HashMap < > ( ) ; public Cell ( int val , Map < Integer , Integer > posCount ) { this . val = val ; this . posCount = posCount ; } } class Excel { public Excel ( int height , char width ) { this . width = width ; this . sheet = new Cell [ height ] [ width ] ; for ( int i = 0 ; i < height ; ++ i ) for ( int j = 0 ; j < width ; ++ j ) sheet [ i ] [ j ] = new Cell ( 0 , null ) ; } public void set ( int row , char column , int val ) { sheet [ row - 1 ] [ column - ' A ' ] = new Cell ( val , null ) ; } public int get ( int row , char column ) { Cell cell = sheet [ row - 1 ] [ column - ' A ' ] ; if ( cell . posCount == null ) return cell . val ; int val = 0 ; for ( Map . Entry < Integer , Integer > entry : cell . posCount . entrySet ( ) ) { final int pos = entry . getKey ( ) ; final int count = entry . getValue ( ) ; val += get ( pos / width + 1 , ( char ) ( ( pos % width ) + ' A ' ) ) * count ; } return val ; } public int sum ( int row , char column , String [ ] numbers ) { sheet [ row - 1 ] [ column - ' A ' ] . posCount = parse ( numbers ) ; return get ( row , column ) ; } private int width ; private Cell [ ] [ ] sheet ; private Map < Integer , Integer > parse ( String [ ] numbers ) { Map < Integer , Integer > count = new HashMap < > ( ) ; for ( final String s : numbers ) { Pair < String , String > tokens = parse ( s ) ; final int startRow = Integer . parseInt ( tokens . getKey ( ) . substring ( 1 ) ) ; final char startCol = tokens . getKey ( ) . charAt ( 0 ) ; final int endRow = Integer . parseInt ( tokens . getValue ( ) . substring ( 1 ) ) ; final char endCol = tokens . getValue ( ) . charAt ( 0 ) ; for ( int i = startRow - 1 ; i < endRow ; ++ i ) for ( int j = startCol - ' A ' ; j < endCol - ' A ' + 1 ; ++ j ) count . merge ( i * width + j , 1 , Integer :: sum ) ; } return count ; } private Pair < String , String > parse ( final String s ) { if ( ! s . contains ( " : " ) ) return new Pair < > ( s , s ) ; String [ ] tokens = s . split ( " : " ) ; return new Pair < > ( tokens [ 0 ] , tokens [ 1 ] ) ; } }
class T { public int i ; public int j ; public int num ; public T ( int i , int j , int num ) { this . i = i ; this . j = j ; this . num = num ; } } class Solution { public int [ ] smallestRange ( List < List < Integer > > nums ) { Queue < T > minHeap = new PriorityQueue < > ( ( a , b ) -> a . num - b . num ) ; int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < nums . size ( ) ; ++ i ) { final int num = nums . get ( i ) . get ( 0 ) ; minHeap . offer ( new T ( i , 0 , num ) ) ; min = Math . min ( min , num ) ; max = Math . max ( max , num ) ; } int minRange = min ; int maxRange = max ; while ( minHeap . size ( ) == nums . size ( ) ) { final int i = minHeap . peek ( ) . i ; final int j = minHeap . poll ( ) . j ; if ( j + 1 < nums . get ( i ) . size ( ) ) { minHeap . offer ( new T ( i , j + 1 , nums . get ( i ) . get ( j + 1 ) ) ) ; max = Math . max ( max , nums . get ( i ) . get ( j + 1 ) ) ; min = minHeap . peek ( ) . num ; } if ( max - min < maxRange - minRange ) { minRange = min ; maxRange = max ; } } return new int [ ] { minRange , maxRange } ; } }
class Solution { public boolean judgeSquareSum ( int c ) { int l = 0 ; int r = ( int ) Math . sqrt ( c ) ; while ( l <= r ) { final int sum = l * l + r * r ; if ( sum == c ) return true ; if ( sum < c ) ++ l ; else -- r ; } return false ; } }
class Solution { public int findDerangement ( int n ) { dp = new Long [ n + 1 ] ; return ( int ) find ( n ) ; } private static final int kMod = 1_000_000_007 ; private Long [ ] dp ; private long find ( int i ) { if ( i == 0 ) return 1 ; if ( i == 1 ) return 0 ; if ( dp [ i ] != null ) return dp [ i ] ; return dp [ i ] = ( i - 1 ) * ( find ( i - 1 ) + find ( i - 2 ) ) % kMod ; } }
class LogSystem { public LogSystem ( ) { granularityToIndices . put ( " Year " , 4 ) ; granularityToIndices . put ( " Month " , 7 ) ; granularityToIndices . put ( " Day " , 10 ) ; granularityToIndices . put ( " Hour " , 13 ) ; granularityToIndices . put ( " Minute " , 16 ) ; granularityToIndices . put ( " Second " , 19 ) ; } public void put ( int id , String timestamp ) { idAndTimestamps . add ( new Pair < > ( id , timestamp ) ) ; } public List < Integer > retrieve ( String start , String end , String granularity ) { List < Integer > ans = new ArrayList < > ( ) ; final int index = granularityToIndices . get ( granularity ) ; final String s = start . substring ( 0 , index ) ; final String e = end . substring ( 0 , index ) ; for ( Pair < Integer , String > idAndTimestamp : idAndTimestamps ) { final String timestamp = idAndTimestamp . getValue ( ) ; final String t = timestamp . substring ( 0 , index ) ; if ( t . compareTo ( s ) >= 0 && t . compareTo ( e ) <= 0 ) ans . add ( idAndTimestamp . getKey ( ) ) ; } return ans ; } private Map < String , Integer > granularityToIndices = new HashMap < > ( ) ; private List < Pair < Integer , String > > idAndTimestamps = new ArrayList < > ( ) ; }
class Solution { public int shoppingOffers ( List < Integer > price , List < List < Integer > > special , List < Integer > needs ) { return dfs ( price , special , needs , 0 ) ; } private int dfs ( List < Integer > price , List < List < Integer > > special , List < Integer > needs , int s ) { int ans = 0 ; for ( int i = 0 ; i < needs . size ( ) ; ++ i ) ans += needs . get ( i ) * price . get ( i ) ; for ( int i = s ; i < special . size ( ) ; ++ i ) { List < Integer > offer = special . get ( i ) ; if ( isValid ( offer , needs ) ) { for ( int j = 0 ; j < needs . size ( ) ; ++ j ) needs . set ( j , needs . get ( j ) - offer . get ( j ) ) ; ans = Math . min ( ans , offer . get ( offer . size ( ) - 1 ) + dfs ( price , special , needs , i ) ) ; for ( int j = 0 ; j < needs . size ( ) ; ++ j ) needs . set ( j , needs . get ( j ) + offer . get ( j ) ) ; } } return ans ; } private boolean isValid ( List < Integer > offer , List < Integer > needs ) { for ( int i = 0 ; i < needs . size ( ) ; ++ i ) if ( offer . get ( i ) > needs . get ( i ) ) return false ; return true ; } }
class Solution { public int minPathSum ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( i > 0 && j > 0 ) grid [ i ] [ j ] += Math . min ( grid [ i - 1 ] [ j ] , grid [ i ] [ j - 1 ] ) ; else if ( i > 0 ) grid [ i ] [ 0 ] += grid [ i - 1 ] [ 0 ] ; else if ( j > 0 ) grid [ 0 ] [ j ] += grid [ 0 ] [ j - 1 ] ; return grid [ m - 1 ] [ n - 1 ] ; } }
class Solution { public String solveEquation ( String equation ) { String [ ] equations = equation . split ( " = " ) ; int [ ] lhs = calculate ( equations [ 0 ] ) ; int [ ] rhs = calculate ( equations [ 1 ] ) ; int coefficient = lhs [ 0 ] - rhs [ 0 ] ; int constant = rhs [ 1 ] - lhs [ 1 ] ; if ( coefficient == 0 && constant == 0 ) return " Infinite ▁ solutions " ; if ( coefficient == 0 && constant != 0 ) return " No ▁ solution " ; return " x = " + constant / coefficient ; } private int [ ] calculate ( final String s ) { int coefficient = 0 ; int constant = 0 ; int num = 0 ; int sign = 1 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { char c = s . charAt ( i ) ; if ( Character . isDigit ( c ) ) num = num * 10 + ( c - '0' ) ; else if ( c == ' + ' || c == ' - ' ) { constant += sign * num ; sign = c == ' + ' ? 1 : - 1 ; num = 0 ; } else { if ( i > 0 && num == 0 && s . charAt ( i - 1 ) == '0' ) continue ; coefficient += num == 0 ? sign : sign * num ; num = 0 ; } } return new int [ ] { coefficient , constant + sign * num } ; } }
class Solution { public double findMaxAverage ( int [ ] nums , int k ) { double sum = 0 ; for ( int i = 0 ; i < k ; ++ i ) sum += nums [ i ] ; double ans = sum ; for ( int i = k ; i < nums . length ; ++ i ) { sum += nums [ i ] - nums [ i - k ] ; ans = Math . max ( ans , sum ) ; } return ans / k ; } }
class Solution { public double findMaxAverage ( int [ ] nums , int k ) { final double kErr = 1e-5 ; double l = ( double ) Arrays . stream ( nums ) . min ( ) . getAsInt ( ) ; double r = ( double ) Arrays . stream ( nums ) . max ( ) . getAsInt ( ) ; while ( r - l > kErr ) { final double m = ( l + r ) / 2 ; if ( check ( nums , k , m ) ) l = m ; else r = m ; } return l ; } private boolean check ( int [ ] nums , int k , double m ) { double sum = 0 ; double prevSum = 0 ; double minPrevSum = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { sum += nums [ i ] - m ; if ( i >= k ) { prevSum += nums [ i - k ] - m ; minPrevSum = Math . min ( minPrevSum , prevSum ) ; } if ( i + 1 >= k && sum >= minPrevSum ) return true ; } return false ; } }
class Solution { public int [ ] findErrorNums ( int [ ] nums ) { int duplicate = 0 ; for ( final int num : nums ) { if ( nums [ Math . abs ( num ) - 1 ] < 0 ) duplicate = Math . abs ( num ) ; else nums [ Math . abs ( num ) - 1 ] *= - 1 ; } for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] > 0 ) return new int [ ] { duplicate , i + 1 } ; throw new IllegalArgumentException ( ) ; } }
import java . util . Arrays ; class Solution { public int findLongestChain ( int [ ] [ ] pairs ) { int ans = 0 ; int prevEnd = Integer . MIN_VALUE ; Arrays . sort ( pairs , ( a , b ) -> a [ 1 ] - b [ 1 ] ) ; for ( int [ ] pair : pairs ) if ( pair [ 0 ] > prevEnd ) { ++ ans ; prevEnd = pair [ 1 ] ; } return ans ; } }
class Solution { public int countSubstrings ( String s ) { int ans = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { ans += extendPalindromes ( s , i , i ) ; ans += extendPalindromes ( s , i , i + 1 ) ; } return ans ; } private int extendPalindromes ( final String s , int l , int r ) { int count = 0 ; while ( l >= 0 && r < s . length ( ) && s . charAt ( l ) == s . charAt ( r ) ) { ++ count ; -- l ; ++ r ; } return count ; } }
class Solution { public String replaceWords ( List < String > dict , String sentence ) { StringBuilder sb = new StringBuilder ( ) ; for ( final String word : dict ) insert ( word ) ; final String [ ] words = sentence . split ( " ▁ " ) ; for ( final String word : words ) sb . append ( ' ▁ ' ) . append ( search ( word ) ) ; return sb . substring ( 1 ) . toString ( ) ; } private class TrieNode { private TrieNode [ ] children = new TrieNode [ 26 ] ; private String word ; } private TrieNode root = new TrieNode ( ) ; private void insert ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ( ) ) { final int i = c - ' a ' ; if ( node . children [ i ] == null ) node . children [ i ] = new TrieNode ( ) ; node = node . children [ i ] ; } node . word = word ; } private String search ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ( ) ) { if ( node . word != null ) return node . word ; final int i = c - ' a ' ; if ( node . children [ i ] == null ) return word ; node = node . children [ i ] ; } return word ; } }
class Solution { public boolean isNumber ( String s ) { s = s . trim ( ) ; if ( s . isEmpty ( ) ) return false ; boolean seenNum = false ; boolean seenDot = false ; boolean seenE = false ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { switch ( s . charAt ( i ) ) { case ' . ' : if ( seenDot || seenE ) return false ; seenDot = true ; break ; case ' e ' : case ' E ' : if ( seenE || ! seenNum ) return false ; seenE = true ; seenNum = false ; break ; case ' + ' : case ' - ' : if ( i > 0 && s . charAt ( i - 1 ) != ' e ' ) return false ; seenNum = false ; break ; default : if ( ! Character . isDigit ( s . charAt ( i ) ) ) return false ; seenNum = true ; } } return seenNum ; } }
class Solution { public int minSteps ( int n ) { int [ ] dp = new int [ n + 1 ] ; for ( int i = 2 ; i <= n ; ++ i ) { dp [ i ] = i ; for ( int j = i / 2 ; j > 2 ; -- j ) if ( i % j == 0 ) { dp [ i ] = dp [ j ] + i / j ; break ; } } return dp [ n ] ; } }
class Solution { public List < TreeNode > findDuplicateSubtrees ( TreeNode root ) { List < TreeNode > ans = new ArrayList < > ( ) ; Map < String , Integer > count = new HashMap < > ( ) ; encode ( root , count , ans ) ; return ans ; } private String encode ( TreeNode root , Map < String , Integer > count , List < TreeNode > ans ) { if ( root == null ) return " " ; final String encoded = root . val + " # " + encode ( root . left , count , ans ) + " # " + encode ( root . right , count , ans ) ; count . merge ( encoded , 1 , Integer :: sum ) ; if ( count . get ( encoded ) == 2 ) ans . add ( root ) ; return encoded ; } }
class BSTIterator { public BSTIterator ( TreeNode root , boolean leftToRight ) { this . leftToRight = leftToRight ; pushLeftsUntilNull ( root ) ; } public int next ( ) { TreeNode root = stack . pop ( ) ; pushLeftsUntilNull ( leftToRight ? root . right : root . left ) ; return root . val ; } public boolean hasNext ( ) { return ! stack . isEmpty ( ) ; } private Deque < TreeNode > stack = new ArrayDeque < > ( ) ; private boolean leftToRight ; private void pushLeftsUntilNull ( TreeNode root ) { while ( root != null ) { stack . push ( root ) ; root = leftToRight ? root . left : root . right ; } } } class Solution { public boolean findTarget ( TreeNode root , int k ) { if ( root == null ) return false ; BSTIterator left = new BSTIterator ( root , true ) ; BSTIterator right = new BSTIterator ( root , false ) ; for ( int l = left . next ( ) , r = right . next ( ) ; l < r ; ) { final int sum = l + r ; if ( sum == k ) return true ; if ( sum < k ) l = left . next ( ) ; else r = right . next ( ) ; } return false ; } }
class Solution { public TreeNode constructMaximumBinaryTree ( int [ ] nums ) { return build ( nums , 0 , nums . length - 1 ) ; } private TreeNode build ( int [ ] nums , int i , int j ) { if ( i > j ) return null ; int maxIndex = i ; for ( int k = i + 1 ; k <= j ; ++ k ) if ( nums [ k ] > nums [ maxIndex ] ) maxIndex = k ; TreeNode root = new TreeNode ( nums [ maxIndex ] ) ; root . left = build ( nums , i , maxIndex - 1 ) ; root . right = build ( nums , maxIndex + 1 , j ) ; return root ; } }
class Solution { public List < List < String > > printTree ( TreeNode root ) { final int m = maxHeight ( root ) ; final int n = ( int ) Math . pow ( 2 , m ) - 1 ; List < List < String > > ans = new ArrayList < > ( ) ; List < String > row = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) row . add ( " " ) ; for ( int i = 0 ; i < m ; ++ i ) ans . add ( new ArrayList < > ( row ) ) ; dfs ( root , 0 , 0 , n - 1 , ans ) ; return ans ; } private int maxHeight ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + Math . max ( maxHeight ( root . left ) , maxHeight ( root . right ) ) ; } private void dfs ( TreeNode root , int row , int left , int right , List < List < String > > ans ) { if ( root == null ) return ; final int mid = ( left + right ) / 2 ; ans . get ( row ) . set ( mid , Integer . toString ( root . val ) ) ; dfs ( root . left , row + 1 , left , mid - 1 , ans ) ; dfs ( root . right , row + 1 , mid + 1 , right , ans ) ; } }
class Solution { public List < Integer > cheapestJump ( int [ ] coins , int maxJump ) { if ( coins [ coins . length - 1 ] == - 1 ) return new ArrayList < > ( ) ; final int n = coins . length ; int [ ] next = new int [ n ] ; Arrays . fill ( next , - 1 ) ; dp = new int [ n ] ; Arrays . fill ( dp , Integer . MAX_VALUE ) ; cheapestJump ( coins , maxJump , 0 , next ) ; if ( dp [ 0 ] == Integer . MAX_VALUE ) return new ArrayList < > ( ) ; return constructPath ( next , 0 ) ; } private int [ ] dp ; private int cheapestJump ( int [ ] coins , int maxJump , int i , int [ ] next ) { if ( i == coins . length - 1 ) return dp [ i ] = coins [ i ] ; if ( dp [ i ] < Integer . MAX_VALUE ) return dp [ i ] ; if ( coins [ i ] == - 1 ) return Integer . MAX_VALUE ; for ( int j = i + 1 ; j < Math . min ( i + maxJump + 1 , coins . length ) ; ++ j ) { final int res = cheapestJump ( coins , maxJump , j , next ) ; if ( res == Integer . MAX_VALUE ) continue ; final int cost = coins [ i ] + res ; if ( cost < dp [ i ] ) { dp [ i ] = cost ; next [ i ] = j ; } } return dp [ i ] ; } private List < Integer > constructPath ( int [ ] next , int i ) { List < Integer > ans = new ArrayList < > ( ) ; while ( i != - 1 ) { ans . add ( i + 1 ) ; i = next [ i ] ; } return ans ; } }
class Solution { public boolean judgeCircle ( String moves ) { int right = 0 ; int up = 0 ; for ( final char move : moves . toCharArray ( ) ) { switch ( move ) { case ' R ' : ++ right ; break ; case ' L ' : -- right ; break ; case ' U ' : ++ up ; break ; case ' D ' : -- up ; break ; } } return right == 0 && up == 0 ; } }
class Solution { public List < Integer > findClosestElements ( int [ ] arr , int k , int x ) { int l = 0 ; int r = arr . length - k ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( x - arr [ m ] <= arr [ m + k ] - x ) r = m ; else l = m + 1 ; } return Arrays . stream ( arr , l , l + k ) . boxed ( ) . collect ( Collectors . toList ( ) ) ; } }
class Solution { public int [ ] plusOne ( int [ ] digits ) { for ( int i = digits . length - 1 ; i >= 0 ; i -- ) { if ( digits [ i ] < 9 ) { ++ digits [ i ] ; return digits ; } digits [ i ] = 0 ; } int [ ] ans = new int [ digits . length + 1 ] ; ans [ 0 ] = 1 ; return ans ; } }
class Solution { public int newInteger ( int n ) { return Integer . parseInt ( Integer . toString ( n , 9 ) ) ; } }
class Solution { public int [ ] [ ] imageSmoother ( int [ ] [ ] M ) { final int m = M . length ; final int n = M [ 0 ] . length ; int ans [ ] [ ] = new int [ m ] [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; int count = 0 ; for ( int y = Math . max ( 0 , i - 1 ) ; y < Math . min ( m , i + 2 ) ; ++ y ) for ( int x = Math . max ( 0 , j - 1 ) ; x < Math . min ( n , j + 2 ) ; ++ x ) { ones += M [ y ] [ x ] ; ++ count ; } ans [ i ] [ j ] = ones / count ; } return ans ; } }
class Solution { public boolean checkEqualTree ( TreeNode root ) { if ( root == null ) return false ; Set < Integer > seen = new HashSet < > ( ) ; final int sum = root . val + dfs ( root . left , seen ) + dfs ( root . right , seen ) ; return sum % 2 == 0 && seen . contains ( sum / 2 ) ; } private int dfs ( TreeNode root , Set < Integer > seen ) { if ( root == null ) return 0 ; final int sum = root . val + dfs ( root . left , seen ) + dfs ( root . right , seen ) ; seen . add ( sum ) ; return sum ; } }
class Solution { public boolean checkPossibility ( int [ ] nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) if ( nums [ i ] > nums [ i + 1 ] ) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . length - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ] ; } }
class Solution { public int pathSum ( int [ ] nums ) { int [ ] [ ] tree = new int [ 4 ] [ 8 ] ; Arrays . stream ( tree ) . forEach ( A -> Arrays . fill ( A , - 1 ) ) ; for ( final int num : nums ) { final int d = num / 100 - 1 ; final int p = ( num % 100 ) / 10 - 1 ; final int v = num % 10 ; tree [ d ] [ p ] = v ; } dfs ( tree , 0 , 0 , 0 ) ; return ans ; } private int ans = 0 ; private void dfs ( int [ ] [ ] tree , int i , int j , int path ) { if ( tree [ i ] [ j ] == - 1 ) return ; if ( i == 3 || Math . max ( tree [ i + 1 ] [ j * 2 ] , tree [ i + 1 ] [ j * 2 + 1 ] ) == - 1 ) { ans += path + tree [ i ] [ j ] ; return ; } dfs ( tree , i + 1 , j * 2 , path + tree [ i ] [ j ] ) ; dfs ( tree , i + 1 , j * 2 + 1 , path + tree [ i ] [ j ] ) ; } }
class Solution { public int [ ] constructArray ( int n , int k ) { int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n - k ; ++ i ) ans [ i ] = i + 1 ; for ( int i = 0 ; i < k ; ++ i ) { if ( i % 2 == 0 ) ans [ n - k + i ] = n - i / 2 ; else ans [ n - k + i ] = n - k + ( i + 1 ) / 2 ; } return ans ; } }
class Solution { public String addBinary ( String a , String b ) { StringBuilder sb = new StringBuilder ( ) ; int carry = 0 ; int i = a . length ( ) - 1 ; int j = b . length ( ) - 1 ; while ( i >= 0 || j >= 0 || carry == 1 ) { if ( i >= 0 ) carry += a . charAt ( i -- ) - '0' ; if ( j >= 0 ) carry += b . charAt ( j -- ) - '0' ; sb . append ( carry % 2 ) ; carry /= 2 ; } return sb . reverse ( ) . toString ( ) ; } }
class Solution { public int maximumSwap ( int num ) { char [ ] s = Integer . toString ( num ) . toCharArray ( ) ; int [ ] lastIndex = new int [ 10 ] ; for ( int i = 0 ; i < s . length ; ++ i ) lastIndex [ s [ i ] - '0' ] = i ; for ( int i = 0 ; i < s . length ; ++ i ) for ( int d = 9 ; d > s [ i ] - '0' ; -- d ) if ( lastIndex [ d ] > i ) { s [ lastIndex [ d ] ] = s [ i ] ; s [ i ] = ( char ) ( '0' + d ) ; return Integer . parseInt ( new String ( s ) ) ; } return num ; } }
class Solution { public int flipLights ( int n , int m ) { n = Math . min ( n , 3 ) ; if ( m == 0 ) return 1 ; if ( m == 1 ) return new int [ ] { 2 , 3 , 4 } [ n - 1 ] ; if ( m == 2 ) return new int [ ] { 2 , 4 , 7 } [ n - 1 ] ; return ( int ) Math . pow ( 2 , n ) ; } }
class Solution { public int findNumberOfLIS ( int [ ] nums ) { final int n = nums . length ; int ans = 0 ; int maxLength = 0 ; int [ ] length = new int [ n ] ; int [ ] count = new int [ n ] ; Arrays . fill ( length , 1 ) ; Arrays . fill ( count , 1 ) ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( nums [ j ] < nums [ i ] ) if ( length [ i ] < length [ j ] + 1 ) { length [ i ] = length [ j ] + 1 ; count [ i ] = count [ j ] ; } else if ( length [ i ] == length [ j ] + 1 ) { count [ i ] += count [ j ] ; } for ( int i = 0 ; i < n ; ++ i ) if ( length [ i ] > maxLength ) { maxLength = length [ i ] ; ans = count [ i ] ; } else if ( length [ i ] == maxLength ) { ans += count [ i ] ; } return ans ; } }
class Solution { public int findLengthOfLCIS ( int [ ] nums ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r < nums . length ; ++ r ) { if ( r > 0 && nums [ r ] <= nums [ r - 1 ] ) l = r ; ans = Math . max ( ans , r - l + 1 ) ; } return ans ; } }
class MagicDictionary { public void buildDict ( String [ ] dictionary ) { for ( final String word : dictionary ) for ( int i = 0 ; i < word . length ( ) ; ++ i ) { final String replaced = getReplaced ( word , i ) ; dict . put ( replaced , dict . containsKey ( replaced ) ? ' * ' : word . charAt ( i ) ) ; } } public boolean search ( String searchWord ) { for ( int i = 0 ; i < searchWord . length ( ) ; ++ i ) { final String replaced = getReplaced ( searchWord , i ) ; if ( dict . getOrDefault ( replaced , searchWord . charAt ( i ) ) != searchWord . charAt ( i ) ) return true ; } return false ; } private Map < String , Character > dict = new HashMap < > ( ) ; private String getReplaced ( final String s , int i ) { return s . substring ( 0 , i ) + ' * ' + s . substring ( i + 1 ) ; } }
class TrieNode { public TrieNode [ ] children = new TrieNode [ 26 ] ; public int sum = 0 ; } class MapSum { public void insert ( String key , int val ) { final int diff = val - keyToVal . getOrDefault ( key , 0 ) ; TrieNode node = root ; for ( final char c : key . toCharArray ( ) ) { final int i = c - ' a ' ; if ( node . children [ i ] == null ) node . children [ i ] = new TrieNode ( ) ; node = node . children [ i ] ; node . sum += diff ; } keyToVal . put ( key , val ) ; } public int sum ( String prefix ) { TrieNode node = root ; for ( final char c : prefix . toCharArray ( ) ) { final int i = c - ' a ' ; if ( node . children [ i ] == null ) return 0 ; node = node . children [ i ] ; } return node . sum ; } private TrieNode root = new TrieNode ( ) ; private Map < String , Integer > keyToVal = new HashMap < > ( ) ; }
class Solution { public boolean checkValidString ( final String s ) { int low = 0 ; int high = 0 ; for ( final char c : s . toCharArray ( ) ) { switch ( c ) { case ' ( ' : ++ low ; ++ high ; break ; case ' ) ' : low = Math . max ( 0 , -- low ) ; -- high ; break ; case ' * ' : low = Math . max ( 0 , -- low ) ; ++ high ; break ; } if ( high < 0 ) return false ; } return low == 0 ; } }
class Solution { public boolean judgePoint24 ( int [ ] nums ) { List < Double > doubleNums = new ArrayList < > ( ) ; for ( final int num : nums ) doubleNums . add ( ( double ) num ) ; return dfs ( doubleNums ) ; } private boolean dfs ( List < Double > nums ) { if ( nums . size ( ) == 1 ) return Math . abs ( nums . get ( 0 ) - 24.0 ) < 0.001 ; for ( int i = 0 ; i < nums . size ( ) ; ++ i ) for ( int j = i + 1 ; j < nums . size ( ) ; ++ j ) for ( final double num : generate ( nums . get ( i ) , nums . get ( j ) ) ) { List < Double > nextRound = new ArrayList < > ( Arrays . asList ( num ) ) ; for ( int k = 0 ; k < nums . size ( ) ; ++ k ) { if ( k == i || k == j ) continue ; nextRound . add ( nums . get ( k ) ) ; } if ( dfs ( nextRound ) ) return true ; } return false ; } private double [ ] generate ( double a , double b ) { return new double [ ] { a * b , a / b , b / a , a + b , a - b , b - a } ; } }
class Solution { public List < String > fullJustify ( String [ ] words , int maxWidth ) { List < String > ans = new ArrayList < > ( ) ; List < StringBuilder > row = new ArrayList < > ( ) ; int rowLetters = 0 ; for ( final String word : words ) { if ( rowLetters + row . size ( ) + word . length ( ) > maxWidth ) { final int spaces = maxWidth - rowLetters ; if ( row . size ( ) == 1 ) { for ( int i = 0 ; i < spaces ; ++ i ) row . get ( 0 ) . append ( " ▁ " ) ; } else { for ( int i = 0 ; i < spaces ; ++ i ) row . get ( i % ( row . size ( ) - 1 ) ) . append ( " ▁ " ) ; } final String joinedRow = row . stream ( ) . map ( StringBuilder :: toString ) . collect ( Collectors . joining ( " " ) ) ; ans . add ( joinedRow ) ; row . clear ( ) ; rowLetters = 0 ; } row . add ( new StringBuilder ( word ) ) ; rowLetters += word . length ( ) ; } final String lastRow = row . stream ( ) . map ( StringBuilder :: toString ) . collect ( Collectors . joining ( " ▁ " ) ) ; StringBuilder sb = new StringBuilder ( lastRow ) ; final int spacesToBeAdded = maxWidth - sb . length ( ) ; for ( int i = 0 ; i < spacesToBeAdded ; ++ i ) sb . append ( " ▁ " ) ; ans . add ( sb . toString ( ) ) ; return ans ; } }
class Solution { public boolean validPalindrome ( String s ) { for ( int l = 0 , r = s . length ( ) - 1 ; l < r ; ++ l , -- r ) if ( s . charAt ( l ) != s . charAt ( r ) ) return validPalindrome ( s , l + 1 , r ) || validPalindrome ( s , l , r - 1 ) ; return true ; } private boolean validPalindrome ( final String s , int l , int r ) { while ( l < r ) if ( s . charAt ( l ++ ) != s . charAt ( r -- ) ) return false ; return true ; } }
class Solution { public String nextClosestTime ( String time ) { char [ ] ans = time . toCharArray ( ) ; Character [ ] digits = { ans [ 0 ] , ans [ 1 ] , ans [ 3 ] , ans [ 4 ] } ; TreeSet < Character > digitsSet = new TreeSet < Character > ( Arrays . asList ( digits ) ) ; ans [ 4 ] = nextClosest ( digitsSet , ans [ 4 ] , '9' ) ; if ( time . charAt ( 4 ) < ans [ 4 ] ) return new String ( ans ) ; ans [ 3 ] = nextClosest ( digitsSet , ans [ 3 ] , '5' ) ; if ( time . charAt ( 3 ) < ans [ 3 ] ) return new String ( ans ) ; ans [ 1 ] = nextClosest ( digitsSet , ans [ 1 ] , ans [ 0 ] == '2' ? '3' : '9' ) ; if ( time . charAt ( 1 ) < ans [ 1 ] ) return new String ( ans ) ; ans [ 0 ] = nextClosest ( digitsSet , ans [ 0 ] , '2' ) ; return new String ( ans ) ; } private char nextClosest ( TreeSet < Character > digitsSet , char digit , char limit ) { Character next = digitsSet . higher ( digit ) ; return next == null || next > limit ? digitsSet . first ( ) : next ; } }
class Solution { public int kEmptySlots ( int [ ] bulbs , int k ) { final int n = bulbs . length ; int ans = Integer . MAX_VALUE ; int [ ] day = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) day [ bulbs [ i ] - 1 ] = i + 1 ; int l = 0 ; int r = l + k + 1 ; for ( int i = 1 ; r < n ; ++ i ) if ( i == r ) { ans = Math . min ( ans , Math . max ( day [ l ] , day [ r ] ) ) ; l = i ; r = i + k + 1 ; } else if ( day [ i ] < Math . max ( day [ l ] , day [ r ] ) ) { l = i ; r = i + k + 1 ; } return ans == Integer . MAX_VALUE ? - 1 : ans ; } }
class UnionFind { public UnionFind ( int n ) { id = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) id [ i ] = i ; } public boolean union ( int u , int v ) { final int i = find ( u ) ; final int j = find ( v ) ; if ( i == j ) return false ; id [ i ] = j ; return true ; } private int [ ] id ; private int find ( int u ) { return id [ u ] == u ? u : ( id [ u ] = find ( id [ u ] ) ) ; } } class Solution { public int [ ] findRedundantConnection ( int [ ] [ ] edges ) { UnionFind uf = new UnionFind ( edges . length + 1 ) ; for ( int [ ] e : edges ) if ( ! uf . union ( e [ 0 ] , e [ 1 ] ) ) return edge ; throw new IllegalArgumentException ( ) ; } }
class UnionFind { public UnionFind ( int n ) { id = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) id [ i ] = i ; } public boolean union ( int u , int v ) { final int i = find ( u ) ; final int j = find ( v ) ; if ( i == j ) return false ; id [ i ] = j ; return true ; } private int [ ] id ; private int find ( int u ) { return id [ u ] == u ? u : ( id [ u ] = find ( id [ u ] ) ) ; } } class Solution { public int [ ] findRedundantDirectedConnection ( int [ ] [ ] edges ) { int [ ] ids = new int [ edges . length + 1 ] ; int nodeWithTwoParents = 0 ; for ( int [ ] e : edges ) { final int v = e [ 1 ] ; if ( ++ ids [ v ] == 2 ) { nodeWithTwoParents = v ; break ; } } if ( nodeWithTwoParents == 0 ) return findRedundantDirectedConnection ( edges , - 1 ) ; for ( int i = edges . length - 1 ; i >= 0 ; -- i ) if ( edges [ i ] [ 1 ] == nodeWithTwoParents ) if ( findRedundantDirectedConnection ( edges , i ) . length == 0 ) return edges [ i ] ; throw new IllegalArgumentException ( ) ; } private int [ ] findRedundantDirectedConnection ( int [ ] [ ] edges , int skippedEdgeIndex ) { UnionFind uf = new UnionFind ( edges . length + 1 ) ; for ( int i = 0 ; i < edges . length ; ++ i ) { if ( i == skippedEdgeIndex ) continue ; if ( ! uf . union ( edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ) return edges [ i ] ; } return new int [ ] { } ; } }
class Solution { public int repeatedStringMatch ( String A , String B ) { final int n = ( int ) Math . ceil ( ( double ) B . length ( ) / ( double ) A . length ( ) ) ; final String s = String . join ( " " , Collections . nCopies ( n , A ) ) ; if ( s . contains ( B ) ) return n ; if ( ( s + A ) . contains ( B ) ) return n + 1 ; return - 1 ; } }
class Solution { public int longestUnivaluePath ( TreeNode root ) { longestUnivaluePathDownFrom ( root ) ; return ans ; } private int ans = 0 ; private int longestUnivaluePathDownFrom ( TreeNode root ) { if ( root == null ) return 0 ; final int l = longestUnivaluePathDownFrom ( root . left ) ; final int r = longestUnivaluePathDownFrom ( root . right ) ; final int arrowLeft = root . left != null && root . left . val == root . val ? l + 1 : 0 ; final int arrowRight = root . right != null && root . right . val == root . val ? r + 1 : 0 ; ans = Math . max ( ans , arrowLeft + arrowRight ) ; return Math . max ( arrowLeft , arrowRight ) ; } }
class Solution { public double knightProbability ( int N , int K , int r , int c ) { final double kProb = 0.125 ; final int [ ] [ ] dirs = { { - 2 , 1 } , { - 1 , 2 } , { 1 , 2 } , { 2 , 1 } , { 2 , - 1 } , { 1 , - 2 } , { - 1 , - 2 } , { - 2 , - 1 } } ; double [ ] [ ] dp = new double [ N ] [ N ] ; dp [ r ] [ c ] = 1.0 ; for ( int k = 0 ; k < K ; ++ k ) { double [ ] [ ] newDp = new double [ N ] [ N ] ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) if ( dp [ i ] [ j ] > 0.0 ) { for ( int [ ] dir : dirs ) { final int x = i + dir [ 0 ] ; final int y = j + dir [ 1 ] ; if ( x < 0 || x >= N || y < 0 || y >= N ) continue ; newDp [ x ] [ y ] += dp [ i ] [ j ] * kProb ; } } dp = newDp ; } double ans = 0.0 ; for ( double [ ] row : dp ) ans += Arrays . stream ( row ) . sum ( ) ; return ans ; } }
class Solution { public int [ ] maxSumOfThreeSubarrays ( int [ ] nums , int k ) { final int n = nums . length - k + 1 ; int [ ] sums = new int [ n ] ; int [ ] l = new int [ n ] ; int [ ] r = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { sum += nums [ i ] ; if ( i >= k ) sum -= nums [ i - k ] ; if ( i >= k - 1 ) sums [ i - k + 1 ] = sum ; } int maxIndex = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( sums [ i ] > sums [ maxIndex ] ) maxIndex = i ; l [ i ] = maxIndex ; } maxIndex = n - 1 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( sums [ i ] >= sums [ maxIndex ] ) maxIndex = i ; r [ i ] = maxIndex ; } int [ ] ans = { - 1 , - 1 , - 1 } ; for ( int i = k ; i + k < n ; ++ i ) if ( ans [ 0 ] == - 1 || sums [ ans [ 0 ] ] + sums [ ans [ 1 ] ] + sums [ ans [ 2 ] ] < sums [ l [ i - k ] ] + sums [ i ] + sums [ r [ i + k ] ] ) { ans [ 0 ] = l [ i - k ] ; ans [ 1 ] = i ; ans [ 2 ] = r [ i + k ] ; } return ans ; } }
class Solution { public int mySqrt ( long x ) { long l = 1 ; long r = x + 1 ; while ( l < r ) { final long m = ( l + r ) / 2 ; if ( m > x / m ) r = m ; else l = m + 1 ; } return ( int ) l - 1 ; } }
class Solution { public int getImportance ( List < Employee > employees , int id ) { Map < Integer , Employee > idToEmployee = new HashMap < > ( ) ; for ( Employee employee : employees ) idToEmployee . put ( employee . id , employee ) ; return dfs ( id , idToEmployee ) ; } private int dfs ( int id , Map < Integer , Employee > idToEmployee ) { int values = 0 ; for ( final int subId : idToEmployee . get ( id ) . subordinates ) values += dfs ( subId , idToEmployee ) ; return idToEmployee . get ( id ) . importance + values ; } }
class Solution { public int minStickers ( String [ ] stickers , String target ) { final int n = target . length ( ) ; final int maxMask = 1 << n ; int [ ] dp = new int [ maxMask ] ; Arrays . fill ( dp , Integer . MAX_VALUE ) ; dp [ 0 ] = 0 ; for ( int mask = 0 ; mask < maxMask ; ++ mask ) { if ( dp [ mask ] == Integer . MAX_VALUE ) continue ; for ( final String sticker : stickers ) { int superMask = mask ; for ( final char c : sticker . toCharArray ( ) ) for ( int i = 0 ; i < n ; ++ i ) if ( c == target . charAt ( i ) && ( superMask >> i & 1 ) == 0 ) { superMask |= 1 << i ; break ; } dp [ superMask ] = Math . min ( dp [ superMask ] , dp [ mask ] + 1 ) ; } } return dp [ maxMask - 1 ] == Integer . MAX_VALUE ? - 1 : dp [ maxMask - 1 ] ; } }
class Solution { public List < String > topKFrequent ( String [ ] words , int k ) { final int n = words . length ; List < String > ans = new ArrayList < > ( ) ; List < String > [ ] bucket = new List [ n + 1 ] ; Map < String , Integer > count = new HashMap < > ( ) ; for ( final String word : words ) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ) ; for ( final String word : count . keySet ( ) ) { final int freq = count . get ( word ) ; if ( bucket [ freq ] == null ) bucket [ freq ] = new ArrayList < > ( ) ; bucket [ freq ] . add ( word ) ; } for ( int freq = n ; freq > 0 ; -- freq ) if ( bucket [ freq ] != null ) { Collections . sort ( bucket [ freq ] ) ; for ( final String word : bucket [ freq ] ) { ans . add ( word ) ; if ( ans . size ( ) == k ) return ans ; } } throw new IllegalArgumentException ( ) ; } }
class Solution { public int numDistinctIslands ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; Set < List < Pair < Integer , Integer > > > islands = new HashSet < > ( ) ; boolean [ ] [ ] seen = new boolean [ m ] [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { List < Pair < Integer , Integer > > island = new ArrayList < > ( ) ; dfs ( grid , i , j , i , j , seen , island ) ; if ( ! island . isEmpty ( ) ) islands . add ( island ) ; } return islands . size ( ) ; } private void dfs ( int [ ] [ ] grid , int i , int j , int i0 , int j0 , boolean [ ] [ ] seen , List < Pair < Integer , Integer > > island ) { if ( i < 0 || i == grid . length || j < 0 || j == grid [ 0 ] . length ) return ; if ( grid [ i ] [ j ] == 0 || seen [ i ] [ j ] ) return ; seen [ i ] [ j ] = true ; island . add ( new Pair < > ( i - i0 , j - j0 ) ) ; dfs ( grid , i + 1 , j , i0 , j0 , seen , island ) ; dfs ( grid , i - 1 , j , i0 , j0 , seen , island ) ; dfs ( grid , i , j + 1 , i0 , j0 , seen , island ) ; dfs ( grid , i , j - 1 , i0 , j0 , seen , island ) ; } }
class Solution { public int maxAreaOfIsland ( int [ ] [ ] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) ans = Math . max ( ans , dfs ( grid , i , j ) ) ; return ans ; } private int dfs ( int [ ] [ ] grid , int i , int j ) { if ( i < 0 || i == grid . length || j < 0 || j == grid [ 0 ] . length ) return 0 ; if ( grid [ i ] [ j ] != 1 ) return 0 ; grid [ i ] [ j ] = 2 ; return 1 + dfs ( grid , i + 1 , j ) + dfs ( grid , i - 1 , j ) + dfs ( grid , i , j + 1 ) + dfs ( grid , i , j - 1 ) ; } }
class Solution { public int countBinarySubstrings ( String s ) { int ans = 0 ; int prevEquals = 0 ; int currEquals = 1 ; for ( int i = 0 ; i + 1 < s . length ( ) ; ++ i ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) ++ currEquals ; else { ans += Math . min ( prevEquals , currEquals ) ; prevEquals = currEquals ; currEquals = 1 ; } return ans + Math . min ( prevEquals , currEquals ) ; } }
class Solution { public int findShortestSubArray ( int [ ] nums ) { int ans = 0 ; int degree = 0 ; Map < Integer , Integer > debut = new HashMap < > ( ) ; Map < Integer , Integer > count = new HashMap < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { final int num = nums [ i ] ; debut . putIfAbsent ( num , i ) ; count . put ( num , count . getOrDefault ( num , 0 ) + 1 ) ; if ( count . get ( num ) > degree ) { degree = count . get ( num ) ; ans = i - debut . get ( num ) + 1 ; } else if ( count . get ( num ) == degree ) { ans = Math . min ( ans , i - debut . get ( num ) + 1 ) ; } } return ans ; } }
class Solution { public int reverse ( int x ) { long ans = 0 ; while ( x != 0 ) { ans = ans * 10 + x % 10 ; x /= 10 ; } return ( ans < Integer . MIN_VALUE || ans > Integer . MAX_VALUE ) ? 0 : ( int ) ans ; } }
class Solution { public int climbStairs ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; } }
public class Solution { public TreeNode searchBST ( TreeNode root , int val ) { if ( root == null ) return null ; if ( root . val == val ) return root ; if ( root . val > val ) return searchBST ( root . left , val ) ; return searchBST ( root . right , val ) ; } }
class Solution { public TreeNode insertIntoBST ( TreeNode root , int val ) { if ( root == null ) return new TreeNode ( val ) ; if ( root . val > val ) root . left = insertIntoBST ( root . left , val ) ; else root . right = insertIntoBST ( root . right , val ) ; return root ; } }
class Solution { public int search ( ArrayReader reader , int target ) { int l = 0 ; int r = ( int ) 1e4 ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( reader . get ( m ) < target ) l = m + 1 ; else r = m ; } return reader . get ( l ) == target ? l : - 1 ; } }
class MyHashSet { public MyHashSet ( ) { set = new boolean [ 1000001 ] ; } public void add ( int key ) { set [ key ] = true ; } public void remove ( int key ) { set [ key ] = false ; } public boolean contains ( int key ) { return set [ key ] ; } private boolean [ ] set = new boolean [ 1000001 ] ; }
class MyLinkedList { private class ListNode { int val ; ListNode next ; public ListNode ( int val ) { this . val = val ; this . next = null ; } } public int get ( int index ) { if ( index < 0 || index >= length ) return - 1 ; ListNode curr = dummy . next ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; return curr . val ; } public void addAtHead ( int val ) { ListNode head = dummy . next ; ListNode node = new ListNode ( val ) ; node . next = head ; dummy . next = node ; ++ length ; } public void addAtTail ( int val ) { ListNode curr = dummy ; while ( curr . next != null ) curr = curr . next ; curr . next = new ListNode ( val ) ; ++ length ; } public void addAtIndex ( int index , int val ) { if ( index > length ) return ; ListNode curr = dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; ListNode cache = curr . next ; ListNode node = new ListNode ( val ) ; node . next = cache ; curr . next = node ; ++ length ; } public void deleteAtIndex ( int index ) { if ( index < 0 || index >= length ) return ; ListNode curr = dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; ListNode cache = curr . next ; curr . next = cache . next ; -- length ; } int length = 0 ; ListNode dummy = new ListNode ( 0 ) ; }
class Solution { public String toLowerCase ( String str ) { final int diff = ' A ' - ' a ' ; char [ ] ans = str . toCharArray ( ) ; for ( int i = 0 ; i < ans . length ; ++ i ) if ( ans [ i ] >= ' A ' && ans [ i ] <= ' Z ' ) ans [ i ] -= diff ; return new String ( ans ) ; } }
class Solution { public String simplifyPath ( String path ) { final String [ ] dirs = path . split ( " / " ) ; Stack < String > stack = new Stack < > ( ) ; for ( final String dir : dirs ) { if ( dir . isEmpty ( ) || dir . equals ( " . " ) ) continue ; if ( dir . equals ( " . . " ) ) { if ( ! stack . isEmpty ( ) ) stack . pop ( ) ; } else { stack . push ( dir ) ; } } return " / " + String . join ( " / " , stack ) ; } }
class Solution { public Solution ( int N , int [ ] blacklist ) { validRange = N - blacklist . length ; for ( final int b : blacklist ) map . put ( b , - 1 ) ; int maxAvailable = N - 1 ; for ( final int b : blacklist ) if ( b < validRange ) { while ( map . containsKey ( maxAvailable ) ) -- maxAvailable ; map . put ( b , maxAvailable -- ) ; } } public int pick ( ) { final int num = rand . nextInt ( validRange ) ; return map . getOrDefault ( num , num ) ; } private int validRange ; private Map < Integer , Integer > map = new HashMap < > ( ) ; private Random rand = new Random ( ) ; }
class Solution { public int numDistinctIslands2 ( int [ ] [ ] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; Set < List < Pair < Integer , Integer > > > islands = new HashSet < > ( ) ; boolean [ ] [ ] seen = new boolean [ m ] [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { List < Pair < Integer , Integer > > island = new ArrayList < > ( ) ; dfs ( grid , i , j , seen , island ) ; if ( ! island . isEmpty ( ) ) islands . add ( normalize ( island ) ) ; } return islands . size ( ) ; } private void dfs ( int [ ] [ ] grid , int i , int j , boolean [ ] [ ] seen , List < Pair < Integer , Integer > > island ) { if ( i < 0 || i == grid . length || j < 0 || j == grid [ 0 ] . length ) return ; if ( grid [ i ] [ j ] == 0 || seen [ i ] [ j ] ) return ; seen [ i ] [ j ] = true ; island . add ( new Pair < > ( i , j ) ) ; dfs ( grid , i + 1 , j , seen , island ) ; dfs ( grid , i - 1 , j , seen , island ) ; dfs ( grid , i , j + 1 , seen , island ) ; dfs ( grid , i , j - 1 , seen , island ) ; } private List < Pair < Integer , Integer > > normalize ( List < Pair < Integer , Integer > > island ) { Pair < Integer , Integer > [ ] [ ] points = new Pair [ 8 ] [ island . size ( ) ] ; for ( int k = 0 ; k < island . size ( ) ; ++ k ) { final int i = island . get ( k ) . getKey ( ) ; final int j = island . get ( k ) . getValue ( ) ; points [ 0 ] [ k ] = new Pair < > ( i , j ) ; points [ 1 ] [ k ] = new Pair < > ( i , - j ) ; points [ 2 ] [ k ] = new Pair < > ( - i , j ) ; points [ 3 ] [ k ] = new Pair < > ( - i , - j ) ; points [ 4 ] [ k ] = new Pair < > ( j , i ) ; points [ 5 ] [ k ] = new Pair < > ( j , - i ) ; points [ 6 ] [ k ] = new Pair < > ( - j , i ) ; points [ 7 ] [ k ] = new Pair < > ( - j , - i ) ; } for ( Pair < Integer , Integer > [ ] p : points ) Arrays . sort ( p , ( a , b ) -> a . getKey ( ) == b . getKey ( ) ? a . getValue ( ) - b . getValue ( ) : a . getKey ( ) - b . getKey ( ) ) ; for ( Pair < Integer , Integer > [ ] p : points ) { for ( int i = 1 ; i < island . size ( ) ; ++ i ) p [ i ] = new Pair < > ( p [ i ] . getKey ( ) - p [ 0 ] . getKey ( ) , p [ i ] . getValue ( ) - p [ 0 ] . getValue ( ) ) ; p [ 0 ] = new Pair < > ( 0 , 0 ) ; } Arrays . sort ( points , new Comparator < Pair < Integer , Integer > [ ] > ( ) { @ Override public int compare ( Pair < Integer , Integer > [ ] a , Pair < Integer , Integer > [ ] b ) { for ( int i = 0 ; i < a . length ; ++ i ) { if ( a [ i ] . getKey ( ) != b [ i ] . getKey ( ) ) return a [ i ] . getKey ( ) - b [ i ] . getKey ( ) ; if ( a [ i ] . getValue ( ) != b [ i ] . getValue ( ) ) return a [ i ] . getValue ( ) - b [ i ] . getValue ( ) ; } return 0 ; } } ) ; return Arrays . asList ( points [ 0 ] ) ; } }
class Solution { public int numSubarrayProductLessThanK ( int [ ] nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; for ( int l = 0 , r = 0 ; r < nums . length ; ++ r ) { prod *= nums [ r ] ; while ( prod >= k ) prod /= nums [ l ++ ] ; ans += r - l + 1 ; } return ans ; } }
class Solution { public int maxProfit ( int [ ] prices , int fee ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( final int price : prices ) { sell = Math . max ( sell , hold + price ) ; hold = Math . max ( hold , sell - price - fee ) ; } return sell ; } }
class Solution { public boolean isOneBitCharacter ( int [ ] bits ) { final int n = bits . length ; int i = 0 ; while ( i < n - 1 ) if ( bits [ i ] == 0 ) i += 1 ; else i += 2 ; return i == n - 1 ; } }
class Solution { public int findLength ( int [ ] nums1 , int [ ] nums2 ) { final int m = nums1 . length ; final int n = nums2 . length ; int ans = 0 ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) if ( nums1 [ i ] == nums2 [ j ] ) { dp [ i ] [ j ] = dp [ i + 1 ] [ j + 1 ] + 1 ; ans = Math . max ( ans , dp [ i ] [ j ] ) ; } return ans ; } }
class Solution { public int smallestDistancePair ( int [ ] nums , int k ) { Arrays . sort ( nums ) ; int l = 0 ; int r = nums [ nums . length - 1 ] - nums [ 0 ] ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( pairDistancesNoGreaterThan ( nums , m ) >= k ) r = m ; else l = m + 1 ; } return l ; } private int pairDistancesNoGreaterThan ( int [ ] nums , int m ) { int count = 0 ; int j = 1 ; for ( int i = 0 ; i < nums . length ; ++ i ) { while ( j < nums . length && nums [ j ] <= nums [ i ] + m ) ++ j ; count += j - i - 1 ; } return count ; } }
class Solution { public int minDistance ( String word1 , String word2 ) { final int m = word1 . length ( ) ; final int n = word2 . length ( ) ; int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) dp [ i ] [ 0 ] = i ; for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ] [ j ] = j ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( word1 . charAt ( i - 1 ) == word2 . charAt ( j - 1 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . min ( dp [ i - 1 ] [ j - 1 ] , Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ) + 1 ; return dp [ m ] [ n ] ; } }
class TrieNode { public TrieNode [ ] children = new TrieNode [ 26 ] ; public String word ; } class Solution { public String longestWord ( String [ ] words ) { for ( final String word : words ) insert ( word ) ; return longestWordFrom ( root ) ; } private TrieNode root = new TrieNode ( ) ; private void insert ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ( ) ) { final int i = c - ' a ' ; if ( node . children [ i ] == null ) node . children [ i ] = new TrieNode ( ) ; node = node . children [ i ] ; } node . word = word ; } private String longestWordFrom ( TrieNode node ) { String ans = node . word == null ? " " : node . word ; for ( TrieNode child : node . children ) if ( child != null && child . word != null ) { String childWord = longestWordFrom ( child ) ; if ( childWord . length ( ) > ans . length ( ) ) ans = childWord ; } return ans ; } }
class Solution { public List < String > removeComments ( String [ ] source ) { List < String > ans = new ArrayList < > ( ) ; boolean commenting = false ; StringBuilder modified = new StringBuilder ( ) ; for ( final String line : source ) { for ( int i = 0 ; i < line . length ( ) ; ) { if ( i + 1 == line . length ( ) ) { if ( ! commenting ) modified . append ( line . charAt ( i ) ) ; ++ i ; break ; } String twoChars = line . substring ( i , i + 2 ) ; if ( twoChars . equals ( " /* " ) && ! commenting ) { commenting = true ; i += 2 ; } else if ( twoChars . equals ( " */ " ) && commenting ) { commenting = false ; i += 2 ; } else if ( twoChars . equals ( " // " ) ) { if ( ! commenting ) break ; else i += 2 ; } else { if ( ! commenting ) modified . append ( line . charAt ( i ) ) ; ++ i ; } } if ( modified . length ( ) > 0 && ! commenting ) { ans . add ( modified . toString ( ) ) ; modified . setLength ( 0 ) ; } } return ans ; } }
class Solution { public int pivotIndex ( int [ ] nums ) { final int sum = Arrays . stream ( nums ) . sum ( ) ; int prefix = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( prefix == sum - prefix - nums [ i ] ) return i ; prefix += nums [ i ] ; } return - 1 ; } }
class Solution { public ListNode [ ] splitListToParts ( ListNode root , int k ) { ListNode [ ] ans = new ListNode [ k ] ; final int length = getLength ( root ) ; final int subLength = length / k ; int remainder = length % k ; ListNode prev = null ; ListNode head = root ; for ( int i = 0 ; i < k ; ++ i , -- remainder ) { ans [ i ] = head ; for ( int j = 0 ; j < subLength + ( remainder > 0 ? 1 : 0 ) ; ++ j ) { prev = head ; head = head . next ; } if ( prev != null ) prev . next = null ; } return ans ; } private int getLength ( ListNode root ) { int length = 0 ; for ( ListNode curr = root ; curr != null ; curr = curr . next ) ++ length ; return length ; } }
class Solution { public String countOfAtoms ( String s ) { StringBuilder sb = new StringBuilder ( ) ; Map < String , Integer > count = parse ( s ) ; for ( final String elem : count . keySet ( ) ) sb . append ( elem + ( count . get ( elem ) == 1 ? " " : String . valueOf ( count . get ( elem ) ) ) ) ; return sb . toString ( ) ; } private int i = 0 ; private Map < String , Integer > parse ( String s ) { Map < String , Integer > count = new TreeMap < > ( ) ; while ( i < s . length ( ) ) if ( s . charAt ( i ) == ' ( ' ) { ++ i ; for ( Map . Entry < String , Integer > entry : parse ( s ) . entrySet ( ) ) { final String elem = entry . getKey ( ) ; final int freq = entry . getValue ( ) ; count . put ( elem , count . getOrDefault ( elem , 0 ) + freq ) ; } } else if ( s . charAt ( i ) == ' ) ' ) { ++ i ; final int num = getNum ( s ) ; for ( final String elem : count . keySet ( ) ) { final int freq = count . get ( elem ) ; count . put ( elem , freq * num ) ; } return count ; } else { final String elem = getElem ( s ) ; final int num = getNum ( s ) ; count . put ( elem , count . getOrDefault ( elem , 0 ) + num ) ; } return count ; } private String getElem ( final String s ) { final int elemStart = i ++ ; while ( i < s . length ( ) && Character . isLowerCase ( s . charAt ( i ) ) ) ++ i ; return s . substring ( elemStart , i ) ; } private int getNum ( final String s ) { final int numStart = i ; while ( i < s . length ( ) && Character . isDigit ( s . charAt ( i ) ) ) ++ i ; final String numString = s . substring ( numStart , i ) ; return numString . isEmpty ( ) ? 1 : Integer . parseInt ( numString ) ; } }
class Solution { public List < Integer > selfDividingNumbers ( int left , int right ) { List < Integer > ans = new ArrayList < > ( ) ; for ( int num = left ; num <= right ; ++ num ) if ( dividingNumber ( num ) ) ans . add ( num ) ; return ans ; } private boolean dividingNumber ( int num ) { for ( int n = num ; n > 0 ; n /= 10 ) if ( n % 10 == 0 || num % ( n % 10 ) != 0 ) return false ; return true ; } }
class MyCalendar { public boolean book ( int start , int end ) { for ( int [ ] t : timeline ) if ( Math . max ( t [ 0 ] , start ) < Math . min ( t [ 1 ] , end ) ) return false ; timeline . add ( new int [ ] { start , end } ) ; return true ; } private List < int [ ] > timeline = new ArrayList < > ( ) ; }
class Solution { public void setZeroes ( int [ ] [ ] matrix ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; boolean shouldFillFirstRow = false ; boolean shouldFillFirstCol = false ; for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ 0 ] [ j ] == 0 ) { shouldFillFirstRow = true ; break ; } for ( int i = 0 ; i < m ; ++ i ) if ( matrix [ i ] [ 0 ] == 0 ) { shouldFillFirstCol = true ; break ; } for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ] [ j ] == 0 ) { matrix [ i ] [ 0 ] = 0 ; matrix [ 0 ] [ j ] = 0 ; } for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ] [ 0 ] == 0 || matrix [ 0 ] [ j ] == 0 ) matrix [ i ] [ j ] = 0 ; if ( shouldFillFirstRow ) for ( int j = 0 ; j < n ; ++ j ) matrix [ 0 ] [ j ] = 0 ; if ( shouldFillFirstCol ) for ( int i = 0 ; i < m ; ++ i ) matrix [ i ] [ 0 ] = 0 ; } }
class Solution { public int countPalindromicSubsequences ( String s ) { final int kMod = 1_000_000_007 ; final int n = s . length ( ) ; int [ ] [ ] dp = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ] [ i ] = 1 ; for ( int d = 1 ; d < n ; ++ d ) for ( int i = 0 ; i + d < n ; ++ i ) { final int j = i + d ; if ( s . charAt ( i ) == s . charAt ( j ) ) { int lo = i + 1 ; int hi = j - 1 ; while ( lo <= hi && s . charAt ( lo ) != s . charAt ( i ) ) ++ lo ; while ( lo <= hi && s . charAt ( hi ) != s . charAt ( i ) ) -- hi ; if ( lo > hi ) dp [ i ] [ j ] = dp [ i + 1 ] [ j - 1 ] * 2 + 2 ; else if ( lo == hi ) dp [ i ] [ j ] = dp [ i + 1 ] [ j - 1 ] * 2 + 1 ; else dp [ i ] [ j ] = dp [ i + 1 ] [ j - 1 ] * 2 - dp [ lo + 1 ] [ hi - 1 ] ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } dp [ i ] [ j ] = ( int ) ( ( dp [ i ] [ j ] + kMod ) % kMod ) ; } return dp [ 0 ] [ n - 1 ] ; } }
class MyCalendarThree { public int book ( int start , int end ) { timeline . merge ( start , 1 , Integer :: sum ) ; timeline . merge ( end , - 1 , Integer :: sum ) ; int ans = 0 ; int activeEvents = 0 ; for ( final int count : timeline . values ( ) ) { activeEvents += count ; ans = Math . max ( ans , activeEvents ) ; } return ans ; } private Map < Integer , Integer > timeline = new TreeMap < > ( ) ; }
class Solution { public int [ ] [ ] floodFill ( int [ ] [ ] image , int sr , int sc , int newColor ) { boolean [ ] [ ] seen = new boolean [ image . length ] [ image [ 0 ] . length ] ; dfs ( image , sr , sc , seen , image [ sr ] [ sc ] , newColor ) ; return image ; } private void dfs ( int [ ] [ ] image , int i , int j , boolean [ ] [ ] seen , int startColor , int newColor ) { if ( i < 0 || i == image . length || j < 0 || j == image [ 0 ] . length ) return ; if ( image [ i ] [ j ] != startColor || seen [ i ] [ j ] ) return ; image [ i ] [ j ] = newColor ; seen [ i ] [ j ] = true ; dfs ( image , i + 1 , j , seen , startColor , newColor ) ; dfs ( image , i - 1 , j , seen , startColor , newColor ) ; dfs ( image , i , j + 1 , seen , startColor , newColor ) ; dfs ( image , i , j - 1 , seen , startColor , newColor ) ; } }
class Solution { public boolean areSentencesSimilar ( String [ ] sentence1 , String [ ] sentence2 , List < List < String > > similarPairs ) { if ( sentence1 . length != sentence2 . length ) return false ; Map < String , Set < String > > map = new HashMap < > ( ) ; for ( List < String > pair : similarPairs ) { map . putIfAbsent ( pair . get ( 0 ) , new HashSet < > ( ) ) ; map . putIfAbsent ( pair . get ( 1 ) , new HashSet < > ( ) ) ; map . get ( pair . get ( 1 ) ) . add ( pair . get ( 0 ) ) ; map . get ( pair . get ( 0 ) ) . add ( pair . get ( 1 ) ) ; } for ( int i = 0 ; i < sentence1 . length ; ++ i ) { if ( sentence1 [ i ] . equals ( sentence2 [ i ] ) ) continue ; if ( ! map . containsKey ( sentence1 [ i ] ) ) return false ; if ( ! map . get ( sentence1 [ i ] ) . contains ( sentence2 [ i ] ) ) return false ; } return true ; } }
class Solution { public int [ ] asteroidCollision ( int [ ] asteroids ) { Stack < Integer > stack = new Stack < > ( ) ; for ( final int a : asteroids ) if ( a > 0 ) { stack . push ( a ) ; } else { while ( ! stack . isEmpty ( ) && stack . peek ( ) > 0 && stack . peek ( ) < - a ) stack . pop ( ) ; if ( stack . isEmpty ( ) || stack . peek ( ) < 0 ) stack . push ( a ) ; else if ( stack . peek ( ) == - a ) stack . pop ( ) ; else ; } return new ArrayList < > ( stack ) . stream ( ) . mapToInt ( i -> i ) . toArray ( ) ; } }
class Solution { public int evaluate ( String expression ) { return evaluate ( expression , new HashMap < > ( ) ) ; } private int evaluate ( final String e , Map < String , Integer > prevScope ) { if ( Character . isDigit ( e . charAt ( 0 ) ) || e . charAt ( 0 ) == ' - ' ) return Integer . parseInt ( e ) ; if ( prevScope . containsKey ( e ) ) return prevScope . get ( e ) ; Map < String , Integer > scope = new HashMap < > ( ) ; scope . putAll ( prevScope ) ; final int spaceIndex = e . indexOf ( ' ▁ ' ) ; final String nextExpression = e . substring ( spaceIndex + 1 , e . length ( ) - 1 ) ; List < String > tokens = split ( nextExpression ) ; if ( e . startsWith ( " ( m " ) ) return evaluate ( tokens . get ( 0 ) , scope ) * evaluate ( tokens . get ( 1 ) , scope ) ; if ( e . startsWith ( " ( a " ) ) return evaluate ( tokens . get ( 0 ) , scope ) + evaluate ( tokens . get ( 1 ) , scope ) ; for ( int i = 0 ; i < tokens . size ( ) - 2 ; i += 2 ) scope . put ( tokens . get ( i ) , evaluate ( tokens . get ( i + 1 ) , scope ) ) ; return evaluate ( tokens . get ( tokens . size ( ) - 1 ) , scope ) ; } private List < String > split ( final String s ) { List < String > tokens = new ArrayList < > ( ) ; StringBuilder sb = new StringBuilder ( ) ; int parenthesis = 0 ; for ( char c : s . toCharArray ( ) ) { if ( c == ' ( ' ) ++ parenthesis ; else if ( c == ' ) ' ) -- parenthesis ; if ( parenthesis == 0 && c == ' ▁ ' ) { tokens . add ( sb . toString ( ) ) ; sb . setLength ( 0 ) ; } else { sb . append ( c ) ; } } if ( sb . length ( ) > 0 ) tokens . add ( sb . toString ( ) ) ; return tokens ; } }
class Solution { public boolean areSentencesSimilarTwo ( String [ ] words1 , String [ ] words2 , List < List < String > > pairs ) { if ( words1 . length != words2 . length ) return false ; Map < String , Set < String > > graph = new HashMap < > ( ) ; for ( List < String > pair : pairs ) { graph . putIfAbsent ( pair . get ( 0 ) , new HashSet < > ( ) ) ; graph . putIfAbsent ( pair . get ( 1 ) , new HashSet < > ( ) ) ; graph . get ( pair . get ( 1 ) ) . add ( pair . get ( 0 ) ) ; graph . get ( pair . get ( 0 ) ) . add ( pair . get ( 1 ) ) ; } for ( int i = 0 ; i < words1 . length ; ++ i ) { if ( words1 [ i ] . equals ( words2 [ i ] ) ) continue ; if ( ! graph . containsKey ( words1 [ i ] ) ) return false ; if ( ! dfs ( graph , words1 [ i ] , words2 [ i ] , new HashSet < > ( ) ) ) return false ; } return true ; } private boolean dfs ( Map < String , Set < String > > graph , final String source , final String target , Set < String > seen ) { if ( graph . get ( source ) . contains ( target ) ) return true ; seen . add ( source ) ; for ( final String child : graph . get ( source ) ) { if ( seen . contains ( child ) ) continue ; if ( dfs ( graph , child , target , seen ) ) return true ; } return false ; } }
class Solution { public int [ ] dailyTemperatures ( int [ ] temperatures ) { int [ ] ans = new int [ temperatures . length ] ; Deque < Integer > stack = new ArrayDeque < > ( ) ; for ( int i = 0 ; i < temperatures . length ; ++ i ) { while ( ! stack . isEmpty ( ) && temperatures [ stack . peek ( ) ] < temperatures [ i ] ) { final int index = stack . pop ( ) ; ans [ index ] = i - index ; } stack . push ( i ) ; } return ans ; } }
class Solution { public boolean searchMatrix ( int [ ] [ ] matrix , int target ) { if ( matrix . length == 0 ) return false ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int l = 0 ; int r = m * n ; while ( l < r ) { final int mid = ( l + r ) / 2 ; final int i = mid / n ; final int j = mid % n ; if ( matrix [ i ] [ j ] == target ) return true ; if ( matrix [ i ] [ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } }
class Solution { public char nextGreatestLetter ( char [ ] letters , char target ) { int l = 0 ; int r = letters . length ; while ( l < r ) { final int m = ( l + r ) / 2 ; if ( letters [ m ] > target ) r = m ; else l = m + 1 ; } return letters [ l % letters . length ] ; } }
class Solution { public int minCostClimbingStairs ( int [ ] cost ) { final int n = cost . length ; for ( int i = 2 ; i < n ; ++ i ) cost [ i ] += Math . min ( cost [ i - 1 ] , cost [ i - 2 ] ) ; return Math . min ( cost [ n - 1 ] , cost [ n - 2 ] ) ; } }
class Solution { public int dominantIndex ( int [ ] nums ) { int ans = 0 ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ] ; ans = i ; } else if ( nums [ i ] > secondMax ) { secondMax = nums [ i ] ; } return max >= 2 * secondMax ? ans : - 1 ; } }
class Solution { public String shortestCompletingWord ( String licensePlate , String [ ] words ) { String ans = " * * * * * * * * * * * * * * * * " ; int [ ] count = new int [ 26 ] ; for ( char c : licensePlate . toCharArray ( ) ) if ( Character . isLetter ( c ) ) ++ count [ Character . toLowerCase ( c ) - ' a ' ] ; for ( final String word : words ) if ( word . length ( ) < ans . length ( ) && isComplete ( count , getCount ( word ) ) ) ans = word ; return ans ; } private boolean isComplete ( int [ ] c1 , int [ ] c2 ) { for ( int i = 0 ; i < 26 ; ++ i ) if ( c1 [ i ] > c2 [ i ] ) return false ; return true ; } private int [ ] getCount ( final String word ) { int [ ] count = new int [ 26 ] ; for ( final char c : word . toCharArray ( ) ) ++ count [ c - ' a ' ] ; return count ; } }
class Solution { public void sortColors ( int [ ] nums ) { int zero = - 1 ; int one = - 1 ; int two = - 1 ; for ( final int num : nums ) if ( num == 0 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; nums [ ++ zero ] = 0 ; } else if ( num == 1 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; } else { nums [ ++ two ] = 2 ; } } }
class Solution { public List < String > ipToCIDR ( String ip , int n ) { List < String > ans = new ArrayList < > ( ) ; long num = getNum ( ip . split ( " \\ . " ) ) ; while ( n > 0 ) { final long lowbit = num & - num ; final long count = lowbit == 0 ? maxLow ( n ) : firstFit ( lowbit , n ) ; ans . add ( getCIDR ( num , getPrefix ( count ) ) ) ; n -= ( int ) count ; num += count ; } return ans ; } private long getNum ( String [ ] x ) { long num = 0 ; for ( int i = 0 ; i < 4 ; ++ i ) num = num * 256 + Long . parseLong ( x [ i ] ) ; return num ; } private int maxLow ( int n ) { for ( int i = 0 ; i < 32 ; ++ i ) if ( 1 << i + 1 > n ) return 1 << i ; throw new IllegalArgumentException ( ) ; } private long firstFit ( long lowbit , long n ) { while ( lowbit > n ) lowbit >>= 1 ; return lowbit ; } private String getCIDR ( long num , long prefix ) { final long d = num & 255 ; num >>= 8 ; final long c = num & 255 ; num >>= 8 ; final long b = num & 255 ; num >>= 8 ; final long a = num & 255 ; return new StringBuilder ( ) . append ( a ) . append ( " . " ) . append ( b ) . append ( " . " ) . append ( c ) . append ( " . " ) . append ( d ) . append ( " / " ) . append ( prefix ) . toString ( ) ; } private int getPrefix ( long count ) { for ( int i = 0 ; i < 32 ; ++ i ) if ( count == 1 << i ) return 32 - i ; throw new IllegalArgumentException ( ) ; } }
class Solution { public String crackSafe ( int n , int k ) { final String allZeros = "0" . repeat ( n ) ; StringBuilder sb = new StringBuilder ( allZeros ) ; dfs ( ( int ) Math . pow ( k , n ) , n , k , new HashSet < > ( Arrays . asList ( allZeros ) ) , sb ) ; return sb . toString ( ) ; } private boolean dfs ( int passwordSize , int n , int k , Set < String > seen , StringBuilder path ) { if ( seen . size ( ) == passwordSize ) return true ; StringBuilder prefix = new StringBuilder ( path . substring ( path . length ( ) - n + 1 ) ) ; for ( char c = '0' ; c < '0' + k ; ++ c ) { prefix . append ( c ) ; final String prefixStr = prefix . toString ( ) ; if ( ! seen . contains ( prefixStr ) ) { seen . add ( prefixStr ) ; path . append ( c ) ; if ( dfs ( passwordSize , n , k , seen , path ) ) return true ; path . deleteCharAt ( path . length ( ) - 1 ) ; seen . remove ( prefixStr ) ; } prefix . deleteCharAt ( prefix . length ( ) - 1 ) ; } return false ; } }
class Solution { public int reachNumber ( int target ) { final int newTarget = Math . abs ( target ) ; int ans = 0 ; int pos = 0 ; while ( pos < newTarget ) pos += ++ ans ; while ( ( pos - newTarget ) % 2 == 1 ) pos += ++ ans ; return ans ; } }
class Solution { public boolean pyramidTransition ( String bottom , List < String > allowed ) { Map < String , List < Character > > prefixToBlocks = new HashMap < > ( ) ; for ( final String a : allowed ) { final String lowerBlocks = a . substring ( 0 , 2 ) ; prefixToBlocks . putIfAbsent ( lowerBlocks , new LinkedList < > ( ) ) ; prefixToBlocks . get ( lowerBlocks ) . add ( a . charAt ( 2 ) ) ; } return dfs ( bottom , " " , 0 , prefixToBlocks ) ; } private boolean dfs ( final String row , final String nextRow , int i , Map < String , List < Character > > prefixToBlocks ) { if ( row . length ( ) == 1 ) return true ; if ( nextRow . length ( ) + 1 == row . length ( ) ) return dfs ( nextRow , " " , 0 , prefixToBlocks ) ; final String prefix = row . substring ( i , i + 2 ) ; if ( prefixToBlocks . containsKey ( prefix ) ) for ( final char c : prefixToBlocks . get ( prefix ) ) if ( dfs ( row , nextRow + c , i + 1 , prefixToBlocks ) ) return true ; return false ; } }
class Solution { public String boldWords ( String [ ] words , String s ) { final int n = s . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; boolean [ ] bold = new boolean [ n ] ; int boldEnd = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { for ( final String word : words ) if ( s . substring ( i ) . startsWith ( word ) ) boldEnd = Math . max ( boldEnd , i + word . length ( ) ) ; bold [ i ] = boldEnd > i ; } int i = 0 ; while ( i < n ) if ( bold [ i ] ) { int j = i ; while ( j < n && bold [ j ] ) ++ j ; sb . append ( " < b > " ) . append ( s . substring ( i , j ) ) . append ( " < / b > " ) ; i = j ; } else { sb . append ( s . charAt ( i ++ ) ) ; } return sb . toString ( ) ; } }
class Solution { public List < Interval > employeeFreeTime ( List < List < Interval > > schedule ) { List < Interval > ans = new ArrayList < > ( ) ; List < Interval > intervals = new ArrayList < > ( ) ; schedule . forEach ( s -> intervals . addAll ( s ) ) ; Collections . sort ( intervals , ( a , b ) -> a . start - b . start ) ; int prevEnd = intervals . get ( 0 ) . end ; for ( Interval interval : intervals ) { if ( interval . start > prevEnd ) ans . add ( new Interval ( prevEnd , interval . start ) ) ; prevEnd = Math . max ( prevEnd , interval . end ) ; } return ans ; } }
class Solution { public String minWindow ( String s , String t ) { int [ ] count = new int [ 128 ] ; int required = t . length ( ) ; int bestLeft = - 1 ; int minLength = s . length ( ) + 1 ; for ( final char c : t . toCharArray ( ) ) ++ count [ c ] ; for ( int l = 0 , r = 0 ; r < s . length ( ) ; ++ r ) { if ( -- count [ s . charAt ( r ) ] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 < minLength ) { bestLeft = l ; minLength = r - l + 1 ; } if ( ++ count [ s . charAt ( l ++ ) ] > 0 ) ++ required ; } } return bestLeft == - 1 ? " " : s . substring ( bestLeft , bestLeft + minLength ) ; } }
class Solution { public String makeLargestSpecial ( String S ) { List < String > specials = new ArrayList < > ( ) ; int count = 0 ; for ( int i = 0 , j = 0 ; j < S . length ( ) ; ++ j ) { count += S . charAt ( j ) == '1' ? 1 : - 1 ; if ( count == 0 ) { specials . add ( "1" + makeLargestSpecial ( S . substring ( i + 1 , j ) ) + "0" ) ; i = j + 1 ; } } Collections . sort ( specials , Collections . reverseOrder ( ) ) ; return String . join ( " " , specials ) ; } }
class Solution { public List < Integer > partitionLabels ( String S ) { List < Integer > ans = new ArrayList < > ( ) ; int [ ] rightmost = new int [ 128 ] ; for ( int i = 0 ; i < S . length ( ) ; ++ i ) rightmost [ S . charAt ( i ) ] = i ; int l = 0 ; int r = 0 ; for ( int i = 0 ; i < S . length ( ) ; ++ i ) { r = Math . max ( r , rightmost [ S . charAt ( i ) ] ) ; if ( r == i ) { ans . add ( i - l + 1 ) ; l = i + 1 ; } } return ans ; } }
class Solution { public boolean isToeplitzMatrix ( int [ ] [ ] matrix ) { for ( int i = 0 ; i + 1 < matrix . length ; ++ i ) for ( int j = 0 ; j + 1 < matrix [ 0 ] . length ; ++ j ) if ( matrix [ i ] [ j ] != matrix [ i + 1 ] [ j + 1 ] ) return false ; return true ; } }
public class Solution { public String reorganizeString ( String s ) { Map < Character , Integer > count = new HashMap < > ( ) ; int maxFreq = 0 ; for ( final char c : s . toCharArray ( ) ) { count . merge ( c , 1 , Integer :: sum ) ; maxFreq = Math . max ( maxFreq , count . get ( c ) ) ; } if ( maxFreq > ( s . length ( ) + 1 ) / 2 ) return " " ; StringBuilder sb = new StringBuilder ( ) ; Queue < Pair < Integer , Character > > maxHeap = new PriorityQueue < > ( ( a , b ) -> b . getKey ( ) - a . getKey ( ) ) ; int prevFreq = 0 ; char prevChar = ' @ ' ; for ( final char c : count . keySet ( ) ) maxHeap . offer ( new Pair < > ( count . get ( c ) , c ) ) ; while ( ! maxHeap . isEmpty ( ) ) { final int freq = maxHeap . peek ( ) . getKey ( ) ; final char c = maxHeap . poll ( ) . getValue ( ) ; sb . append ( c ) ; if ( prevFreq > 0 ) maxHeap . offer ( new Pair < > ( prevFreq , prevChar ) ) ; prevFreq = freq - 1 ; prevChar = c ; } return sb . toString ( ) ; } }
class Solution { public int maxChunksToSorted ( int [ ] arr ) { final int n = arr . length ; int ans = 0 ; int [ ] maxL = new int [ n ] ; int [ ] minR = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) maxL [ i ] = i == 0 ? arr [ i ] : Math . max ( arr [ i ] , maxL [ i - 1 ] ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) minR [ i ] = i == n - 1 ? arr [ i ] : Math . min ( arr [ i ] , minR [ i + 1 ] ) ; for ( int i = 0 ; i + 1 < n ; ++ i ) if ( maxL [ i ] <= minR [ i + 1 ] ) ++ ans ; return ans + 1 ; } }
public static < K , V > Map < K , List < V >> transpose ( List < Map < K , V > > list ) { Map < K , List < V > > result = new HashMap < > ( ) ; for ( Map < K , V > map : list ) { for ( Map . Entry < K , V > entry : map . entrySet ( ) ) { List < V > values = result . get ( entry . getKey ( ) ) ; if ( values == null ) { values = new ArrayList < > ( ) ; result . put ( entry . getKey ( ) , values ) ; } values . add ( entry . getValue ( ) ) ; } } return result ; }
List < String > list = new ArrayList < String > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . add ( " d " ) ; list . add ( " e " ) ; list . add ( " f " ) ; list . add ( " g " ) ; list . add ( " h " ) ; list . add ( " i " ) ; list . add ( " j " ) ; list . add ( " k " ) ; list . add ( " l " ) ; list . add ( " m " ) ; list . add ( " n " ) ; list . add ( " o " ) ; list . add ( " p " ) ; list . add ( " q " ) ; list . add ( " r " ) ; list . add ( " s " ) ; list . add ( " t " ) ; list . add ( " u " ) ; list . add ( " v " ) ; list . add ( " w " ) ; list . add ( " x " ) ; list . add ( " y " ) ; list . add ( " z " ) ; List < String > list2 = new ArrayList < String > ( ) ; list2 . add ( " a " ) ; list2 . add ( " b " ) ; list2 . add ( " c " ) ; list2 . add ( " d " ) ; list2 . add ( " e " ) ; list2 . add ( " f " ) ; list2 . add ( " g " ) ; list2 . add ( " h " ) ; list2 . add ( " i " ) ; list2 . add ( " j " ) ; list2 . add ( " k " ) ; list2 . add ( " l " ) ; list2 . add ( " m " ) ; list2 . add ( " n " ) ; list2 . add ( " o " ) ; list2 . add ( " p " ) ; list2 . add ( " q " ) ; list2 . add ( " r " ) ; list2 . add ( " s " ) ; list2 . add ( " t " ) ; list2 . add ( " u " ) ; list2 . add ( " v " ) ; list2 . add ( " w " ) ; list2 . add ( " x " ) ; list2 . add ( " y " ) ; list2 . add ( " z " ) ; List < Integer > indexes = new ArrayList < Integer > ( ) ; for ( String s : list2 ) { indexes . add ( list . indexOf ( s ) ) ; } System . out . println ( indexes ) ;
List < String > list = Arrays . asList ( " a " , " b " , " c " ) ; String [ ] array = list . toArray ( new String [ list . size ( ) ] ) ;
Query query = new Query ( " Person " ) ; query . addFilter ( " address " , Query . FilterOperator . EQUAL , KeyFactory . createKey ( " Address " , "123" ) ) ; DatastoreService datastore = DatastoreServiceFactory . getDatastoreService ( ) ; PreparedQuery pq = datastore . prepare ( query ) ; for ( Entity result : pq . asIterable ( ) ) { String firstName = ( String ) result . getProperty ( " firstName " ) ; String lastName = ( String ) result . getProperty ( " lastName " ) ; System . out . println ( firstName + " ▁ " + lastName + " ▁ lives ▁ at ▁ " + result . getProperty ( " address " ) ) ; }
public static List < Integer > sum ( List < List < Integer > > lists ) { List < Integer > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < lists . get ( 0 ) . size ( ) ; i ++ ) { int sum = 0 ; for ( List < Integer > list : lists ) { sum += list . get ( i ) ; } result . add ( sum ) ; } return result ; }
public static < T > List < List < T > > unzip ( List < List < T > > list ) { List < List < T > > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < list . get ( 0 ) . size ( ) ; i ++ ) { List < T > subList = new ArrayList < > ( ) ; for ( List < T > sub : list ) { subList . add ( sub . get ( i ) ) ; } result . add ( subList ) ; } return result ; }
public static List < Pair < String , Integer > > map ( String s ) { List < Pair < String , Integer > > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { result . add ( new Pair < > ( s . substring ( i , i + 1 ) , i ) ) ; } return result ; }
String [ ] list = { " a " , " b " , " c " } ; System . out . println ( String . join ( " \t " , list ) ) ;
List < List < Integer > > listOfLists = new ArrayList < > ( ) ; listOfLists . add ( Arrays . asList ( 1 , 2 , 3 ) ) ; listOfLists . add ( Arrays . asList ( 4 , 5 , 6 ) ) ; listOfLists . add ( Arrays . asList ( 7 , 8 , 9 ) ) ; List < Integer > mergedList = listOfLists . stream ( ) . flatMap ( Collection :: stream ) . collect ( Collectors . toList ( ) ) ;
import pandas as pd import matplotlib . pyplot as plt df = pd . read_csv ( ' data . csv ' ) df . plot ( kind = ' bar ' , stacked = True ) plt . show ( )
String str = " This ▁ is ▁ a ▁ [ test ] ▁ string . " ; Pattern p = Pattern . compile ( " \\ [ ( . * ? ) \\ ] " ) ; Matcher m = p . matcher ( str ) ; while ( m . find ( ) ) { System . out . println ( m . group ( 1 ) ) ; }
Map < String , String > map = new HashMap < > ( ) ; map . put ( " key " , " value " ) ;
public static float hexToFloat ( String hex ) { return Float . intBitsToFloat ( Integer . parseInt ( hex , 16 ) ) ; }
List < Tuple2 < String , Integer > > list = new ArrayList < > ( ) ; list . add ( new Tuple2 < > ( " a " , 1 ) ) ; list . add ( new Tuple2 < > ( " b " , 2 ) ) ; list . add ( new Tuple2 < > ( " c " , 3 ) ) ;
String regex = " \\ b ( \\ w + ) ( \\ s + \\ 1 ) + \\ b " ; Pattern p = Pattern . compile ( regex , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( input ) ; while ( m . find ( ) ) { input = input . replaceAll ( m . group ( ) , m . group ( 1 ) ) ; }
File dir = new File ( " / path / to / dir " ) ; File [ ] files = dir . listFiles ( ) ; Random rand = new Random ( ) ; File file = files [ rand . nextInt ( files . length ) ] ;
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . add ( " d " ) ; list . add ( " e " ) ; list . add ( " f " ) ; list . add ( " g " ) ; list . add ( " h " ) ; list . add ( " i " ) ; list . add ( " j " ) ; list . add ( " k " ) ; list . add ( " l " ) ; list . add ( " m " ) ; list . add ( " n " ) ; list . add ( " o " ) ; list . add ( " p " ) ; list . add ( " q " ) ; list . add ( " r " ) ; list . add ( " s " ) ; list . add ( " t " ) ; list . add ( " u " ) ; list . add ( " v " ) ; list . add ( " w " ) ; list . add ( " x " ) ; list . add ( " y " ) ; list . add ( " z " ) ; list . removeIf ( s -> s . equals ( " a " ) ) ;
import java . net . InetAddress ; import java . net . UnknownHostException ; public class Main { public static void main ( String [ ] args ) throws UnknownHostException { InetAddress start = InetAddress . getByName ( "192.168.0.1" ) ; InetAddress end = InetAddress . getByName ( "192.168.0.255" ) ; InetAddress current = start ; while ( ! current . equals ( end ) ) { System . out . println ( current ) ; byte [ ] address = current . getAddress ( ) ; address [ 3 ] ++ ; current = InetAddress . getByAddress ( address ) ; } } }
public static boolean allEqual ( List < Integer > list ) { return list . stream ( ) . distinct ( ) . limit ( 2 ) . count ( ) <= 1 ; }
String value = "00001" ; int intValue = Integer . parseInt ( value ) ; intValue ++ ; String newValue = String . format ( " % 05d " , intValue ) ;
for ( int i = list . size ( ) - 1 ; i >= 0 ; i -- ) { System . out . println ( list . get ( i ) ) ; }
Map < String , List < String > > map = new HashMap < > ( ) ; map . put ( " key1" , Arrays . asList ( " value1" , " value2" ) ) ; map . put ( " key2" , Arrays . asList ( " value3" , " value4" ) ) ;
String fileName = " file . txt " ; String line = null ; try { FileReader fileReader = new FileReader ( fileName ) ; BufferedReader bufferedReader = new BufferedReader ( fileReader ) ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { System . out . println ( line ) ; } bufferedReader . close ( ) ; } catch ( FileNotFoundException ex ) { System . out . println ( " Unable ▁ to ▁ open ▁ file ▁ ' " + fileName + " ' " ) ; } catch ( IOException ex ) { System . out . println ( " Error ▁ reading ▁ file ▁ ' " + fileName + " ' " ) ; }
List < String > list = new ArrayList < > ( ) ; list . add ( "2019-01-01" ) ; list . add ( "2019-01-02" ) ; list . add ( "2019-01-03" ) ; list . add ( "2019-01-04" ) ; list . add ( "2019-01-05" ) ; list . add ( "2019-01-06" ) ; list . add ( "2019-01-07" ) ; list . add ( "2019-01-08" ) ; list . add ( "2019-01-09" ) ; list . add ( "2019-01-10" ) ; list . add ( "2019-01-11" ) ; list . add ( "2019-01-12" ) ; list . add ( "2019-01-13" ) ; list . add ( "2019-01-14" ) ; list . add ( "2019-01-15" ) ; list . add ( "2019-01-16" ) ; list . add ( "2019-01-17" ) ; list . add ( "2019-01-18" ) ; list . add ( "2019-01-19" ) ; list . add ( "2019-01-20" ) ; list . add ( "2019-01-21" ) ; list . add ( "2019-01-22" ) ; list . add ( "2019-01-23" ) ; list . add ( "2019-01-24" ) ; list . add ( "2019-01-25" ) ; list . add ( "2019-01-26" ) ; list . add ( "2019-01-27" ) ; list . add ( "2019-01-28" ) ; list . add ( "2019-01-29" ) ; list . add ( "2019-01-30" ) ; list . add ( "2019-01-31" ) ; Collections . sort ( list , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { try { return new SimpleDateFormat ( " yyyy - MM - dd " ) . parse ( o1 ) . compareTo ( new SimpleDateFormat ( " yyyy - MM - dd " ) . parse ( o2 ) ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return 0 ; } } ) ; for ( String s : list ) { System . out . println ( s ) ; }
public static boolean all ( String s , Predicate < Character > p ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! p . test ( s . charAt ( i ) ) ) { return false ; } } return true ; }
Collections . sort ( list , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { return o1 . split ( " ▁ " ) [ 1 ] . compareTo ( o2 . split ( " ▁ " ) [ 1 ] ) ; } } ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . removeIf ( s -> s . equals ( " b " ) ) ;
public static int sum ( List < Object > list ) { int sum = 0 ; for ( Object obj : list ) { if ( obj instanceof Integer ) { sum += ( Integer ) obj ; } else if ( obj instanceof List ) { sum += sum ( ( List < Object > ) obj ) ; } } return sum ; }
String s = " Hello ▁ World " ; s = s . replaceAll ( " [ aeiou ] " , " _ " ) ; System . out . println ( s ) ;
Spectrogram spectrogram = new Spectrogram ( data , sampleRate ) ; Colorbar colorbar = new Colorbar ( spectrogram ) ; spectrogram . addColorbar ( colorbar ) ;
public class MaxValue { public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int max = arr [ 0 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; } } System . out . println ( max ) ; } }
String str = " Hello ▁ < < name > > , ▁ We ▁ have ▁ your ▁ full ▁ name ▁ as ▁ < < full ▁ name > > ▁ in ▁ our ▁ system . " ; String name = " Alex ▁ Kolenchiskey " ; String fullName = " Alex ▁ Kolenchiskey " ; String str1 = str . replace ( " < < name > > " , name ) ; String str2 = str1 . replace ( " < < full ▁ name > > " , fullName ) ; System . out . println ( str2 ) ;
import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Iterator ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Row ; import org . apache . poi . xssf . usermodel . XSSFSheet ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; public class ReadExcelFile { public static void main ( String [ ] args ) throws IOException { FileInputStream file = new FileInputStream ( new File ( " C : \\ Users \\ Saurabh ▁ Dhingra \\ workspace \\ Read ▁ Excel ▁ File \\ src\ \r eadExcelFile \\ ReadExcelFile . xlsx " ) ) ; XSSFWorkbook workbook = new XSSFWorkbook ( file ) ; XSSFSheet sheet = workbook . getSheetAt ( 0 ) ; Iterator < Row > rowIterator = sheet . iterator ( ) ; while ( rowIterator . hasNext ( ) ) { Row row = rowIterator . next ( ) ; Iterator < Cell > cellIterator = row . cellIterator ( ) ; while ( cellIterator . hasNext ( ) ) { Cell cell = cellIterator . next ( ) ; switch ( cell . getCellType ( ) ) { case Cell . CELL_TYPE_NUMERIC : System . out . print ( cell . getNumericCellValue ( ) + " t " ) ; break ; case Cell . CELL_TYPE_STRING :
for file in ` ls * . java ` do echo " Processing ▁ $ file " sed - i ' s / \t / ▁ ▁ ▁ ▁ / g ' $file done
public static int longestWord ( String [ ] words ) { int maxLength = 0 ; for ( String word : words ) { maxLength = Math . max ( maxLength , word . length ( ) ) ; } return maxLength ; }
import pprint import logging logging . basicConfig ( filename = ' example . log ' , level = logging . DEBUG ) logging . debug ( pprint . pformat ( some_dict ) )
public static void createDirIfNotExists ( String dir ) { File theDir = new File ( dir ) ; if ( ! theDir . exists ( ) ) { System . out . println ( " creating ▁ directory : ▁ " + dir ) ; boolean result = false ; try { theDir . mkdir ( ) ; result = true ; } catch ( SecurityException se ) { } if ( result ) { System . out . println ( " DIR ▁ created " ) ; } } }
List < List < Integer > > list = new ArrayList < > ( ) ; list . add ( Arrays . asList ( 1 , 2 , 3 ) ) ; list . add ( Arrays . asList ( 4 , 5 , 6 ) ) ; list . add ( Arrays . asList ( 7 , 8 , 9 ) ) ; List < Integer > flatList = list . stream ( ) . flatMap ( Collection :: stream ) . collect ( Collectors . toList ( ) ) ;
Map < String , String > map = new HashMap < > ( ) ; map . put ( " key1" , " value1" ) ; map . put ( " key2" , null ) ; map . put ( " key3" , " value3" ) ; map . entrySet ( ) . removeIf ( entry -> entry . getValue ( ) == null ) ;
public static < K , V extends Comparable < ? super V > > K maxKey ( Map < K , V > map ) { Entry < K , V > max = null ; for ( Entry < K , V > entry : map . entrySet ( ) ) { if ( max == null || entry . getValue ( ) . compareTo ( max . getValue ( ) ) > 0 ) { max = entry ; } } return max . getKey ( ) ; }
MongoCursor < Document > cursor = collection . find ( ) . iterator ( ) ; while ( cursor . hasNext ( ) ) { Document doc = cursor . next ( ) ; for ( Map . Entry < String , Object > entry : doc . entrySet ( ) ) { System . out . println ( entry . getKey ( ) + " : ▁ " + entry . getValue ( ) ) ; } }
int index = IntStream . range ( 0 , list . size ( ) ) . filter ( i -> list . get ( i ) ) . findFirst ( ) . orElse ( - 1 ) ;
FileWriter fw = new FileWriter ( " output . txt " ) ; fw . write ( " Hello ▁ World " ) ; fw . close ( ) ;
List < String > list1 = new ArrayList < String > ( ) ; list1 . add ( " a " ) ; list1 . add ( " b " ) ; list1 . add ( " c " ) ; List < String > list2 = new ArrayList < String > ( ) ; list2 . add ( " d " ) ; list2 . add ( " e " ) ; list2 . add ( " f " ) ; list1 . addAll ( list2 ) ;
public static Date epochToDate ( long epoch ) { return new Date ( epoch ) ; }
String str = " Hello ▁ World " ; str = str . replace ( " World " , " Java " ) ;
public static void main ( String [ ] args ) { LocalDate start = LocalDate . of ( 2020 , 1 , 1 ) ; LocalDate end = LocalDate . of ( 2020 , 12 , 31 ) ; List < LocalDate > dates = new ArrayList < > ( ) ; while ( start . isBefore ( end ) ) { LocalDate date = start . with ( TemporalAdjusters . dayOfWeekInMonth ( 2 , DayOfWeek . FRIDAY ) ) ; dates . add ( date ) ; start = start . plusMonths ( 1 ) ; } System . out . println ( dates ) ; }
String cp1251 = " Привет " ; String utf8 = new String ( cp1251 . getBytes ( " CP1251" ) , " UTF - 8" ) ;
String str = " www . google . com " ; String [ ] parts = str . split ( " \\ . " ) ; String lastWord = parts [ parts . length - 1 ] ;
File dir = new File ( " / home / user / Documents " ) ; File [ ] files = dir . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir , String name ) { return name . endsWith ( " . txt " ) ; } } ) ;
import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . net . URL ; public class DownloadFile { public static void main ( String [ ] args ) throws IOException { String url = " http : // www . example . com / example . zip " ; String file = " example . zip " ; downloadUsingStream ( url , file ) ; } private static void downloadUsingStream ( String urlStr , String file ) throws IOException { URL url = new URL ( urlStr ) ; InputStream is = url . openStream ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; byte [ ] buffer = new byte [ 4096 ] ; int bytesRead = 0 ; System . out . print ( " Downloading ▁ " + urlStr + " ▁ . . . ▁ " ) ; while ( ( bytesRead = is . read ( buffer ) ) != - 1 ) { fos . write ( buffer , 0 , bytesRead ) ; } System . out . println ( " done ! " ) ; is . close ( ) ; fos . close ( ) ; } }
String s = " Hello ▁ World " ; s = s . replaceAll ( " \\ s " , " _ " ) ; System . out . println ( s ) ;
Collections . sort ( list , new Comparator < Person > ( ) { @ Override public int compare ( Person o1 , Person o2 ) { return o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; } } ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( "1" ) ; list . add ( "2" ) ; list . add ( "3" ) ; List < Integer > intList = list . stream ( ) . map ( Integer :: parseInt ) . collect ( Collectors . toList ( ) ) ;
Collections . sort ( list , new Comparator < Map . Entry < String , Integer > > ( ) { @ Override public int compare ( Map . Entry < String , Integer > o1 , Map . Entry < String , Integer > o2 ) { return o1 . getValue ( ) . compareTo ( o2 . getValue ( ) ) ; } } ) ;
String str = " Hello ! ▁ This ▁ is ▁ a ▁ test ▁ string . " ; str = str . replaceAll ( " [ ^ a - zA - Z0-9 ] " , " " ) ;
public class User { private String name ; private String email ; private String phone ; private String address ; private String city ; private String state ; private String country ; private String zip ; private String password ; private String role ; private String status ; private String createdAt ; private String updatedAt ; }
public static void main ( String [ ] args ) { Cluster cluster = Cluster . builder ( ) . addContactPoint ( "127.0.0.1" ) . build ( ) ; Session session = cluster . connect ( " mykeyspace " ) ; ResultSet results = session . execute ( " SELECT ▁ * ▁ FROM ▁ mytable " ) ; for ( Row row : results ) { System . out . format ( " % s ▁ % d \n " , row . getString ( " mycolumn " ) , row . getInt ( " mycolumn2" ) ) ; } }
int [ ] [ ] matrix = new int [ list1 . size ( ) ] [ list2 . size ( ) ] ; for ( int i = 0 ; i < list1 . size ( ) ; i ++ ) { for ( int j = 0 ; j < list2 . size ( ) ; j ++ ) { matrix [ i ] [ j ] = list1 . get ( i ) * list2 . get ( j ) ; } }
String str = " Hello ▁ World " ; int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ' l ' ) { count ++ ; } } System . out . println ( count ) ;
String s = " \" Hello \" " ; s = s . replaceAll ( " \" " , " \\ \\ \" " ) ;
public static void main ( String [ ] args ) { LocalDateTime now = LocalDateTime . now ( ) ; LocalDateTime plus = now . plusYears ( 100 ) ; LocalDateTime minus = now . minusYears ( 100 ) ; System . out . println ( now ) ; System . out . println ( plus ) ; System . out . println ( minus ) ; }
String str = " \\ \" " ; str = str . replace ( " \ \" , " " ) ;
public static double [ ] mean ( double [ ] [ ] x ) { double [ ] mean = new double [ x [ 0 ] . length ] ; for ( int i = 0 ; i < x . length ; i ++ ) { for ( int j = 0 ; j < x [ 0 ] . length ; j ++ ) { mean [ j ] += x [ i ] [ j ] ; } } for ( int i = 0 ; i < mean . length ; i ++ ) { mean [ i ] /= x . length ; } return mean ; }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; String input = scanner . nextLine ( ) ; System . out . println ( input ) ; } }
import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class RegexTest { public static void main ( String [ ] args ) { String text = " This ▁ is ▁ a ▁ [ test ] ▁ of ▁ the ▁ [ emergency ] ▁ broadcast ▁ system . " ; Pattern pattern = Pattern . compile ( " \\ [ ( . * ? ) \\ ] " ) ; Matcher matcher = pattern . matcher ( text ) ; while ( matcher . find ( ) ) { System . out . println ( matcher . group ( 1 ) ) ; } } }
public static int lastIndexOf ( String str , char ch ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ch ) { return i ; } } return - 1 ; }
String [ ] list = { " a " , " b " , " c " } ; String result = String . join ( " , " , list ) ;
List < String > list = new ArrayList < > ( ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { list . add ( entry . getValue ( ) ) ; }
try { } catch ( Exception e ) { }
String s = " Hello " ; s . toUpperCase ( ) ;
if ( myVar != null ) { }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . HttpURLConnection ; import java . net . URL ; public class HttpURLConnectionExample { private static final String USER_AGENT = " Mozilla / 5.0" ; private static final String GET_URL = " http : // localhost : 9090 / SpringMVCExample " ; private static final String POST_URL = " http : // localhost : 9090 / SpringMVCExample / home " ; private static final String POST_PARAMS = " userName = Pankaj " ; public static void main ( String [ ] args ) throws IOException { sendGET ( ) ; System . out . println ( " GET ▁ DONE " ) ; sendPOST ( ) ; System . out . println ( " POST ▁ DONE " ) ; } private static void sendGET ( ) throws IOException { URL obj = new URL ( GET_URL ) ; HttpURLConnection con = ( HttpURLConnection ) obj . openConnection ( ) ; con . setRequestMethod ( " GET " ) ; con . setRequestProperty ( " User - Agent " , USER_AGENT ) ; int responseCode = con . getResponseCode ( ) ; System . out . println ( " GET ▁ Response ▁ Code ▁ : : ▁ " + responseCode ) ; if ( responseCode == HttpURLConnection . HTTP_OK ) { BufferedReader in = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String inputLine ; StringBuffer response = new StringBuffer ( ) ; while ( ( inputLine = in . readLine ( ) ) != null ) { response . append ( inputLine ) ; } in . close ( ) ; System . out . println ( response . toString ( ) ) ; } else { System . out . println ( " GET ▁ request ▁ not ▁ worked " ) ; } } private static void sendPOST ( ) throws IOException { URL obj = new URL ( POST_URL ) ; HttpURLConnection con = ( HttpURLConnection ) obj . openConnection ( ) ; con . setRequestMethod ( " POST " ) ; con . setRequestProperty ( "User-Agent
List < String > list = Arrays . asList ( "1" , "2" , "3" ) ; List < Integer > intList = list . stream ( ) . map ( Integer :: parseInt ) . collect ( Collectors . toList ( ) ) ;
String str = " hello ▁ world " ; str . toUpperCase ( ) ;
Map < String , Integer > map = new HashMap < > ( ) ; for ( String s : list ) { map . put ( s , map . getOrDefault ( s , 0 ) + 1 ) ; }
public static int countWord ( String word , String sentence ) { int count = 0 ; for ( String s : sentence . split ( " ▁ " ) ) { if ( s . equals ( word ) ) { count ++ ; } } return count ; }
int [ ] [ ] arr = new int [ ] [ ] { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int [ ] [ ] sliced = Arrays . copyOfRange ( arr , 1 , 3 ) ;
int sum = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { sum += list . get ( i ) . getValue ( ) ; }
public class AlphanumericSort { public static void main ( String [ ] args ) { List < String > list = Arrays . asList ( " a1" , " a10" , " a2" , " a3" , " a4" , " a5" , " a6" , " a7" , " a8" , " a9" ) ; Collections . sort ( list , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { return extractInt ( o1 ) - extractInt ( o2 ) ; } int extractInt ( String s ) { String num = s . replaceAll ( " \\ D " , " " ) ; return num . isEmpty ( ) ? 0 : Integer . parseInt ( num ) ; } } ) ; System . out . println ( list ) ; } }
String s = " This ▁ is ▁ a ▁ ( test ) ▁ string " ; s = s . replaceAll ( " \\ ( \\ w + \\ ) " , " " ) ;
List < Integer > list1 = new ArrayList < > ( ) ; list1 . add ( 1 ) ; list1 . add ( 2 ) ; list1 . add ( 3 ) ; List < Integer > list2 = new ArrayList < > ( ) ; list2 . add ( 4 ) ; list2 . add ( 5 ) ; list2 . add ( 6 ) ; list2 . addAll ( 0 , list1 ) ; System . out . println ( list2 ) ;
int count = 0 ; for ( String s : list ) { if ( s == null ) { count ++ ; } }
String rreplace ( String s , String toReplace , String replacement ) { int pos = s . lastIndexOf ( toReplace ) ; if ( pos > - 1 ) { return s . substring ( 0 , pos ) + replacement + s . substring ( pos + toReplace . length ( ) , s . length ( ) ) ; } else { return s ; } }
import java . util . Date ; import java . text . DateFormat ; import java . text . SimpleDateFormat ; DateFormat dateFormat = new SimpleDateFormat ( " yyyy / MM / dd ▁ HH : mm : ss " ) ; Date date = new Date ( ) ; System . out . println ( dateFormat . format ( date ) ) ;
import hep . aida . * ; import java . util . Random ; public class Hist2DColorBar { public static void main ( String [ ] args ) { IAnalysisFactory af = IAnalysisFactory . create ( ) ; ITree tree = af . createTreeFactory ( ) . create ( ) ; IHistogramFactory hf = af . createHistogramFactory ( tree ) ; IPlotter plotter = af . createPlotterFactory ( ) . create ( " Plot " ) ; IHistogram2D h2d = hf . createHistogram2D ( " h2d " , 50 , - 3 , 3 , 50 , - 3 , 3 ) ; Random r = new Random ( ) ; for ( int i = 0 ; i < 10000 ; i ++ ) { double x = r . nextGaussian ( ) ; double y = r . nextGaussian ( ) ; h2d . fill ( x , y ) ; } plotter . region ( 0 ) . plot ( h2d ) ; plotter . show ( ) ; plotter . interact ( ) ; } }
public static void main ( String [ ] args ) { int n = 3 ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = 0 ; } print ( arr ) ; while ( increment ( arr ) ) { print ( arr ) ; } } private static boolean increment ( int [ ] arr ) { int i = arr . length - 1 ; while ( i >= 0 ) { if ( arr [ i ] == 0 ) { arr [ i ] = 1 ; return true ; } else { arr [ i ] = 0 ; i -- ; } } return false ; } private static void print ( int [ ] arr ) { for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] ) ; } System . out . println ( ) ; }
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; int sum = 0 ; for ( Integer value : map . values ( ) ) { sum += value ; } System . out . println ( sum ) ;
public static void main ( String [ ] args ) { String html = " < html > < body > < div > < p > Hello < / p > < p > World < / p > < / div > < / body > < / html > " ; Document doc = Jsoup . parse ( html ) ; Element p = doc . select ( " p : contains ( World ) " ) . first ( ) ; System . out . println ( p . text ( ) ) ; }
String acronym = " U . S . A . " ; acronym = acronym . replaceAll ( " \\ . + " , " " ) ;
String s = " Hello , ▁ World ! " ; s = s . replaceAll ( " [ ^ a - zA - Z0-9 ] " , " " ) ;
public static Map < String , String > toMap ( List < List < String > > list ) { Map < String , String > map = new HashMap < > ( ) ; for ( List < String > entry : list ) { map . put ( entry . get ( 0 ) , entry . get ( 1 ) ) ; } return map ; }
public static void reverse ( List < Integer > list , int start , int end ) { if ( start < 0 || end >= list . size ( ) || start >= end ) { return ; } while ( start < end ) { int temp = list . get ( start ) ; list . set ( start , list . get ( end ) ) ; list . set ( end , temp ) ; start ++ ; end -- ; } }
public static boolean isInDictionary ( String word , Map < String , List < String > > dictionary ) { for ( String key : dictionary . keySet ( ) ) { if ( dictionary . get ( key ) . contains ( word ) ) { return true ; } } return false ; }
String json = " { \" name \" : \" John \" , \" age \" : 30 , \" car \" : null } " ; JSONObject obj = new JSONObject ( json ) ; String name = obj . getString ( " name " ) ; int age = obj . getInt ( " age " ) ; System . out . println ( name ) ; System . out . println ( age ) ;
List < Tuple < String , Integer > > list1 = new ArrayList < > ( ) ; list1 . add ( new Tuple < > ( " a " , 1 ) ) ; list1 . add ( new Tuple < > ( " b " , 2 ) ) ; list1 . add ( new Tuple < > ( " c " , 3 ) ) ; List < Tuple < String , Integer > > list2 = new ArrayList < > ( ) ; list2 . add ( new Tuple < > ( " a " , 1 ) ) ; list2 . add ( new Tuple < > ( " b " , 2 ) ) ; list2 . add ( new Tuple < > ( " c " , 3 ) ) ; boolean isEqual = list1 . equals ( list2 ) ;
List < String > list = new ArrayList < String > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . add ( " d " ) ; list . add ( " e " ) ; list . add ( " f " ) ; list . add ( " g " ) ; list . add ( " h " ) ; list . add ( " i " ) ; list . add ( " j " ) ; list . add ( " k " ) ; list . add ( " l " ) ; list . add ( " m " ) ; list . add ( " n " ) ; list . add ( " o " ) ; list . add ( " p " ) ; list . add ( " q " ) ; list . add ( " r " ) ; list . add ( " s " ) ; list . add ( " t " ) ; list . add ( " u " ) ; list . add ( " v " ) ; list . add ( " w " ) ; list . add ( " x " ) ; list . add ( " y " ) ; list . add ( " z " ) ; Collections . sort ( list , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { if ( o1 . matches ( " [ a - m ] . * " ) && o2 . matches ( " [ n - z ] . * " ) ) { return - 1 ; } else if ( o1 . matches ( " [ n - z ] . * " ) && o2 . matches ( " [ a - m ] . * " ) ) { return 1 ; } else { return o1 . compareTo ( o2 ) ; } } } ) ; System . out . println ( list ) ;
String unicodeString = " Hello ▁ World " ; byte [ ] byteString = unicodeString . getBytes ( " UTF - 8" ) ;
List < String > lines = Arrays . asList ( " spring " , " node " , " mkyong " ) ; List < String > result = lines . stream ( ) . filter ( line -> ! " mkyong " . equals ( line ) ) . collect ( Collectors . toList ( ) ) ; result . forEach ( System . out :: println ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . remove ( " b " ) ;
List < String > list1 = new ArrayList < String > ( ) ; list1 . add ( " a " ) ; list1 . add ( " b " ) ; list1 . add ( " c " ) ; List < String > list2 = new ArrayList < String > ( ) ; list2 . add ( " d " ) ; list2 . add ( " e " ) ; list2 . add ( " f " ) ; list1 . addAll ( list2 ) ;
public static Date getLastDayOfMonth ( Date date ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; calendar . set ( Calendar . DAY_OF_MONTH , calendar . getActualMaximum ( Calendar . DAY_OF_MONTH ) ) ; return calendar . getTime ( ) ; }
List < Map < String , Object > > list = new ArrayList < > ( ) ; list . add ( new HashMap < String , Object > ( ) { { put ( " key1" , " value1" ) ; put ( " key2" , " value2" ) ; } } ) ; list . add ( new HashMap < String , Object > ( ) { { put ( " key1" , " value1" ) ; put ( " key2" , " value2" ) ; } } ) ; list . add ( new HashMap < String , Object > ( ) { { put ( " key1" , " value1" ) ; put ( " key2" , " value2" ) ; } } ) ; list . forEach ( map -> map . remove ( " key1" ) ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( " abc " ) ; list . add ( " def " ) ; list . add ( " ghi " ) ; list . add ( " jkl " ) ; List < String > subList = new ArrayList < > ( ) ; subList . add ( " abc " ) ; subList . add ( " jkl " ) ; list . removeAll ( subList ) ;
List < List < Integer > > list = new ArrayList < > ( ) ; list . add ( Arrays . asList ( 1 , 2 , 3 ) ) ; list . add ( Arrays . asList ( 4 , 5 , 6 ) ) ; list . add ( Arrays . asList ( 7 , 8 , 9 ) ) ; List < List < Integer > > zipped = IntStream . range ( 0 , list . get ( 0 ) . size ( ) ) . mapToObj ( i -> list . stream ( ) . map ( l -> l . get ( i ) ) . collect ( Collectors . toList ( ) ) ) . collect ( Collectors . toList ( ) ) ;
String s = " Hello , ▁ World ! " ; System . out . println ( s . toUpperCase ( ) ) ;
public static void main ( String [ ] args ) { List < Tuple2 < String , Float > > list = new ArrayList < > ( ) ; list . add ( new Tuple2 < > ( " a " , 1.0f ) ) ; list . add ( new Tuple2 < > ( " b " , 2.0f ) ) ; list . add ( new Tuple2 < > ( " c " , 3.0f ) ) ; list . add ( new Tuple2 < > ( " d " , 4.0f ) ) ; list . add ( new Tuple2 < > ( " e " , 5.0f ) ) ; list . add ( new Tuple2 < > ( " f " , 6.0f ) ) ; list . add ( new Tuple2 < > ( " g " , 7.0f ) ) ; list . add ( new Tuple2 < > ( " h " , 8.0f ) ) ; list . add ( new Tuple2 < > ( " i " , 9.0f ) ) ; list . add ( new Tuple2 < > ( " j " , 10.0f ) ) ; list . add ( new Tuple2 < > ( " k " , 11.0f ) ) ; list . add ( new Tuple2 < > ( " l " , 12.0f ) ) ; list . add ( new Tuple2 < > ( " m " , 13.0f ) ) ; list . add ( new Tuple2 < > ( " n " , 14.0f ) ) ; list . add ( new Tuple2 < > ( " o " , 15.0f ) ) ; list . add ( new Tuple2 < > ( " p " , 16.0f ) ) ; list . add ( new Tuple2 < > ( " q " , 17.0f ) ) ; list . add ( new Tuple2 < > ( " r " , 18.0f ) ) ; list . add ( new Tuple2 < > ( " s " , 19.0f ) ) ; list . add ( new Tuple2 < > ( " t " , 20.0f ) ) ; list . add ( new Tuple2 < > ( " u " , 21.0f ) ) ; list . add ( new Tuple2 < > ( " v " , 22.0f ) ) ; list . add ( new Tuple2 < > ( " w " , 23.0f ) ) ; list .
public static char mostFrequentChar ( String s ) { Map < Character , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( map . containsKey ( c ) ) { map . put ( c , map . get ( c ) + 1 ) ; } else { map . put ( c , 1 ) ; } } int max = 0 ; char maxChar = ' ▁ ' ; for ( Map . Entry < Character , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) > max ) { max = entry . getValue ( ) ; maxChar = entry . getKey ( ) ; } } return maxChar ; }
String str = " Hello ▁ World " ; if ( str . matches ( " . * [ a - zA - Z ] . * " ) ) { System . out . println ( " String ▁ contains ▁ letters " ) ; } else { System . out . println ( " String ▁ doesn ' t ▁ contain ▁ letters " ) ; }
Map < String , Double > map = new HashMap < > ( ) ; map . put ( " a " , 1.0 ) ; map . put ( " b " , 2.0 ) ; map . put ( " c " , 3.0 ) ; double sum = 0.0 ; for ( Double value : map . values ( ) ) { sum += value ; } double average = sum / map . size ( ) ;
Collections . sort ( list , new Comparator < int [ ] > ( ) { @ Override public int compare ( int [ ] o1 , int [ ] o2 ) { if ( o1 [ 0 ] != o2 [ 0 ] ) { return o2 [ 0 ] - o1 [ 0 ] ; } else { return o1 [ 1 ] - o2 [ 1 ] ; } } } ) ;
Map < String , String > map = new HashMap < > ( ) ; map . put ( " key " , " value " ) ;
String [ ] words = { " Hello " , " World " } ; String firstLetters = " " ; for ( String word : words ) { firstLetters += word . charAt ( 0 ) ; }
public static List < List < Integer > > getAllCombinations ( List < Integer > list ) { List < List < Integer > > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < list . size ( ) ; j ++ ) { List < Integer > temp = new ArrayList < > ( ) ; temp . add ( list . get ( i ) ) ; temp . add ( list . get ( j ) ) ; result . add ( temp ) ; } } return result ; }
Collections . sort ( list , new Comparator < Person > ( ) { @ Override public int compare ( Person p1 , Person p2 ) { int cmp = p1 . getLastName ( ) . compareTo ( p2 . getLastName ( ) ) ; if ( cmp != 0 ) { return cmp ; } return p1 . getFirstName ( ) . compareTo ( p2 . getFirstName ( ) ) ; } } ) ;
import java . util . Random ; public class RandomNumberGenerator { public static void main ( String [ ] args ) { Random random = new Random ( ) ; int [ ] distribution = new int [ 10 ] ; for ( int i = 0 ; i < 1000000 ; i ++ ) { distribution [ random . nextInt ( 10 ) ] ++ ; } for ( int i = 0 ; i < 10 ; i ++ ) { System . out . println ( i + " : ▁ " + distribution [ i ] ) ; } } }
int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int [ ] arr2 = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr2 . length ; j ++ ) { if ( arr [ i ] == arr2 [ j ] ) { System . out . println ( i + " ▁ " + j ) ; } } }
String url = " http : // www . example . com / foo / bar / baz " ; String lastPart = url . substring ( url . lastIndexOf ( ' / ' ) + 1 ) ;
String str = " Hello ▁ World " ; str = str . replaceAll ( " [ ^ \\ d . ] " , " " ) ;
String str = " Hello ▁ World " ; str . matches ( " [ a - zA - Z ▁ ] + " ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; List < List < String > > listOfLists = new ArrayList < > ( ) ; listOfLists . add ( list ) ; listOfLists . add ( list ) ; listOfLists . add ( list ) ; List < String > mergedList = listOfLists . stream ( ) . flatMap ( Collection :: stream ) . collect ( Collectors . toList ( ) ) ;
Map < String , String > map = new HashMap < > ( ) ; map . put ( " A " , " a " ) ; map . put ( " B " , " b " ) ; map . put ( " C " , " c " ) ; Map < String , String > lowercaseMap = map . entrySet ( ) . stream ( ) . collect ( Collectors . toMap ( e -> e . getKey ( ) . toLowerCase ( ) , e -> e . getValue ( ) . toLowerCase ( ) ) ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; if ( list . contains ( " a " ) || list . contains ( " b " ) || list . contains ( " c " ) ) { }
Collections . sort ( list , new Comparator < Map . Entry < String , Integer > > ( ) { @ Override public int compare ( Map . Entry < String , Integer > o1 , Map . Entry < String , Integer > o2 ) { return o1 . getValue ( ) . compareTo ( o2 . getValue ( ) ) ; } } ) ;
public static boolean containsNonAscii ( String str ) { return ! str . matches ( " \\ p { ASCII } + " ) ; }
Date date = new Date ( ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; cal . add ( Calendar . MONTH , 6 ) ; date = cal . getTime ( ) ;
Tuple2 < String , Integer > tuple1 = new Tuple2 < > ( " a " , 1 ) ; Tuple2 < String , Integer > tuple2 = new Tuple2 < > ( " b " , 2 ) ; Tuple2 < String , Integer > tuple3 = new Tuple2 < > ( " c " , 3 ) ; Tuple3 < String , Integer , Integer > tuple = new Tuple3 < > ( tuple1 , tuple2 , tuple3 ) ;
Colorbar cb = plot . getColorbar ( ) ; cb . setRange ( 0 , 1 ) ;
String s = " ÄÖÜäöüß " ; byte [ ] bytes = s . getBytes ( " ISO - 8859-1" ) ; String s2 = new String ( bytes , " UTF - 8" ) ;
List < String > list1 = Arrays . asList ( " a " , " b " , " c " ) ; List < String > list2 = Arrays . asList ( " d " , " e " , " f " ) ; List < String > list3 = new ArrayList < > ( ) ; list3 . addAll ( list1 ) ; list3 . addAll ( list2 ) ;
import java . io . * ; public class WriteMultipleLines { public static void main ( String [ ] args ) { String fileName = " temp . txt " ; try { FileWriter fileWriter = new FileWriter ( fileName ) ; BufferedWriter bufferedWriter = new BufferedWriter ( fileWriter ) ; bufferedWriter . write ( " Hello ▁ there , " ) ; bufferedWriter . write ( " ▁ here ▁ is ▁ some ▁ text . " ) ; bufferedWriter . newLine ( ) ; bufferedWriter . write ( " We ▁ are ▁ writing " ) ; bufferedWriter . write ( " ▁ the ▁ text ▁ to ▁ the ▁ file . " ) ; bufferedWriter . close ( ) ; } catch ( IOException ex ) { System . out . println ( " Error ▁ writing ▁ to ▁ file ▁ ' " + fileName + " ' " ) ; } } }
import com . github . mike10004 . common . system . SystemInfo ; import com . github . mike10004 . common . system . SystemInfo . CpuUsage ; import com . github . mike10004 . common . system . SystemInfo . MemoryUsage ; SystemInfo systemInfo = SystemInfo . getInstance ( ) ; CpuUsage cpuUsage = systemInfo . getCpuUsage ( ) ; MemoryUsage memoryUsage = systemInfo . getMemoryUsage ( ) ;
String s = " \\ N { GREEK ▁ SMALL ▁ LETTER ▁ ALPHA } \\ N { GREEK ▁ CAPITAL ▁ LETTER ▁ OMEGA } " ; System . out . println ( s ) ;
String str = " ▁ ▁ ▁ Hello ▁ World ▁ ▁ ▁ " ; str = str . trim ( ) ;
List < Integer > list = new ArrayList < > ( ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( null ) ; list . add ( 0 ) ; list . removeAll ( Collections . singleton ( null ) ) ; System . out . println ( list ) ;
String str = " This ▁ is ▁ a ▁ test . ▁ This ▁ is , ▁ too . " ; String word = " is " ; int pos = str . indexOf ( word ) ; int start = str . lastIndexOf ( " ▁ " , pos ) ; int end = str . indexOf ( " ▁ " , pos ) ; if ( start == - 1 ) { start = 0 ; } if ( end == - 1 ) { end = str . length ( ) ; } String sentence = str . substring ( start , end ) ; System . out . println ( sentence ) ;
import java . util . ArrayList ; import java . util . List ; import org . apache . commons . math3 . ml . clustering . CentroidCluster ; import org . apache . commons . math3 . ml . clustering . KMeansPlusPlusClusterer ; import org . apache . commons . math3 . ml . clustering . MultiKMeansPlusPlusClusterer ; import org . apache . commons . math3 . ml . distance . EuclideanDistance ; public class KMeans { public static void main ( String [ ] args ) { List < Point > points = new ArrayList < Point > ( ) ; points . add ( new Point ( 1 ) ) ; points . add ( new Point ( 2 ) ) ; points . add ( new Point ( 3 ) ) ; points . add ( new Point ( 4 ) ) ; points . add ( new Point ( 5 ) ) ; points . add ( new Point ( 6 ) ) ; points . add ( new Point ( 7 ) ) ; points . add ( new Point ( 8 ) ) ; points . add ( new Point ( 9 ) ) ; points . add ( new Point ( 10 ) ) ; KMeansPlusPlusClusterer < Point > clusterer = new KMeansPlusPlusClusterer < Point > ( 2 , 1000 , new EuclideanDistance ( ) ) ; List < CentroidCluster < Point > > clusterResults = clusterer . cluster ( points ) ; for ( CentroidCluster < Point > cluster : clusterResults ) { System . out . println ( " Cluster ▁ center : ▁ " + cluster . getCenter ( ) . getPoint ( ) [ 0 ] ) ; System . out . println ( " Points : ▁ " ) ; for ( Point point : cluster . getPoints ( ) ) { System . out . println ( point . getPoint ( ) [ 0 ] ) ; } } } } class Point { private double [ ] point ; public Point ( double x ) { point = new double [ ] { x } ; } public double [ ] getPoint ( ) { return point ; } }
import java . util . Calendar ; import java . util . Date ; import java . util . TimeZone ; public class Main { public static void main ( String [ ] args ) { Date date = new Date ( ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; calendar . setTimeZone ( TimeZone . getTimeZone ( " UTC " ) ) ; System . out . println ( calendar . getTime ( ) ) ; } }
if ( map . containsKey ( key ) ) { }
Collections . sort ( list , new Comparator < List < String > > ( ) { @ Override public int compare ( List < String > o1 , List < String > o2 ) { return o1 . get ( index ) . compareTo ( o2 . get ( index ) ) ; } } ) ;
public static String get ( String url ) throws IOException { URL obj = new URL ( url ) ; HttpURLConnection con = ( HttpURLConnection ) obj . openConnection ( ) ; con . setRequestMethod ( " GET " ) ; con . setRequestProperty ( " User - Agent " , " Mozilla / 5.0" ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String inputLine ; StringBuffer response = new StringBuffer ( ) ; while ( ( inputLine = in . readLine ( ) ) != null ) { response . append ( inputLine ) ; } in . close ( ) ; return response . toString ( ) ; } public static String post ( String url , String data ) throws IOException { URL obj = new URL ( url ) ; HttpURLConnection con = ( HttpURLConnection ) obj . openConnection ( ) ; con . setRequestMethod ( " POST " ) ; con . setRequestProperty ( " User - Agent " , " Mozilla / 5.0" ) ; con . setRequestProperty ( " Accept - Language " , " en - US , en ; q = 0.5" ) ; con . setDoOutput ( true ) ; DataOutputStream wr = new DataOutputStream ( con . getOutputStream ( ) ) ; wr . writeBytes ( data ) ; wr . flush ( ) ; wr . close ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( con . getInputStream ( ) ) ) ; String inputLine ; StringBuffer response = new StringBuffer ( ) ; while ( ( inputLine = in . readLine ( ) ) != null ) { response . append ( inputLine ) ; } in . close ( ) ; return response . toString ( ) ; }
public class SortJson { public static void main ( String [ ] args ) throws IOException { String json = " { \" a \" : 1 , \" b \" : 2 , \" c \" : 3 , \" d \" : 4 , \" e \" : 5 } " ; ObjectMapper mapper = new ObjectMapper ( ) ; Map < String , Integer > map = mapper . readValue ( json , new TypeReference < Map < String , Integer > > ( ) { } ) ; Map < String , Integer > sortedMap = map . entrySet ( ) . stream ( ) . sorted ( Map . Entry . comparingByKey ( ) ) . collect ( Collectors . toMap ( Map . Entry :: getKey , Map . Entry :: getValue , ( oldValue , newValue ) -> oldValue , LinkedHashMap :: new ) ) ; System . out . println ( sortedMap ) ; } }
Random random = new Random ( ) ; int index = random . nextInt ( list . size ( ) ) ; String item = list . get ( index ) ;
List < Integer > list = new ArrayList < > ( ) ; list . add ( Integer . valueOf ( "1" ) ) ; list . add ( Integer . valueOf ( "2" ) ) ; list . add ( Integer . valueOf ( "3" ) ) ;
public static < T > List < Set < T > > removeDuplicates ( List < Set < T > > list ) { List < Set < T > > result = new ArrayList < > ( ) ; for ( Set < T > set : list ) { if ( ! result . contains ( set ) ) { result . add ( set ) ; } } return result ; }
List < String > names = new ArrayList < > ( ) ; for ( Person person : persons ) { names . add ( person . getName ( ) ) ; }
JButton button = new JButton ( " Button " ) ; button . setBackground ( Color . RED ) ;
String regex = " \\ d + " ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( string ) ; if ( matcher . find ( ) ) { System . out . println ( matcher . group ( 0 ) ) ; }
import java . util . Map ; import java . util . HashMap ; import java . util . List ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Iterator ; import java . util . Enumeration ; import java . util . regex . Pattern ; import java . util . regex . Matcher ; import java . util . logging . Logger ; import java . util . logging . Level ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . HttpURLConnection ; import java . net . URLConnection ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . net . SocketException ; import java . net . SocketTimeoutException ; import java . net . ConnectException ; import java . net . ProtocolException ; import java . net . HttpRetryException ; import java . net . Proxy ; import java . net . ProxySelector ; import java . net . InetSocketAddress ; import java . net . Proxy . Type ; import java . net . CookieHandler ; import java . net . CookieManager ; import java . net . CookiePolicy ; import java . net . CookieStore ; import java . net . HttpCookie ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . HttpCookie ; import java . net . CookieStore ; import java . net . CookiePolicy ; import java . net . CookieManager ; import java . net . CookieHandler ; import java . net . HttpURLConnection ; import java . net . URLConnection ; import java . net . URL ; import java . net . MalformedURLException ; import java . net . URLEncoder ; import java . net . URL
String arabicText = " العربية " ; String englishText = " English " ; String mixedText = " العربية ▁ English " ; String arabicTextRegex = " [ \u0600 - \u06FF ] + " ; String englishTextRegex = " [ a - zA - Z ] + " ; System . out . println ( arabicText . matches ( arabicTextRegex ) ) ; System . out . println ( englishText . matches ( arabicTextRegex ) ) ; System . out . println ( mixedText . matches ( arabicTextRegex ) ) ; System . out . println ( arabicText . matches ( englishTextRegex ) ) ; System . out . println ( englishText . matches ( englishTextRegex ) ) ; System . out . println ( mixedText . matches ( englishTextRegex ) ) ;
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ;
public static void main ( String [ ] args ) { List < String > list = Arrays . asList ( " a " , " b " , " c " ) ; List < List < String > > result = new ArrayList < > ( ) ; permute ( list , 0 , result ) ; System . out . println ( result ) ; } private static void permute ( List < String > list , int start , List < List < String > > result ) { if ( start == list . size ( ) ) { result . add ( new ArrayList < > ( list ) ) ; } else { for ( int i = start ; i < list . size ( ) ; i ++ ) { Collections . swap ( list , start , i ) ; permute ( list , start + 1 , result ) ; Collections . swap ( list , start , i ) ; } } }
public class ReverseString { public static void main ( String [ ] args ) { String str = " Hello ▁ World " ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { sb . append ( str . charAt ( i ) ) ; } System . out . println ( sb . toString ( ) ) ; } }
JSONObject json = new JSONObject ( jsonString ) ; JSONArray jsonArray = json . getJSONArray ( " key " ) ; for ( int i = 0 ; i < jsonArray . length ( ) ; i ++ ) { JSONObject jsonObject = jsonArray . getJSONObject ( i ) ; String value = jsonObject . getString ( " key " ) ; }
public static List < String > splitString ( String str , int chunkSize ) { List < String > chunks = new ArrayList < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i += chunkSize ) { chunks . add ( str . substring ( i , Math . min ( str . length ( ) , i + chunkSize ) ) ) ; } return chunks ; }
Collections . sort ( list , new Comparator < List < Integer > > ( ) { @ Override public int compare ( List < Integer > o1 , List < Integer > o2 ) { return o1 . get ( 0 ) - o2 . get ( 0 ) ; } } ) ;
String s = "123abc " ; s . matches ( " ^ \\ d + . * " ) ;
public static boolean isNumeric ( String str ) { try { double d = Double . parseDouble ( str ) ; } catch ( NumberFormatException nfe ) { return false ; } return true ; }
String text = " aab " ; String regexp = " a + " ; Pattern pattern = Pattern . compile ( regexp ) ; Matcher matcher = pattern . matcher ( text ) ; while ( matcher . find ( ) ) { System . out . println ( matcher . group ( ) ) ; }
public class Main { public static void main ( String [ ] args ) { Map < String , String > map1 = new HashMap < > ( ) ; map1 . put ( " key1" , " value1" ) ; map1 . put ( " key2" , " value2" ) ; map1 . put ( " key3" , " value3" ) ; Map < String , String > map2 = new HashMap < > ( ) ; map2 . put ( " key3" , " value3" ) ; map2 . put ( " key2" , " value2" ) ; map2 . put ( " key1" , " value1" ) ; System . out . println ( map1 . hashCode ( ) ) ; System . out . println ( map2 . hashCode ( ) ) ; } }
Canvas canvas = new Canvas ( ) ; TextItem textItem = new TextItem ( " Hello ▁ World " ) ; textItem . setFontSize ( 20 ) ; canvas . addItem ( textItem ) ;
public static boolean containsList ( List < Object > list ) { for ( Object o : list ) { if ( o instanceof List ) { return true ; } } return false ; }
String hex = "0123456789ABCDEF " ; List < Integer > values = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < hex . length ( ) ; i ++ ) { char c = hex . charAt ( i ) ; int d = Character . digit ( c , 16 ) ; values . add ( d ) ; }
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; String last = list . get ( list . size ( ) - 1 ) ;
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; System . out . print ( " Enter ▁ your ▁ name : ▁ " ) ; String name = scanner . nextLine ( ) ; System . out . println ( " Hello ▁ " + name ) ; } }
public class Solution { public int strStr ( String haystack , String needle ) { if ( needle . length ( ) == 0 ) return 0 ; if ( haystack . length ( ) == 0 ) return - 1 ; for ( int i = 0 ; i < haystack . length ( ) - needle . length ( ) + 1 ; i ++ ) { if ( haystack . substring ( i , i + needle . length ( ) ) . equals ( needle ) ) { return i ; } } return - 1 ; } }
public static float stringToFloat ( String s ) { return Float . intBitsToFloat ( s . hashCode ( ) ) ; }
String s = " Hello ▁ World " ; s = s . replaceAll ( " ( ? i ) hello " , " Hi " ) ;
List < String > list = Arrays . asList ( " a " , " b " , " c " , " d " , " a " , " b " , " c " , " d " ) ; int count = 0 ; for ( String element : list ) { if ( element . equals ( " a " ) ) { count ++ ; } } System . out . println ( count ) ;
# Import BeautifulSoup from bs4 import BeautifulSoup # Create a BeautifulSoup object from the HTML : soup soup = BeautifulSoup ( html_doc , ' html . parser ' ) # Print the title of Guido 's webpage print ( soup . title ) # Find all ' a ' tags ( which define hyperlinks ) : a_tags a_tags = soup . find_all ( ' a ' ) # Print the URLs to the shell for link in a_tags : print ( link . get ( ' href ' ) )
int x = 5 ; if ( x instanceof Integer ) { System . out . println ( " x ▁ is ▁ an ▁ integer " ) ; }
Arrays . sort ( array , new Comparator < int [ ] > ( ) { @ Override public int compare ( int [ ] o1 , int [ ] o2 ) { return Integer . compare ( o1 [ 0 ] , o2 [ 0 ] ) ; } } ) ;
public class Main { public static void main ( String [ ] args ) { System . out . println ( new Main ( ) . getClass ( ) . getName ( ) ) ; } }
Collections . sort ( list , new Comparator < Tuple > ( ) { @ Override public int compare ( Tuple o1 , Tuple o2 ) { return o1 . getSecond ( ) . compareTo ( o2 . getSecond ( ) ) ; } } ) ;
public class Solution { public boolean repeatedSubstringPattern ( String s ) { int len = s . length ( ) ; for ( int i = len / 2 ; i >= 1 ; i -- ) { if ( len % i == 0 ) { int m = len / i ; String subS = s . substring ( 0 , i ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int j = 0 ; j < m ; j ++ ) { sb . append ( subS ) ; } if ( sb . toString ( ) . equals ( s ) ) return true ; } } return false ; } }
import java . sql . Connection ; import java . sql . DriverManager ; import java . sql . SQLException ; public class Main { public static void main ( String [ ] args ) throws SQLException { Connection connection = DriverManager . getConnection ( " jdbc : mysql : // localhost : 3306 / test ? useServerPrepStmts = true & cachePrepStmts = false " , " root " , " root " ) ; } }
URL url = new URL ( " http : // www . example . com / example . txt " ) ; ReadableByteChannel rbc = Channels . newChannel ( url . openStream ( ) ) ; FileOutputStream fos = new FileOutputStream ( " example . txt " ) ; fos . getChannel ( ) . transferFrom ( rbc , 0 , Long . MAX_VALUE ) ;
from bs4 import BeautifulSoup import requests url = ' https : // www . google . com / search ? q = java ' response = requests . get ( url ) soup = BeautifulSoup ( response . text , ' html . parser ' ) for meta in soup . find_all ( ' meta ' ) : if ' name ' in meta . attrs and meta [ ' name ' ] == ' description ' : print ( meta [ ' content ' ] )
String [ ] arr = { " abc " , " ab " , " a " , " abcd " } ; Arrays . sort ( arr , new Comparator < String > ( ) { @ Override public int compare ( String s1 , String s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) { return s1 . length ( ) - s2 . length ( ) ; } return s1 . compareTo ( s2 ) ; } } ) ;
public static int convertToBase10 ( String s ) { int result = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { result = result * 2 + ( s . charAt ( i ) - '0' ) ; } return result ; }
public static int countOccurrences ( String haystack , char needle ) { int count = 0 ; for ( int i = 0 ; i < haystack . length ( ) ; i ++ ) { if ( haystack . charAt ( i ) == needle ) { count ++ ; } } return count ; }
String html = " < html > < head > < title > Test < / title > < / head > < body > \u00A0 < / body > < / html > " ; Document doc = Jsoup . parse ( html ) ; String text = doc . text ( ) ; System . out . println ( text ) ;
List < Integer > list = new ArrayList < > ( ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; list . add ( 4 ) ; list . add ( 5 ) ; list . add ( 6 ) ; list . add ( 7 ) ; list . add ( 8 ) ; list . add ( 9 ) ; list . add ( 10 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; list . remove ( 0 ) ; System . out . println ( list ) ;
import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Row ; import org . apache . poi . ss . usermodel . Sheet ; import org . apache . poi . ss . usermodel . Workbook ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; public class XlsxWriter { public static void main ( String [ ] args ) throws IOException { String [ ] columns = { " Name " , " Email " , " Date ▁ Of ▁ Birth " , " Salary " } ; String path = " C : \\ Users \\ user \\ Desktop\ \" ; String fileName = " Employee . xlsx " ; String sheetName = " Employee " ; List < Employee > list = new ArrayList < > ( ) ; list . add ( new Employee ( " Rajeev ▁ Singh " , " rajeev @ example . com " , "1991-04-21" , 9000000.0 ) ) ; list . add ( new Employee ( " Thomas ▁ cook " , " thomas @ example . com " , "1980-07-02" , 6500000.0 ) ) ; list . add ( new Employee ( " Steve ▁ Maiden " , " steve @ example . com " , "1978-09-23" , 7500000.0 ) ) ; list . add ( new Employee ( " Brad ▁ pit " , " brad @ example . com " , "1956-12-02" , 8500000.0 ) ) ; list . add ( new Employee ( " Herry ▁ Porter " , " herry @ example . com " , "1961-01-25" , 7500000.0 ) ) ; list . add ( new Employee ( " Clark ▁ Man " , " clark @ example . com " , "1951-11-12" , 6500000.0 ) ) ; list . add ( new Employee ( " Paul ▁ Robinson " , " paul @ example . com " , "1964-01-31" , 5500000.0 ) ) ; list . add ( new Employee ( " Buffet " , " buffet @ example . com " ,
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , "1" ) ; map . put ( " b " , "2" ) ; map . put ( " c " , "3" ) ; Map < String , Integer > result = map . entrySet ( ) . stream ( ) . collect ( Collectors . toMap ( Map . Entry :: getKey , e -> Integer . valueOf ( e . getValue ( ) ) ) ) ;
Map < String , String > map = new HashMap < > ( ) ; map . put ( " key1" , " value1" ) ; map . put ( " key2" , " value2" ) ; List < String > list = new ArrayList < > ( map . values ( ) ) ;
String str = " Hello ▁ World " ; String subStr = str . substring ( 0 , 5 ) ;
public static void main ( String [ ] args ) { String word = " hello " ; int count = 0 ; for ( int i = 0 ; i < word . length ( ) - 1 ; i ++ ) { if ( isConsonant ( word . charAt ( i ) ) && isConsonant ( word . charAt ( i + 1 ) ) ) { count ++ ; } } System . out . println ( count ) ; } public static boolean isConsonant ( char c ) { return ! ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ; }
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . clear ( ) ;
Yaml yaml = new Yaml ( ) ; Map < String , Object > map = yaml . load ( new FileInputStream ( new File ( " test . yaml " ) ) ) ;
import java . io . File ; import java . io . FileNotFoundException ; import java . util . Scanner ; public class ReadCSV { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner scanner = new Scanner ( new File ( " data . csv " ) ) ; scanner . useDelimiter ( " , " ) ; while ( scanner . hasNext ( ) ) { System . out . print ( scanner . next ( ) + " | " ) ; } scanner . close ( ) ; } }
String sql = " SELECT ▁ * ▁ FROM ▁ users ▁ WHERE ▁ id ▁ IN ▁ ( ? ) " ; PreparedStatement stmt = conn . prepareStatement ( sql ) ; stmt . setArray ( 1 , conn . createArrayOf ( " integer " , new Integer [ ] { 1 , 2 , 3 } ) ) ; ResultSet rs = stmt . executeQuery ( ) ;
List < String > list1 = Arrays . asList ( " a " , " b " , " c " ) ; List < String > list2 = Arrays . asList ( "1" , "2" , "3" ) ; List < Tuple2 < String , String > > list = list1 . stream ( ) . flatMap ( s1 -> list2 . stream ( ) . map ( s2 -> new Tuple2 < > ( s1 , s2 ) ) ) . collect ( Collectors . toList ( ) ) ;
String [ ] array = { " a " , " b " , " c " } ; String string = " a " ; Arrays . asList ( array ) . contains ( string ) ;
int count = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { if ( data [ i ] == null ) { count ++ ; } }
List < String > list = Arrays . asList ( " a " , " " , " b " , " c " , " " , " d " ) ; list . removeAll ( Collections . singleton ( " " ) ) ;
String str = " Hello ▁ World " ; String newStr = str . substring ( 2 ) ;
String s = " a \n b " ; Pattern p = Pattern . compile ( " ( . * ? ) b " , Pattern . DOTALL ) ; Matcher m = p . matcher ( s ) ; m . find ( ) ; System . out . println ( m . group ( 1 ) ) ;
public static boolean allEqual ( List < Integer > list ) { return list . stream ( ) . distinct ( ) . limit ( 2 ) . count ( ) <= 1 ; }
if ( list . isEmpty ( ) ) { }
public class Main { public static void main ( String [ ] args ) { Thread thread1 = new Thread ( new Runnable ( ) { @ Override public void run ( ) { System . out . println ( " Hello ▁ from ▁ thread ▁ 1" ) ; } } ) ; Thread thread2 = new Thread ( new Runnable ( ) { @ Override public void run ( ) { System . out . println ( " Hello ▁ from ▁ thread ▁ 2" ) ; } } ) ; thread1 . start ( ) ; thread2 . start ( ) ; } }
List < String > first = Arrays . asList ( " a " , " b " , " c " ) ; List < String > second = Arrays . asList ( " x " , " y " , " z " ) ; List < String > result = new ArrayList < > ( ) ; result . add ( first . get ( 0 ) ) ; result . add ( second . get ( second . size ( ) - 1 ) ) ;
List < String > names = new ArrayList < String > ( ) ; for ( User user : users ) { names . add ( user . getName ( ) ) ; }
List < Integer > list = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Tuple2 < Integer , Integer > > pairs = new ArrayList < > ( ) ; for ( int i = 0 ; i < list . size ( ) - 1 ; i ++ ) { if ( list . get ( i ) % 2 == 0 && list . get ( i + 1 ) % 2 == 0 ) { pairs . add ( new Tuple2 < > ( list . get ( i ) , list . get ( i + 1 ) ) ) ; } }
File dir = new File ( " / path / to / dir " ) ; File [ ] files = dir . listFiles ( ) ; for ( File file : files ) { if ( file . isFile ( ) ) { System . out . println ( file . getName ( ) ) ; } }
import java . util . ArrayList ; import java . util . List ; import com . google . gson . Gson ; import com . google . gson . GsonBuilder ; public class Main { public static void main ( String [ ] args ) { Gson gson = new GsonBuilder ( ) . create ( ) ; List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; String json = gson . toJson ( list ) ; System . out . println ( json ) ; } }
Random random = new Random ( ) ; int randomInt = random . nextInt ( 10 ) ;
public static < T > List < List < T > > splitList ( List < T > list , int chunkSize ) { List < List < T > > chunks = new ArrayList < > ( ) ; for ( int i = 0 ; i < list . size ( ) ; i += chunkSize ) { chunks . add ( list . subList ( i , Math . min ( i + chunkSize , list . size ( ) ) ) ) ; } return chunks ; }
boolean x = true ; boolean y = false ; boolean z = x ^ y ;
List < String > list = Arrays . asList ( " a " , " b " , " c " ) ; List < String > newList = list . stream ( ) . map ( s -> " x " + s ) . collect ( Collectors . toList ( ) ) ;
import java . util . Random ; import java . util . Set ; import java . util . TreeSet ; public class RandomNumberGenerator { public static void main ( String [ ] args ) { Random random = new Random ( ) ; Set < Integer > set = new TreeSet < > ( ) ; while ( set . size ( ) < 10 ) { set . add ( random . nextInt ( 100 ) ) ; } System . out . println ( set ) ; } }
from bs4 import BeautifulSoup soup = BeautifulSoup ( html , ' html . parser ' ) soup . find_all ( string = re . compile ( ' Java ' ) )
String str = " Hello ▁ World " ; str = str . replace ( ' l ' , ' x ' ) ;
Map < String , List < String > > map = new HashMap < > ( ) ; map . put ( " key " , new ArrayList < > ( ) ) ; map . get ( " key " ) . add ( " value " ) ;
String [ ] strs = { " abc " , " def " , " ghi " } ; for ( int i = 0 ; i < strs . length ; i ++ ) { strs [ i ] = strs [ i ] . replace ( " a " , " " ) ; }
String time = "12:00:00" ; SimpleDateFormat sdf = new SimpleDateFormat ( " HH : mm : ss " ) ; Date date = sdf . parse ( time ) ;
List < List < String > > list = new ArrayList < > ( ) ; list . add ( Arrays . asList ( " a " , " b " , " c " ) ) ; list . add ( Arrays . asList ( " d " , " e " , " f " ) ) ; list . add ( Arrays . asList ( " g " , " h " , " i " ) ) ; list . stream ( ) . map ( l -> l . stream ( ) . map ( s -> s . replace ( " a " , " A " ) ) . collect ( Collectors . toList ( ) ) ) . collect ( Collectors . toList ( ) ) ;
public void closeWindow ( ) { this . dispose ( ) ; }
public int getRowCount ( String tableName ) { int count = 0 ; try { Statement stmt = connection . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( " SELECT ▁ COUNT ( * ) ▁ FROM ▁ " + tableName ) ; rs . next ( ) ; count = rs . getInt ( 1 ) ; rs . close ( ) ; stmt . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return count ; }
List < List < Integer > > list = new ArrayList < > ( ) ; list . add ( Arrays . asList ( 1 , 2 , 3 ) ) ; list . add ( Arrays . asList ( 1 , 2 , 4 ) ) ; list . add ( Arrays . asList ( 1 , 2 , 5 ) ) ; Collections . sort ( list , new Comparator < List < Integer > > ( ) { @ Override public int compare ( List < Integer > o1 , List < Integer > o2 ) { for ( int i = 0 ; i < Math . min ( o1 . size ( ) , o2 . size ( ) ) ; i ++ ) { int cmp = Integer . compare ( o1 . get ( i ) , o2 . get ( i ) ) ; if ( cmp != 0 ) { return cmp ; } } return Integer . compare ( o1 . size ( ) , o2 . size ( ) ) ; } } ) ; System . out . println ( list ) ;
List < String > list1 = Arrays . asList ( " a " , " b " , " c " ) ; List < String > list2 = Arrays . asList ( " b " , " c " , " d " ) ; boolean anyMatch = list1 . stream ( ) . anyMatch ( list2 :: contains ) ;
import java . io . File ; import java . io . FileNotFoundException ; import java . util . Scanner ; public class ReadFiles { public static void main ( String [ ] args ) { File file = new File ( " / Users / joe / Desktop / test " ) ; readFiles ( file ) ; } public static void readFiles ( File file ) { if ( file . isDirectory ( ) ) { File [ ] files = file . listFiles ( ) ; for ( File f : files ) { readFiles ( f ) ; } } else { try { Scanner scanner = new Scanner ( file ) ; while ( scanner . hasNext ( ) ) { System . out . println ( scanner . nextLine ( ) ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } } }
String s = " String ▁ with ▁ ( words ) ▁ in ▁ parentheses " ; s = s . replaceAll ( " \\ ( . * ? \\ ) ▁ ? " , " " ) ;
List < String > list = Arrays . asList ( " a " , " b " , " c " , " d " , " e " , " f " , " g " , " h " , " i " , " j " , " k " , " l " , " m " , " n " , " o " , " p " , " q " , " r " , " s " , " t " , " u " , " v " , " w " , " x " , " y " , " z " ) ; Map < String , List < String > > grouped = list . stream ( ) . collect ( Collectors . groupingBy ( s -> s . substring ( 0 , 1 ) ) ) ; System . out . println ( grouped ) ;
public class SortList { public static void main ( String [ ] args ) { List < String > list = Arrays . asList ( " a " , " b " , " c " , " d " , " e " ) ; List < Integer > order = Arrays . asList ( 3 , 1 , 4 , 2 , 0 ) ; List < String > sorted = new ArrayList < > ( list . size ( ) ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { sorted . add ( null ) ; } for ( int i = 0 ; i < list . size ( ) ; i ++ ) { sorted . set ( order . get ( i ) , list . get ( i ) ) ; } System . out . println ( sorted ) ; } }
public static List < Integer > findAllPositionsOfMaxValue ( List < Integer > list ) { List < Integer > result = new ArrayList < > ( ) ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( list . get ( i ) > max ) { max = list . get ( i ) ; result . clear ( ) ; result . add ( i ) ; } else if ( list . get ( i ) == max ) { result . add ( i ) ; } } return result ; }
client . deleteFile ( " / path / to / file " ) ; client . deleteFolder ( " / path / to / folder " ) ;
WebElement element = driver . findElement ( By . xpath ( " // * [ contains ( @ onclick , ▁ ' clickMe ' ) ] " ) ) ; element . click ( ) ;
String str = " ▁ ▁ ▁ Hello ▁ World ▁ ▁ ▁ " ; str = str . replaceAll ( " \\ s + " , " " ) ;
public static void main ( String [ ] args ) { String [ ] numbers = "1.2.3.4.5.6.7.8.9.10" . split ( " \\ . " ) ; Arrays . sort ( numbers , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { return Integer . valueOf ( o1 ) . compareTo ( Integer . valueOf ( o2 ) ) ; } } ) ; System . out . println ( Arrays . toString ( numbers ) ) ; }
String regex = " ( \\ d + ) " ; String string = "12345" ; String subst = " $ 1a " ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( string ) ; String result = matcher . replaceAll ( subst ) ; System . out . println ( result ) ;
List < List < String > > listOfLists = new ArrayList < > ( ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ; listOfLists . add ( new ArrayList < > ( ) ) ;
public static int countEnd ( String str , char c ) { int count = 0 ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == c ) { count ++ ; } else { break ; } } return count ; }
public static int sum ( int [ ] arr ) { int sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum += Math . pow ( arr [ i ] , i ) ; } return sum ; }
import java . util . Random ; public class RandomColor { public static void main ( String [ ] args ) { Random random = new Random ( ) ; int r = random . nextInt ( 256 ) ; int g = random . nextInt ( 256 ) ; int b = random . nextInt ( 256 ) ; System . out . println ( " r ▁ = ▁ " + r ) ; System . out . println ( " g ▁ = ▁ " + g ) ; System . out . println ( " b ▁ = ▁ " + b ) ; } }
import org . jfree . chart . ChartFactory ; import org . jfree . chart . ChartPanel ; import org . jfree . chart . JFreeChart ; import org . jfree . chart . axis . AxisLocation ; import org . jfree . chart . axis . NumberAxis ; import org . jfree . chart . plot . PlotOrientation ; import org . jfree . chart . plot . XYPlot ; import org . jfree . data . xy . XYDataset ; import org . jfree . data . xy . XYSeries ; import org . jfree . data . xy . XYSeriesCollection ; import org . jfree . ui . ApplicationFrame ; import org . jfree . ui . RefineryUtilities ; public class XYPlotDemo2 extends ApplicationFrame { public XYPlotDemo2 ( String title ) { super ( title ) ; XYDataset dataset = createDataset ( ) ; JFreeChart chart = createChart ( dataset ) ; ChartPanel chartPanel = new ChartPanel ( chart ) ; chartPanel . setPreferredSize ( new java . awt . Dimension ( 500 , 270 ) ) ; setContentPane ( chartPanel ) ; } private XYDataset createDataset ( ) { XYSeries series1 = new XYSeries ( " First " ) ; series1 . add ( 1.0 , 1.0 ) ; series1 . add ( 2.0 , 4.0 ) ; series1 . add ( 3.0 , 3.0 ) ; series1 . add ( 4.0 , 5.0 ) ; series1 . add ( 5.0 , 5.0 ) ; series1 . add ( 6.0 , 7.0 ) ; series1 . add ( 7.0 , 7.0 ) ; series1 . add ( 8.0 , 8.0 ) ; XYSeries series2 = new XYSeries ( " Second " ) ; series2 . add ( 1.0 , 5.0 ) ; series2 . add ( 2.0 , 7.0 ) ; series2 . add ( 3.0 , 6.0 ) ; series2 . add ( 4.0 , 8.0 ) ;
String str = " Hello ▁ World " ; String result = str . replaceAll ( " \\ w * ( World ) \\ w * " , " $ 1" ) ;
List < String > list1 = Arrays . asList ( " A " , " B " , " C " ) ; List < String > list2 = Arrays . asList ( " D " , " E " , " F " ) ; List < String > list3 = Arrays . asList ( " G " , " H " , " I " ) ; List < String > result = Stream . of ( list1 , list2 , list3 ) . flatMap ( Collection :: stream ) . collect ( Collectors . toList ( ) ) ;
@ RequestMapping ( value = " / " , method = RequestMethod . GET ) public ResponseEntity < String > get ( ) { HttpHeaders headers = new HttpHeaders ( ) ; headers . add ( " Content - Type " , " application / json ; ▁ charset = utf - 8" ) ; return new ResponseEntity < String > ( " { \" message \" : ▁ \" Hello ▁ World \" } " , headers , HttpStatus . OK ) ; }
public static < T > List < List < T > > allCombinations ( List < List < T > > lists ) { List < List < T > > result = new ArrayList < > ( ) ; allCombinations ( lists , 0 , new ArrayList < > ( ) , result ) ; return result ; } private static < T > void allCombinations ( List < List < T > > lists , int depth , List < T > current , List < List < T > > result ) { if ( depth == lists . size ( ) ) { result . add ( current ) ; return ; } for ( T element : lists . get ( depth ) ) { List < T > copy = new ArrayList < > ( current ) ; copy . add ( element ) ; allCombinations ( lists , depth + 1 , copy , result ) ; } }
String fileName = " file . txt " ; String line = null ; StringBuilder sb = new StringBuilder ( ) ; try { FileReader fileReader = new FileReader ( fileName ) ; BufferedReader bufferedReader = new BufferedReader ( fileReader ) ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { sb . append ( line . replaceAll ( " \\ ^ M " , " " ) ) ; } bufferedReader . close ( ) ; } catch ( FileNotFoundException ex ) { System . out . println ( " Unable ▁ to ▁ open ▁ file ▁ ' " + fileName + " ' " ) ; } catch ( IOException ex ) { System . out . println ( " Error ▁ reading ▁ file ▁ ' " + fileName + " ' " ) ; }
String [ ] list = { " a " , " b " , " c " } ; String [ ] newList = new String [ list . length + 1 ] ; System . arraycopy ( list , 0 , newList , 0 , list . length ) ; newList [ list . length ] = " d " ;
public static void main ( String [ ] args ) { String str = " abcdabcd " ; Set < Character > set = new HashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { set . add ( str . charAt ( i ) ) ; } System . out . println ( set ) ; }
public class User { @ Id private String id ; @ Required private String name ; @ Required private String email ; @ Required private String password ; @ Required private String role ; @ Required private String status ; @ Required private String createdAt ; @ Required private String updatedAt ; }
public static float bytesToFloat ( byte [ ] bytes ) { return ByteBuffer . wrap ( bytes ) . getFloat ( ) ; }
Map < String , Object > map = new HashMap < > ( ) ; for ( Map . Entry < String , Object > entry : generator . entrySet ( ) ) { map . put ( entry . getKey ( ) , entry . getValue ( ) ) ; }
public class Binary4Tuple { public static void main ( String [ ] args ) { for ( int i = 0 ; i < 16 ; i ++ ) { System . out . println ( String . format ( " % 4s " , Integer . toBinaryString ( i ) ) . replace ( ' ▁ ' , '0' ) ) ; } } }
Arrays . sort ( arr , ( a , b ) -> { if ( a . equals ( b ) ) { return 0 ; } if ( a . length ( ) == b . length ( ) ) { return a . compareTo ( b ) ; } return a . length ( ) - b . length ( ) ; } ) ;
for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { System . out . println ( entry . getKey ( ) + " / " + entry . getValue ( ) ) ; }
import java . io . * ; import java . util . * ; import java . text . * ; import java . math . * ; import java . util . regex . * ; public class Solution { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; String [ ] arr = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = in . next ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( arr [ i ] ) ; } } }
public class Main { public static void main ( String [ ] args ) { Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; map . put ( " d " , 4 ) ; map . put ( " e " , 5 ) ; map . put ( " f " , 6 ) ; map . put ( " g " , 7 ) ; map . put ( " h " , 8 ) ; map . put ( " i " , 9 ) ; map . put ( " j " , 10 ) ; map . put ( " k " , 11 ) ; map . put ( " l " , 12 ) ; map . put ( " m " , 13 ) ; map . put ( " n " , 14 ) ; map . put ( " o " , 15 ) ; map . put ( " p " , 16 ) ; map . put ( " q " , 17 ) ; map . put ( " r " , 18 ) ; map . put ( " s " , 19 ) ; map . put ( " t " , 20 ) ; map . put ( " u " , 21 ) ; map . put ( " v " , 22 ) ; map . put ( " w " , 23 ) ; map . put ( " x " , 24 ) ; map . put ( " y " , 25 ) ; map . put ( " z " , 26 ) ; List < String > keys = new ArrayList < > ( map . keySet ( ) ) ; List < Integer > values = new ArrayList < > ( map . values ( ) ) ; System . out . println ( keys ) ; System . out . println ( values ) ; } }
String [ ] suffixes = { " a " , " b " , " c " } ; String str = " abc " ; for ( String suffix : suffixes ) { if ( str . endsWith ( suffix ) ) { System . out . println ( " String ▁ ends ▁ with ▁ " + suffix ) ; } }
class Student { private int id ; private String fname ; private double cgpa ; public Student ( int id , String fname , double cgpa ) { super ( ) ; this . id = id ; this . fname = fname ; this . cgpa = cgpa ; } public int getId ( ) { return id ; } public String getFname ( ) { return fname ; } public double getCgpa ( ) { return cgpa ; } } public class Solution { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int testCases = Integer . parseInt ( in . nextLine ( ) ) ; List < Student > studentList = new ArrayList < Student > ( ) ; while ( testCases > 0 ) { int id = in . nextInt ( ) ; String fname = in . next ( ) ; double cgpa = in . nextDouble ( ) ; Student st = new Student ( id , fname , cgpa ) ; studentList . add ( st ) ; testCases -- ; } Collections . sort ( studentList , new Comparator < Student > ( ) { @ Override public int compare ( Student s1 , Student s2 ) { if ( s1 . getCgpa ( ) == s2 . getCgpa ( ) ) { if ( s1 . getFname ( ) . equals ( s2 . getFname ( ) ) ) { return s1 . getId ( ) - s2 . getId ( ) ; } else { return s1 . getFname ( ) . compareTo ( s2 . getFname ( ) ) ; } } else { return ( int ) ( s2 . getCgpa ( ) - s1 . getCgpa ( ) ) ; } } } ) ; for ( Student st : studentList ) { System . out . println ( st . getFname ( ) ) ; } } }
public static int sumOfProductOfCombinations ( List < Integer > list ) { int sum = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < list . size ( ) ; j ++ ) { sum += list . get ( i ) * list . get ( j ) ; } } return sum ; }
File file = new File ( " file . txt " ) ; file . delete ( ) ;
Map < String , String > map = new HashMap < String , String > ( ) ; map . put ( " key1" , " value1" ) ; map . put ( " key2" , " value2" ) ; map . put ( " key3" , " value3" ) ; String value = map . get ( " key1" ) ;
DateFormat df = new SimpleDateFormat ( " yyyy - MM - dd " ) ; Date date = df . parse ( "2018-01-01" ) ;
public static < T > T nthToLast ( LinkedList < T > list , int n ) { if ( list . isEmpty ( ) ) { return null ; } LinkedList < T > reversed = new LinkedList < T > ( ) ; while ( ! list . isEmpty ( ) ) { reversed . addFirst ( list . removeFirst ( ) ) ; } T result = null ; for ( int i = 0 ; i < n ; i ++ ) { result = reversed . removeFirst ( ) ; } while ( ! reversed . isEmpty ( ) ) { list . addFirst ( reversed . removeFirst ( ) ) ; } return result ; }
public static < T > void sort ( List < T > list , List < ? extends Comparable < ? super T > > order ) { Map < T , Integer > index = new HashMap < T , Integer > ( ) ; for ( int i = 0 ; i < order . size ( ) ; i ++ ) { index . put ( order . get ( i ) , i ) ; } Collections . sort ( list , new Comparator < T > ( ) { @ Override public int compare ( T o1 , T o2 ) { return index . get ( o1 ) - index . get ( o2 ) ; } } ) ; }
List < String > list1 = Arrays . asList ( " a " , " b " , " c " ) ; List < String > list2 = Arrays . asList ( "1" , "2" , "3" ) ; List < String > list3 = Arrays . asList ( " x " , " y " , " z " ) ; List < List < String > > lists = Arrays . asList ( list1 , list2 , list3 ) ; List < String > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < list1 . size ( ) ; i ++ ) { for ( List < String > list : lists ) { result . add ( list . get ( i ) ) ; } } System . out . println ( result ) ;
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; for ( Map . Entry < String , Integer > entry : map . entrySet ( ) ) { System . out . println ( entry . getKey ( ) + " : ▁ " + entry . getValue ( ) ) ; }
public static void main ( String [ ] args ) { List < Integer > list1 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list2 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list3 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list4 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list5 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list6 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list7 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list8 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list9 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list10 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list11 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list12 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list13 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > list14 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8
public class Book { private String name ; private List < Author > authors ; } public class Author { private String name ; private List < Book > books ; } public class BookRepository { public List < Book > findByAuthors ( List < Author > authors ) { } }
@ DELETE @ Path ( " / { id } " ) public Response delete ( @ PathParam ( " id " ) int id ) { try { User user = userService . findById ( id ) ; userService . delete ( user ) ; return Response . status ( Response . Status . OK ) . build ( ) ; } catch ( Exception e ) { return Response . status ( Response . Status . NOT_FOUND ) . build ( ) ; } }
List < Integer > list1 = Arrays . asList ( 1 , 2 , 3 ) ; List < Integer > list2 = Arrays . asList ( 4 , 5 , 6 ) ; List < Integer > list3 = new ArrayList < > ( ) ; for ( int i = 0 ; i < list1 . size ( ) ; i ++ ) { list3 . add ( list1 . get ( i ) + list2 . get ( i ) ) ; } System . out . println ( list3 ) ;
Map < String , Map < String , String > > map = list . stream ( ) . collect ( Collectors . groupingBy ( e -> e . get ( " id " ) , Collectors . toMap ( e -> e . get ( " key " ) , e -> e . get ( " value " ) ) ) ) ;
LocalDate today = LocalDate . now ( ) ; LocalDate other = LocalDate . of ( 2012 , Month . MARCH , 12 ) ; if ( today . equals ( other ) ) { System . out . println ( " Today ▁ and ▁ date ▁ are ▁ the ▁ same ▁ day ! " ) ; }
Map < String , String > map = new HashMap < String , String > ( ) ; for ( String [ ] array : list ) { map . put ( array [ 0 ] , array [ 1 ] ) ; }
String s = " ▁ ▁ Hello ▁ World ▁ ▁ " ; s = s . trim ( ) ;
String str = "30M1000N20M " ; String [ ] strs = str . split ( " ( ? < = \\ D ) ( ? = \\ d ) | ( ? < = \\ d ) ( ? = \\ D ) " ) ;
String name = " John ▁ Doe " ; Pattern pattern = Pattern . compile ( " ^ [ A - Z ] [ a - z ] + \\ s [ A - Z ] [ a - z ] + $ " ) ; Matcher matcher = pattern . matcher ( name ) ; if ( matcher . matches ( ) ) { System . out . println ( " Name ▁ is ▁ valid " ) ; } else { System . out . println ( " Name ▁ is ▁ invalid " ) ; }
int [ ] a = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; List < Integer > nonZeroIndices = new ArrayList < > ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] != 0 ) { nonZeroIndices . add ( i ) ; } }
Legend legend = chart . getLegend ( ) ; legend . setFrame ( BlockBorder . NONE ) ;
import java . awt . Color ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . geom . Ellipse2D ; import java . awt . geom . Line2D ; import javax . swing . JComponent ; public class PlotComponent extends JComponent { public void paintComponent ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; Ellipse2D . Double circle = new Ellipse2D . Double ( 0 , 0 , 20 , 20 ) ; g2 . draw ( circle ) ; Line2D . Double line = new Line2D . Double ( 0 , 0 , 20 , 20 ) ; g2 . draw ( line ) ; } } ```NEW_LINE``` java import javax . swing . JFrame ; public class PlotFrame extends JFrame { public PlotFrame ( ) { setSize ( 300 , 400 ) ; setTitle ( " Plot ▁ Frame " ) ; PlotComponent component = new PlotComponent ( ) ; add ( component ) ; } } ```NEW_LINE``` java import javax . swing . JFrame ; public class PlotViewer { public static void main ( String [ ] args ) { JFrame frame = new PlotFrame ( ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; } }
import java . io . BufferedReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . net . URL ; import java . net . URLConnection ; public class Main { public static void main ( String [ ] args ) throws IOException { URL url = new URL ( " https : // jsonplaceholder . typicode . com / todos / 1" ) ; URLConnection connection = url . openConnection ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( connection . getInputStream ( ) ) ) ; String inputLine ; StringBuilder content = new StringBuilder ( ) ; while ( ( inputLine = in . readLine ( ) ) != null ) { content . append ( inputLine ) ; } in . close ( ) ; FileWriter fileWriter = new FileWriter ( " todo . json " ) ; fileWriter . write ( content . toString ( ) ) ; fileWriter . close ( ) ; } }
Collections . sort ( list , new Comparator < Tuple > ( ) { @ Override public int compare ( Tuple o1 , Tuple o2 ) { return o1 . getKey ( ) . compareTo ( o2 . getKey ( ) ) ; } } ) ;
List < String > list1 = Arrays . asList ( " a " , " b " , " c " ) ; List < String > list2 = Arrays . asList ( " d " , " e " , " f " ) ; List < String > list3 = new ArrayList < String > ( ) ; list3 . addAll ( list1 ) ; list3 . addAll ( list2 ) ;
List < Integer > list = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > greaterThanFive = list . stream ( ) . filter ( i -> i > 5 ) . collect ( Collectors . toList ( ) ) ;
public class Solution { public boolean isMatch ( String s , String p ) { if ( s == null || p == null ) { return false ; } boolean [ ] [ ] dp = new boolean [ s . length ( ) + 1 ] [ p . length ( ) + 1 ] ; dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < p . length ( ) ; i ++ ) { if ( p . charAt ( i ) == ' * ' && dp [ 0 ] [ i - 1 ] ) { dp [ 0 ] [ i + 1 ] = true ; } } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = 0 ; j < p . length ( ) ; j ++ ) { if ( p . charAt ( j ) == ' . ' ) { dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] ; } if ( p . charAt ( j ) == s . charAt ( i ) ) { dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] ; } if ( p . charAt ( j ) == ' * ' ) { if ( p . charAt ( j - 1 ) != s . charAt ( i ) && p . charAt ( j - 1 ) != ' . ' ) { dp [ i + 1 ] [ j + 1 ] = dp [ i + 1 ] [ j - 1 ] ; } else { dp [ i + 1 ] [ j + 1 ] = ( dp [ i + 1 ] [ j ] || dp [ i ] [ j + 1 ] || dp [ i + 1 ] [ j - 1 ] ) ; } } } } return dp [ s . length ( ) ] [ p . length ( ) ] ; } }
List < String > list = new ArrayList < String > ( ) ; list . add ( " item1" ) ; list . add ( " item2" ) ; list . add ( " item3" ) ;
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = scanner . nextInt ( ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( a [ i ] + a [ j ] + a [ k ] == 0 ) { count ++ ; } } } } System . out . println ( count ) ; } }
System . out . print ( " Hello " ) ; System . out . print ( " World " ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list . add ( " " ) ; list .
Collections . sort ( list , new Comparator < List < Integer > > ( ) { @ Override public int compare ( List < Integer > o1 , List < Integer > o2 ) { if ( o1 . get ( 0 ) == o2 . get ( 0 ) ) { return o1 . get ( 1 ) - o2 . get ( 1 ) ; } else { return o1 . get ( 0 ) - o2 . get ( 0 ) ; } } } ) ;
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; List < String > copy = new ArrayList < > ( list ) ;
import java . net . URL ; import java . net . HttpURLConnection ; public class CheckURL { public static void main ( String [ ] args ) { try { URL url = new URL ( " http : // www . google . com " ) ; HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestMethod ( " GET " ) ; connection . connect ( ) ; int code = connection . getResponseCode ( ) ; System . out . println ( " Response ▁ code ▁ of ▁ the ▁ object ▁ is ▁ " + code ) ; if ( code == 200 ) { System . out . println ( " OK " ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
String [ ] array1 = { " a " , " b " , " c " , " d " , " e " , " f " } ; String [ ] array2 = { " b " , " d " , " f " } ; List < String > list = new ArrayList < String > ( Arrays . asList ( array1 ) ) ; list . removeAll ( Arrays . asList ( array2 ) ) ; array1 = list . toArray ( new String [ list . size ( ) ] ) ;
String s = " aabbccdd " ; s = s . replaceAll ( " ( . ) ( ? = . * \\ 1 ) " , " " ) ;
List < String > keys = new ArrayList < > ( ) ; for ( Map . Entry < String , Map < String , String > > entry : dict . entrySet ( ) ) { keys . addAll ( entry . getValue ( ) . keySet ( ) ) ; }
import java . io . File ; import java . text . SimpleDateFormat ; public class FileDate { public static void main ( String [ ] args ) { File file = new File ( " / tmp / foo . txt " ) ; SimpleDateFormat sdf = new SimpleDateFormat ( " MM / dd / yyyy ▁ HH : mm : ss " ) ; System . out . println ( " Last ▁ Modified ▁ Date : ▁ " + sdf . format ( file . lastModified ( ) ) ) ; System . out . println ( " Created ▁ Date : ▁ " + sdf . format ( file . lastModified ( ) ) ) ; } }
public static int nthOccurrence ( String str , char c , int n ) { int pos = str . indexOf ( c , 0 ) ; while ( n -- > 0 && pos != - 1 ) pos = str . indexOf ( c , pos + 1 ) ; return pos ; }
public class NullCoalescingOperator { public static void main ( String [ ] args ) { String s = null ; String s2 = " " ; String s3 = " Hello " ; String s4 = " World " ; String s5 = " ! " ; String s6 = null ; String s7 = " " ; String s8 = " Hello " ; String s9 = " World " ; String s10 = " ! " ; String s11 = null ; String s12 = " " ; String s13 = " Hello " ; String s14 = " World " ; String s15 = " ! " ; String s16 = null ; String s17 = " " ; String s18 = " Hello " ; String s19 = " World " ; String s20 = " ! " ; String s21 = null ; String s22 = " " ; String s23 = " Hello " ; String s24 = " World " ; String s25 = " ! " ; String s26 = null ; String s27 = " " ; String s28 = " Hello " ; String s29 = " World " ; String s30 = " ! " ; String s31 = null ; String s32 = " " ; String s33 = " Hello " ; String s34 = " World " ; String s35 = " ! " ; String s36 = null ; String s37 = " " ; String s38 = " Hello " ; String s39 = " World " ; String s40 = " ! " ; String s41 = null ; String s42 = " " ; String s43 = " Hello " ; String s44 = " World " ; String s45 = " ! " ; String s46 = null ; String s47 = " " ; String s48 = " Hello " ; String s49 = " World " ; String s50 = " ! " ; String s51 = null ; String s52 = " " ; String s53 = " Hello " ; String s54 = " World " ; String s55 = " ! " ;
import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { try { Process p = Runtime . getRuntime ( ) . exec ( " ls ▁ - l " ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line = null ; while ( ( line = in . readLine ( ) ) != null ) { System . out . println ( line ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
List < String > list = new ArrayList < > ( ) ; list . add ( "1" ) ; list . add ( "2" ) ; list . add ( "3" ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . removeIf ( s -> ! s . matches ( " \\ d + " ) ) ;
String s = " Hello , ▁ World ! " ; s = s . replaceAll ( " \\ p { Punct } " , " " ) ;
public class Main { public static void main ( String [ ] args ) { Map < String , String > map = new HashMap < > ( ) ; map . put ( " key1" , " value1" ) ; map . put ( " key2" , " value2" ) ; map . put ( " key3" , " value3" ) ; System . out . println ( map ) ; } }
public static List < Integer > removeDuplicates ( List < Integer > list ) { List < Integer > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( i == 0 || list . get ( i ) != list . get ( i - 1 ) ) { result . add ( list . get ( i ) ) ; } } return result ; }
String s = " \\ x61 \\ x62 \\ x63" ; byte [ ] b = s . getBytes ( StandardCharsets . ISO_8859_1 ) ;
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; int max = 0 ; String maxKey = null ; for ( Map . Entry < String , Integer > entry : map . entrySet ( ) ) { if ( maxKey == null || entry . getValue ( ) > max ) { maxKey = entry . getKey ( ) ; max = entry . getValue ( ) ; } }
File file = new File ( " / path / to / file " ) ; if ( file . exists ( ) ) { }
String json = " { \" name \" : \" John \" , \" age \" : 30 , \" car \" : null } " ; JSONObject obj = new JSONObject ( json ) ; String name = obj . getString ( " name " ) ; int age = obj . getInt ( " age " ) ;
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; List < Map . Entry < String , Integer > > list = new ArrayList < > ( map . entrySet ( ) ) ; list . sort ( Map . Entry . comparingByValue ( ) ) ; for ( Map . Entry < String , Integer > entry : list ) { System . out . println ( entry . getKey ( ) + " : ▁ " + entry . getValue ( ) ) ; }
List < Integer > list = Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ; List < Integer > result = new ArrayList < > ( ) ; for ( Integer element : list ) { result . add ( element + 1 ) ; }
String url = " http : // www . example . com / index . html ? param1 = value1 & param2 = value2" ; String urlWithoutParams = url . split ( " \\ ? " ) [ 0 ] ;
String dateString = "2018-01-01T00:00:00.000Z " ; DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( " yyyy - MM - dd ' T ' HH : mm : ss . SSS ' Z ' " ) ; LocalDateTime dateTime = LocalDateTime . parse ( dateString , formatter ) ;
public static String removeFinalCharacters ( String str , int n ) { if ( str . length ( ) <= n ) { return " " ; } return removeFinalCharacters ( str . substring ( 0 , str . length ( ) - 1 ) , n ) ; }
String text = " " ; Elements elements = doc . select ( " div . class " ) ; for ( Element element : elements ) { text = element . text ( ) ; }
int largestIntLessThanX ( int x ) { return x - 1 ; }
List < Integer > numbers = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; boolean allEven = numbers . stream ( ) . allMatch ( n -> n % 2 == 0 ) ;
String [ ] cmd = { " / bin / sh " , " - c " , " echo ▁ ' hello ' ▁ | ▁ grep ▁ ' hello ' " } ; Process p = Runtime . getRuntime ( ) . exec ( cmd ) ;
String dateString = "2018-01-01" ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd " ) ; Date date = sdf . parse ( dateString ) ; sdf = new SimpleDateFormat ( " yyyyMMdd " ) ; String newDateString = sdf . format ( date ) ;
List < List < String > > listOfLists = new ArrayList < > ( ) ; List < String > list1 = new ArrayList < > ( ) ; list1 . add ( " a " ) ; list1 . add ( " b " ) ; list1 . add ( " c " ) ; List < String > list2 = new ArrayList < > ( ) ; list2 . add ( " a " ) ; list2 . add ( " b " ) ; list2 . add ( " c " ) ; listOfLists . add ( list1 ) ; listOfLists . add ( list2 ) ; List < String > result = listOfLists . stream ( ) . flatMap ( Collection :: stream ) . distinct ( ) . collect ( Collectors . toList ( ) ) ;
FileWriter fw = new FileWriter ( " output . txt " , true ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; bw . write ( " Hello ▁ World " ) ; bw . newLine ( ) ; bw . close ( ) ;
String sentence = " This ▁ is ▁ a ▁ sentence " ; String [ ] words = sentence . split ( " ▁ " ) ; int [ ] lengths = new int [ words . length ] ; for ( int i = 0 ; i < words . length ; i ++ ) { lengths [ i ] = words [ i ] . length ( ) ; }
public static List < Map < String , Object > > split ( Map < String , List < Object > > map ) { List < Map < String , Object > > result = new ArrayList < > ( ) ; for ( Map . Entry < String , List < Object > > entry : map . entrySet ( ) ) { for ( Object value : entry . getValue ( ) ) { Map < String , Object > item = new HashMap < > ( ) ; item . put ( entry . getKey ( ) , value ) ; result . add ( item ) ; } } return result ; }
if ( ! list . contains ( item ) ) { }
String str = " " ; if ( str . isEmpty ( ) ) { System . out . println ( " String ▁ is ▁ empty " ) ; }
public static List < Integer > add ( List < Integer > a , List < Integer > b ) { List < Integer > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { result . add ( a . get ( i ) + b . get ( i ) ) ; } return result ; }
String unicode = " \\ u0041 \\ u0042 \\ u0043" ; String normal = StringEscapeUtils . unescapeJava ( unicode ) ;
public static void main ( String [ ] args ) { List < String > tokens = Arrays . asList ( " a " , " b " , " c " ) ; List < String > result = new ArrayList < > ( ) ; generateAllStrings ( tokens , result , 0 , " " ) ; System . out . println ( result ) ; } private static void generateAllStrings ( List < String > tokens , List < String > result , int index , String current ) { if ( index == tokens . size ( ) ) { result . add ( current ) ; return ; } generateAllStrings ( tokens , result , index + 1 , current + tokens . get ( index ) ) ; generateAllStrings ( tokens , result , index + 1 , current ) ; }
int count = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( list . get ( i ) > 5 ) { count ++ ; } }
String url = " http : // www . example . com / index . html # top " ; String urlWithoutFragment = url . replaceAll ( " # . * " , " " ) ;
public static void main ( String [ ] args ) { int [ ] arr = new int [ 100 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = i ; } shuffleArray ( arr ) ; for ( int i = 0 ; i < 10 ; i ++ ) { System . out . println ( arr [ i ] ) ; } } static void shuffleArray ( int [ ] ar ) { Random rnd = ThreadLocalRandom . current ( ) ; for ( int i = ar . length - 1 ; i > 0 ; i -- ) { int index = rnd . nextInt ( i + 1 ) ; int a = ar [ index ] ; ar [ index ] = ar [ i ] ; ar [ i ] = a ; } }
public class Main { public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setSize ( 400 , 400 ) ; frame . setVisible ( true ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . toFront ( ) ; } }
String [ ] str = { "1" , "2" , "3" } ; List < Integer > list = new ArrayList < > ( ) ; for ( String s : str ) { list . add ( Integer . parseInt ( s ) ) ; }
public static int convert ( List < Integer > numbers ) { StringBuilder sb = new StringBuilder ( ) ; for ( int number : numbers ) { sb . append ( number ) ; } return Integer . parseInt ( sb . toString ( ) ) ; }
public static < T > Map < T , List < Tuple2 < T , T > >> splitByFirst ( List < Tuple2 < T , T > > list ) { Map < T , List < Tuple2 < T , T > > > map = new HashMap < > ( ) ; for ( Tuple2 < T , T > tuple : list ) { List < Tuple2 < T , T > > subList = map . get ( tuple . getFirst ( ) ) ; if ( subList == null ) { subList = new ArrayList < > ( ) ; map . put ( tuple . getFirst ( ) , subList ) ; } subList . add ( tuple ) ; } return map ; }
List < String > flatList = new ArrayList < > ( ) ; for ( List < String > list : listOfLists ) { flatList . addAll ( list ) ; }
import java . awt . Color ; import java . awt . Graphics2D ; import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import javax . imageio . ImageIO ; public class RemoveWhiteSpace { public static void main ( String [ ] args ) throws IOException { BufferedImage image = ImageIO . read ( new File ( " image . png " ) ) ; int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; int minX = width ; int minY = height ; int maxX = - 1 ; int maxY = - 1 ; for ( int y = 0 ; y < height ; y ++ ) { for ( int x = 0 ; x < width ; x ++ ) { int pixel = image . getRGB ( x , y ) ; if ( pixel != Color . WHITE . getRGB ( ) ) { if ( minX > x ) minX = x ; if ( maxX < x ) maxX = x ; if ( minY > y ) minY = y ; if ( maxY < y ) maxY = y ; } } } BufferedImage result = new BufferedImage ( maxX - minX + 1 , maxY - minY + 1 , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = result . createGraphics ( ) ; g . drawImage ( image , 0 , 0 , result . getWidth ( ) , result . getHeight ( ) , minX , minY , maxX + 1 , maxY + 1 , null ) ; g . dispose ( ) ; ImageIO . write ( result , " png " , new File ( " result . png " ) ) ; } }
Map < String , String > map = new HashMap < > ( ) ; map . put ( " key " , " value " ) ; map . remove ( " key " ) ;
String str = " Hello \n World " ; str = str . replaceAll ( " \ \r | \ \n " , " " ) ;
String str = " Hello ▁ World " ; boolean contains = str . contains ( " Hello " ) ;
String regex = " \\ d + " ; String text = "123 ▁ 456 ▁ 789" ; Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( text ) ; while ( matcher . find ( ) ) { System . out . println ( matcher . group ( ) ) ; }
public static double average ( List < Integer > list ) { double sum = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { sum += list . get ( i ) ; } return sum / list . size ( ) ; }
String str = " { \" name \" : \" John \" , \" age \" : 30 , \" car \" : null } " ; JSONObject json = new JSONObject ( str ) ; String name = json . getString ( " name " ) ; int age = json . getInt ( " age " ) ; System . out . println ( name ) ; System . out . println ( age ) ;
public static int countElements ( Map < String , Object > map ) { int count = 0 ; for ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) instanceof Map ) { count += countElements ( ( Map < String , Object > ) entry . getValue ( ) ) ; } else if ( entry . getValue ( ) instanceof List ) { for ( Object o : ( List < Object > ) entry . getValue ( ) ) { if ( o instanceof Map ) { count += countElements ( ( Map < String , Object > ) o ) ; } else { count ++ ; } } } else { count ++ ; } } return count ; }
String str = " Hello ▁ World " ; str = str . replaceAll ( " [ ^ a - zA - Z0-9 ] " , " " ) ;
String input = "1 ▁ fish ▁ 2 ▁ fish ▁ red ▁ fish ▁ blue ▁ fish " ; Scanner s = new Scanner ( input ) . useDelimiter ( " \\ s * fish \\ s * " ) ; System . out . println ( s . nextInt ( ) ) ; System . out . println ( s . nextInt ( ) ) ; System . out . println ( s . next ( ) ) ; System . out . println ( s . next ( ) ) ; s . close ( ) ;
float f = Float . parseFloat ( "3.14" ) ; int i = Integer . parseInt ( "123" ) ;
int sum = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { sum += list . get ( i ) ; }
import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; public class MD5Checksum { public static byte [ ] createChecksum ( String filename ) throws NoSuchAlgorithmException , IOException { File file = new File ( filename ) ; FileInputStream fis = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ 1024 ] ; MessageDigest complete = MessageDigest . getInstance ( " MD5" ) ; int numRead ; do { numRead = fis . read ( buffer ) ; if ( numRead > 0 ) { complete . update ( buffer , 0 , numRead ) ; } } while ( numRead != - 1 ) ; fis . close ( ) ; return complete . digest ( ) ; } public static String getMD5Checksum ( String filename ) throws NoSuchAlgorithmException , IOException { byte [ ] b = createChecksum ( filename ) ; String result = " " ; for ( int i = 0 ; i < b . length ; i ++ ) { result += Integer . toString ( ( b [ i ] & 0xff ) + 0x100 , 16 ) . substring ( 1 ) ; } return result ; } public static void main ( String args [ ] ) { try { System . out . println ( getMD5Checksum ( " test . txt " ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
String str = " Hello ▁ World " ; String sub = str . substring ( str . indexOf ( " ▁ " ) + 1 ) ;
List < Integer > list1 = Arrays . asList ( 1 , 2 , 3 , 4 , 5 ) ; List < Integer > list2 = Arrays . asList ( 3 , 4 , 5 , 6 , 7 ) ; list1 . stream ( ) . filter ( i -> ! list2 . contains ( i ) ) . collect ( Collectors . toList ( ) ) ;
int sum = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { sum += list . get ( i ) ; }
int random = ( int ) ( Math . random ( ) * 3 ) ; System . out . println ( random ) ;
public class Child extends Base { public Child ( int x ) { super ( x ) ; } }
DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; LocalDateTime dateTime = LocalDateTime . parse ( "2017-12-03 ▁ 10:15:30" , formatter ) ;
public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { System . out . println ( arr [ i ] + " ▁ " + arr [ j ] ) ; } } }
String s = " Hello ▁ World " ; s = s . substring ( 0 , s . length ( ) - 1 ) ;
import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; public class WriteToFile { public static void main ( String [ ] args ) { String [ ] [ ] data = new String [ 3 ] [ 2 ] ; data [ 0 ] [ 0 ] = "1" ; data [ 0 ] [ 1 ] = "2" ; data [ 1 ] [ 0 ] = "3" ; data [ 1 ] [ 1 ] = "4" ; data [ 2 ] [ 0 ] = "5" ; data [ 2 ] [ 1 ] = "6" ; try { File file = new File ( " C : \\ Users \\ User \\ Desktop \\ test . txt " ) ; FileWriter writer = new FileWriter ( file ) ; for ( int i = 0 ; i < data . length ; i ++ ) { for ( int j = 0 ; j < data [ i ] . length ; j ++ ) { writer . write ( data [ i ] [ j ] + " ▁ " ) ; } writer . write ( " \r \n " ) ; } writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
Arrays . sort ( array , new Comparator < Map < String , Object > > ( ) { @ Override public int compare ( Map < String , Object > o1 , Map < String , Object > o2 ) { return o1 . get ( " name " ) . toString ( ) . compareTo ( o2 . get ( " name " ) . toString ( ) ) ; } } ) ;
public class Hierarchy { private final Map < String , List < String > > hierarchy ; public Hierarchy ( Map < String , List < String > > hierarchy ) { this . hierarchy = hierarchy ; } public List < String > getChildren ( String parent ) { return hierarchy . get ( parent ) ; } public List < String > getParents ( String child ) { return hierarchy . entrySet ( ) . stream ( ) . filter ( entry -> entry . getValue ( ) . contains ( child ) ) . map ( Map . Entry :: getKey ) . collect ( Collectors . toList ( ) ) ; } public List < String > getAncestors ( String child ) { List < String > ancestors = new ArrayList < > ( ) ; List < String > parents = getParents ( child ) ; ancestors . addAll ( parents ) ; parents . forEach ( parent -> ancestors . addAll ( getAncestors ( parent ) ) ) ; return ancestors ; } public List < String > getDescendants ( String parent ) { List < String > descendants = new ArrayList < > ( ) ; List < String > children = getChildren ( parent ) ; descendants . addAll ( children ) ; children . forEach ( child -> descendants . addAll ( getDescendants ( child ) ) ) ; return descendants ; } }
Date date = new Date ( ) ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; String formattedDate = sdf . format ( date ) ; System . out . println ( formattedDate ) ;
# The config file is located in the user 's home directory.NEW_LINE# The home directory is different on different platforms . # The following code is a cross - platform way to get the home directory . # Get the user 's home directory. home_dir = os . path . expanduser ( ' ~ ' ) # Get the full path to the config file . config_file_path = os . path . join ( home_dir , ' . config ' , ' my _ app ' , ' config . ini ' ) # Create the config parser object . config = configparser . ConfigParser ( ) # Read the config file . config . read ( config_file_path ) # Get the value of the " Server " setting in the " [ network ] " section . server = config . get ( ' network ' , ' server ' ) # Get the value of the " Port " setting in the " [ network ] " section . port = config . getint ( ' network ' , ' port ' ) # Get the value of the " Log ▁ File " setting in the " [ logging ] " section . log_file = config . get ( ' logging ' , ' log ▁ file ' ) # Get the value of the " Log ▁ Level " setting in the " [ logging ] " section . log_level = config . get ( ' logging ' , ' log ▁ level ' ) # Get the value of the " Log ▁ Format " setting in the " [ logging ] " section . log_format = config . get ( ' logging ' , ' log ▁ format ' ) # Print the values . print ( ' Server : ' , server ) print ( ' Port : ' , port ) print ( ' Log ▁ File : ' , log_file ) print ( ' Log ▁ Level : ' , log_level ) print ( ' Log ▁ Format : ' , log_format ) # Write the config file . with open ( config_file_path , ' w ' ) as config_file : config . write ( config_file )
public static int getMaxStringLength ( List < List < String > > list ) { int maxLength = 0 ; for ( List < String > subList : list ) { for ( String s : subList ) { if ( s . length ( ) > maxLength ) { maxLength = s . length ( ) ; } } } return maxLength ; }
public class ReverseString { public static void main ( String [ ] args ) { String str = " Hello ▁ World " ; StringBuilder sb = new StringBuilder ( str ) ; System . out . println ( sb . reverse ( ) . toString ( ) ) ; } }
float f = 1.23456789f ; System . out . println ( String . format ( " % .2f " , f ) ) ;
int maxIndex = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( list . get ( i ) . getValue ( ) > list . get ( maxIndex ) . getValue ( ) ) { maxIndex = i ; } }
import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Scanner ; public class Replace { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner console = new Scanner ( System . in ) ; System . out . print ( " Input ▁ file : ▁ " ) ; String inputFileName = console . next ( ) ; System . out . print ( " Output ▁ file : ▁ " ) ; String outputFileName = console . next ( ) ; System . out . print ( " Old : ▁ " ) ; String old = console . next ( ) ; System . out . print ( " New : ▁ " ) ; String replacement = console . next ( ) ; File inputFile = new File ( inputFileName ) ; Scanner in = new Scanner ( inputFile ) ; PrintWriter out = new PrintWriter ( outputFileName ) ; while ( in . hasNextLine ( ) ) { String line = in . nextLine ( ) ; line = line . replace ( old , replacement ) ; out . println ( line ) ; } in . close ( ) ; out . close ( ) ; } }
public static int max ( int [ ] list , int length ) { int max = list [ 0 ] ; for ( int i = 1 ; i < length ; i ++ ) { if ( list [ i ] > max ) { max = list [ i ] ; } } return max ; }
List < String > list = new ArrayList < > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; String value = list . get ( 1 ) ;
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; map . put ( " d " , 4 ) ; for ( Map . Entry < String , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) == 3 ) { System . out . println ( entry . getKey ( ) ) ; } }
String s = " " ; if ( s . isEmpty ( ) ) { System . out . println ( " String ▁ is ▁ empty " ) ; }
String str = " Hello ▁ World " ; str = str . replaceFirst ( " Hello " , " Hi " ) ;
List < String > list1 = new ArrayList < String > ( ) ; list1 . add ( " a " ) ; list1 . add ( " b " ) ; list1 . add ( " c " ) ; List < String > list2 = new ArrayList < String > ( ) ; list2 . add ( " a " ) ; list2 . add ( " b " ) ; list1 . removeAll ( list2 ) ;
try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; }
import java . awt . Font ; import java . awt . Color ; import java . awt . Dimension ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . RenderingHints ; import java . awt . geom . AffineTransform ; import javax . swing . JFrame ; import javax . swing . JPanel ; public class Main extends JPanel { private void doDrawing ( Graphics g ) { Graphics2D g2d = ( Graphics2D ) g ; g2d . setColor ( Color . blue ) ; RenderingHints rh = new RenderingHints ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; rh . put ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_QUALITY ) ; g2d . setRenderingHints ( rh ) ; Font font = new Font ( " Serif " , Font . PLAIN , 24 ) ; g2d . setFont ( font ) ; g2d . drawString ( " Java ▁ 2D " , 50 , 50 ) ; AffineTransform at = new AffineTransform ( ) ; at . rotate ( Math . PI / 4 ) ; Font f = font . deriveFont ( at ) ; g2d . setFont ( f ) ; g2d . drawString ( " Java ▁ 2D " , 50 , 150 ) ; } @ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; doDrawing ( g ) ; } public static void main ( String [ ] args ) { JFrame frame = new JFrame ( " Java ▁ 2D " ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . add ( new Main ( ) ) ; frame . setSize ( 350 , 250 ) ; frame . setLocationRelativeTo ( null ) ; frame . setVisible ( true ) ; } }
String [ ] array = { " a " , " b " , " c " } ; String result = Arrays . toString ( array ) ;
String currentDir = System . getProperty ( " user . dir " ) ; String fileDir = new File ( " . " ) . getAbsolutePath ( ) ;
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; map . put ( " d " , 4 ) ; List < Map . Entry < String , Integer > > list = new ArrayList < > ( map . entrySet ( ) ) ; list . sort ( Comparator . comparing ( Map . Entry :: getValue ) ) ; list . sort ( Comparator . comparing ( Map . Entry :: getKey ) ) ;
List < String > keys = new ArrayList < > ( ) ; for ( Map < String , Object > map : list ) { keys . addAll ( map . keySet ( ) ) ; }
Collections . sort ( list , new Comparator < Tuple > ( ) { @ Override public int compare ( Tuple o1 , Tuple o2 ) { if ( o1 . getFirst ( ) == o2 . getFirst ( ) ) { return o1 . getSecond ( ) . compareTo ( o2 . getSecond ( ) ) ; } return o1 . getFirst ( ) . compareTo ( o2 . getFirst ( ) ) ; } } ) ;
File [ ] files = new File ( " / path / to / directory " ) . listFiles ( new FilenameFilter ( ) { @ Override public boolean accept ( File dir , String name ) { return name . endsWith ( " . txt " ) ; } } ) ;
Map < String , Object > attributes = object . getAttributes ( ) ;
String s = " Hello , ▁ World ! " ; s = s . replaceAll ( " ▁ " , " " ) ;
public static boolean isNumeric ( String str ) { try { double d = Double . parseDouble ( str ) ; } catch ( NumberFormatException nfe ) { return false ; } return true ; }
String s = " Price ▁ is ▁ $ 25.99" ; double price = Double . parseDouble ( s . substring ( s . indexOf ( ' $ ' ) + 1 ) ) ;
public static void main ( String [ ] args ) throws Exception { Class . forName ( " org . sqlite . JDBC " ) ; Connection conn = DriverManager . getConnection ( " jdbc : sqlite : test . db " ) ; Statement stat = conn . createStatement ( ) ; ResultSet rs = stat . executeQuery ( " select ▁ * ▁ from ▁ tbl1 ; " ) ; ResultSetMetaData rsmd = rs . getMetaData ( ) ; int columnCount = rsmd . getColumnCount ( ) ; for ( int i = 1 ; i <= columnCount ; i ++ ) { String name = rsmd . getColumnName ( i ) ; System . out . println ( name ) ; } }
List < Integer > indexes = IntStream . range ( 0 , list . size ( ) ) . filter ( i -> list . get ( i ) ) . boxed ( ) . collect ( Collectors . toList ( ) ) ;
Random random = new Random ( ) ; int randomNumber = random . nextInt ( 100 ) ;
public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int random = ( int ) ( Math . random ( ) * arr . length ) ; System . out . println ( arr [ random ] ) ; }
public static String reverseInPairs ( String input ) { char [ ] chars = input . toCharArray ( ) ; for ( int i = 0 ; i < chars . length - 1 ; i += 2 ) { char temp = chars [ i ] ; chars [ i ] = chars [ i + 1 ] ; chars [ i + 1 ] = temp ; } return new String ( chars ) ; }
public E peek ( ) { return ( size == 0 ) ? null : elements [ 0 ] ; }
String s = " Hello " ; byte [ ] bytes = s . getBytes ( " UTF - 8" ) ;
import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { int [ ] [ ] ndarray = { { 1 , 2 , 3 } , { 4 , 5 , 6 } } ; int [ ] array = Arrays . stream ( ndarray ) . flatMapToInt ( Arrays :: stream ) . toArray ( ) ; System . out . println ( Arrays . toString ( array ) ) ; } }
String s = " aabfooaabfooabfoob " ; String [ ] tokens = s . split ( " a * b " ) ; for ( String token : tokens ) { System . out . println ( token ) ; }
Map < String , Integer > map = new HashMap < > ( ) ; map . put ( " a " , 1 ) ; map . put ( " b " , 2 ) ; map . put ( " c " , 3 ) ; map . put ( " d " , 4 ) ; map . put ( " e " , 5 ) ; map . entrySet ( ) . removeIf ( entry -> entry . getValue ( ) > 3 ) ;
String str = " This ▁ is ▁ a ▁ ' string ' " ; str = str . replace ( " ' " , " " ) ;
public static void main ( String [ ] args ) { List < Tuple > list = new ArrayList < > ( ) ; list . add ( new Tuple ( " a " , " b " ) ) ; list . add ( new Tuple ( " c " , " d " ) ) ; list . add ( new Tuple ( " e " , " f " ) ) ; list . add ( new Tuple ( " g " , " h " ) ) ; list . add ( new Tuple ( " i " , " j " ) ) ; list . add ( new Tuple ( " k " , " l " ) ) ; list . add ( new Tuple ( " m " , " n " ) ) ; list . add ( new Tuple ( " o " , " p " ) ) ; list . add ( new Tuple ( " q " , " r " ) ) ; list . add ( new Tuple ( " s " , " t " ) ) ; list . add ( new Tuple ( " u " , " v " ) ) ; list . add ( new Tuple ( " w " , " x " ) ) ; list . add ( new Tuple ( " y " , " z " ) ) ; list . add ( new Tuple ( "1" , "2" ) ) ; list . add ( new Tuple ( "3" , "4" ) ) ; list . add ( new Tuple ( "5" , "6" ) ) ; list . add ( new Tuple ( "7" , "8" ) ) ; list . add ( new Tuple ( "9" , "0" ) ) ; list . add ( new Tuple ( " ! " , " @ " ) ) ; list . add ( new Tuple ( " # " , " $ " ) ) ; list . add ( new Tuple ( " % " , " ^ " ) ) ; list . add ( new Tuple ( " & " , " * " ) ) ; list . add ( new Tuple ( " ( " , " ) " ) ) ; list . add ( new Tuple ( " - " , " _ " ) ) ; list . add ( new Tuple ( " = " , " + " ) ) ; list . add ( new Tuple ( " [ " , " ] " ) ) ; list . add ( new Tuple ( " { " , " } " ) ) ; list . add ( new Tuple ( " ; " , " : " ) ) ; list . add ( new Tuple ( " ' " , " \" " ) ) ; list . add ( new Tuple ( "<
List < List < Integer > > subLists = new ArrayList < > ( ) ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) { subLists . add ( list . subList ( i , Math . min ( i + 2 , list . size ( ) ) ) ) ; }
List < Tuple > list = new ArrayList < > ( ) ; list . add ( new Tuple ( 1 , 2 ) ) ;
byte [ ] key = " key " . getBytes ( ) ; byte [ ] value = " value " . getBytes ( ) ; client . put ( key , value ) ; byte [ ] result = client . get ( key ) ;
public static int [ ] maxLength ( List < List < String > > list ) { int [ ] maxLength = new int [ list . get ( 0 ) . size ( ) ] ; for ( List < String > row : list ) { for ( int i = 0 ; i < row . size ( ) ; i ++ ) { maxLength [ i ] = Math . max ( maxLength [ i ] , row . get ( i ) . length ( ) ) ; } } return maxLength ; }
Calendar cal = Calendar . getInstance ( ) ; cal . add ( Calendar . MONTH , 6 ) ; Date date = cal . getTime ( ) ;
public static double [ ] removeNan ( double [ ] array ) { List < Double > list = new ArrayList < > ( ) ; for ( double d : array ) { if ( ! Double . isNaN ( d ) ) { list . add ( d ) ; } } double [ ] result = new double [ list . size ( ) ] ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { result [ i ] = list . get ( i ) ; } return result ; }
List < User > users = new Select ( ) . from ( User . class ) . join ( Profile . class ) . on ( " user . profile _ id ▁ = ▁ profile . id " ) . orderBy ( " profile . name " ) . execute ( ) ;
int sum = 0 ; for ( List < List < Integer > > listOfLists : listOfListsOfLists ) { for ( List < Integer > list : listOfLists ) { sum += list . get ( 1 ) ; } }
List < String > list = Arrays . asList ( " a " , " b " , " c " ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . println ( i + " : ▁ " + list . get ( i ) ) ; }
public static String removeDuplicates ( String s ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( sb . indexOf ( String . valueOf ( s . charAt ( i ) ) ) == - 1 ) { sb . append ( s . charAt ( i ) ) ; } } return sb . toString ( ) ; }
public static boolean isNot ( String str , String regex ) { return ! str . matches ( regex ) ; }
List < String > dates = new ArrayList < > ( ) ; Collections . sort ( dates , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { return o1 . compareTo ( o2 ) ; } } ) ;
import java . util . ArrayList ; import java . util . List ; import org . apache . commons . math3 . linear . RealMatrix ; public class MatrixToList { public static List < Double > matrixToList ( RealMatrix matrix ) { List < Double > list = new ArrayList < Double > ( ) ; for ( int i = 0 ; i < matrix . getRowDimension ( ) ; i ++ ) { for ( int j = 0 ; j < matrix . getColumnDimension ( ) ; j ++ ) { list . add ( matrix . getEntry ( i , j ) ) ; } } return list ; } }
String s = " aabbccddeeff " ; StringBuilder sb = new StringBuilder ( ) ; char last = ' \0' ; for ( char c : s . toCharArray ( ) ) { if ( c != last ) { sb . append ( c ) ; last = c ; } } System . out . println ( sb . toString ( ) ) ;
String [ ] array = { " a " , " b " , " c " , " d " , " e " } ; String [ ] result = Arrays . stream ( array ) . map ( s -> s . substring ( 0 , 1 ) ) . toArray ( String [ ] :: new ) ;
import com . google . appengine . tools . cloudstorage . GcsFileOptions ; import com . google . appengine . tools . cloudstorage . GcsFilename ; import com . google . appengine . tools . cloudstorage . GcsOutputChannel ; import com . google . appengine . tools . cloudstorage . GcsService ; import com . google . appengine . tools . cloudstorage . GcsServiceFactory ; import com . google . appengine . tools . cloudstorage . RetryParams ; import java . io . IOException ; import java . nio . channels . Channels ; public class GcsExample { private static final String BUCKETNAME = " my - bucket " ; private final GcsService gcsService = GcsServiceFactory . createGcsService ( RetryParams . getDefaultInstance ( ) ) ; public void writeFile ( String filename , byte [ ] content ) throws IOException { GcsFileOptions instance = GcsFileOptions . getDefaultInstance ( ) ; GcsFilename gcsFilename = new GcsFilename ( BUCKETNAME , filename ) ; GcsOutputChannel outputChannel ; outputChannel = gcsService . createOrReplace ( gcsFilename , instance ) ; outputChannel . write ( ByteBuffer . wrap ( content ) ) ; outputChannel . close ( ) ; } }
public class Solution { public String [ ] reorderLogFiles ( String [ ] logs ) { Arrays . sort ( logs , ( log1 , log2 ) -> { String [ ] split1 = log1 . split ( " ▁ " , 2 ) ; String [ ] split2 = log2 . split ( " ▁ " , 2 ) ; boolean isDigit1 = Character . isDigit ( split1 [ 1 ] . charAt ( 0 ) ) ; boolean isDigit2 = Character . isDigit ( split2 [ 1 ] . charAt ( 0 ) ) ; if ( ! isDigit1 && ! isDigit2 ) { int cmp = split1 [ 1 ] . compareTo ( split2 [ 1 ] ) ; if ( cmp != 0 ) return cmp ; return split1 [ 0 ] . compareTo ( split2 [ 0 ] ) ; } return isDigit1 ? ( isDigit2 ? 0 : 1 ) : - 1 ; } ) ; return logs ; } }
import java . awt . Color ; import java . awt . Font ; import java . awt . FontMetrics ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . Rectangle ; import java . awt . geom . Rectangle2D ; import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import javax . imageio . ImageIO ; public class Legend { public static void main ( String [ ] args ) throws IOException { List < String > labels = new ArrayList < String > ( ) ; labels . add ( " A " ) ; labels . add ( " B " ) ; labels . add ( " C " ) ; labels . add ( " D " ) ; labels . add ( " E " ) ; labels . add ( " F " ) ; labels . add ( " G " ) ; labels . add ( " H " ) ; labels . add ( " I " ) ; labels . add ( " J " ) ; labels . add ( " K " ) ; labels . add ( " L " ) ; labels . add ( " M " ) ; labels . add ( " N " ) ; labels . add ( " O " ) ; labels . add ( " P " ) ; labels . add ( " Q " ) ; labels . add ( " R " ) ; labels . add ( " S " ) ; labels . add ( " T " ) ; labels . add ( " U " ) ; labels . add ( " V " ) ; labels . add ( " W " ) ; labels . add ( " X " ) ; labels . add ( " Y " ) ; labels . add ( " Z " ) ; labels . add ( " AA " ) ; labels . add ( " AB " ) ; labels . add ( " AC " ) ; labels . add ( " AD " ) ; labels . add ( " AE " ) ; labels . add ( " AF " ) ; labels . add ( " AG " ) ; labels . add ( " AH " ) ; labels . add ( " AI " ) ; labels . add ( " AJ " ) ; labels . add ( " AK " ) ; labels . add ( " AL " ) ; labels . add ( " AM " ) ; labels . add ( " AN " ) ; labels .
List < String > list = new ArrayList < String > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; list . add ( " d " ) ; list . add ( " e " ) ; list . add ( " f " ) ; list . add ( " g " ) ; list . add ( " h " ) ; list . add ( " i " ) ; list . add ( " j " ) ; list . add ( " k " ) ; list . add ( " l " ) ; list . add ( " m " ) ; list . add ( " n " ) ; list . add ( " o " ) ; list . add ( " p " ) ; list . add ( " q " ) ; list . add ( " r " ) ; list . add ( " s " ) ; list . add ( " t " ) ; list . add ( " u " ) ; list . add ( " v " ) ; list . add ( " w " ) ; list . add ( " x " ) ; list . add ( " y " ) ; list . add ( " z " ) ; List < String > subList = list . subList ( 0 , 5 ) ;
public static List < Map < String , Object > > sort ( List < Map < String , Object > > list , String order ) { List < Map < String , Object > > sortedList = new ArrayList < > ( ) ; for ( String key : order . split ( " , " ) ) { for ( Map < String , Object > map : list ) { if ( map . get ( " key " ) . equals ( key ) ) { sortedList . add ( map ) ; } } } return sortedList ; }
public class IpConverter { public static long ipToLong ( String ipAddress ) { String [ ] ipAddressInArray = ipAddress . split ( " \\ . " ) ; long result = 0 ; for ( int i = 0 ; i < ipAddressInArray . length ; i ++ ) { int power = 3 - i ; int ip = Integer . parseInt ( ipAddressInArray [ i ] ) ; result += ip * Math . pow ( 256 , power ) ; } return result ; } public static String longToIp ( long ip ) { return ( ( ip >> 24 ) & 0xFF ) + " . " + ( ( ip >> 16 ) & 0xFF ) + " . " + ( ( ip >> 8 ) & 0xFF ) + " . " + ( ip & 0xFF ) ; } }
List < Integer > hexBytes = Arrays . asList ( "0x01" , "0x02" , "0x03" ) ; List < Integer > hexInts = hexBytes . stream ( ) . map ( Integer :: decode ) . collect ( Collectors . toList ( ) ) ;
String str = " a , b , c , d , e , f , g " ; String [ ] strs = str . split ( " , " ) ;
public static String decrypt ( String encrypted , String key , String iv ) throws Exception { Cipher cipher = Cipher . getInstance ( " AES / CBC / PKCS5Padding " ) ; SecretKeySpec secretKeySpec = new SecretKeySpec ( key . getBytes ( " UTF - 8" ) , " AES " ) ; IvParameterSpec ivParameterSpec = new IvParameterSpec ( iv . getBytes ( " UTF - 8" ) ) ; cipher . init ( Cipher . DECRYPT_MODE , secretKeySpec , ivParameterSpec ) ; byte [ ] decodedEncryptedData = Base64 . getDecoder ( ) . decode ( encrypted ) ; byte [ ] original = cipher . doFinal ( decodedEncryptedData ) ; return new String ( original ) ; }
I ' m ▁ trying ▁ to ▁ create ▁ a ▁ MITM ▁ proxy ▁ over ▁ SSL . ▁ I ' m using the following code : < code > import socket import ssl def mitm_proxy ( client_socket , server_socket ) : while True : data = client_socket . recv ( 1024 ) if not data : break server_socket . sendall ( data ) data = server_socket . recv ( 1024 ) if not data : break client_socket . sendall ( data ) def main ( ) : server_socket = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) server_socket . bind ( ( '', 8443)) server_socket . listen ( 5 ) while True : client_socket , addr = server_socket . accept ( ) print ( ' Got ▁ connection ▁ from ' , addr ) server_socket = ssl . wrap_socket ( socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) ) server_socket . connect ( ( ' localhost ' , 8443 ) ) mitm_proxy ( client_socket , server_socket ) if __name__ == ' _ _ main _ _ ' : main ( ) < / code > I 'm using the following Java code to connect to the proxy: < code > import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . net . Socket ; import java . net . UnknownHostException ; import javax . net . ssl . SSLSocketFactory ; public class Client { public static void main ( String [ ] args ) throws UnknownHostException , IOException { Socket socket = SSLSocketFactory . getDefault ( ) . createSocket ( " localhost " , 8443 ) ; PrintWriter out = new PrintWriter ( socket . getOutputStream ( ) , true ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) ) ) ; BufferedReader stdIn = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String userInput ; while ( ( userInput = stdIn . readLine ( ) )
String str = "1 , , 3,4,5" ; String [ ] strArr = str . split ( " , " ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String s : strArr ) { if ( s . isEmpty ( ) ) { sb . append ( "0 , " ) ; } else { sb . append ( s ) . append ( " , " ) ; } } System . out . println ( sb . toString ( ) ) ;
List < String > stringList = Arrays . asList ( "1" , "2" , "3" ) ; List < Integer > integerList = new ArrayList < > ( ) ; for ( String s : stringList ) { integerList . add ( Integer . parseInt ( s ) ) ; }
import java . util . regex . Pattern ; import java . util . regex . Matcher ; public class RegexMatches { public static void main ( String args [ ] ) { String line = " This ▁ order ▁ was ▁ placed ▁ for ▁ QT3000 ! ▁ OK ? " ; String pattern = " ( . * ) ( \\ d + ) ( . * ) " ; Pattern r = Pattern . compile ( pattern ) ; Matcher m = r . matcher ( line ) ; if ( m . find ( ) ) { System . out . println ( " Found ▁ value : ▁ " + m . group ( 0 ) ) ; System . out . println ( " Found ▁ value : ▁ " + m . group ( 1 ) ) ; System . out . println ( " Found ▁ value : ▁ " + m . group ( 2 ) ) ; } else { System . out . println ( " NO ▁ MATCH " ) ; } } }
List < Integer > list = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; List < Integer > firstThree = list . subList ( 0 , 3 ) ; List < Integer > lastThree = list . subList ( list . size ( ) - 3 , list . size ( ) ) ;
import requests from bs4 import BeautifulSoup url = ' https : // www . monster . com / jobs / search / ? q = Software - Developer & where = Australia ' page = requests . get ( url ) soup = BeautifulSoup ( page . content , ' html . parser ' ) results = soup . find ( id = ' ResultsContainer ' ) print ( results . prettify ( ) )
public static void main ( String [ ] args ) { List < Integer > list = Arrays . asList ( 1 , - 1 , 2 , - 2 , 3 , - 3 , 4 , - 4 , 5 , - 5 ) ; Collections . sort ( list , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { if ( o1 < 0 && o2 < 0 ) { return o2 - o1 ; } else if ( o1 < 0 ) { return 1 ; } else if ( o2 < 0 ) { return - 1 ; } else { return o1 - o2 ; } } } ) ; System . out . println ( list ) ; }
String str = " Hello ▁ World " ; boolean contains = str . contains ( " Hello " ) ;
String s = " \\ u0041 \\ u0042 \\ u0043" ; System . out . println ( s ) ;
import java . awt . Font ; import java . awt . FontMetrics ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . RenderingHints ; import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import javax . imageio . ImageIO ; public class FontSize { public static void main ( String [ ] args ) throws IOException { List < String > labels = new ArrayList < > ( ) ; labels . add ( " A " ) ; labels . add ( " B " ) ; labels . add ( " C " ) ; labels . add ( " D " ) ; labels . add ( " E " ) ; labels . add ( " F " ) ; labels . add ( " G " ) ; labels . add ( " H " ) ; labels . add ( " I " ) ; labels . add ( " J " ) ; labels . add ( " K " ) ; labels . add ( " L " ) ; labels . add ( " M " ) ; labels . add ( " N " ) ; labels . add ( " O " ) ; labels . add ( " P " ) ; labels . add ( " Q " ) ; labels . add ( " R " ) ; labels . add ( " S " ) ; labels . add ( " T " ) ; labels . add ( " U " ) ; labels . add ( " V " ) ; labels . add ( " W " ) ; labels . add ( " X " ) ; labels . add ( " Y " ) ; labels . add ( " Z " ) ; labels . add ( " AA " ) ; labels . add ( " AB " ) ; labels . add ( " AC " ) ; labels . add ( " AD " ) ; labels . add ( " AE " ) ; labels . add ( " AF " ) ; labels . add ( " AG " ) ; labels . add ( " AH " ) ; labels . add ( " AI " ) ; labels . add ( " AJ " ) ; labels . add ( " AK " ) ; labels . add ( " AL " ) ; labels . add ( " AM " ) ; labels . add ( " AN " ) ; labels . add ( " AO " ) ; labels . add ( " AP " ) ; labels . add ( "AQ
public static double magnitudeSquared ( double [ ] vector ) { double sum = 0 ; for ( int i = 0 ; i < vector . length ; i ++ ) { sum += vector [ i ] * vector [ i ] ; } return sum ; }
Map < String , String > map = new HashMap < > ( ) ; map . put ( " foo " , " bar " ) ; map . put ( " foobar " , " baz " ) ; map . entrySet ( ) . stream ( ) . filter ( e -> e . getKey ( ) . contains ( " foo " ) ) . forEach ( e -> System . out . println ( e . getKey ( ) + " : ▁ " + e . getValue ( ) ) ) ;
List < Tuple3 < String , Integer , Integer > > list = new ArrayList < > ( ) ; list . add ( new Tuple3 < > ( " a " , 1 , 2 ) ) ; list . add ( new Tuple3 < > ( " b " , 2 , 3 ) ) ; list . add ( new Tuple3 < > ( " c " , 3 , 4 ) ) ; list . add ( new Tuple3 < > ( " d " , 4 , 5 ) ) ; list . add ( new Tuple3 < > ( " e " , 5 , 6 ) ) ; list . add ( new Tuple3 < > ( " f " , 6 , 7 ) ) ; list . add ( new Tuple3 < > ( " g " , 7 , 8 ) ) ; list . add ( new Tuple3 < > ( " h " , 8 , 9 ) ) ; list . add ( new Tuple3 < > ( " i " , 9 , 10 ) ) ; list . add ( new Tuple3 < > ( " j " , 10 , 11 ) ) ; list . sort ( Comparator . comparingInt ( t -> t . _2 ( ) + t . _3 ( ) ) ) ; list . forEach ( System . out :: println ) ;
public static void sort ( List < List < String > > list , int ... keys ) { Collections . sort ( list , new Comparator < List < String > > ( ) { @ Override public int compare ( List < String > o1 , List < String > o2 ) { for ( int key : keys ) { int cmp = o1 . get ( key ) . compareTo ( o2 . get ( key ) ) ; if ( cmp != 0 ) { return cmp ; } } return 0 ; } } ) ; }
List < String > list = new ArrayList < String > ( ) ; list . add ( " a " ) ; list . add ( " b " ) ; list . add ( " c " ) ; if ( list . contains ( " a " ) ) { System . out . println ( " a ▁ is ▁ in ▁ the ▁ list " ) ; }
public static String getDayOfWeek ( String dateString ) { SimpleDateFormat format = new SimpleDateFormat ( " yyyy - MM - dd " ) ; Date date = null ; try { date = format . parse ( dateString ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; int dayOfWeek = calendar . get ( Calendar . DAY_OF_WEEK ) ; String dayOfWeekString = " " ; switch ( dayOfWeek ) { case 1 : dayOfWeekString = " Sunday " ; break ; case 2 : dayOfWeekString = " Monday " ; break ; case 3 : dayOfWeekString = " Tuesday " ; break ; case 4 : dayOfWeekString = " Wednesday " ; break ; case 5 : dayOfWeekString = " Thursday " ; break ; case 6 : dayOfWeekString = " Friday " ; break ; case 7 : dayOfWeekString = " Saturday " ; break ; } return dayOfWeekString ; }
List < Integer > list = new ArrayList < Integer > ( ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; list . add ( 4 ) ; list . add ( 5 ) ; list . removeIf ( i -> i % 2 == 0 ) ; System . out . println ( list ) ;
public static void reverse ( List < Integer > list ) { for ( int i = 0 ; i < list . size ( ) / 2 ; i ++ ) { int temp = list . get ( i ) ; list . set ( i , list . get ( list . size ( ) - i - 1 ) ) ; list . set ( list . size ( ) - i - 1 , temp ) ; } }
String [ ] sentences = text . split ( " \\ . " ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < sentences . length && i < maxSentences ; i ++ ) { sb . append ( sentences [ i ] ) ; if ( i < sentences . length - 1 ) { sb . append ( " . " ) ; } }
List < String > list = new ArrayList < > ( ) ; list . size ( ) ;
import java . awt . Dimension ; import java . awt . Toolkit ; import javax . swing . JFrame ; public class Main { public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setSize ( new Dimension ( 300 , 300 ) ) ; frame . setLocationRelativeTo ( null ) ; frame . setVisible ( true ) ; } }
String s = " Hello " ; System . out . println ( s . charAt ( 0 ) ) ; System . out . println ( s . charAt ( 4 ) ) ;
List < List < List < Integer > > > list = new ArrayList < > ( ) ; List < List < Integer > > list1 = new ArrayList < > ( ) ; List < Integer > list11 = new ArrayList < > ( ) ; list11 . add ( 1 ) ; list11 . add ( 2 ) ; list11 . add ( 3 ) ; list1 . add ( list11 ) ; List < Integer > list12 = new ArrayList < > ( ) ; list12 . add ( 4 ) ; list12 . add ( 5 ) ; list12 . add ( 6 ) ; list1 . add ( list12 ) ; list . add ( list1 ) ; List < List < Integer > > list2 = new ArrayList < > ( ) ; List < Integer > list21 = new ArrayList < > ( ) ; list21 . add ( 7 ) ; list21 . add ( 8 ) ; list21 . add ( 9 ) ; list2 . add ( list21 ) ; List < Integer > list22 = new ArrayList < > ( ) ; list22 . add ( 10 ) ; list22 . add ( 11 ) ; list22 . add ( 12 ) ; list2 . add ( list22 ) ; list . add ( list2 ) ; for ( List < List < Integer > > l : list ) { for ( List < Integer > l1 : l ) { for ( Integer i : l1 ) { System . out . println ( i ) ; } } }
List < String > values = new ArrayList < > ( ) ; for ( Map < String , String > map : list ) { values . add ( map . get ( " key " ) ) ; }
int sum = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { sum += list . get ( i ) . get ( 1 ) ; }
List < Map < String , Object > > list = new ArrayList < > ( ) ; Map < String , Object > map = new HashMap < > ( ) ; map . put ( " name " , " John " ) ; map . put ( " age " , 30 ) ; list . add ( map ) ; String name = ( String ) list . get ( 0 ) . get ( " name " ) ; Integer age = ( Integer ) list . get ( 0 ) . get ( " age " ) ;
import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import javax . imageio . ImageIO ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedImage image = ImageIO . read ( new File ( " image . png " ) ) ; int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; int [ ] pixels = image . getRGB ( 0 , 0 , width , height , null , 0 , width ) ; for ( int i = 0 ; i < pixels . length ; i ++ ) { int alpha = ( pixels [ i ] >> 24 ) & 0xff ; System . out . println ( alpha ) ; } } }
public static boolean isSubset ( List < Integer > list , List < Integer > sublist ) { return sublist . stream ( ) . allMatch ( list :: contains ) ; }
public static Map < String , String > merge ( List < Map < String , String > > maps ) { Map < String , String > result = new HashMap < > ( ) ; for ( Map < String , String > map : maps ) { result . putAll ( map ) ; } return result ; }
public class Solution { public boolean isMatch ( String s , String p ) { if ( s == null || p == null ) { return false ; } boolean [ ] [ ] dp = new boolean [ s . length ( ) + 1 ] [ p . length ( ) + 1 ] ; dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < p . length ( ) ; i ++ ) { if ( p . charAt ( i ) == ' * ' && dp [ 0 ] [ i - 1 ] ) { dp [ 0 ] [ i + 1 ] = true ; } } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = 0 ; j < p . length ( ) ; j ++ ) { if ( p . charAt ( j ) == ' . ' ) { dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] ; } if ( p . charAt ( j ) == s . charAt ( i ) ) { dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] ; } if ( p . charAt ( j ) == ' * ' ) { if ( p . charAt ( j - 1 ) != s . charAt ( i ) && p . charAt ( j - 1 ) != ' . ' ) { dp [ i + 1 ] [ j + 1 ] = dp [ i + 1 ] [ j - 1 ] ; } else { dp [ i + 1 ] [ j + 1 ] = ( dp [ i + 1 ] [ j ] || dp [ i ] [ j + 1 ] || dp [ i + 1 ] [ j - 1 ] ) ; } } } } return dp [ s . length ( ) ] [ p . length ( ) ] ; } }
JButton button = new JButton ( " Click ▁ me " ) ; button . setBackground ( Color . RED ) ; button . setForeground ( Color . WHITE ) ;
List < String > list = Arrays . asList ( "1" , "2" , "3" ) ; List < Integer > intList = list . stream ( ) . map ( Integer :: parseInt ) . collect ( Collectors . toList ( ) ) ;
import java . awt . Color ; import java . awt . Dimension ; import java . awt . Font ; import java . awt . Graphics ; import java . awt . Graphics2D ; import java . awt . RenderingHints ; import java . awt . geom . Ellipse2D ; import java . awt . geom . Line2D ; import java . awt . geom . Rectangle2D ; import java . util . ArrayList ; import java . util . List ; import javax . swing . JFrame ; import javax . swing . JPanel ; public class Plot extends JPanel { private static final long serialVersionUID = 1L ; private static final int MAX_SCORE = 20 ; private static final int PREF_W = 800 ; private static final int PREF_H = 650 ; private static final int BORDER_GAP = 30 ; private static final Color GRAPH_COLOR = Color . green ; private static final Color GRAPH_POINT_COLOR = new Color ( 150 , 50 , 50 , 180 ) ; private static final Stroke GRAPH_STROKE = new BasicStroke ( 3f ) ; private static final int GRAPH_POINT_WIDTH = 12 ; private static final int Y_HATCH_CNT = 10 ; private List < Integer > scores ; public Plot ( List < Integer > scores ) { this . scores = scores ; } @ Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; double xScale = ( ( double ) getWidth ( ) - 2 * BORDER_GAP ) / ( scores . size ( ) - 1 ) ; double yScale = ( ( double ) getHeight ( ) - 2 * BORDER_GAP ) / ( MAX_SCORE - 1 ) ;
String s = " abc \n " ; s = s . substring ( 0 , s . length ( ) - 1 ) ;
for ( int i = 0 ; i < set . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < set . size ( ) ; j ++ ) { } }
StringBuilder sb = new StringBuilder ( ) ; for ( byte b : bytes ) { sb . append ( String . format ( " % 02X ▁ " , b ) ) ; } System . out . println ( sb . toString ( ) ) ;
String dateString = "2018-01-01" ; DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( " yyyy - MM - dd " ) ; LocalDate date = LocalDate . parse ( dateString , formatter ) ;
int index = Collections . binarySearch ( list , value ) ; if ( index < 0 ) { index = - index - 1 ; }
List < Integer > list = new ArrayList < Integer > ( ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ;
String str = " Hello ▁ World " ; String firstTwoChars = str . substring ( 0 , 2 ) ;
String str = " Hello ▁ World " ; str = str . toLowerCase ( ) ;
@ RequestMapping ( value = " / { id } " , method = RequestMethod . GET ) public String get ( @ PathVariable ( " id " ) String id ) { return id ; }
public static int [ ] hex2Rgb ( String colorStr ) { return new int [ ] { Integer . valueOf ( colorStr . substring ( 1 , 3 ) , 16 ) , Integer . valueOf ( colorStr . substring ( 3 , 5 ) , 16 ) , Integer . valueOf ( colorStr . substring ( 5 , 7 ) , 16 ) } ; } public static String rgb2Hex ( int [ ] rgb ) { return String . format ( " # %02x % 02x % 02x " , rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; }
File file = new File ( " / path / to / file " ) ; File dir = new File ( " / path / to / dir " ) ; file . getCanonicalPath ( ) . startsWith ( dir . getCanonicalPath ( ) ) ;
import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import javax . imageio . ImageIO ; import javax . swing . ImageIcon ; import javax . swing . JFrame ; import javax . swing . JLabel ; public class DisplayImage { public static void main ( String [ ] args ) { BufferedImage img = null ; try { img = ImageIO . read ( new File ( " / Users / johndoe / Desktop / image . jpg " ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } ImageIcon icon = new ImageIcon ( img ) ; JFrame frame = new JFrame ( ) ; frame . setLayout ( new FlowLayout ( ) ) ; frame . setSize ( 200 , 300 ) ; JLabel lbl = new JLabel ( ) ; lbl . setIcon ( icon ) ; frame . add ( lbl ) ; frame . setVisible ( true ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; } }
String s = " Hello \n World " ; s = s . replace ( " \n " , " \r \n " ) ;
String [ ] strs = str . split ( " ▁ " ) ; int [ ] nums = new int [ strs . length ] ; for ( int i = 0 ; i < strs . length ; i ++ ) { nums [ i ] = Integer . parseInt ( strs [ i ] ) ; }
import java . awt . Dimension ; import java . awt . Toolkit ; public class Main { public static void main ( String [ ] args ) { Dimension screenSize = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; double width = screenSize . getWidth ( ) ; double height = screenSize . getHeight ( ) ; System . out . println ( " Screen ▁ resolution : ▁ " + width + " x " + height ) ; } }
public static int getClosest ( List < Integer > list , int given ) { int minDiff = Integer . MAX_VALUE ; int number = 0 ; for ( int num : list ) { int diff = Math . abs ( num - given ) ; if ( diff < minDiff ) { minDiff = diff ; number = num ; } } return number ; }
public Object lookup ( String name ) { Scope current = root ; while ( current != null ) { Object value = current . getAttribute ( name ) ; if ( value != null ) { return value ; } current = current . getParent ( ) ; } return null ; }
import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; public class DosLineBreaks { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new FileReader ( " file . txt " ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . endsWith ( " \r " ) ) { System . out . println ( " DOS ▁ line ▁ break ▁ detected " ) ; } } } }
