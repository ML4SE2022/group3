class Solution { public int [ ] twoSum ( int [ ] nums , int target ) { Map < Integer , Integer > numToIndex = new HashMap < > ( ) ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( numToIndex . containsKey ( target - nums [ i ] ) ) return new int [ ] { numToIndex . get ( target - nums [ i ] ) , i } ; numToIndex . put ( nums [ i ] , i ) ; } throw new IllegalArgumentException ( ) ; } } class Solution { public boolean isMatch ( String s , String p ) { final int m = s . length ( ) ; final int n = p . length ( ) ; boolean [ ] [ ] dp = new boolean [ m + 1 ] [ n + 1 ] ; dp [ 0 ] [ 0 ] = true ; for ( int j = 0 ; j < p . length ( ) ; ++ j ) if ( p . charAt ( j ) == ' ▁ * ▁ ' && dp [ 0 ] [ j - 1 ] ) dp [ 0 ] [ j + 1 ] = true ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( p . charAt ( j ) == ' ▁ * ▁ ' ) { final boolean noRepeat = dp [ i + 1 ] [ j - 1 ] ; final boolean doRepeat = isMatch ( s , i , p , j - 1 ) && dp [ i ] [ j + 1 ] ; dp [ i + 1 ] [ j + 1 ] = noRepeat || doRepeat ; } else if ( isMatch ( s , i , p , j ) ) { dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] ; } return dp [ m ] [ n ] ; } private boolean isMatch ( final String s , int i , final String p , int j ) { return j >= 0 && p . charAt ( j ) == ' ▁ . ▁ ' || s . charAt ( i ) == p . charAt ( j ) ; } } class Solution { public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { ListNode dummy = new ListNode ( 0 ) ; ListNode curr = dummy ; int carry = 0 ; while ( l1 != null || l2 != null || carry > 0 ) { if ( l1 != null ) { carry += l1 . val ; l1 = l1 . next ; } if ( l2 != null ) { carry += l2 . val ; l2 = l2 . next ; } curr . next = new ListNode ( carry % 10 ) ; carry /= 10 ; curr = curr . next ; } return dummy . next ; } } class Solution { public int lengthOfLongestSubstring ( String s ) { int ans = 0 ; int [ ] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length ( ) ; ++ r ) { ++ count [ s . charAt ( r ) ] ; while ( count [ s . charAt ( r ) ] > 1 ) -- count [ s . charAt ( l ++ ) ] ; ans = Math . max ( ans , r - l + 1 ) ; } return ans ; } } class Solution { public double findMedianSortedArrays ( int [ ] nums1 , int [ ] nums2 ) { final int n1 = nums1 . length ; final int n2 = nums2 . length ; if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ) ; int l = 0 ; int r = n1 ; while ( l <= r ) { final int partition1 = ( l + r ) / 2 ; final int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; final int maxLeft1 = partition1 == 0 ? Integer . MIN_VALUE : nums1 [ partition1 - 1 ] ; final int maxLeft2 = partition2 == 0 ? Integer . MIN_VALUE : nums2 [ partition2 - 1 ] ; final int minRight1 = partition1 == n1 ? Integer . MAX_VALUE : nums1 [ partition1 ] ; final int minRight2 = partition2 == n2 ? Integer . MAX_VALUE : nums2 [ partition2 ] ; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( Math . max ( maxLeft1 , maxLeft2 ) + Math . min ( minRight1 , minRight2 ) ) * 0.5 : Math . max ( maxLeft1 , maxLeft2 ) ; else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw new IllegalArgumentException ( ) ; } } class Solution { public String longestPalindrome ( String s ) { if ( s . isEmpty ( ) ) return " ▁ " ; int [ ] indices = { 0 , 0 } ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { int [ ] indices1 = extend ( s , i , i ) ; if ( indices1 [ 1 ] - indices1 [ 0 ] > indices [ 1 ] - indices [ 0 ] ) indices = indices1 ; if ( i + 1 < s . length ( ) && s . charAt ( i ) == s . charAt ( i + 1 ) ) { int [ ] indices2 = extend ( s , i , i + 1 ) ; if ( indices2 [ 1 ] - indices2 [ 0 ] > indices [ 1 ] - indices [ 0 ] ) indices = indices2 ; } } return s . substring ( indices [ 0 ] , indices [ 1 ] + 1 ) ; } private int [ ] extend ( final String s , int i , int j ) { for ( ; i >= 0 && j < s . length ( ) ; -- i , ++ j ) if ( s . charAt ( i ) != s . charAt ( j ) ) break ; return new int [ ] { i + 1 , j - 1 } ; } } class Solution { public String convert ( String s , int numRows ) { StringBuilder sb = new StringBuilder ( ) ; List < Character > [ ] rows = new List [ numRows ] ; int k = 0 ; int direction = numRows == 1 ? 0 : - 1 ; for ( int i = 0 ; i < numRows ; ++ i ) rows [ i ] = new ArrayList < > ( ) ; for ( final char c : s . toCharArray ( ) ) { rows [ k ] . add ( c ) ; if ( k == 0 || k == numRows - 1 ) direction *= - 1 ; k += direction ; } for ( List < Character > row : rows ) for ( final char c : row ) sb . append ( c ) ; return sb . toString ( ) ; } } class Solution { public int reverse ( int x ) { long ans = 0 ; while ( x != 0 ) { ans = ans * 10 + x % 10 ; x /= 10 ; } return ( ans < Integer . MIN_VALUE || ans > Integer . MAX_VALUE ) ? 0 : ( int ) ans ; } } class Solution { public int myAtoi ( String s ) { s = s . strip ( ) ; if ( s . isEmpty ( ) ) return 0 ; final int sign = s . charAt ( 0 ) == ' ▁ - ▁ ' ? - 1 : 1 ; if ( s . charAt ( 0 ) == ' ▁ + ▁ ' || s . charAt ( 0 ) == ' ▁ - ▁ ' ) s = s . substring ( 1 ) ; long num = 0 ; for ( final char c : s . toCharArray ( ) ) { if ( ! Character . isDigit ( c ) ) break ; num = num * 10 + ( c - '0' ) ; if ( sign * num <= Integer . MIN_VALUE ) return Integer . MIN_VALUE ; if ( sign * num >= Integer . MAX_VALUE ) return Integer . MAX_VALUE ; } return sign * ( int ) num ; } } class Solution { public boolean isPalindrome ( int x ) { if ( x < 0 ) return false ; long reversed = 0 ; int y = x ; while ( y > 0 ) { reversed = reversed * 10 + y % 10 ; y /= 10 ; } return reversed == x ; } }