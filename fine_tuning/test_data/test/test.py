class Solution : NEW_LINE INDENT def twoSum ( self , nums : List [ int ] , target : int ) -> List [ int ] : NEW_LINE INDENT numToIndex = { } NEW_LINE for i , num in enumerate ( nums ) : NEW_LINE INDENT if target - num in numToIndex : NEW_LINE INDENT return numToIndex [ target - num ] , i NEW_LINE DEDENT numToIndex [ num ] = i NEW_LINE DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def isMatch ( self , s : str , p : str ) -> bool : NEW_LINE INDENT m = len ( s ) NEW_LINE n = len ( p ) NEW_LINE dp = [ [ False ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = True NEW_LINE def isMatch ( i : int , j : int ) -> bool : NEW_LINE INDENT return j >= 0 and p [ j ] == ' . ' or s [ i ] == p [ j ] NEW_LINE DEDENT for j , c in enumerate ( p ) : NEW_LINE INDENT if c == ' * ' and dp [ 0 ] [ j - 1 ] : NEW_LINE INDENT dp [ 0 ] [ j + 1 ] = True NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if p [ j ] == ' * ' : NEW_LINE INDENT noRepeat = dp [ i + 1 ] [ j - 1 ] NEW_LINE doRepeat = isMatch ( i , j - 1 ) and dp [ i ] [ j + 1 ] NEW_LINE dp [ i + 1 ] [ j + 1 ] = noRepeat or doRepeat NEW_LINE DEDENT elif isMatch ( i , j ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : NEW_LINE INDENT dummy = ListNode ( 0 ) NEW_LINE curr = dummy NEW_LINE carry = 0 NEW_LINE while carry or l1 or l2 : NEW_LINE INDENT if l1 : NEW_LINE INDENT carry += l1 . val NEW_LINE l1 = l1 . next NEW_LINE DEDENT if l2 : NEW_LINE INDENT carry += l2 . val NEW_LINE l2 = l2 . next NEW_LINE DEDENT curr . next = ListNode ( carry % 10 ) NEW_LINE carry //= 10 NEW_LINE curr = curr . next NEW_LINE DEDENT return dummy . next NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def lengthOfLongestSubstring ( self , s : str ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE count = Counter ( ) NEW_LINE l = 0 NEW_LINE for r , c in enumerate ( s ) : NEW_LINE INDENT count [ c ] += 1 NEW_LINE while count [ c ] > 1 : NEW_LINE INDENT count [ s [ l ] ] -= 1 NEW_LINE l += 1 NEW_LINE DEDENT ans = max ( ans , r - l + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def findMedianSortedArrays ( self , nums1 : List [ int ] , nums2 : List [ int ] ) -> float : NEW_LINE INDENT n1 = len ( nums1 ) NEW_LINE n2 = len ( nums2 ) NEW_LINE if n1 > n2 : NEW_LINE INDENT return self . findMedianSortedArrays ( nums2 , nums1 ) NEW_LINE DEDENT l = 0 NEW_LINE r = n1 NEW_LINE while l <= r : NEW_LINE INDENT partition1 = ( l + r ) // 2 NEW_LINE partition2 = ( n1 + n2 + 1 ) // 2 - partition1 NEW_LINE maxLeft1 = - 2 ** 31 if partition1 == 0 else nums1 [ partition1 - 1 ] NEW_LINE maxLeft2 = - 2 ** 31 if partition2 == 0 else nums2 [ partition2 - 1 ] NEW_LINE minRight1 = 2 ** 31 - 1 if partition1 == n1 else nums1 [ partition1 ] NEW_LINE minRight2 = 2 ** 31 - 1 if partition2 == n2 else nums2 [ partition2 ] NEW_LINE if maxLeft1 <= minRight2 and maxLeft2 <= minRight1 : NEW_LINE INDENT return ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 ) ) * 0.5 if ( n1 + n2 ) % 2 == 0 else max ( maxLeft1 , maxLeft2 ) NEW_LINE DEDENT elif maxLeft1 > minRight2 : NEW_LINE INDENT r = partition1 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = partition1 + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestPalindrome ( self , s : str ) -> str : NEW_LINE INDENT if not s : NEW_LINE INDENT return ' ' NEW_LINE DEDENT indices = [ 0 , 0 ] NEW_LINE def extend ( s : str , i : int , j : int ) -> Tuple [ int , int ] : NEW_LINE INDENT while i >= 0 and j < len ( s ) : NEW_LINE INDENT if s [ i ] != s [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE j += 1 NEW_LINE DEDENT return i + 1 , j - 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT l1 , r1 = extend ( s , i , i ) NEW_LINE if r1 - l1 > indices [ 1 ] - indices [ 0 ] : NEW_LINE INDENT indices = l1 , r1 NEW_LINE DEDENT if i + 1 < len ( s ) and s [ i ] == s [ i + 1 ] : NEW_LINE INDENT l2 , r2 = extend ( s , i , i + 1 ) NEW_LINE if r2 - l2 > indices [ 1 ] - indices [ 0 ] : NEW_LINE INDENT indices = l2 , r2 NEW_LINE DEDENT DEDENT DEDENT return s [ indices [ 0 ] : indices [ 1 ] + 1 ] NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def convert ( self , s : str , numRows : int ) -> str : NEW_LINE INDENT rows = [ ' ' ] * numRows NEW_LINE k = 0 NEW_LINE direction = ( numRows == 1 ) - 1 NEW_LINE for c in s : NEW_LINE INDENT rows [ k ] += c NEW_LINE if k == 0 or k == numRows - 1 : NEW_LINE INDENT direction *= - 1 NEW_LINE DEDENT k += direction NEW_LINE DEDENT return ' ' . join ( rows ) NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def reverse ( self , x : int ) -> int : NEW_LINE INDENT ans = 0 NEW_LINE sign = - 1 if x < 0 else 1 NEW_LINE x *= sign NEW_LINE while x : NEW_LINE INDENT ans = ans * 10 + x % 10 NEW_LINE x //= 10 NEW_LINE DEDENT return 0 if ans < - 2 ** 31 or ans > 2 ** 31 - 1 else sign * ans NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def myAtoi ( self , s : str ) -> int : NEW_LINE INDENT s = s . strip ( ) NEW_LINE if not s : NEW_LINE INDENT return 0 NEW_LINE DEDENT sign = - 1 if s [ 0 ] == ' - ' else 1 NEW_LINE if s [ 0 ] in { ' - ' , ' + ' } : NEW_LINE INDENT s = s [ 1 : ] NEW_LINE DEDENT num = 0 NEW_LINE for c in s : NEW_LINE INDENT if not c . isdigit ( ) : NEW_LINE INDENT break NEW_LINE DEDENT num = num * 10 + ord ( c ) - ord ( '0' ) NEW_LINE if sign * num <= - 2 ** 31 : NEW_LINE INDENT return - 2 ** 31 NEW_LINE DEDENT if sign * num >= 2 ** 31 - 1 : NEW_LINE INDENT return 2 ** 31 - 1 NEW_LINE DEDENT DEDENT return sign * num NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def isPalindrome ( self , x : int ) -> bool : NEW_LINE INDENT if x < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT rev = 0 NEW_LINE y = x NEW_LINE while y : NEW_LINE INDENT rev = rev * 10 + y % 10 NEW_LINE y //= 10 NEW_LINE DEDENT return rev == x NEW_LINE DEDENT DEDENT
